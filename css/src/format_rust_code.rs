//! Module for converting CSS types to Rust code

#[cfg(not(feature = "std"))]
use alloc::string::ToString;
use alloc::{collections::btree_map::BTreeMap, format, string::String, vec::Vec};
use core::hash::Hash;

use crate::{
    corety::*,
    css::*,
    props::{basic::*, layout::*, property::*, style::*},
};

// Trait for formatting types as Rust code
pub trait FormatAsRustCode {
    fn format_as_rust_code(&self, tabs: usize) -> String;
}

// Trait for getting hash of types
pub trait GetHash {
    fn get_hash(&self) -> u64;
}

impl<T: Hash> GetHash for T {
    fn get_hash(&self) -> u64 {
        use highway::{HighwayHash, HighwayHasher, Key};
        let mut hasher = HighwayHasher::new(Key([0; 4]));
        self.hash(&mut hasher);
        hasher.finalize64()
    }
}

// In order to generate the Rust code, all items that implement Drop
// have to be declared before being used.
#[derive(Default)]
pub struct VecContents {
    // the u64 is the hash of the type (generated by string.get_hash())
    pub strings: BTreeMap<u64, AzString>,
    pub style_filters: BTreeMap<u64, StyleFilterVec>,
    pub style_background_sizes: BTreeMap<u64, StyleBackgroundSizeVec>,
    pub style_background_repeats: BTreeMap<u64, StyleBackgroundRepeatVec>,
    pub style_background_contents: BTreeMap<u64, StyleBackgroundContentVec>,
    pub style_background_positions: BTreeMap<u64, StyleBackgroundPositionVec>,
    pub style_transforms: BTreeMap<u64, StyleTransformVec>,
    pub font_families: BTreeMap<u64, StyleFontFamilyVec>,
    pub linear_color_stops: BTreeMap<u64, NormalizedLinearColorStopVec>,
    pub radial_color_stops: BTreeMap<u64, NormalizedRadialColorStopVec>,
}

impl VecContents {
    pub fn format(&self, tabs: usize) -> String {
        let mut result = String::new();
        let t = "    ".repeat(tabs);
        let t2 = "    ".repeat(tabs + 1);

        for (key, item) in self.strings.iter() {
            result.push_str(&format!(
                "\r\n    const STRING_{}: AzString = AzString::from_const_str(\"{}\");",
                key,
                item.as_str()
            ));
        }

        for (key, item) in self.style_filters.iter() {
            let val = item
                .iter()
                .map(|filter| format_style_filter(filter, tabs + 1))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!(
                "\r\n    const STYLE_FILTER_{}_ITEMS: &[StyleFilter] = &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.style_background_sizes.iter() {
            let val = item
                .iter()
                .map(|bgs| format_style_background_size(bgs))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!(
                "\r\n    const STYLE_BACKGROUND_SIZE_{}_ITEMS: &[StyleBackgroundSize] = \
                 &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.style_background_repeats.iter() {
            let val = item
                .iter()
                .map(|bgr| bgr.format_as_rust_code(tabs + 1))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!(
                "\r\n    const STYLE_BACKGROUND_REPEAT_{}_ITEMS: &[StyleBackgroundRepeat] = \
                 &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.style_background_contents.iter() {
            let val = item
                .iter()
                .map(|bgc| format_style_background_content(bgc, tabs + 1))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!(
                "\r\n    const STYLE_BACKGROUND_CONTENT_{}_ITEMS: &[StyleBackgroundContent] = \
                 &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.style_background_positions.iter() {
            let val = item
                .iter()
                .map(|bgp| format_style_background_position(bgp, tabs))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", t));

            result.push_str(&format!(
                "\r\n    const STYLE_BACKGROUND_POSITION_{}_ITEMS: &[StyleBackgroundPosition] = \
                 &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.style_transforms.iter() {
            let val = format_style_transforms(item.as_ref(), tabs + 1);

            result.push_str(&format!(
                "\r\n    const STYLE_TRANSFORM_{}_ITEMS: &[StyleTransform] = &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.font_families.iter() {
            let val = format_font_ids(item.as_ref(), tabs + 1);

            result.push_str(&format!(
                "\r\n    const STYLE_FONT_FAMILY_{}_ITEMS: &[StyleFontFamily] = &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.linear_color_stops.iter() {
            let val = format_linear_color_stops(item.as_ref(), 1);

            result.push_str(&format!(
                "\r\n    const LINEAR_COLOR_STOP_{}_ITEMS: &[NormalizedLinearColorStop] = \
                 &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        for (key, item) in self.radial_color_stops.iter() {
            let val = format_radial_color_stops(item.as_ref(), tabs);

            result.push_str(&format!(
                "\r\n    const RADIAL_COLOR_STOP_{}_ITEMS: &[NormalizedRadialColorStop] = \
                 &[\r\n{}{}\r\n{}];",
                key, t2, val, t
            ));
        }

        result
    }

    // given a CSS property, clones all the necessary strings (see class documentation)
    pub fn insert_from_css_property(&mut self, prop: &CssProperty) {
        match prop {
            CssProperty::FontFamily(CssPropertyValue::Exact(v)) => {
                for family in v.iter() {
                    match family {
                        StyleFontFamily::System(s) => {
                            // if the font-family is surrounded by quotes, strip them ("Arial" ->
                            // Arial)
                            let s = s.as_str();
                            let s = s.trim();
                            let s = s.trim_start_matches('\"');
                            let s = s.trim_end_matches('\"');
                            let s = s.trim_start_matches('\'');
                            let s = s.trim_end_matches('\'');

                            self.strings.insert(s.get_hash(), s.to_string().into());
                        }
                        StyleFontFamily::File(s) => {
                            let s = s.as_str();
                            let s = s.trim();
                            let s = s.trim_start_matches('\"');
                            let s = s.trim_end_matches('\"');
                            let s = s.trim_start_matches('\'');
                            let s = s.trim_end_matches('\'');

                            self.strings.insert(s.get_hash(), s.to_string().into());
                        }
                        _ => {}
                    }
                }
                self.font_families.insert(v.get_hash(), v.clone());
            }
            CssProperty::Transform(CssPropertyValue::Exact(v)) => {
                self.style_transforms.insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundRepeat(CssPropertyValue::Exact(v)) => {
                self.style_background_repeats
                    .insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundSize(CssPropertyValue::Exact(v)) => {
                self.style_background_sizes.insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundPosition(CssPropertyValue::Exact(v)) => {
                self.style_background_positions
                    .insert(v.get_hash(), v.clone());
            }
            CssProperty::BackgroundContent(CssPropertyValue::Exact(v)) => {
                for background in v.iter() {
                    match background {
                        StyleBackgroundContent::Image(id) => {
                            self.strings.insert(id.get_hash(), id.clone());
                        }
                        StyleBackgroundContent::LinearGradient(lg) => {
                            self.linear_color_stops
                                .insert(lg.stops.get_hash(), lg.stops.clone());
                        }
                        StyleBackgroundContent::RadialGradient(rg) => {
                            self.linear_color_stops
                                .insert(rg.stops.get_hash(), rg.stops.clone());
                        }
                        StyleBackgroundContent::ConicGradient(lg) => {
                            self.radial_color_stops
                                .insert(lg.stops.get_hash(), lg.stops.clone());
                        }
                        _ => {}
                    }
                }
                self.style_background_contents
                    .insert(v.get_hash(), v.clone());
            }
            CssProperty::Filter(CssPropertyValue::Exact(v)) => {
                self.style_filters.insert(v.get_hash(), v.clone());
            }
            CssProperty::BackdropFilter(CssPropertyValue::Exact(v)) => {
                self.style_filters.insert(v.get_hash(), v.clone());
            }
            _ => {}
        }
    }
}

// Helper functions for formatting values

fn format_pixel_value(p: &PixelValue) -> String {
    match p.metric {
        SizeMetric::Px => format!(
            "PixelValue::const_px({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Pt => format!(
            "PixelValue::const_pt({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Em => format!(
            "PixelValue::const_em({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Percent => format!(
            "PixelValue::const_percent({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::In => format!(
            "PixelValue::const_in({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Cm => format!(
            "PixelValue::const_cm({})",
            libm::roundf(p.number.get()) as isize
        ),
        SizeMetric::Mm => format!(
            "PixelValue::const_mm({})",
            libm::roundf(p.number.get()) as isize
        ),
    }
}

fn format_pixel_value_no_percent(p: &PixelValueNoPercent) -> String {
    format!(
        "PixelValueNoPercent {{ inner: {} }}",
        format_pixel_value(&p.inner)
    )
}

fn format_float_value(f: &FloatValue) -> String {
    format!("FloatValue::const_new({})", libm::roundf(f.get()) as isize)
}

fn format_percentage_value(f: &PercentageValue) -> String {
    format!(
        "PercentageValue::const_new({})",
        libm::roundf(f.normalized() * 100.0) as isize
    )
}

fn format_angle_value(f: &AngleValue) -> String {
    format!(
        "AngleValue::const_deg({})",
        libm::roundf(f.to_degrees()) as isize
    )
}

fn format_color_value(c: &ColorU) -> String {
    format!(
        "ColorU {{ r: {}, g: {}, b: {}, a: {} }}",
        c.r, c.g, c.b, c.a
    )
}

// Macro implementations for common patterns

macro_rules! impl_float_value_fmt {
    ($struct_name:ident) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_float_value(&self.inner)
                )
            }
        }
    };
}

impl_float_value_fmt!(LayoutFlexGrow);
impl_float_value_fmt!(LayoutFlexShrink);

macro_rules! impl_percentage_value_fmt {
    ($struct_name:ident) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_percentage_value(&self.inner)
                )
            }
        }
    };
}

impl_percentage_value_fmt!(StyleLineHeight);
impl_percentage_value_fmt!(StyleOpacity);

macro_rules! impl_pixel_value_fmt {
    ($struct_name:ident) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_pixel_value(&self.inner)
                )
            }
        }
    };
}

impl_pixel_value_fmt!(StyleTabWidth);
impl_pixel_value_fmt!(StyleBorderTopLeftRadius);
impl_pixel_value_fmt!(StyleBorderBottomLeftRadius);
impl_pixel_value_fmt!(StyleBorderTopRightRadius);
impl_pixel_value_fmt!(StyleBorderBottomRightRadius);

impl_pixel_value_fmt!(LayoutBorderTopWidth);
impl_pixel_value_fmt!(LayoutBorderLeftWidth);
impl_pixel_value_fmt!(LayoutBorderRightWidth);
impl_pixel_value_fmt!(LayoutBorderBottomWidth);
impl_pixel_value_fmt!(StyleLetterSpacing);
impl_pixel_value_fmt!(StyleWordSpacing);
impl_pixel_value_fmt!(StyleFontSize);

impl_pixel_value_fmt!(LayoutMarginTop);
impl_pixel_value_fmt!(LayoutMarginBottom);
impl_pixel_value_fmt!(LayoutMarginRight);
impl_pixel_value_fmt!(LayoutMarginLeft);

impl_pixel_value_fmt!(LayoutPaddingTop);
impl_pixel_value_fmt!(LayoutPaddingBottom);
impl_pixel_value_fmt!(LayoutPaddingRight);
impl_pixel_value_fmt!(LayoutPaddingLeft);

impl_pixel_value_fmt!(LayoutWidth);
impl_pixel_value_fmt!(LayoutHeight);
impl_pixel_value_fmt!(LayoutMinHeight);
impl_pixel_value_fmt!(LayoutMinWidth);
impl_pixel_value_fmt!(LayoutMaxWidth);
impl_pixel_value_fmt!(LayoutMaxHeight);
impl_pixel_value_fmt!(LayoutTop);
impl_pixel_value_fmt!(LayoutBottom);

impl FormatAsRustCode for LayoutZIndex {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        match self {
            LayoutZIndex::Auto => String::from("LayoutZIndex::Auto"),
            LayoutZIndex::Integer(val) => {
                format!("LayoutZIndex::Integer({})", val)
            }
        }
    }
}
impl_pixel_value_fmt!(LayoutRight);
impl_pixel_value_fmt!(LayoutLeft);

impl FormatAsRustCode for LayoutFlexBasis {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        match self {
            LayoutFlexBasis::Auto => String::from("LayoutFlexBasis::Auto"),
            LayoutFlexBasis::Exact(px) => {
                format!("LayoutFlexBasis::Exact({})", format_pixel_value(px))
            }
        }
    }
}

impl_pixel_value_fmt!(LayoutColumnGap);
impl_pixel_value_fmt!(LayoutRowGap);

macro_rules! impl_grid_value_fmt {
    ($struct_name:ident) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!("{} {{ /* TODO */ }}", stringify!($struct_name))
            }
        }
    };
}

impl_grid_value_fmt!(GridTemplate);
impl_grid_value_fmt!(GridPlacement);

macro_rules! impl_color_value_fmt {
    ($struct_name:ty) => {
        impl FormatAsRustCode for $struct_name {
            fn format_as_rust_code(&self, _tabs: usize) -> String {
                format!(
                    "{} {{ inner: {} }}",
                    stringify!($struct_name),
                    format_color_value(&self.inner)
                )
            }
        }
    };
}

impl_color_value_fmt!(StyleTextColor);
impl_color_value_fmt!(StyleBorderTopColor);
impl_color_value_fmt!(StyleBorderLeftColor);
impl_color_value_fmt!(StyleBorderRightColor);
impl_color_value_fmt!(StyleBorderBottomColor);

macro_rules! impl_enum_fmt {($enum_name:ident, $($enum_type:ident),+) => (
    impl FormatAsRustCode for $enum_name {
        fn format_as_rust_code(&self, _tabs: usize) -> String {
            match self {
                $(
                    $enum_name::$enum_type => String::from(concat!(stringify!($enum_name), "::", stringify!($enum_type))),
                )+
            }
        }
    }
)}

impl_enum_fmt!(
    StyleMixBlendMode,
    Normal,
    Multiply,
    Screen,
    Overlay,
    Darken,
    Lighten,
    ColorDodge,
    ColorBurn,
    HardLight,
    SoftLight,
    Difference,
    Exclusion,
    Hue,
    Saturation,
    Color,
    Luminosity
);

impl_enum_fmt!(StyleHyphens, Auto, None);

impl_enum_fmt!(StyleDirection, Ltr, Rtl);

impl_enum_fmt!(StyleWhiteSpace, Normal, Pre, Nowrap);

impl_enum_fmt!(StyleVisibility, Visible, Hidden, Collapse);

impl_enum_fmt!(LayoutWritingMode, HorizontalTb, VerticalRl, VerticalLr);

impl_enum_fmt!(LayoutClear, None, Left, Right, Both);

impl_enum_fmt!(
    StyleCursor,
    Alias,
    AllScroll,
    Cell,
    ColResize,
    ContextMenu,
    Copy,
    Crosshair,
    Default,
    EResize,
    EwResize,
    Grab,
    Grabbing,
    Help,
    Move,
    NResize,
    NsResize,
    NeswResize,
    NwseResize,
    Pointer,
    Progress,
    RowResize,
    SResize,
    SeResize,
    Text,
    Unset,
    VerticalText,
    WResize,
    Wait,
    ZoomIn,
    ZoomOut
);

impl_enum_fmt!(
    BorderStyle,
    None,
    Solid,
    Double,
    Dotted,
    Dashed,
    Hidden,
    Groove,
    Ridge,
    Inset,
    Outset
);

impl_enum_fmt!(StyleBackgroundRepeat, NoRepeat, Repeat, RepeatX, RepeatY);

impl_enum_fmt!(
    LayoutDisplay,
    None,
    Block,
    Inline,
    InlineBlock,
    Flex,
    InlineFlex,
    Table,
    InlineTable,
    TableRowGroup,
    TableHeaderGroup,
    TableFooterGroup,
    TableRow,
    TableColumnGroup,
    TableColumn,
    TableCell,
    TableCaption,
    ListItem,
    RunIn,
    Marker,
    Grid,
    InlineGrid,
    Initial,
    Inherit,
    FlowRoot
);

impl_enum_fmt!(LayoutFloat, Left, Right, None);

impl_enum_fmt!(LayoutBoxSizing, ContentBox, BorderBox);

impl_enum_fmt!(LayoutFlexDirection, Row, RowReverse, Column, ColumnReverse);

impl_enum_fmt!(LayoutFlexWrap, Wrap, NoWrap, WrapReverse);

impl_enum_fmt!(
    LayoutJustifyContent,
    Start,
    End,
    Center,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly
);

impl_enum_fmt!(LayoutAlignItems, Stretch, Center, Start, End, Baseline);

impl_enum_fmt!(
    LayoutAlignContent,
    Start,
    End,
    Stretch,
    Center,
    SpaceBetween,
    SpaceAround
);

impl_enum_fmt!(Shape, Circle, Ellipse);

impl_enum_fmt!(LayoutPosition, Static, Fixed, Absolute, Relative);

impl_enum_fmt!(LayoutOverflow, Auto, Scroll, Visible, Hidden, Clip);

impl_enum_fmt!(StyleTextAlign, Center, Left, Right, Justify, Start, End);

impl_enum_fmt!(
    DirectionCorner,
    Right,
    Left,
    Top,
    Bottom,
    TopRight,
    TopLeft,
    BottomRight,
    BottomLeft
);

impl_enum_fmt!(ExtendMode, Clamp, Repeat);

impl_enum_fmt!(StyleBackfaceVisibility, Visible, Hidden);

// Complex type implementations

impl FormatAsRustCode for StyleFilterVec {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleFilterVec::from_const_slice(STYLE_FILTER_{}_ITEMS)",
            self.get_hash()
        )
    }
}

impl FormatAsRustCode for StyleBackgroundSizeVec {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleBackgroundSizeVec::from_const_slice(STYLE_BACKGROUND_SIZE_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_background_size(c: &StyleBackgroundSize) -> String {
    match c {
        StyleBackgroundSize::Contain => String::from("StyleBackgroundSize::Contain"),
        StyleBackgroundSize::Cover => String::from("StyleBackgroundSize::Cover"),
        StyleBackgroundSize::ExactSize([w, h]) => format!(
            "StyleBackgroundSize::ExactSize([{}, {}])",
            format_pixel_value(w),
            format_pixel_value(h)
        ),
    }
}

impl FormatAsRustCode for ScrollbarStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        let t = String::from("    ").repeat(tabs);
        let t1 = String::from("    ").repeat(tabs + 1);
        format!(
            "ScrollbarStyle {{\r\n{}horizontal: {},\r\n{}vertical: {},\r\n{}}}",
            t1,
            format_scrollbar_info(&self.horizontal, tabs + 1),
            t1,
            format_scrollbar_info(&self.vertical, tabs + 1),
            t,
        )
    }
}

fn format_scrollbar_info(s: &ScrollbarInfo, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!(
        "ScrollbarInfo {{\r\n{}width: {},\r\n{}padding_left: {},\r\n{}padding_right: \
         {},\r\n{}track: {},\r\n{}thumb: {},\r\n{}button: {},\r\n{}button: {},\r\n{}resizer: \
         {},\r\n{}}}",
        t1,
        s.width.format_as_rust_code(tabs + 1),
        t1,
        s.padding_left.format_as_rust_code(tabs + 1),
        t1,
        s.padding_right.format_as_rust_code(tabs + 1),
        t1,
        format_style_background_content(&s.track, tabs + 1),
        t1,
        format_style_background_content(&s.thumb, tabs + 1),
        t1,
        format_style_background_content(&s.button, tabs + 1),
        t1,
        format_style_background_content(&s.corner, tabs + 1),
        t1,
        format_style_background_content(&s.resizer, tabs + 1),
        t
    )
}

impl FormatAsRustCode for StyleBackgroundRepeatVec {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleBackgroundRepeatVec::from_const_slice(STYLE_BACKGROUND_REPEAT_{}_ITEMS)",
            self.get_hash()
        )
    }
}

impl FormatAsRustCode for StyleBackgroundContentVec {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleBackgroundContentVec::from_const_slice(STYLE_BACKGROUND_CONTENT_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_background_content(content: &StyleBackgroundContent, tabs: usize) -> String {
    match content {
        StyleBackgroundContent::LinearGradient(l) => format!(
            "StyleBackgroundContent::LinearGradient({})",
            format_linear_gradient(l, tabs)
        ),
        StyleBackgroundContent::RadialGradient(r) => format!(
            "StyleBackgroundContent::RadialGradient({})",
            format_radial_gradient(r, tabs)
        ),
        StyleBackgroundContent::ConicGradient(r) => format!(
            "StyleBackgroundContent::ConicGradient({})",
            format_conic_gradient(r, tabs)
        ),
        StyleBackgroundContent::Image(id) => format!("StyleBackgroundContent::Image({:?})", id),
        StyleBackgroundContent::Color(c) => {
            format!("StyleBackgroundContent::Color({})", format_color_value(c))
        }
    }
}

fn format_direction(d: &Direction, tabs: usize) -> String {
    match d {
        Direction::Angle(fv) => format!("Direction::Angle({})", format_angle_value(fv)),
        Direction::FromTo(DirectionCorners { from, to }) => format!(
            "Direction::FromTo(DirectionCorners {{ from: {}, to: {} }})",
            from.format_as_rust_code(tabs + 1),
            to.format_as_rust_code(tabs + 1)
        ),
    }
}

fn format_linear_gradient(l: &LinearGradient, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!(
        "LinearGradient {{\r\n{}direction: {},\r\n{}extend_mode: {},\r\n{}stops: \
         NormalizedLinearColorStopVec::from_const_slice(LINEAR_COLOR_STOP_{}_ITEMS),\r\n{}}}",
        t1,
        format_direction(&l.direction, tabs + 1),
        t1,
        l.extend_mode.format_as_rust_code(tabs + 1),
        t1,
        l.stops.get_hash(),
        t,
    )
}

fn format_conic_gradient(r: &ConicGradient, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);

    format!(
        "ConicGradient {{\r\n{}extend_mode: {},\r\n{}center: {},\r\n{}angle: {},\r\n{}stops: \
         NormalizedRadialColorStopVec::from_const_slice(RADIAL_COLOR_STOP_{}_ITEMS),\r\n{}}}",
        t1,
        r.extend_mode.format_as_rust_code(tabs + 1),
        t1,
        format_style_background_position(&r.center, tabs + 1),
        t1,
        format_angle_value(&r.angle),
        t1,
        r.stops.get_hash(),
        t,
    )
}

fn format_radial_gradient(r: &RadialGradient, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!(
        "RadialGradient {{\r\n{}shape: {},\r\n{}extend_mode: {},\r\n{}position: {},\r\n{}size: \
         RadialGradientSize::{:?},\r\n{}stops: \
         NormalizedLinearColorStopVec::from_const_slice(LINEAR_COLOR_STOP_{}_ITEMS),\r\n{}}}",
        t1,
        r.shape.format_as_rust_code(tabs + 1),
        t1,
        r.extend_mode.format_as_rust_code(tabs + 1),
        t1,
        format_style_background_position(&r.position, tabs + 1),
        t1,
        r.size,
        t1,
        r.stops.get_hash(),
        t,
    )
}

fn format_linear_color_stops(stops: &[NormalizedLinearColorStop], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    stops
        .iter()
        .map(|s| format_linear_color_stop(s))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

fn format_linear_color_stop(g: &NormalizedLinearColorStop) -> String {
    format!(
        "NormalizedLinearColorStop {{ offset: {}, color: {} }}",
        format_percentage_value(&g.offset),
        format_color_value(&g.color),
    )
}

fn format_radial_color_stops(stops: &[NormalizedRadialColorStop], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    stops
        .iter()
        .map(|s| format_radial_color_stop(s))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

fn format_radial_color_stop(g: &NormalizedRadialColorStop) -> String {
    format!(
        "RadialColorStop {{ angle: {}, color: {} }}",
        format_angle_value(&g.angle),
        format_color_value(&g.color),
    )
}

impl FormatAsRustCode for StyleTransformVec {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleTransformVec::from_const_slice(STYLE_TRANSFORM_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_filter(st: &StyleFilter, tabs: usize) -> String {
    let tabs_minus_one = String::from("    ").repeat(tabs);
    let tabs_str = String::from("    ").repeat(tabs + 1);
    match st {
        StyleFilter::Blend(mb) => format!("StyleFilter::Blend({})", mb.format_as_rust_code(tabs)),
        StyleFilter::Flood(c) => format!("StyleFilter::Flood({})", format_color_value(c)),
        StyleFilter::Blur(m) => format!(
            "StyleFilter::Blur(StyleBlur {{ width: {}, height: {} }})",
            format_pixel_value(&m.width),
            format_pixel_value(&m.height)
        ),
        StyleFilter::Opacity(pct) => {
            format!("StyleFilter::Opacity({})", format_percentage_value(pct))
        }
        StyleFilter::ColorMatrix(cm) => format!(
            "StyleFilter::ColorMatrix(StyleColorMatrix {{ matrix: {} }})",
            cm.matrix
                .iter()
                .map(|f| format_float_value(f))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", tabs_str))
        ),
        StyleFilter::DropShadow(m) => {
            format!("StyleFilter::DropShadow({})", m.format_as_rust_code(tabs))
        }
        StyleFilter::ComponentTransfer => format!("StyleFilter::ComponentTransfer"),
        StyleFilter::Offset(o) => format!(
            "StyleFilter::Offset(StyleFilterOffset {{ x: {}, y: {} }})",
            format_pixel_value(&o.x),
            format_pixel_value(&o.y)
        ),
        StyleFilter::Composite(StyleCompositeFilter::Over) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Over)")
        }
        StyleFilter::Composite(StyleCompositeFilter::In) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::In)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Atop) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Atop)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Out) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Out)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Xor) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Xor)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Lighter) => {
            format!("StyleFilter::Composite(StyleCompositeFilter::Lighter)")
        }
        StyleFilter::Composite(StyleCompositeFilter::Arithmetic(fv)) => format!(
            "StyleFilter::Composite(StyleCompositeFilter::Arithmetic({}))",
            fv.iter()
                .map(|f| format_float_value(f))
                .collect::<Vec<_>>()
                .join(&format!(",\r\n{}", tabs_minus_one))
        ),
    }
}

fn format_style_transforms(stops: &[StyleTransform], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    stops
        .iter()
        .map(|s| format_style_transform(s, tabs))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

fn format_style_transform(st: &StyleTransform, tabs: usize) -> String {
    let tabs_minus_one = String::from("    ").repeat(tabs);
    let tabs = String::from("    ").repeat(tabs + 1);
    match st {
        StyleTransform::Matrix(m) => format!(
            "StyleTransform::Matrix(StyleTransformMatrix2D {{ a: {}, b: {}, c: {}, d: {}, tx: {}, \
             ty: {} }})",
            format_float_value(&m.a),
            format_float_value(&m.b),
            format_float_value(&m.c),
            format_float_value(&m.d),
            format_float_value(&m.tx),
            format_float_value(&m.ty)
        ),
        StyleTransform::Matrix3D(m) => format!(
            "StyleTransform::Matrix3D(StyleTransformMatrix3D {{\r\n{tabs}m11: {},\r\n{tabs}m12: \
             {},\r\n{tabs}m13: {},\r\n{tabs}m14: {},\r\n{tabs}m21: {},\r\n{tabs}m22: \
             {},\r\n{tabs}m23: {},\r\n{tabs}m24: {},\r\n{tabs}m31: {},\r\n{tabs}m32: \
             {},\r\n{tabs}m33: {},\r\n{tabs}m34: {},\r\n{tabs}m41: {},\r\n{tabs}m42: \
             {},\r\n{tabs}m43: {},\r\n{tabs}m44: {}\r\n{tabs_minus_one}}})",
            format_float_value(&m.m11),
            format_float_value(&m.m12),
            format_float_value(&m.m13),
            format_float_value(&m.m14),
            format_float_value(&m.m21),
            format_float_value(&m.m22),
            format_float_value(&m.m23),
            format_float_value(&m.m24),
            format_float_value(&m.m31),
            format_float_value(&m.m32),
            format_float_value(&m.m33),
            format_float_value(&m.m34),
            format_float_value(&m.m41),
            format_float_value(&m.m42),
            format_float_value(&m.m43),
            format_float_value(&m.m44),
            tabs = tabs,
            tabs_minus_one = tabs_minus_one,
        ),
        StyleTransform::Translate(t) => format!(
            "StyleTransform::Translate(StyleTransformTranslate2D {{ x: {}, y: {} }})",
            format_pixel_value(&t.x),
            format_pixel_value(&t.y)
        ),
        StyleTransform::Translate3D(t) => format!(
            "StyleTransform::Translate3D(StyleTransformTranslate3D {{ x: {}, y: {}, z: {})",
            format_pixel_value(&t.x),
            format_pixel_value(&t.y),
            format_pixel_value(&t.z)
        ),
        StyleTransform::TranslateX(x) => {
            format!("StyleTransform::TranslateX({})", format_pixel_value(&x))
        }
        StyleTransform::TranslateY(y) => {
            format!("StyleTransform::TranslateY({})", format_pixel_value(&y))
        }
        StyleTransform::TranslateZ(z) => {
            format!("StyleTransform::TranslateZ({})", format_pixel_value(&z))
        }
        StyleTransform::Rotate(r) => format!("StyleTransform::Rotate({})", format_angle_value(&r)),
        StyleTransform::Rotate3D(r) => format!(
            "StyleTransform::Rotate3D(StyleTransformRotate3D {{ {}, {}, {}, {} }})",
            format_float_value(&r.x),
            format_float_value(&r.y),
            format_float_value(&r.z),
            format_angle_value(&r.angle)
        ),
        StyleTransform::RotateX(x) => {
            format!("StyleTransform::RotateX({})", format_angle_value(&x))
        }
        StyleTransform::RotateY(y) => {
            format!("StyleTransform::RotateY({})", format_angle_value(&y))
        }
        StyleTransform::RotateZ(z) => {
            format!("StyleTransform::RotateZ({})", format_angle_value(&z))
        }
        StyleTransform::Scale(s) => format!(
            "StyleTransform::Scale(StyleTransformScale2D {{ x: {}, y: {} }})",
            format_float_value(&s.x),
            format_float_value(&s.y)
        ),
        StyleTransform::Scale3D(s) => format!(
            "StyleTransform::Scale3D(StyleTransformScale3D {{ x; {}, y: {}, z: {} }})",
            format_float_value(&s.x),
            format_float_value(&s.y),
            format_float_value(&s.z)
        ),
        StyleTransform::ScaleX(x) => {
            format!("StyleTransform::ScaleX({})", format_percentage_value(&x))
        }
        StyleTransform::ScaleY(y) => {
            format!("StyleTransform::ScaleY({})", format_percentage_value(&y))
        }
        StyleTransform::ScaleZ(z) => {
            format!("StyleTransform::ScaleZ({})", format_percentage_value(&z))
        }
        StyleTransform::Skew(sk) => format!(
            "StyleTransform::Skew(StyleTransformSkew2D {{ x: {}, y: {} }})",
            format_angle_value(&sk.x),
            format_angle_value(&sk.y)
        ),
        StyleTransform::SkewX(x) => {
            format!("StyleTransform::SkewX({})", format_angle_value(&x))
        }
        StyleTransform::SkewY(y) => {
            format!("StyleTransform::SkewY({})", format_angle_value(&y))
        }
        StyleTransform::Perspective(dist) => {
            format!("StyleTransform::Perspective({})", format_pixel_value(&dist))
        }
    }
}

fn format_font_ids(font_ids: &[StyleFontFamily], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    font_ids
        .iter()
        .map(|s| format!("{}", s.format_as_rust_code(tabs + 1)))
        .collect::<Vec<_>>()
        .join(&format!(",\r\n{}", t))
}

impl FormatAsRustCode for StyleFontFamilyVec {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleFontFamilyVec::from_const_slice(STYLE_FONT_FAMILY_{}_ITEMS)",
            self.get_hash()
        )
    }
}

impl FormatAsRustCode for StyleFontFamily {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        match self {
            StyleFontFamily::System(id) => {
                format!("StyleFontFamily::System(STRING_{})", id.get_hash())
            }
            StyleFontFamily::File(path) => {
                format!("StyleFontFamily::File(STRING_{})", path.get_hash())
            }
            StyleFontFamily::Ref(font_ref) => {
                format!("StyleFontFamily::Ref({:0x})", font_ref.data as usize)
            }
        }
    }
}

impl FormatAsRustCode for StyleBackgroundPositionVec {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleBackgroundPositionVec::from_const_slice(STYLE_BACKGROUND_POSITION_{}_ITEMS)",
            self.get_hash()
        )
    }
}

fn format_style_background_position(b: &StyleBackgroundPosition, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);
    format!(
        "StyleBackgroundPosition {{\r\n{}horizontal: {},\r\n{}vertical: {},\r\n{}}}",
        t1,
        format_background_position_horizontal(&b.horizontal),
        t1,
        format_background_position_vertical(&b.vertical),
        t
    )
}

fn format_background_position_horizontal(b: &BackgroundPositionHorizontal) -> String {
    match b {
        BackgroundPositionHorizontal::Left => format!("BackgroundPositionHorizontal::Left"),
        BackgroundPositionHorizontal::Center => format!("BackgroundPositionHorizontal::Center"),
        BackgroundPositionHorizontal::Right => format!("BackgroundPositionHorizontal::Right"),
        BackgroundPositionHorizontal::Exact(p) => format!(
            "BackgroundPositionHorizontal::Exact({})",
            format_pixel_value(p)
        ),
    }
}

fn format_background_position_vertical(b: &BackgroundPositionVertical) -> String {
    match b {
        BackgroundPositionVertical::Top => format!("BackgroundPositionVertical::Top"),
        BackgroundPositionVertical::Center => format!("BackgroundPositionVertical::Center"),
        BackgroundPositionVertical::Bottom => format!("BackgroundPositionVertical::Bottom"),
        BackgroundPositionVertical::Exact(p) => format!(
            "BackgroundPositionVertical::Exact({})",
            format_pixel_value(p)
        ),
    }
}

impl FormatAsRustCode for StyleBorderTopStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderTopStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBorderRightStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderRightStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBorderLeftStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderLeftStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBorderBottomStyle {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        format!(
            "StyleBorderBottomStyle {{ inner: {} }}",
            &self.inner.format_as_rust_code(tabs)
        )
    }
}

impl FormatAsRustCode for StyleBoxShadow {
    fn format_as_rust_code(&self, tabs: usize) -> String {
        let t = String::from("    ").repeat(tabs);
        format!(
            "StyleBoxShadow {{\r\n{}    offset: [{}, {}],\r\n{}    color: {},\r\n{}    \
             blur_radius: {},\r\n{}    spread_radius: {},\r\n{}    clip_mode: \
             BoxShadowClipMode::{:?},\r\n{}}}",
            t,
            format_pixel_value_no_percent(&self.offset[0]),
            format_pixel_value_no_percent(&self.offset[1]),
            t,
            format_color_value(&self.color),
            t,
            format_pixel_value_no_percent(&self.blur_radius),
            t,
            format_pixel_value_no_percent(&self.spread_radius),
            t,
            self.clip_mode,
            t
        )
    }
}

impl FormatAsRustCode for StyleTransformOrigin {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StyleTransformOrigin {{ x: {}, y: {} }}",
            format_pixel_value(&self.x),
            format_pixel_value(&self.y)
        )
    }
}

impl FormatAsRustCode for StylePerspectiveOrigin {
    fn format_as_rust_code(&self, _tabs: usize) -> String {
        format!(
            "StylePerspectiveOrigin {{ x: {}, y: {} }}",
            format_pixel_value(&self.x),
            format_pixel_value(&self.y)
        )
    }
}

// High-level CSS to Rust code generation

pub fn css_to_rust_code(css: &Css) -> String {
    let mut output = String::new();

    output.push_str("const CSS: Css = Css {\r\n");
    output.push_str("\tstylesheets: [\r\n");

    for stylesheet in css.stylesheets.iter() {
        output.push_str("\t\tStylesheet {\r\n");
        output.push_str("\t\t\trules: [\r\n");

        for block in stylesheet.rules.iter() {
            output.push_str("\t\t\t\tCssRuleBlock: {\r\n");
            output.push_str(&format!(
                "\t\t\t\t\tpath: {},\r\n",
                print_block_path(&block.path, 5)
            ));

            output.push_str("\t\t\t\t\tdeclarations: [\r\n");

            for declaration in block.declarations.iter() {
                output.push_str(&format!(
                    "\t\t\t\t\t\t{},\r\n",
                    print_declaration(declaration, 6)
                ));
            }

            output.push_str("\t\t\t\t\t]\r\n");

            output.push_str("\t\t\t\t},\r\n");
        }

        output.push_str("\t\t\t]\r\n");
        output.push_str("\t\t},\r\n");
    }

    output.push_str("\t]\r\n");
    output.push_str("};");

    let output = output.replace("\t", "    ");

    output
}

fn print_block_path(path: &CssPath, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);

    format!(
        "CssPath {{\r\n{}selectors: {}\r\n{}}}",
        t1,
        format_selectors(path.selectors.as_ref(), tabs + 1),
        t
    )
}

fn format_selectors(selectors: &[CssPathSelector], tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    let t1 = String::from("    ").repeat(tabs + 1);

    let selectors_formatted = selectors
        .iter()
        .map(|s| format!("{}{},", t1, format_single_selector(s, tabs + 1)))
        .collect::<Vec<String>>()
        .join("\r\n");

    format!("vec![\r\n{}\r\n{}].into()", selectors_formatted, t)
}

fn format_single_selector(p: &CssPathSelector, _tabs: usize) -> String {
    match p {
        CssPathSelector::Global => format!("CssPathSelector::Global"),
        CssPathSelector::Type(ntp) => format!("CssPathSelector::Type({})", format_node_type(ntp)),
        CssPathSelector::Class(class) => {
            format!("CssPathSelector::Class(String::from({:?}))", class)
        }
        CssPathSelector::Id(id) => format!("CssPathSelector::Id(String::from({:?}))", id),
        CssPathSelector::PseudoSelector(cps) => format!(
            "CssPathSelector::PseudoSelector({})",
            format_pseudo_selector_type(cps)
        ),
        CssPathSelector::DirectChildren => format!("CssPathSelector::DirectChildren"),
        CssPathSelector::Children => format!("CssPathSelector::Children"),
    }
}

fn format_node_type(n: &NodeTypeTag) -> &'static str {
    match n {
        // Block elements
        NodeTypeTag::Body => "NodeTypeTag::Body",
        NodeTypeTag::Div => "NodeTypeTag::Div",
        NodeTypeTag::P => "NodeTypeTag::P",
        NodeTypeTag::H1 => "NodeTypeTag::H1",
        NodeTypeTag::H2 => "NodeTypeTag::H2",
        NodeTypeTag::H3 => "NodeTypeTag::H3",
        NodeTypeTag::H4 => "NodeTypeTag::H4",
        NodeTypeTag::H5 => "NodeTypeTag::H5",
        NodeTypeTag::H6 => "NodeTypeTag::H6",
        NodeTypeTag::Br => "NodeTypeTag::Br",
        NodeTypeTag::Hr => "NodeTypeTag::Hr",
        NodeTypeTag::Pre => "NodeTypeTag::Pre",
        NodeTypeTag::BlockQuote => "NodeTypeTag::BlockQuote",
        NodeTypeTag::Address => "NodeTypeTag::Address",

        // List elements
        NodeTypeTag::Ul => "NodeTypeTag::Ul",
        NodeTypeTag::Ol => "NodeTypeTag::Ol",
        NodeTypeTag::Li => "NodeTypeTag::Li",
        NodeTypeTag::Dl => "NodeTypeTag::Dl",
        NodeTypeTag::Dt => "NodeTypeTag::Dt",
        NodeTypeTag::Dd => "NodeTypeTag::Dd",

        // Table elements
        NodeTypeTag::Table => "NodeTypeTag::Table",
        NodeTypeTag::Caption => "NodeTypeTag::Caption",
        NodeTypeTag::THead => "NodeTypeTag::THead",
        NodeTypeTag::TBody => "NodeTypeTag::TBody",
        NodeTypeTag::TFoot => "NodeTypeTag::TFoot",
        NodeTypeTag::Tr => "NodeTypeTag::Tr",
        NodeTypeTag::Th => "NodeTypeTag::Th",
        NodeTypeTag::Td => "NodeTypeTag::Td",
        NodeTypeTag::ColGroup => "NodeTypeTag::ColGroup",
        NodeTypeTag::Col => "NodeTypeTag::Col",

        // Form elements
        NodeTypeTag::Form => "NodeTypeTag::Form",
        NodeTypeTag::FieldSet => "NodeTypeTag::FieldSet",
        NodeTypeTag::Legend => "NodeTypeTag::Legend",
        NodeTypeTag::Label => "NodeTypeTag::Label",
        NodeTypeTag::Input => "NodeTypeTag::Input",
        NodeTypeTag::Button => "NodeTypeTag::Button",
        NodeTypeTag::Select => "NodeTypeTag::Select",
        NodeTypeTag::OptGroup => "NodeTypeTag::OptGroup",
        NodeTypeTag::SelectOption => "NodeTypeTag::SelectOption",
        NodeTypeTag::TextArea => "NodeTypeTag::TextArea",

        // Inline elements
        NodeTypeTag::Span => "NodeTypeTag::Span",
        NodeTypeTag::A => "NodeTypeTag::A",
        NodeTypeTag::Em => "NodeTypeTag::Em",
        NodeTypeTag::Strong => "NodeTypeTag::Strong",
        NodeTypeTag::B => "NodeTypeTag::B",
        NodeTypeTag::I => "NodeTypeTag::I",
        NodeTypeTag::Code => "NodeTypeTag::Code",
        NodeTypeTag::Samp => "NodeTypeTag::Samp",
        NodeTypeTag::Kbd => "NodeTypeTag::Kbd",
        NodeTypeTag::Var => "NodeTypeTag::Var",
        NodeTypeTag::Cite => "NodeTypeTag::Cite",
        NodeTypeTag::Abbr => "NodeTypeTag::Abbr",
        NodeTypeTag::Acronym => "NodeTypeTag::Acronym",
        NodeTypeTag::Q => "NodeTypeTag::Q",
        NodeTypeTag::Sub => "NodeTypeTag::Sub",
        NodeTypeTag::Sup => "NodeTypeTag::Sup",
        NodeTypeTag::Small => "NodeTypeTag::Small",
        NodeTypeTag::Big => "NodeTypeTag::Big",

        // Content elements
        NodeTypeTag::Text => "NodeTypeTag::Text",
        NodeTypeTag::Img => "NodeTypeTag::Img",
        NodeTypeTag::IFrame => "NodeTypeTag::IFrame",

        // Pseudo-elements
        NodeTypeTag::Before => "NodeTypeTag::Before",
        NodeTypeTag::After => "NodeTypeTag::After",
        NodeTypeTag::Marker => "NodeTypeTag::Marker",
        NodeTypeTag::Placeholder => "NodeTypeTag::Placeholder",
    }
}

fn format_pseudo_selector_type(p: &CssPathPseudoSelector) -> String {
    match p {
        CssPathPseudoSelector::First => format!("CssPathPseudoSelector::First"),
        CssPathPseudoSelector::Last => format!("CssPathPseudoSelector::Last"),
        CssPathPseudoSelector::NthChild(n) => format!(
            "CssPathPseudoSelector::NthChild({})",
            format_nth_child_selector(n)
        ),
        CssPathPseudoSelector::Hover => format!("CssPathPseudoSelector::Hover"),
        CssPathPseudoSelector::Active => format!("CssPathPseudoSelector::Active"),
        CssPathPseudoSelector::Focus => format!("CssPathPseudoSelector::Focus"),
    }
}

fn format_nth_child_selector(n: &CssNthChildSelector) -> String {
    match n {
        CssNthChildSelector::Number(num) => format!("CssNthChildSelector::Number({})", num),
        CssNthChildSelector::Even => format!("CssNthChildSelector::Even"),
        CssNthChildSelector::Odd => format!("CssNthChildSelector::Odd"),
        CssNthChildSelector::Pattern(CssNthChildPattern { repeat, offset }) => format!(
            "CssNthChildSelector::Pattern(CssNthChildPattern {{ repeat: {}, offset: {} }})",
            repeat, offset
        ),
    }
}

fn print_declaration(decl: &CssDeclaration, tabs: usize) -> String {
    match decl {
        CssDeclaration::Static(s) => format!(
            "CssDeclaration::Static({})",
            format_static_css_prop(s, tabs)
        ),
        CssDeclaration::Dynamic(d) => format!(
            "CssDeclaration::Dynamic({})",
            format_dynamic_css_prop(d, tabs)
        ),
    }
}

pub fn format_static_css_prop(prop: &CssProperty, tabs: usize) -> String {
    match prop {
        CssProperty::LayoutTextJustify(j) => format!(
            "CssProperty::LayoutTextJustify({})",
            print_css_property_value(j, tabs, "LayoutText")
        ),
        CssProperty::TextColor(p) => format!(
            "CssProperty::TextColor({})",
            print_css_property_value(p, tabs, "StyleTextColor")
        ),
        CssProperty::FontSize(p) => format!(
            "CssProperty::FontSize({})",
            print_css_property_value(p, tabs, "StyleFontSize")
        ),
        CssProperty::FontFamily(p) => format!(
            "CssProperty::FontFamily({})",
            print_css_property_value(p, tabs, "StyleFontFamilyVec")
        ),
        CssProperty::TextAlign(p) => format!(
            "CssProperty::TextAlign({})",
            print_css_property_value(p, tabs, "StyleTextAlign")
        ),
        CssProperty::LetterSpacing(p) => format!(
            "CssProperty::LetterSpacing({})",
            print_css_property_value(p, tabs, "StyleLetterSpacing")
        ),
        CssProperty::LineHeight(p) => format!(
            "CssProperty::LineHeight({})",
            print_css_property_value(p, tabs, "StyleLineHeight")
        ),
        CssProperty::WordSpacing(p) => format!(
            "CssProperty::WordSpacing({})",
            print_css_property_value(p, tabs, "StyleWordSpacing")
        ),
        CssProperty::TabWidth(p) => format!(
            "CssProperty::TabWidth({})",
            print_css_property_value(p, tabs, "StyleTabWidth")
        ),
        CssProperty::Cursor(p) => format!(
            "CssProperty::Cursor({})",
            print_css_property_value(p, tabs, "StyleCursor")
        ),
        CssProperty::Display(p) => format!(
            "CssProperty::Display({})",
            print_css_property_value(p, tabs, "LayoutDisplay")
        ),
        CssProperty::Float(p) => format!(
            "CssProperty::Float({})",
            print_css_property_value(p, tabs, "LayoutFloat")
        ),
        CssProperty::BoxSizing(p) => format!(
            "CssProperty::BoxSizing({})",
            print_css_property_value(p, tabs, "LayoutBoxSizing")
        ),
        CssProperty::Width(p) => format!(
            "CssProperty::Width({})",
            print_css_property_value(p, tabs, "LayoutWidth")
        ),
        CssProperty::Height(p) => format!(
            "CssProperty::Height({})",
            print_css_property_value(p, tabs, "LayoutHeight")
        ),
        CssProperty::MinWidth(p) => format!(
            "CssProperty::MinWidth({})",
            print_css_property_value(p, tabs, "LayoutMinWidth")
        ),
        CssProperty::MinHeight(p) => format!(
            "CssProperty::MinHeight({})",
            print_css_property_value(p, tabs, "LayoutMinHeight")
        ),
        CssProperty::MaxWidth(p) => format!(
            "CssProperty::MaxWidth({})",
            print_css_property_value(p, tabs, "LayoutMaxWidth")
        ),
        CssProperty::MaxHeight(p) => format!(
            "CssProperty::MaxHeight({})",
            print_css_property_value(p, tabs, "LayoutMaxHeight")
        ),
        CssProperty::Position(p) => format!(
            "CssProperty::Position({})",
            print_css_property_value(p, tabs, "LayoutPosition")
        ),
        CssProperty::Top(p) => format!(
            "CssProperty::Top({})",
            print_css_property_value(p, tabs, "LayoutTop")
        ),
        CssProperty::Right(p) => format!(
            "CssProperty::Right({})",
            print_css_property_value(p, tabs, "LayoutRight")
        ),
        CssProperty::Left(p) => format!(
            "CssProperty::Left({})",
            print_css_property_value(p, tabs, "LayoutLeft")
        ),
        CssProperty::Bottom(p) => format!(
            "CssProperty::Bottom({})",
            print_css_property_value(p, tabs, "LayoutBottom")
        ),
        CssProperty::ZIndex(p) => format!(
            "CssProperty::ZIndex({})",
            print_css_property_value(p, tabs, "LayoutZIndex")
        ),
        CssProperty::FlexWrap(p) => format!(
            "CssProperty::FlexWrap({})",
            print_css_property_value(p, tabs, "LayoutFlexWrap")
        ),
        CssProperty::FlexDirection(p) => format!(
            "CssProperty::FlexDirection({})",
            print_css_property_value(p, tabs, "LayoutFlexDirection")
        ),
        CssProperty::FlexGrow(p) => format!(
            "CssProperty::FlexGrow({})",
            print_css_property_value(p, tabs, "LayoutFlexGrow")
        ),
        CssProperty::FlexShrink(p) => format!(
            "CssProperty::FlexShrink({})",
            print_css_property_value(p, tabs, "LayoutFlexShrink")
        ),
        CssProperty::JustifyContent(p) => format!(
            "CssProperty::JustifyContent({})",
            print_css_property_value(p, tabs, "LayoutJustifyContent")
        ),
        CssProperty::AlignItems(p) => format!(
            "CssProperty::AlignItems({})",
            print_css_property_value(p, tabs, "LayoutAlignItems")
        ),
        CssProperty::AlignContent(p) => format!(
            "CssProperty::AlignContent({})",
            print_css_property_value(p, tabs, "LayoutAlignContent")
        ),
        CssProperty::BackgroundContent(p) => format!(
            "CssProperty::BackgroundContent({})",
            print_css_property_value(p, tabs, "StyleBackgroundContentVec")
        ),
        CssProperty::BackgroundPosition(p) => format!(
            "CssProperty::BackgroundPosition({})",
            print_css_property_value(p, tabs, "StyleBackgroundPositionVec")
        ),
        CssProperty::BackgroundSize(p) => format!(
            "CssProperty::BackgroundSize({})",
            print_css_property_value(p, tabs, "StyleBackgroundSizeVec")
        ),
        CssProperty::BackgroundRepeat(p) => format!(
            "CssProperty::BackgroundRepeat({})",
            print_css_property_value(p, tabs, "StyleBackgroundRepeatVec")
        ),
        CssProperty::OverflowX(p) => format!(
            "CssProperty::OverflowX({})",
            print_css_property_value(p, tabs, "LayoutOverflow")
        ),
        CssProperty::OverflowY(p) => format!(
            "CssProperty::OverflowY({})",
            print_css_property_value(p, tabs, "LayoutOverflow")
        ),
        CssProperty::PaddingTop(p) => format!(
            "CssProperty::PaddingTop({})",
            print_css_property_value(p, tabs, "LayoutPaddingTop")
        ),
        CssProperty::PaddingLeft(p) => format!(
            "CssProperty::PaddingLeft({})",
            print_css_property_value(p, tabs, "LayoutPaddingLeft")
        ),
        CssProperty::PaddingRight(p) => format!(
            "CssProperty::PaddingRight({})",
            print_css_property_value(p, tabs, "LayoutPaddingRight")
        ),
        CssProperty::PaddingBottom(p) => format!(
            "CssProperty::PaddingBottom({})",
            print_css_property_value(p, tabs, "LayoutPaddingBottom")
        ),
        CssProperty::MarginTop(p) => format!(
            "CssProperty::MarginTop({})",
            print_css_property_value(p, tabs, "LayoutMarginTop")
        ),
        CssProperty::MarginLeft(p) => format!(
            "CssProperty::MarginLeft({})",
            print_css_property_value(p, tabs, "LayoutMarginLeft")
        ),
        CssProperty::MarginRight(p) => format!(
            "CssProperty::MarginRight({})",
            print_css_property_value(p, tabs, "LayoutMarginRight")
        ),
        CssProperty::MarginBottom(p) => format!(
            "CssProperty::MarginBottom({})",
            print_css_property_value(p, tabs, "LayoutMarginBottom")
        ),
        CssProperty::BorderTopLeftRadius(p) => format!(
            "CssProperty::BorderTopLeftRadius({})",
            print_css_property_value(p, tabs, "StyleBorderTopLeftRadius")
        ),
        CssProperty::BorderTopRightRadius(p) => format!(
            "CssProperty::BorderTopRightRadius({})",
            print_css_property_value(p, tabs, "StyleBorderTopRightRadius")
        ),
        CssProperty::BorderBottomLeftRadius(p) => format!(
            "CssProperty::BorderBottomLeftRadius({})",
            print_css_property_value(p, tabs, "StyleBorderBottomLeftRadius")
        ),
        CssProperty::BorderBottomRightRadius(p) => format!(
            "CssProperty::BorderBottomRightRadius({})",
            print_css_property_value(p, tabs, "StyleBorderBottomRightRadius")
        ),
        CssProperty::BorderTopColor(p) => format!(
            "CssProperty::BorderTopColor({})",
            print_css_property_value(p, tabs, "StyleBorderTopColor")
        ),
        CssProperty::BorderRightColor(p) => format!(
            "CssProperty::BorderRightColor({})",
            print_css_property_value(p, tabs, "StyleBorderRightColor")
        ),
        CssProperty::BorderLeftColor(p) => format!(
            "CssProperty::BorderLeftColor({})",
            print_css_property_value(p, tabs, "StyleBorderLeftColor")
        ),
        CssProperty::BorderBottomColor(p) => format!(
            "CssProperty::BorderBottomColor({})",
            print_css_property_value(p, tabs, "StyleBorderBottomColor")
        ),
        CssProperty::BorderTopStyle(p) => format!(
            "CssProperty::BorderTopStyle({})",
            print_css_property_value(p, tabs, "StyleBorderTopStyle")
        ),
        CssProperty::BorderRightStyle(p) => format!(
            "CssProperty::BorderRightStyle({})",
            print_css_property_value(p, tabs, "StyleBorderRightStyle")
        ),
        CssProperty::BorderLeftStyle(p) => format!(
            "CssProperty::BorderLeftStyle({})",
            print_css_property_value(p, tabs, "StyleBorderLeftStyle")
        ),
        CssProperty::BorderBottomStyle(p) => format!(
            "CssProperty::BorderBottomStyle({})",
            print_css_property_value(p, tabs, "StyleBorderBottomStyle")
        ),
        CssProperty::BorderTopWidth(p) => format!(
            "CssProperty::BorderTopWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderTopWidth")
        ),
        CssProperty::BorderRightWidth(p) => format!(
            "CssProperty::BorderRightWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderRightWidth")
        ),
        CssProperty::BorderLeftWidth(p) => format!(
            "CssProperty::BorderLeftWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderLeftWidth")
        ),
        CssProperty::BorderBottomWidth(p) => format!(
            "CssProperty::BorderBottomWidth({})",
            print_css_property_value(p, tabs, "LayoutBorderBottomWidth")
        ),
        CssProperty::BoxShadowLeft(p) => format!(
            "CssProperty::BoxShadowLeft({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::BoxShadowRight(p) => format!(
            "CssProperty::BoxShadowRight({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::BoxShadowTop(p) => format!(
            "CssProperty::BoxShadowTop({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::BoxShadowBottom(p) => format!(
            "CssProperty::BoxShadowBottom({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::ScrollbarStyle(p) => format!(
            "CssProperty::ScrollbarStyle({})",
            print_css_property_value(p, tabs, "ScrollbarStyle")
        ),
        CssProperty::Opacity(p) => format!(
            "CssProperty::Opacity({})",
            print_css_property_value(p, tabs, "StyleOpacity")
        ),
        CssProperty::Visibility(p) => format!(
            "CssProperty::Visibility({})",
            print_css_property_value(p, tabs, "StyleVisibility")
        ),
        CssProperty::Transform(p) => format!(
            "CssProperty::Transform({})",
            print_css_property_value(p, tabs, "StyleTransformVec")
        ),
        CssProperty::TransformOrigin(p) => format!(
            "CssProperty::TransformOrigin({})",
            print_css_property_value(p, tabs, "StyleTransformOrigin")
        ),
        CssProperty::PerspectiveOrigin(p) => format!(
            "CssProperty::PerspectiveOrigin({})",
            print_css_property_value(p, tabs, "StylePerspectiveOrigin")
        ),
        CssProperty::BackfaceVisibility(p) => format!(
            "CssProperty::BackfaceVisibility({})",
            print_css_property_value(p, tabs, "StyleBackfaceVisibility")
        ),
        CssProperty::MixBlendMode(p) => format!(
            "CssProperty::MixBlendMode({})",
            print_css_property_value(p, tabs, "StyleMixBlendMode")
        ),
        CssProperty::Filter(p) => format!(
            "CssProperty::Filter({})",
            print_css_property_value(p, tabs, "StyleFilterVec")
        ),
        CssProperty::BackdropFilter(p) => format!(
            "CssProperty::Filter({})",
            print_css_property_value(p, tabs, "StyleFilterVec")
        ),
        CssProperty::TextShadow(p) => format!(
            "CssProperty::TextShadow({})",
            print_css_property_value(p, tabs, "StyleBoxShadow")
        ),
        CssProperty::Hyphens(p) => format!(
            "CssProperty::Hyphens({})",
            print_css_property_value(p, tabs, "StyleHyphens")
        ),
        CssProperty::Direction(p) => format!(
            "CssProperty::Direction({})",
            print_css_property_value(p, tabs, "Direction")
        ),
        CssProperty::WhiteSpace(p) => format!(
            "CssProperty::WhiteSpace({})",
            print_css_property_value(p, tabs, "WhiteSpace")
        ),
        CssProperty::FlexBasis(p) => format!(
            "CssProperty::FlexBasis({})",
            print_css_property_value(p, tabs, "LayoutFlexBasis")
        ),
        CssProperty::ColumnGap(p) => format!(
            "CssProperty::ColumnGap({})",
            print_css_property_value(p, tabs, "LayoutColumnGap")
        ),
        CssProperty::RowGap(p) => format!(
            "CssProperty::RowGap({})",
            print_css_property_value(p, tabs, "LayoutRowGap")
        ),
        CssProperty::GridTemplateColumns(p) => format!(
            "CssProperty::GridTemplateColumns({})",
            print_css_property_value(p, tabs, "LayoutGridTemplateColumns")
        ),
        CssProperty::GridTemplateRows(p) => format!(
            "CssProperty::GridTemplateRows({})",
            print_css_property_value(p, tabs, "LayoutGridTemplateRows")
        ),
        CssProperty::GridAutoFlow(p) => format!(
            "CssProperty::GridAutoFlow({})",
            print_css_property_value(p, tabs, "LayoutGridAutoFlow")
        ),
        CssProperty::JustifySelf(p) => format!(
            "CssProperty::JustifySelf({})",
            print_css_property_value(p, tabs, "LayoutJustifySelf")
        ),
        CssProperty::JustifyItems(p) => format!(
            "CssProperty::JustifyItems({})",
            print_css_property_value(p, tabs, "LayoutJustifyItems")
        ),
        CssProperty::Gap(p) => format!(
            "CssProperty::Gap({})",
            print_css_property_value(p, tabs, "LayoutGap")
        ),
        CssProperty::GridGap(p) => format!(
            "CssProperty::GridGap({})",
            print_css_property_value(p, tabs, "LayoutGap")
        ),
        CssProperty::AlignSelf(p) => format!(
            "CssProperty::AlignSelf({})",
            print_css_property_value(p, tabs, "LayoutAlignSelf")
        ),
        CssProperty::Font(p) => format!(
            "CssProperty::Font({})",
            print_css_property_value(p, tabs, "StyleFontFamilyVec")
        ),
        CssProperty::GridAutoRows(p) => format!(
            "CssProperty::GridAutoRows({})",
            print_css_property_value(p, tabs, "LayoutGridAutoRows")
        ),
        CssProperty::GridAutoColumns(p) => format!(
            "CssProperty::GridAutoColumns({})",
            print_css_property_value(p, tabs, "LayoutGridAutoColumns")
        ),
        CssProperty::GridRow(p) => format!(
            "CssProperty::GridRow({})",
            print_css_property_value(p, tabs, "LayoutGridRow")
        ),
        CssProperty::GridColumn(p) => format!(
            "CssProperty::GridColumn({})",
            print_css_property_value(p, tabs, "LayoutGridColumn")
        ),
        CssProperty::WritingMode(p) => format!(
            "CssProperty::WritingMode({})",
            print_css_property_value(p, tabs, "LayoutWritingMode")
        ),
        CssProperty::Clear(p) => format!(
            "CssProperty::Clear({})",
            print_css_property_value(p, tabs, "LayoutClear")
        ),
    }
}

fn print_css_property_value<T: FormatAsRustCode>(
    prop_val: &CssPropertyValue<T>,
    tabs: usize,
    property_value_type: &'static str,
) -> String {
    match prop_val {
        CssPropertyValue::Auto => format!("{}Value::Auto", property_value_type),
        CssPropertyValue::None => format!("{}Value::None", property_value_type),
        CssPropertyValue::Initial => format!("{}Value::Initial", property_value_type),
        CssPropertyValue::Inherit => format!("{}Value::Inherit", property_value_type),
        CssPropertyValue::Exact(t) => format!(
            "{}Value::Exact({})",
            property_value_type,
            t.format_as_rust_code(tabs)
        ),
    }
}

fn format_dynamic_css_prop(decl: &DynamicCssProperty, tabs: usize) -> String {
    let t = String::from("    ").repeat(tabs);
    format!(
        "DynamicCssProperty {{\r\n{}    dynamic_id: {:?},\r\n{}    default_value: {},\r\n{}}}",
        t,
        decl.dynamic_id,
        t,
        format_static_css_prop(&decl.default_value, tabs + 1),
        t
    )
}
