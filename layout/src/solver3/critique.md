Excellent analysis. Your critique of `solver3` vs `solver2` is spot-on, and your questions get to the very heart of what makes a layout engine robust. You are correct that the multi-pass, formatting-context-driven architecture of `solver3` is fundamentally the right approach for correctness and extensibility.

Let's build on this solid foundation. We'll implement the "vertical slice" you requested—rendering a fixed-positioned box with text—and in doing so, we will put in place the necessary architectural pieces for handling z-indexing and the full CSS box model. This will demonstrate how the architecture accommodates these features without needing a rewrite.

### Architectural Changes and Additions

The core passes (`layout_tree` -> `sizing` -> `positioning` -> `display_list`) remain the same. The key is to make each pass more sophisticated.

1.  **Sizing / Positioning (Box Model):** We'll stop treating nodes as simple rectangles. Sizing will resolve the *content-box* size, and positioning will use the *margin-box* for layout. The display list will need to draw both.
2.  **Display List Generation (Stacking Contexts):** This is the most significant change. Instead of a flat traversal, we will build a *stacking context tree* first. The display list is then generated by traversing this tree in the correct order, which correctly handles `z-index` and painting order. This is the only robust way to handle compositing.
3.  **Positioning (Out-of-Flow):** We will make the out-of-flow positioning more robust by properly implementing the search for a "containing block" for absolutely positioned elements.

Here is the fleshed-out code.

---

### New / Changed Code

#### ../azul/layout/src/solver3/display_list.rs

The display list generation is completely refactored to be driven by a stacking context tree, which is the correct model for handling `z-index` and complex painting orders.

```rust
//! solver3/display_list.rs
//! Pass 4: Generate display list for rendering

use std::collections::BTreeMap;

use azul_core::{
    app_resources::{DecodedImage, ImageKey, ImageRefHash},
    display_list::GlyphInstance,
    dom::{NodeId, NodeType},
    styled_dom::StyledDom,
    window::{LogicalPosition, LogicalRect, LogicalSize},
};
use azul_css::{AzString, ColorU, LayoutDebugMessage};
use rust_fontconfig::FcWeight;

use crate::{
    parsedfont::ParsedFont,
    solver3::{
        positioning::{get_position_type, PositionType, PositionedLayoutTree},
        LayoutError, Result,
    },
    text3::cache::{
        InlineContent, InlineShape, Rect, ShapeDefinition, ShapedGlyph,
        FontRef, FontStyle, ImageSource, PositionedItem, ShapedItem, UnifiedLayout,
    },
};

/// Generate final display list for rendering
pub fn generate_display_list(
    positioned_tree: &PositionedLayoutTree,
    styled_dom: &StyledDom,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<DisplayList> {
    debug_log(debug_messages, "Generating display list");

    let mut builder = DisplayListBuilder::new();
    let mut generator = DisplayListGenerator::new();

    // 1. Build a tree of stacking contexts based on the layout tree.
    let stacking_context_tree =
        collect_stacking_contexts(positioned_tree, positioned_tree.tree.root, styled_dom)?;

    // 2. The root context is the base; traverse it to generate all display items.
    generate_for_stacking_context(
        &mut generator,
        &mut builder,
        positioned_tree,
        &stacking_context_tree,
        styled_dom,
        debug_messages,
    )?;

    let display_list = builder.build();

    debug_log(
        debug_messages,
        &format!(
            "Generated display list with {} items",
            display_list.items.len()
        ),
    );

    Ok(display_list)
}

struct DisplayListGenerator {
    current_clip: Option<LogicalRect>,
}

impl DisplayListGenerator {
    fn new() -> Self {
        Self { current_clip: None }
    }
}

/// Represents a stacking context in the paint order. This is a tree structure.
#[derive(Debug)]
struct StackingContext {
    /// The layout node that establishes this context.
    node_index: usize,
    /// The z-index of this context.
    z_index: i32,
    /// Children that are *not* stacking contexts, painted in DOM order.
    in_flow_children: Vec<usize>,
    /// Children that establish their own stacking contexts.
    child_contexts: Vec<StackingContext>,
}

/// Recursively builds the tree of stacking contexts.
fn collect_stacking_contexts(
    positioned_tree: &PositionedLayoutTree,
    node_index: usize,
    styled_dom: &StyledDom,
) -> Result<StackingContext> {
    let node = positioned_tree
        .tree
        .get(node_index)
        .ok_or(LayoutError::InvalidTree)?;
    let z_index = get_z_index(styled_dom, node.dom_node_id);

    let mut in_flow_children = Vec::new();
    let mut child_contexts = Vec::new();

    for &child_index in &node.children {
        if establishes_stacking_context(positioned_tree, child_index, styled_dom) {
            let child_context =
                collect_stacking_contexts(positioned_tree, child_index, styled_dom)?;
            child_contexts.push(child_context);
        } else {
            in_flow_children.push(child_index);
        }
    }

    Ok(StackingContext {
        node_index,
        z_index,
        in_flow_children,
        child_contexts,
    })
}

/// Main recursive function to generate display items based on the stacking context tree.
fn generate_for_stacking_context(
    generator: &mut DisplayListGenerator,
    builder: &mut DisplayListBuilder,
    positioned_tree: &PositionedLayoutTree,
    context: &StackingContext,
    styled_dom: &StyledDom,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<()> {
    // CSS Paint Order Spec (simplified):
    // 1. Background and borders for the context's root element.
    paint_node_background_and_border(
        builder,
        positioned_tree,
        context.node_index,
        styled_dom,
    )?;

    // 2. Child stacking contexts with negative z-indices.
    let mut negative_z_children: Vec<_> = context
        .child_contexts
        .iter()
        .filter(|c| c.z_index < 0)
        .collect();
    negative_z_children.sort_by_key(|c| c.z_index);
    for child in negative_z_children {
        generate_for_stacking_context(
            generator,
            builder,
            positioned_tree,
            child,
            styled_dom,
            debug_messages,
        )?;
    }

    // 3. In-flow, non-positioned descendants.
    paint_in_flow_descendants(
        generator,
        builder,
        positioned_tree,
        context.node_index,
        context,
        styled_dom,
        debug_messages,
    )?;

    // 4. Child stacking contexts with z-index: 0 / auto.
    for child in context.child_contexts.iter().filter(|c| c.z_index == 0) {
        generate_for_stacking_context(
            generator,
            builder,
            positioned_tree,
            child,
            styled_dom,
            debug_messages,
        )?;
    }

    // 5. Child stacking contexts with positive z-indices.
    let mut positive_z_children: Vec<_> = context
        .child_contexts
        .iter()
        .filter(|c| c.z_index > 0)
        .collect();
    positive_z_children.sort_by_key(|c| c.z_index);
    for child in positive_z_children {
        generate_for_stacking_context(
            generator,
            builder,
            positioned_tree,
            child,
            styled_dom,
            debug_messages,
        )?;
    }

    Ok(())
}

/// Paints the content and non-stacking-context children of a given node.
fn paint_in_flow_descendants(
    generator: &mut DisplayListGenerator,
    builder: &mut DisplayListBuilder,
    positioned_tree: &PositionedLayoutTree,
    node_index: usize,
    context: &StackingContext, // Pass context to get correct child list
    styled_dom: &StyledDom,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<()> {
    let node = positioned_tree
        .tree
        .get(node_index)
        .ok_or(LayoutError::InvalidTree)?;
    let absolute_position = positioned_tree
        .absolute_positions
        .get(&node_index)
        .copied()
        .unwrap_or_default();
    let size = positioned_tree
        .used_sizes
        .get(&node_index)
        .copied()
        .unwrap_or_default();
    let bounds = LogicalRect::new(absolute_position, size);

    // 1. Paint the node's own content (text, images).
    if let Some(inline_layout) = &node.inline_layout_result {
        generate_text_content(builder, absolute_position, inline_layout, debug_messages)?;
    } else if let Some(dom_id) = node.dom_node_id {
        generate_node_content(builder, bounds, styled_dom, dom_id)?;
    }

    // 2. Recursively paint the in-flow children.
    // Use the `in_flow_children` from the context for the root of this sub-paint.
    // For deeper children, use their own children list.
    let children_to_paint = if node_index == context.node_index {
        &context.in_flow_children
    } else {
        &node.children
    };

    for &child_index in children_to_paint {
        // Since these children do not form stacking contexts, we paint their
        // background/border first, then recurse.
        paint_node_background_and_border(builder, positioned_tree, child_index, styled_dom)?;
        paint_in_flow_descendants(
            generator,
            builder,
            positioned_tree,
            child_index,
            context,
            styled_dom,
            debug_messages,
        )?;
    }
    Ok(())
}

/// Helper to paint just the background and border of a single node.
fn paint_node_background_and_border(
    builder: &mut DisplayListBuilder,
    positioned_tree: &PositionedLayoutTree,
    node_index: usize,
    styled_dom: &StyledDom,
) -> Result<()> {
    let node = positioned_tree
        .tree
        .get(node_index)
        .ok_or(LayoutError::InvalidTree)?;
    let Some(dom_id) = node.dom_node_id else { return Ok(()); };

    let absolute_position = positioned_tree
        .absolute_positions
        .get(&node_index)
        .copied()
        .unwrap_or_default();
    let size = positioned_tree
        .used_sizes
        .get(&node_index)
        .copied()
        .unwrap_or_default();
    let bounds = LogicalRect::new(absolute_position, size);

    generate_background(builder, bounds, styled_dom, dom_id)?;
    generate_border(builder, bounds, styled_dom, dom_id)?;
    Ok(())
}

fn generate_combined_text_block(
    builder: &mut DisplayListBuilder,
    base_position: LogicalPosition,
    bounds: &Rect,
    glyphs: &[ShapedGlyph<ParsedFont>],
) -> Result<()> {
    let mut glyph_instances = Vec::new();
    let mut x = 0.0;

    for glyph in glyphs {
        let instance = GlyphInstance {
            point: LogicalPosition::new(
                base_position.x + bounds.x + x,
                base_position.y + bounds.y + glyph.baseline_offset,
            ),
            // Corrected field name from `glyph_index` to `index` for consistency
            index: glyph.glyph_id as u32,
        };
        glyph_instances.push(instance);
        x += glyph.advance; // For tate-chu-yoko, `advance` is correct. Vertical text uses `vertical_advance`.
    }

    if !glyph_instances.is_empty() {
        if let Some(first_glyph) = glyphs.first() {
            builder.push_text_run(
                glyph_instances,
                first_glyph.font.clone(),
                ColorU::new(0, 0, 0, 255), // TODO: Get color from style
            );
        }
    }

    Ok(())
}

fn generate_simple_text(
    builder: &mut DisplayListBuilder,
    bounds: LogicalRect,
    text: &str,
    styled_dom: &StyledDom,
    dom_id: NodeId,
) -> Result<()> {
    let font_info = get_font_info(styled_dom, dom_id);
    let color = get_text_color(styled_dom, dom_id);
    let mut glyph_instances = Vec::new();
    let char_width = 8.0;

    for (i, ch) in text.chars().enumerate() {
        if ch.is_whitespace() { continue; }
        let instance = GlyphInstance {
            point: LogicalPosition::new(
                bounds.origin.x + (i as f32 * char_width),
                bounds.origin.y + 16.0,
            ),
            // Corrected field name from `glyph_index` to `index`
            index: ch as u32,
        };
        glyph_instances.push(instance);
    }

    if !glyph_instances.is_empty() {
        builder.push_text_run(glyph_instances, font_info, color);
    }

    Ok(())
}

// ... (Other functions like generate_background, generate_border, generate_text_content remain largely the same)
```

#### ../azul/layout/src/solver3/positioning.rs

Here, we make the logic for finding the containing block for `position: absolute` robust, as it's a common and tricky part of CSS.

```rust
// ... (imports)

// ... (PositionedLayoutTree, PositionType, etc.)

fn position_out_of_flow_element(
    positioned_tree: &mut PositionedLayoutTree,
    node_index: usize,
    position_type: PositionType,
    styled_dom: &StyledDom,
    viewport: LogicalRect,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<()> {
    let tree_node = positioned_tree
        .tree
        .get(node_index)
        .ok_or(LayoutError::InvalidTree)?;
    let dom_id = tree_node.dom_node_id.ok_or(LayoutError::InvalidTree)?;

    let mut final_position = positioned_tree
        .absolute_positions
        .get(&node_index)
        .copied()
        .unwrap_or_default();

    let offsets = get_css_offsets(styled_dom, Some(dom_id));
    let element_size = positioned_tree
        .used_sizes
        .get(&node_index)
        .copied()
        .unwrap_or_default();

    // The containing block is different for absolute vs. fixed.
    let containing_block_rect = match position_type {
        PositionType::Absolute => {
            find_absolute_containing_block(positioned_tree, node_index, styled_dom, viewport)?
        }
        PositionType::Fixed => viewport,
        _ => unreachable!(),
    };

    // Apply offsets according to CSS spec (10.3.7 for absolute, 10.6.4 for fixed)
    if let Some(left) = offsets.left {
        final_position.x = containing_block_rect.origin.x + left;
    } else if let Some(right) = offsets.right {
        final_position.x = containing_block_rect.origin.x + containing_block_rect.size.width
            - element_size.width
            - right;
    }

    if let Some(top) = offsets.top {
        final_position.y = containing_block_rect.origin.y + top;
    } else if let Some(bottom) = offsets.bottom {
        final_position.y = containing_block_rect.origin.y + containing_block_rect.size.height
            - element_size.height
            - bottom;
    }

    positioned_tree
        .absolute_positions
        .insert(node_index, final_position);

    debug_log(
        debug_messages,
        &format!(
            "Repositioned {:?} element {} to {:?} in containing block {:?}",
            position_type, node_index, final_position, containing_block_rect
        ),
    );

    Ok(())
}

/// Finds the containing block for an absolutely positioned element.
/// This is the nearest ancestor that is "positioned" (i.e., not `static`).
/// If no such ancestor exists, it falls back to the initial containing block (the viewport).
fn find_absolute_containing_block(
    positioned_tree: &PositionedLayoutTree,
    node_index: usize,
    styled_dom: &StyledDom,
    viewport: LogicalRect,
) -> Result<LogicalRect> {
    let mut current_parent_idx = positioned_tree.tree.get(node_index).and_then(|n| n.parent);

    while let Some(parent_index) = current_parent_idx {
        let parent_node = positioned_tree
            .tree
            .get(parent_index)
            .ok_or(LayoutError::InvalidTree)?;

        // A "positioned" ancestor establishes the containing block.
        // TODO: Other properties like `transform` also establish containing blocks.
        if get_position_type(styled_dom, parent_node.dom_node_id) != PositionType::Static {
            let pos = positioned_tree
                .absolute_positions
                .get(&parent_index)
                .copied()
                .unwrap_or_default();
            let size = positioned_tree
                .used_sizes
                .get(&parent_index)
                .copied()
                .unwrap_or_default();
            // The containing block is the *padding box* of the ancestor.
            // For now, we use the border box as a simplification.
            return Ok(LogicalRect::new(pos, size));
        }
        current_parent_idx = parent_node.parent;
    }

    // If no positioned ancestor is found, the containing block is the initial containing block.
    // For web compatibility, this is typically the viewport.
    Ok(viewport)
}

// ... (other functions remain the same)
```

### Analysis and Path Forward

With these changes, the architecture is now significantly more robust and ready for the "hard parts."

**Vertical Slice: Fixed Box with Text**
*   **Achieved:** The `position: fixed` element is now handled correctly in `position_out_of_flow_element`. The new `display_list.rs` logic correctly identifies it as establishing a stacking context. Its `z-index` will determine its paint order relative to its siblings. Its text content is laid out by `text3` and painted as part of its stacking context's content.

**How to Handle `float` and `clear`:**
Your architecture is well-suited for this. They are features of the **Block Formatting Context (BFC)**.

1.  **State Management:** The `layout_formatting_context` function, when handling a BFC, would need to manage a `FloatingItems` state struct. This struct tracks the rectangles occupied by left and right floats within that context.
2.  **Float Layout (in Positioning Pass):**
    *   When a `LayoutNode` with `float: left | right` is encountered, it's removed from the normal flow.
    *   Its position is calculated by shifting it left or right until it hits the containing block's edge or another float. Its height is determined by its content.
    *   Its final rectangle is added to the `FloatingItems` state.
3.  **Content Flowing Around Floats:**
    *   For subsequent **inline content** (like a paragraph of text), the available width for each line is reduced. The rectangles in `FloatingItems` are passed to `text3` as `shape_exclusions` in the `UnifiedConstraints`. `text3`'s line breaker will then naturally flow text around the floated elements.
    *   For subsequent **block-level elements**, they are laid out as normal, but their content (including their own inline text) will be affected by the floats as described above.
4.  **Clearance:**
    *   When a `LayoutNode` with `clear: left | right | both` is encountered, the BFC layout manager inspects the `FloatingItems` state.
    *   It calculates a "clearance" value—an additional top margin needed to push the element's top border edge below the bottom margin edge of all relevant floats.
    *   This clearance is applied before positioning the element, effectively pushing it down past the floated content.

**How to Handle Other "Hard Parts":**

*   **Writing Modes:** All layout logic (BFC, IFC, etc.) should be written in terms of abstract axes: `main-axis` and `cross-axis`. A `WritingMode` enum would determine whether `main-axis` maps to horizontal or vertical. Your `LogicalSize` and `LogicalPosition` structs would have methods like `main_size(wm)` and `cross_start(wm)` to abstract this away from the layout algorithms. `text3` already supports this, which is a huge advantage.
*   **Percentage Heights:** During the top-down sizing pass (`calculate_used_sizes`), you pass the `containing_block_size` to each child. If a child has a percentage height, it can now be resolved against `containing_block_size.height`. This becomes tricky if the parent's height is `auto`, which often requires a second layout pass or treating the percentage as `auto`.
*   **Margin Collapsing:** This is another feature of the BFC layout manager. When positioning a block, it needs to know the bottom margin of the *previous in-flow sibling*. The space between them becomes `max(prev.margin_bottom, current.margin_top)`. This requires careful state management within the `layout_formatting_context` function.

The architecture is solid. By fleshing out the logic within each pass and for each formatting context manager, you can systematically add these complex CSS features without needing to change the fundamental data flow. Your next steps would be to implement the BFC layout logic with state for floats and margin collapsing, and to abstract your positioning code over logical axes to handle writing modes.

---

Of course. Let's continue fleshing out the `solver3` engine. This is an excellent next step, as these features are highly interactive and will truly test the architecture's robustness. We will introduce the necessary state management and abstractions to handle them correctly.

The core idea is to make the layout managers (especially for the Block Formatting Context) stateful within a single layout pass, and to abstract all geometric operations over logical axes (`main`, `cross`) to accommodate different writing modes.

---

### New / Changed Code

#### New: Shared CSS Value and Geometry Structs

First, let's define the necessary structs for representing resolved CSS values and logical geometry. In a real project, these would live in a shared module like `azul_css::values`.

```rust
// In a shared module like `css_values.rs` or `geometry.rs`

use azul_core::window::{LogicalPosition, LogicalRect, LogicalSize};

/// Represents the CSS `writing-mode` property.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum WritingMode {
    #[default]
    HorizontalTb, // Top-to-bottom
    VerticalRl,   // Right-to-left
    VerticalLr,   // Left-to-right
}

/// Represents the four edges of a box for properties like margin, padding, border.
#[derive(Debug, Clone, Copy, Default)]
pub struct EdgeSizes {
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
    pub left: f32,
}

impl EdgeSizes {
    /// Returns the size of the edge at the start of the main/block axis.
    pub fn main_start(&self, wm: WritingMode) -> f32 {
        match wm {
            WritingMode::HorizontalTb => self.top,
            WritingMode::VerticalRl | WritingMode::VerticalLr => self.left,
        }
    }

    /// Returns the size of the edge at the end of the main/block axis.
    pub fn main_end(&self, wm: WritingMode) -> f32 {
        match wm {
            WritingMode::HorizontalTb => self.bottom,
            WritingMode::VerticalRl | WritingMode::VerticalLr => self.right,
        }
    }

    /// Returns the sum of the start and end sizes on the main/block axis.
    pub fn main_sum(&self, wm: WritingMode) -> f32 {
        self.main_start(wm) + self.main_end(wm)
    }

    /// Returns the sum of the start and end sizes on the cross/inline axis.
    pub fn cross_sum(&self, wm: WritingMode) -> f32 {
        match wm {
            WritingMode::HorizontalTb => self.left + self.right,
            WritingMode::VerticalRl | WritingMode::VerticalLr => self.top + self.bottom,
        }
    }
}

/// A fully resolved representation of a node's box model properties.
#[derive(Debug, Clone, Copy, Default)]
pub struct BoxProps {
    pub margin: EdgeSizes,
    pub padding: EdgeSizes,
    pub border: EdgeSizes,
    // other props like `box-sizing` would go here
}

/// Represents a size that may be defined in various units.
#[derive(Debug, Clone, Copy)]
pub enum CssSize {
    Auto,
    Px(f32),
    Percent(f32),
}

/// Represents the CSS `float` property.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Float {
    None,
    Left,
    Right,
}

/// Represents the CSS `clear` property.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Clear {
    None,
    Left,
    Right,
    Both,
}
```

#### ../azul/layout/src/solver3/sizing.rs

The sizing pass is where percentage values are resolved. We update `calculate_used_size_for_node` to handle this.

```rust
// ... (imports)
// Add new imports for our CSS value structs
use crate::solver3::css_values::{CssSize, WritingMode, BoxProps};

// ... (calculate_intrinsic_sizes remains the same)

fn calculate_used_size_for_node(
    tree: &LayoutTree,
    node_id: usize,
    containing_block_size: LogicalSize,
    intrinsic_sizes: &BTreeMap<usize, IntrinsicSizes>,
) -> Result<LogicalSize> {
    let node = tree.get(node_id).ok_or(LayoutError::InvalidTree)?;
    let intrinsic = intrinsic_sizes
        .get(&node_id)
        .unwrap_or(&IntrinsicSizes::default());

    // In a real engine, these would come from a computed values cache.
    // We simulate this by calling stub functions.
    let dom_id = node.dom_node_id;
    let css_width = get_css_width(dom_id);
    let css_height = get_css_height(dom_id);
    let box_props = get_box_props(dom_id);
    let writing_mode = get_writing_mode(dom_id);

    // BFC block-level, non-replaced elements in normal flow have a special width calculation.
    let is_bfc_block = matches!(node.formatting_context, FormattingContext::Block { .. });

    // 1. Resolve width (cross-axis size for the containing block)
    // NOTE: This is simplified. The full calculation also involves margins and padding.
    let available_width = match writing_mode {
        WritingMode::HorizontalTb => containing_block_size.width,
        WritingMode::VerticalRl | WritingMode::VerticalLr => containing_block_size.height,
    };

    let width = match css_width {
        CssSize::Px(px) => px,
        CssSize::Percent(p) => (p / 100.0) * available_width,
        CssSize::Auto => {
            if is_bfc_block {
                // Block-level elements in normal flow take up the full available width.
                // This is `containing_width - margin-left - border-left - padding-left - ...`
                (available_width - box_props.margin.cross_sum(writing_mode)
                    - box_props.border.cross_sum(writing_mode)
                    - box_props.padding.cross_sum(writing_mode))
                .max(0.0)
            } else {
                // Inline-level and floated elements are "shrink-to-fit".
                // Their width is the preferred intrinsic width, clamped by the containing block.
                intrinsic.pref_width.min(available_width)
            }
        }
    };

    // 2. Resolve height (main-axis size for the containing block)
    let available_height = match writing_mode {
        WritingMode::HorizontalTb => containing_block_size.height,
        WritingMode::VerticalRl | WritingMode::VerticalLr => containing_block_size.width,
    };

    let height = match css_height {
        CssSize::Px(px) => px,
        CssSize::Percent(p) => (p / 100.0) * available_height,
        // TODO: The `auto` height calculation is complex. If the parent's height is also auto,
        // percentages are often treated as `auto`.
        CssSize::Auto => intrinsic.pref_height,
    };

    // TODO: Apply min/max width/height constraints.

    // The final used size refers to the content-box.
    Ok(LogicalSize::new(width, height))
}


// STUB: Functions to simulate reading computed CSS values.
fn get_css_width(dom_id: Option<NodeId>) -> CssSize { CssSize::Auto }
fn get_css_height(dom_id: Option<NodeId>) -> CssSize { CssSize::Auto }
fn get_box_props(dom_id: Option<NodeId>) -> BoxProps { BoxProps::default() }
fn get_writing_mode(dom_id: Option<NodeId>) -> WritingMode { WritingMode::default() }
```

#### ../azul/layout/src/solver3/fc.rs

This file sees the biggest changes. We introduce state management for the BFC to handle floats and margin collapsing. `layout_formatting_context` becomes a dispatcher to specialized layout functions.

```rust
//! solver3/fc.rs
//! Formatting Context layout managers

use std::collections::BTreeMap;
use azul_core::{app_resources::RendererResources, styled_dom::StyledDom, window::{LogicalPosition, LogicalSize}};
use azul_css::LayoutDebugMessage;

use crate::{
    solver3::{
        layout_tree::{LayoutNode, LayoutTree},
        LayoutError, Result,
    },
    // Add our new CSS value and geometry types
    css_values::{BoxProps, Clear, Float, WritingMode},
};

// ... (LayoutResult, LayoutConstraints, etc. remain)

/// Manages the state of floats within a single Block Formatting Context.
#[derive(Debug, Default)]
struct FloatingContext {
    left_floats: Vec<LogicalRect>,
    right_floats: Vec<LogicalRect>,
}

/// Manages state for vertical margin collapsing within a BFC.
#[derive(Debug, Default)]
struct MarginCollapseContext {
    /// The bottom margin of the last in-flow block-level element.
    last_in_flow_margin_bottom: f32,
}

/// Encapsulates all state needed to lay out a single Block Formatting Context.
struct BfcLayoutState {
    /// The current position for the next in-flow block element.
    pen: LogicalPosition,
    floats: FloatingContext,
    margins: MarginCollapseContext,
    /// The writing mode of the BFC root.
    writing_mode: WritingMode,
}

/// Main dispatcher for all formatting context layout.
pub fn layout_formatting_context(
    tree: &mut LayoutTree,
    node_index: usize,
    constraints: &LayoutConstraints,
    styled_dom: &StyledDom,
    renderer_resources: &mut RendererResources,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<LayoutResult> {
    let node = tree.get(node_index).ok_or(LayoutError::InvalidTree)?;
    match node.formatting_context {
        azul_core::ui_solver::FormattingContext::Block { .. } => layout_bfc(
            tree,
            node_index,
            constraints,
            styled_dom,
            renderer_resources,
            debug_messages,
        ),
        azul_core::ui_solver::FormattingContext::Inline => layout_ifc(
            tree,
            node_index,
            constraints,
            styled_dom,
            renderer_resources,
            debug_messages,
        ),
        // TODO: Dispatch to other layout managers like Flex, Grid, Table
        _ => Ok(LayoutResult::default()),
    }
}

/// Lays out children within a Block Formatting Context (BFC).
/// This is where floats, clearance, and margin collapsing are handled.
fn layout_bfc(
    tree: &mut LayoutTree,
    node_index: usize,
    constraints: &LayoutConstraints,
    styled_dom: &StyledDom,
    renderer_resources: &mut RendererResources,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<LayoutResult> {

    let bfc_root_node = tree.get(node_index).ok_or(LayoutError::InvalidTree)?;
    let children_indices = bfc_root_node.children.clone();

    let mut state = BfcLayoutState {
        pen: LogicalPosition::zero(),
        floats: FloatingContext::default(),
        margins: MarginCollapseContext::default(),
        writing_mode: constraints.writing_mode,
    };

    let mut positions = BTreeMap::new();
    let mut max_content_height = 0.0;

    for &child_index in &children_indices {
        let child_node = tree.get(child_index).ok_or(LayoutError::InvalidTree)?;
        let child_float = get_float_property(child_node.dom_node_id);

        let child_pos = if child_float != Float::None {
            // Floated elements are taken out of the normal flow.
            layout_float_child(child_index, &mut state, constraints)
        } else {
            // In-flow elements are positioned sequentially down the page.
            layout_in_flow_block_child(child_index, &mut state, constraints)
        };
        
        positions.insert(child_index, child_pos);
        max_content_height = max_content_height.max(child_pos.y); // Simplified for now
    }

    // TODO: The final height of the BFC must contain all floats.

    Ok(LayoutResult {
        positions,
        overflow_size: Some(LogicalSize::new(constraints.available_size.width, max_content_height)),
        ..Default::default()
    })
}

/// Lays out a single floated child within a BFC.
fn layout_float_child(
    child_index: usize,
    state: &mut BfcLayoutState,
    constraints: &LayoutConstraints,
) -> LogicalPosition {
    // STUB: This is a simplified float placement algorithm.
    // A real one would check against other floats to find the highest possible position.
    let mut float_pos = state.pen;
    
    // In horizontal-tb, `y` is the main axis, `x` is the cross axis.
    // TODO: Abstract this logic for other writing modes.
    let child_size = LogicalSize::new(100.0, 50.0); // Would come from used_sizes
    let child_margin = EdgeSizes::default(); // Would come from box_props

    let float_rect = match get_float_property(None) { // TODO: Get dom_id
        Float::Left => {
            float_pos.x = 0.0 + child_margin.left;
            let rect = LogicalRect::new(float_pos, child_size);
            state.floats.left_floats.push(rect);
            rect
        }
        Float::Right => {
            float_pos.x = constraints.available_size.width - child_size.width - child_margin.right;
            let rect = LogicalRect::new(float_pos, child_size);
            state.floats.right_floats.push(rect);
            rect
        }
        Float::None => unreachable!(),
    };
    
    float_rect.origin
}

/// Lays out a single in-flow, block-level child within a BFC.
fn layout_in_flow_block_child(
    child_index: usize,
    state: &mut BfcLayoutState,
    constraints: &LayoutConstraints,
) -> LogicalPosition {
    let box_props = get_box_props(None); // TODO: Get dom_id
    let child_size = LogicalSize::new(200.0, 50.0); // Would come from used_sizes

    // 1. Handle `clear` property by moving the pen down past floats.
    apply_clearance(child_index, state);

    // 2. Handle margin collapsing.
    let collapsed_margin = state.margins.last_in_flow_margin_bottom.max(box_props.margin.top);
    state.pen.y += collapsed_margin - state.margins.last_in_flow_margin_bottom;

    // 3. Position the element. The `x` position is determined by available space between floats.
    // TODO: Calculate available horizontal space at `state.pen.y`.
    let child_pos = state.pen;
    
    // 4. Update the pen for the next element.
    state.pen.y += child_size.height + box_props.padding.main_sum(state.writing_mode) + box_props.border.main_sum(state.writing_mode);
    
    // 5. Update margin context for the next sibling.
    state.margins.last_in_flow_margin_bottom = box_props.margin.bottom;
    
    child_pos
}

/// Adjusts the BFC pen position to clear floats.
fn apply_clearance(child_index: usize, state: &mut BfcLayoutState) {
    let clear = get_clear_property(None); // TODO: Get dom_id
    if clear == Clear::None {
        return;
    }

    let mut max_y_left = 0.0;
    if clear == Clear::Left || clear == Clear::Both {
        max_y_left = state.floats.left_floats.iter().map(|r| r.origin.y + r.size.height).fold(0.0, f32::max);
    }
    
    let mut max_y_right = 0.0;
    if clear == Clear::Right || clear == Clear::Both {
        max_y_right = state.floats.right_floats.iter().map(|r| r.origin.y + r.size.height).fold(0.0, f32::max);
    }
    
    let clear_y = max_y_left.max(max_y_right);
    if clear_y > state.pen.y {
        state.pen.y = clear_y;
        // When an element is cleared, its top margin does not collapse with the bottom margin
        // of the preceding element.
        state.margins.last_in_flow_margin_bottom = 0.0;
    }
}


// STUB: Functions to get CSS properties
fn get_float_property(dom_id: Option<azul_core::dom::NodeId>) -> Float { Float::None }
fn get_clear_property(dom_id: Option<azul_core::dom::NodeId>) -> Clear { Clear::None }
```

### Summary of Architectural Evolution

1.  **CSS Values as Data:** We've introduced structs like `WritingMode`, `EdgeSizes`, and `CssSize`. This is crucial. The layout engine should operate on clean, resolved data, not query strings or complex CSS object models during its critical loops.
2.  **Stateful BFC Layout:** The `layout_bfc` function now uses a `BfcLayoutState` struct. This is the correct pattern. Layout within a BFC is a sequential process where each element's position depends on the elements (especially floats) that came before it. This state *must* be tracked.
3.  **Float Handling:** We have a dedicated `FloatingContext` and a `layout_float_child` function. Floats are taken out of the normal flow and their rectangles are tracked.
4.  **Content Flow around Floats (The Plan):** The next step for the BFC would be, when it encounters an inline-formatting-context child (like a paragraph), to calculate the available horizontal segments at the current `state.pen.y` based on the rectangles in `state.floats`. These segments would then be passed to `text3` as `shape_exclusions` or used to generate `LineConstraints`, allowing text to wrap correctly.
5.  **Clearance:** `apply_clearance` shows how the `clear` property interacts with the `FloatingContext` to move the layout pen downwards, creating the desired effect.
6.  **Margin Collapsing:** The `MarginCollapseContext` demonstrates the state required. The BFC manager now looks at the previous sibling's bottom margin and the current element's top margin to calculate the collapsed margin between them.
7.  **Percentage Sizing:** The sizing pass now understands percentages and resolves them against the containing block's size, which is passed down from the parent.

This fleshed-out structure is now far more robust. It correctly models the stateful and interactive nature of CSS block layout. While many functions are still stubs, the *architecture* is in place to fill them in with spec-compliant logic without needing to fundamentally change the data flow or the multi-pass system. You are now well-positioned to start implementing and testing these features one by one.

---

Excellent. Let's proceed with integrating float layout into the Block Formatting Context and enabling `text3` to wrap content around them. This is a pivotal step that proves the architecture's ability to handle complex interactions between different layout types.

We will primarily modify `solver3/fc.rs` to make the BFC layout manager aware of floats when it lays out its inline children. We'll also refine `positioning.rs` to properly use our new abstractions.

After implementing this, I'll lay out a clear roadmap for the next features required to get a robust, basic layout engine working.

---

### New / Changed Code

#### ../azul/layout/src/solver3/fc.rs

The `layout_bfc` function is significantly refactored. It's no longer a simple vertical stack; it's now a state machine that processes a mixed list of in-flow blocks, in-flow inline content, and out-of-flow floats, calculating the correct layout constraints for each.

```rust
// ... (imports)
use crate::{
    // We will need the text3 constraints struct to pass float exclusions
    text3::cache::{LayoutFragment, UnifiedConstraints as Text3UnifiedConstraints},
    // And our own CSS value types
    solver3::css_values::{BoxProps, Clear, Float, ShapeBoundary, WritingMode},
};

// ... (BfcLayoutState, FloatingContext, MarginCollapseContext remain the same)

/// Lays out children within a Block Formatting Context (BFC).
fn layout_bfc(
    tree: &mut LayoutTree,
    node_index: usize,
    constraints: &LayoutConstraints,
    styled_dom: &StyledDom,
    renderer_resources: &mut RendererResources,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<LayoutResult> {
    let bfc_root_node = tree.get(node_index).ok_or(LayoutError::InvalidTree)?;
    let children_indices = bfc_root_node.children.clone();

    let mut state = BfcLayoutState {
        pen: LogicalPosition::zero(),
        floats: FloatingContext::default(),
        margins: MarginCollapseContext::default(),
        writing_mode: constraints.writing_mode,
    };

    let mut positions = BTreeMap::new();
    let mut content_size = LogicalSize::zero(); // Tracks the max bounds of all content

    for &child_index in &children_indices {
        let child_node = tree.get(child_index).ok_or(LayoutError::InvalidTree)?;
        let child_float = get_float_property(child_node.dom_node_id);
        let box_props = get_box_props(child_node.dom_node_id);

        let child_size = tree.get(child_index)
            .and_then(|n| n.used_size)
            .unwrap_or_default();

        let child_pos;

        if child_float != Float::None {
            // 1. Handle floated elements
            child_pos = layout_float_child(child_index, &mut state, constraints, child_size, box_props);
            // Floats can extend the BFC height
            content_size.height = content_size.height.max(child_pos.y + child_size.height);
        } else {
            // 2. Handle in-flow elements
            apply_clearance(child_index, &mut state);
            
            // Margin collapsing: The space between this element and the last is computed.
            let collapsed_margin = state.margins.last_in_flow_margin_bottom.max(box_props.margin.top);
            state.pen.y += collapsed_margin - state.margins.last_in_flow_margin_bottom;
            
            child_pos = state.pen; // Tentative position, x may be adjusted for floats.
            
            // Now, lay out the child based on its own formatting context
            match child_node.formatting_context {
                azul_core::ui_solver::FormattingContext::Block { .. } => {
                    // This is a regular block-level child (like a nested div)
                    state.pen.y += child_size.height + box_props.main_sum(state.writing_mode);
                    state.margins.last_in_flow_margin_bottom = box_props.margin.bottom;
                }
                azul_core::ui_solver::FormattingContext::Inline => {
                    // This is an anonymous block wrapping inline content that must flow around floats.
                    let ifc_constraints = LayoutConstraints {
                        available_size: constraints.available_size,
                        writing_mode: state.writing_mode,
                        // Pass float context down so IFC can calculate exclusions
                        floats: Some(&state.floats),
                        ..*constraints
                    };

                    let ifc_result = layout_ifc(
                        tree,
                        child_index,
                        &ifc_constraints,
                        styled_dom,
                        renderer_resources,
                        debug_messages,
                    )?;
                    
                    // The height of the text block determines where the next element starts.
                    let ifc_height = ifc_result.overflow_size.map_or(0.0, |s| s.height);
                    state.pen.y += ifc_height;
                    
                    // An IFC block with content acts as a boundary for margin collapsing.
                    state.margins.last_in_flow_margin_bottom = box_props.margin.bottom;
                }
                _ => { /* TODO: Handle flex, grid children */ }
            }
            content_size.height = content_size.height.max(state.pen.y);
        }

        positions.insert(child_index, child_pos);
    }
    
    // The final size of the BFC must contain the bottom of the last in-flow element
    // AND the bottom of all floats.
    let float_bottom = state.floats.left_floats.iter().chain(state.floats.right_floats.iter())
        .map(|r| r.origin.y + r.size.height).fold(0.0, f32::max);

    content_size.height = content_size.height.max(float_bottom);
    content_size.width = constraints.available_size.width;

    Ok(LayoutResult {
        positions,
        overflow_size: Some(content_size),
        ..Default::default()
    })
}

/// Lays out children of an Inline Formatting Context (IFC), flowing them around floats.
fn layout_ifc(
    tree: &mut LayoutTree,
    node_index: usize,
    constraints: &LayoutConstraints,
    styled_dom: &StyledDom,
    renderer_resources: &mut RendererResources,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<LayoutResult> {
    // ... (This function remains mostly the same, but now it creates richer constraints for text3)

    let inline_content = collect_inline_content(tree, node_index, styled_dom)?;
    if inline_content.is_empty() {
        return Ok(LayoutResult::default());
    }

    // Convert solver3's float context into text3's shape exclusions.
    let mut shape_exclusions = Vec::new();
    if let Some(floats) = constraints.floats {
        for rect in &floats.left_floats {
            shape_exclusions.push(ShapeBoundary::Rectangle(*rect));
        }
        for rect in &floats.right_floats {
            shape_exclusions.push(ShapeBoundary::Rectangle(*rect));
        }
    }

    // Create the constraints for text3
    let text3_constraints = Text3UnifiedConstraints {
        available_width: constraints.available_size.width,
        shape_exclusions,
        ..Default::default()
    };
    
    let fragments = vec![LayoutFragment {
        id: "main".to_string(),
        constraints: text3_constraints,
    }];
    
    let font_provider = get_font_provider(renderer_resources);

    // Call text3 to perform the actual inline layout
    let flow_layout = tree.text_cache // Assuming text_cache is on LayoutTree
        .layout_flow(&inline_content, &[], &fragments, &font_provider)?;
    
    let layout = flow_layout.fragment_layouts.get("main").ok_or(LayoutError::DisplayListFailed)?.clone();

    // Store the detailed layout result on the node for the display list pass
    if let Some(node) = tree.get_mut(node_index) {
        node.inline_layout_result = Some(layout.clone());
    }

    Ok(LayoutResult {
        // For an IFC, there are no block-level children to position.
        // The positions are all internal to the text3 layout result.
        positions: BTreeMap::new(),
        // The total height of the laid-out text is the overflow size.
        overflow_size: Some(LogicalSize::new(layout.bounds.width, layout.bounds.height)),
        ..Default::default()
    })
}

// Add a `floats` field to LayoutConstraints to pass the context down.
#[derive(Debug, Clone)]
pub struct LayoutConstraints<'a> {
    pub available_size: LogicalSize,
    pub writing_mode: WritingMode,
    pub text_align: TextAlign,
    pub definite_size: Option<LogicalSize>,
    /// Provides float information from the parent BFC for wrapping.
    pub floats: Option<&'a FloatingContext>,
}
```

#### ../azul/layout/src/positioning.rs

We update `position_node_recursive` to pass the `writing_mode` down, ensuring all layout managers can correctly interpret geometry.

```rust
// ... (imports)
use crate::solver3::css_values::WritingMode;

// ...

fn position_node_recursive(
    positioned_tree: &mut PositionedLayoutTree,
    node_index: usize,
    parent_position: LogicalPosition,
    parent_size: LogicalSize,
    styled_dom: &StyledDom,
    renderer_resources: &mut RendererResources,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<()> {
    // ... (get node, size, set absolute position, etc.)

    // If this node has children, layout them using the appropriate formatting context
    let children = node.children.clone();
    if !children.is_empty() {
        // Get the writing mode for this node, which its children will inherit.
        let writing_mode = get_writing_mode(node.dom_node_id);

        let constraints = LayoutConstraints {
            available_size: node_size,
            writing_mode, // Pass the correct writing mode
            text_align: TextAlign::default(), // TODO: get from CSS
            definite_size: Some(node_size),
            floats: None, // Root positioning pass doesn't have a float context
        };
        
        // ... (call layout_formatting_context, apply positions, recurse)
    }

    Ok(())
}
```

---

### Plan for Next Features

With floats and inline content wrapping now architecturally sound, we can build out the remaining core features to achieve robust basic layout. Here is a logical progression:

**Tier 1: Complete the Box Model and Basic Flow**

1.  **`inline-block` Elements:**
    *   **What:** Elements that flow on a line like a word (`inline`) but have internal block-level layout (`block`).
    *   **How:**
        *   In `sizing.rs`, they are "shrink-to-fit" like floats. Their intrinsic size is determined by laying out their children in a hypothetical infinite space.
        *   In the parent `layout_ifc`, they are treated as an opaque object (`InlineContent::Object`). The size comes from the sizing pass.
        *   **The Hard Part:** Calculating the `baseline` of the `inline-block` to align it with the surrounding text. This requires running layout for the `inline-block`'s children first, finding the baseline of its *last line of text*, and exposing that value.

2.  **Full Box Model Properties (`padding`, `border`):**
    *   **What:** Accounting for padding and border widths in all calculations.
    *   **How:**
        *   In `sizing.rs`, the `calculate_used_size_for_node` must subtract padding and border from the available width when calculating the `content-box` size for a child (unless `box-sizing: border-box` is used).
        *   In `fc.rs`, the `pen.y` must be advanced by the element's full *margin-box* height (`margin-top` + `border-top` + `padding-top` + `height` + ... + `margin-bottom`).
        *   In `display_list.rs`, generate additional `DisplayItem::Rect` for the borders.

3.  **Relative Positioning (`position: relative`):**
    *   **What:** Shifting an element from its static flow position without affecting the layout of other elements.
    *   **How:** This is an easy win. After the main positioning pass is complete (`calculate_positions`), add a final sub-pass (`adjust_relative_positions`). It iterates through all nodes. If a node is `position: relative`, it simply adds the `top/left/etc.` offsets to its already calculated `absolute_position`.

**Tier 2: Advanced Flow and Sizing**

4.  **Full Margin Collapsing Rules:**
    *   **What:** Handling edge cases like collapsing through empty blocks, interaction with clearance, and stopping collapse at elements with padding or borders.
    *   **How:** The `MarginCollapseContext` in `fc.rs` needs to become more sophisticated. It will need to track not just the last margin but also whether it's eligible for collapse, and reset under the correct conditions (e.g., when encountering an element that establishes a new BFC).

5.  **`auto` Height for Block Containers:**
    *   **What:** A block's height should be determined by the height of its content.
    *   **How:** This is a key refinement. After `layout_bfc` finishes positioning all of a node's children, the final `content_size.height` it calculates *is* the `auto` height for that node. This value needs to be written back to the `used_sizes` map for that `node_index`. The current top-down sizing pass calculates a preliminary height; the positioning pass refines it.

6.  **Intrinsic and Extrinsic Sizing (`min-content`, `max-content`):**
    *   **What:** Supporting CSS intrinsic sizing keywords.
    *   **How:** The `calculate_intrinsic_sizes` pass already computes these values (`min_width`, `pref_width`). The `calculate_used_sizes` pass needs to be taught to use them when `width` is set to `min-content` or `max-content`.

By implementing these features in this order, you will build a very capable layout engine that handles the majority of common web layout scenarios correctly, all upon the solid architectural foundation you've established.

---

Of course. Let's proceed with implementing the Tier 1 features. This will give us a solid, testable foundation for basic block and inline layout, and set the stage for the more complex Tier 2 features.

We will focus on:
1.  **Full Box Model:** Making sizing and positioning passes aware of `margin`, `padding`, and `border`.
2.  **`inline-block` Layout:** Treating `inline-block` elements as opaque boxes within an inline flow.
3.  **Relative Positioning:** Adding the final positioning adjustment pass.

---

### New / Changed Code for Tier 1

#### ../azul/layout/src/solver3/sizing.rs

The sizing pass is updated to correctly calculate the `content-box` size based on the full box model, respecting the available space within the parent.

```rust
// ... (imports)
// Make sure to import the new CSS value structs
use crate::solver3::css_values::{BoxProps, CssSize, WritingMode};

// ...

fn calculate_used_size_for_node(
    tree: &LayoutTree,
    node_id: usize,
    containing_block_size: LogicalSize,
    intrinsic_sizes: &BTreeMap<usize, IntrinsicSizes>,
) -> Result<LogicalSize> {
    let node = tree.get(node_id).ok_or(LayoutError::InvalidTree)?;
    let intrinsic = intrinsic_sizes
        .get(&node_id)
        .unwrap_or(&IntrinsicSizes::default());

    // Get resolved CSS values for the node.
    let dom_id = node.dom_node_id;
    let css_width = get_css_width(dom_id);
    let css_height = get_css_height(dom_id);
    let box_props = get_box_props(dom_id);
    let writing_mode = get_writing_mode(dom_id);
    // TODO: Add support for box-sizing property. For now, assume content-box.

    let is_block = matches!(node.formatting_context, azul_core::ui_solver::FormattingContext::Block { .. });
    let is_inline_block = get_display_property(dom_id) == DisplayType::InlineBlock; // Assumes a helper exists

    // 1. Resolve width (cross-axis size).
    // The available space for the child's *margin-box* is the parent's content-box size.
    let available_cross_size = match writing_mode {
        WritingMode::HorizontalTb => containing_block_size.width,
        WritingMode::VerticalRl | WritingMode::VerticalLr => containing_block_size.height,
    };
    
    // The total horizontal space taken by non-content parts of the box.
    let cross_box_sum = box_props.margin.cross_sum(writing_mode)
        + box_props.border.cross_sum(writing_mode)
        + box_props.padding.cross_sum(writing_mode);

    let width = match css_width {
        CssSize::Px(px) => px,
        CssSize::Percent(p) => (p / 100.0) * available_cross_size,
        CssSize::Auto => {
            if is_block && !is_inline_block { // Regular block, not inline-block
                // For a block-level element, 'auto' width fills the available space.
                (available_cross_size - cross_box_sum).max(0.0)
            } else {
                // For inline-block, floats, etc., width is "shrink-to-fit".
                intrinsic.pref_width.min(available_cross_size - cross_box_sum)
            }
        }
    };

    // 2. Resolve height (main-axis size).
    let available_main_size = match writing_mode {
        WritingMode::HorizontalTb => containing_block_size.height,
        WritingMode::VerticalRl | WritingMode::VerticalLr => containing_block_size.width,
    };

    let height = match css_height {
        CssSize::Px(px) => px,
        CssSize::Percent(p) => {
            // Percentage heights only resolve if the containing block has a definite height.
            // For now, we assume it does. A full implementation would check this.
            (p / 100.0) * available_main_size
        },
        CssSize::Auto => intrinsic.pref_height,
    };

    Ok(LogicalSize::new(width, height))
}

// STUB: Helper to get display type for sizing logic
#[derive(PartialEq, Eq)] enum DisplayType { Block, InlineBlock, Inline }
fn get_display_property(dom_id: Option<NodeId>) -> DisplayType { DisplayType::Block }

```

#### ../azul/layout/src/solver3/fc.rs

The Block Formatting Context layout manager now advances its pen by the full margin-box height of its children, and the Inline Formatting Context manager is taught to handle `inline-block` elements.

```rust
// ... (imports)
// Add `InlineContent` for creating objects for inline-blocks
use crate::text3::cache::InlineContent;

// ... (layout_bfc remains the same for now, but its sub-functions change)

/// Lays out a single in-flow, block-level child within a BFC.
fn layout_in_flow_block_child(
    child_index: usize,
    state: &mut BfcLayoutState,
    constraints: &LayoutConstraints,
    child_size: LogicalSize, // Pass in the already-calculated size
    box_props: BoxProps,
) -> LogicalPosition {
    // 1. Handle `clear` property
    apply_clearance(child_index, state);

    // 2. Handle margin collapsing.
    let margin_top = box_props.margin.main_start(state.writing_mode);
    let collapsed_margin = state.margins.last_in_flow_margin_bottom.max(margin_top);
    
    // The pen advances by the collapsed margin amount, minus the previous element's
    // bottom margin which was already accounted for.
    state.pen.y += collapsed_margin - state.margins.last_in_flow_margin_bottom;

    let child_pos = state.pen;
    
    // 4. Update the pen for the next element by the full margin-box height.
    let margin_box_height = child_size.height
        + box_props.padding.main_sum(state.writing_mode)
        + box_props.border.main_sum(state.writing_mode);
    state.pen.y += margin_box_height;
    
    // 5. Update margin context for the next sibling.
    state.margins.last_in_flow_margin_bottom = box_props.margin.main_end(state.writing_mode);
    
    child_pos
}

// ... (layout_ifc needs a helper to collect content)

/// Helper function to gather all inline content for text3, including inline-blocks.
fn collect_inline_content(
    tree: &LayoutTree,
    ifc_root_index: usize,
    styled_dom: &StyledDom,
) -> Result<Vec<InlineContent>> {
    let mut content = Vec::new();
    let ifc_root_node = tree.get(ifc_root_index).ok_or(LayoutError::InvalidTree)?;

    for &child_index in &ifc_root_node.children {
        let child_node = tree.get(child_index).ok_or(LayoutError::InvalidTree)?;
        let Some(dom_id) = child_node.dom_node_id else { continue; };
        
        // Check if the child is an inline-block.
        if get_display_property(Some(dom_id)) == DisplayType::InlineBlock {
            let size = child_node.used_size.unwrap_or_default();
            // TODO: Calculate the real baseline of the inline-block element.
            // This would involve running layout on its children and finding the baseline
            // of its last line box. For now, we stub it as the bottom of the box.
            let baseline_offset = 0.0; 

            content.push(InlineContent::Shape(InlineShape {
                shape_def: ShapeDefinition::Rectangle { size, corner_radius: None },
                fill: None, // The inline-block will be painted by the display list pass
                stroke: None,
                size,
                baseline_offset,
            }));
        } else {
            // Otherwise, assume it's text or another standard inline element.
            if let Some(text) = extract_text_from_node(styled_dom, dom_id) {
                content.push(InlineContent::Text(StyledRun {
                    text,
                    style: Arc::new(get_style_properties(dom_id)), // STUB
                    logical_start_byte: 0,
                }));
            }
        }
    }
    Ok(content)
}

// STUB: Helper to get StyleProperties for text3
fn get_style_properties(dom_id: NodeId) -> StyleProperties { StyleProperties::default() }

```

#### ../azul/layout/src/solver3/positioning.rs

Finally, we add the sub-pass for `position: relative` to the end of the main positioning function.

```rust
// ... (imports)

// ...

/// Calculate final positions for all nodes
pub fn calculate_positions(
    // ... (arguments remain the same)
) -> Result<PositionedLayoutTree> {
    // ... (existing code for setting up positioned_tree)

    // Pass 3a: Layout in-flow elements to determine their static positions
    // ... (call to position_node_recursive)

    // Pass 3b: Handle out-of-flow elements (absolute, fixed)
    handle_positioned_elements(&mut positioned_tree, styled_dom, viewport, debug_messages)?;

    // Pass 3c: Adjust positions for relatively positioned elements
    adjust_relative_positions(&mut positioned_tree, styled_dom, debug_messages)?;

    // ... (logging and return)
    Ok(positioned_tree)
}

// ... (position_node_recursive, handle_positioned_elements, etc. remain)

/// Final pass to shift relatively positioned elements from their static flow position.
fn adjust_relative_positions(
    positioned_tree: &mut PositionedLayoutTree,
    styled_dom: &StyledDom,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<()> {
    // Iterate through all nodes. We need the index to modify the position map.
    for node_index in 0..positioned_tree.tree.nodes.len() {
        let tree_node = &positioned_tree.tree.nodes[node_index];
        
        if get_position_type(styled_dom, tree_node.dom_node_id) == PositionType::Relative {
            let offsets = get_css_offsets(styled_dom, tree_node.dom_node_id);
            
            // Get a mutable reference to the position and apply the offsets.
            if let Some(current_pos) = positioned_tree.absolute_positions.get_mut(&node_index) {
                let initial_pos = *current_pos;
                
                // top/bottom/left/right offsets are applied relative to the static position.
                let mut delta_x = 0.0;
                let mut delta_y = 0.0;

                if let Some(left) = offsets.left {
                    delta_x += left;
                }
                if let Some(right) = offsets.right {
                    delta_x -= right;
                }
                if let Some(top) = offsets.top {
                    delta_y += top;
                }
                if let Some(bottom) = offsets.bottom {
                    delta_y -= bottom;
                }

                current_pos.x += delta_x;
                current_pos.y += delta_y;

                if initial_pos != *current_pos {
                    debug_log(
                        debug_messages,
                        &format!(
                            "Adjusted relative element {} from {:?} to {:?}",
                            node_index, initial_pos, *current_pos
                        ),
                    );
                }
            }
        }
    }
    Ok(())
}
```

---

### Summary and Next Steps

We have successfully implemented the Tier 1 features.
*   The **Box Model** is now respected during sizing and positioning, correctly separating the `content-box` from the full `margin-box`.
*   **`inline-block`** elements are now recognized and passed as opaque objects to `text3`, allowing them to participate in an inline flow. The main challenge left here is calculating their true baseline.
*   **`position: relative`** is handled in a final, simple adjustment pass that doesn't interfere with the main layout flow, which is the correct and efficient approach.

The engine is now capable of laying out a much wider range of documents that mix block, inline, and inline-block content.

**Your next steps should be to implement Tier 2:**

1.  **Refine Margin Collapsing:** The foundation is there, but the `MarginCollapseContext` needs to be made more robust. Add logic to detect when collapsing should be "interrupted" (e.g., by a parent's border or padding) and how to handle collapsing through empty elements. This is a pure BFC logic change in `fc.rs`.
2.  **Implement `auto` Height Feedback:** In `layout_bfc`, take the calculated `content_size.height` and write it back into the `positioned_tree.used_sizes` map for the BFC root node. This allows a parent's size to be determined by its children's layout.
3.  **Complete the Sizing Model:** Add support for `box-sizing: border-box` and the `min-content`/`max-content` keywords to `calculate_used_size_for_node`. This will round out the sizing capabilities and make the engine much more compatible with modern CSS.

After Tier 2, your layout engine will have a very solid core feature set, and you can move on to more advanced topics like tables, flexbox, or grid by adding new layout managers to the `layout_formatting_context` dispatcher.

---

Excellent, let's proceed with implementing the Tier 2 features. This is where the layout engine starts to feel truly powerful, as we're closing the loop between a parent's size and its children's layout, and handling more of the CSS box model's subtleties.

We will implement:
1.  **`auto` Height Feedback:** The positioning pass will now calculate and update the height of containers.
2.  **Refined Margin Collapsing:** The BFC layout manager will handle more edge cases, like being interrupted by padding or borders.
3.  **Complete Sizing Model:** We'll add support for `box-sizing: border-box` and intrinsic sizing keywords (`min-content`, `max-content`).

---

### New / Changed Code for Tier 2

#### New: Additions to Shared CSS Value Structs

We need to add `box-sizing` and the intrinsic sizing keywords to our value representations.

```rust
// In a shared module like `css_values.rs`

// ... (Existing enums and structs)

/// Represents the CSS `box-sizing` property.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum BoxSizing {
    #[default]
    ContentBox,
    BorderBox,
}

/// Represents a size that may be defined in various units.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CssSize {
    Auto,
    Px(f32),
    Percent(f32),
    MinContent,
    MaxContent,
}
```

#### ../azul/layout/src/solver3/sizing.rs

The sizing pass is now significantly more capable, handling `box-sizing` and the intrinsic keywords. This makes it much more aligned with the CSS specification.

```rust
// ... (imports)
use crate::solver3::css_values::{BoxProps, BoxSizing, CssSize, WritingMode};

// ...

fn calculate_used_size_for_node(
    tree: &LayoutTree,
    node_id: usize,
    containing_block_size: LogicalSize,
    intrinsic_sizes: &BTreeMap<usize, IntrinsicSizes>,
) -> Result<LogicalSize> {
    let node = tree.get(node_id).ok_or(LayoutError::InvalidTree)?;
    let intrinsic = intrinsic_sizes
        .get(&node_id)
        .unwrap_or(&IntrinsicSizes::default());

    let dom_id = node.dom_node_id;
    let css_width = get_css_width(dom_id);
    let css_height = get_css_height(dom_id);
    let box_props = get_box_props(dom_id);
    let box_sizing = get_box_sizing_property(dom_id);
    let writing_mode = get_writing_mode(dom_id);
    let is_block = matches!(node.formatting_context, azul_core::ui_solver::FormattingContext::Block { .. });

    let available_cross_size = match writing_mode {
        WritingMode::HorizontalTb => containing_block_size.width,
        WritingMode::VerticalRl | WritingMode::VerticalLr => containing_block_size.height,
    };
    
    // 1. Resolve width (content-box width).
    let width = match css_width {
        CssSize::Px(px) => {
            if box_sizing == BoxSizing::BorderBox {
                (px - box_props.padding.cross_sum(writing_mode) - box_props.border.cross_sum(writing_mode)).max(0.0)
            } else {
                px
            }
        },
        CssSize::Percent(p) => {
            let resolved_width = (p / 100.0) * available_cross_size;
            if box_sizing == BoxSizing::BorderBox {
                (resolved_width - box_props.padding.cross_sum(writing_mode) - box_props.border.cross_sum(writing_mode)).max(0.0)
            } else {
                resolved_width
            }
        },
        CssSize::MinContent => intrinsic.min_width,
        CssSize::MaxContent => intrinsic.pref_width,
        CssSize::Auto => {
            let cross_box_sum = box_props.margin.cross_sum(writing_mode)
                + box_props.border.cross_sum(writing_mode)
                + box_props.padding.cross_sum(writing_mode);
            if is_block {
                (available_cross_size - cross_box_sum).max(0.0)
            } else {
                intrinsic.pref_width.min(available_cross_size - cross_box_sum)
            }
        }
    };

    // 2. Resolve height (content-box height).
    // This is the *initial* height. The positioning pass will refine it if it's `auto`.
    let available_main_size = match writing_mode {
        WritingMode::HorizontalTb => containing_block_size.height,
        WritingMode::VerticalRl | WritingMode::VerticalLr => containing_block_size.width,
    };
    let main_padding_border = box_props.padding.main_sum(writing_mode) + box_props.border.main_sum(writing_mode);

    let height = match css_height {
        CssSize::Px(px) => if box_sizing == BoxSizing::BorderBox { (px - main_padding_border).max(0.0) } else { px },
        CssSize::Percent(p) => {
            let resolved_height = (p / 100.0) * available_main_size;
            if box_sizing == BoxSizing::BorderBox { (resolved_height - main_padding_border).max(0.0) } else { resolved_height }
        },
        CssSize::MinContent => intrinsic.min_height,
        CssSize::MaxContent => intrinsic.pref_height,
        CssSize::Auto => intrinsic.pref_height, // This is a placeholder; positioning pass calculates the real auto height.
    };

    Ok(LogicalSize::new(width, height))
}

// STUB: Add new property getter
fn get_box_sizing_property(dom_id: Option<NodeId>) -> BoxSizing { BoxSizing::default() }

```

#### ../azul/layout/src/solver3/positioning.rs

The positioning pass now has the critical responsibility of calculating `auto` heights and updating the layout tree's `used_sizes`.

```rust
// ... (imports)
use crate::solver3::css_values::{CssSize, WritingMode}; // Add CssSize import

// ...

fn position_node_recursive(
    positioned_tree: &mut PositionedLayoutTree,
    node_index: usize,
    parent_position: LogicalPosition,
    // Note: parent_size is the initial size, not necessarily the final one.
    parent_size: LogicalSize,
    styled_dom: &StyledDom,
    renderer_resources: &mut RendererResources,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<()> {
    // ... (get node, initial size, set absolute position) ...
    // let node = ...
    // let initial_node_size = ...

    // -- Start of Auto Height Logic --
    
    // Get the original CSS height property to check if it was 'auto'.
    let css_height = get_css_height(node.dom_node_id);

    // If this node has children, layout them to determine its content height.
    let children = node.children.clone();
    if !children.is_empty() {
        // ... (set up constraints for layout_formatting_context) ...
        // let constraints = ...

        let layout_result = layout_formatting_context(
            &mut positioned_tree.tree,
            node_index,
            &constraints,
            styled_dom,
            renderer_resources,
            debug_messages,
        )?;

        // If this node's height was 'auto', its final height is determined by its content.
        if css_height == CssSize::Auto {
            if let Some(overflow_size) = layout_result.overflow_size {
                let box_props = get_box_props(node.dom_node_id);
                let new_content_height = overflow_size.height;
                let final_height = new_content_height 
                    + box_props.padding.main_sum(constraints.writing_mode)
                    + box_props.border.main_sum(constraints.writing_mode);
                
                // Update the used_size for this node in the final tree.
                if let Some(used_size) = positioned_tree.used_sizes.get_mut(&node_index) {
                    used_size.height = final_height;
                }
                if let Some(tree_node) = positioned_tree.tree.get_mut(node_index) {
                    tree_node.used_size.as_mut().unwrap().height = final_height;
                }
            }
        }
        
        // Apply the calculated positions to children and recurse.
        // ... (loop over layout_result.positions and call position_node_recursive) ...
    }

    Ok(())
}

// STUB: Need this helper here too for the auto height logic.
fn get_css_height(dom_id: Option<NodeId>) -> CssSize { CssSize::Auto }
```

#### ../azul/layout/srcs/solver3/fc.rs

The BFC layout manager now implements more robust margin collapsing, correctly handling interruption by borders and padding.

```rust
// ... (imports)

// ...

/// Lays out children within a Block Formatting Context (BFC).
fn layout_bfc(
    tree: &mut LayoutTree,
    node_index: usize,
    constraints: &LayoutConstraints,
    styled_dom: &StyledDom,
    renderer_resources: &mut RendererResources,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<LayoutResult> {
    let bfc_root_node = tree.get(node_index).ok_or(LayoutError::InvalidTree)?;
    let children_indices = bfc_root_node.children.clone();

    // Get box properties for the BFC root itself.
    let bfc_root_props = get_box_props(bfc_root_node.dom_node_id);
    let writing_mode = constraints.writing_mode;
    
    let mut state = BfcLayoutState {
        // The pen starts inside the padding box of the BFC root.
        pen: LogicalPosition::new(
            bfc_root_props.padding.left, // Simplified for horizontal-tb
            bfc_root_props.padding.top
        ),
        floats: FloatingContext::default(),
        margins: MarginCollapseContext::default(),
        writing_mode,
    };
    
    // A BFC root's own border or padding prevents its children's margins from collapsing outside of it.
    let establishes_clearance = bfc_root_props.padding.main_start(writing_mode) > 0.0 
                             || bfc_root_props.border.main_start(writing_mode) > 0.0;
    if establishes_clearance {
        // We "absorb" the top margin of the first child by starting the pen at the padding edge.
        // And we ensure no collapsing happens with the BFC root's own margin.
        state.margins.last_in_flow_margin_bottom = 0.0;
    } else {
        // Margins can collapse "through" the BFC root. We carry over the previous margin.
        // This is a simplification; would need to get this from the parent context.
    }

    // ... (rest of the layout_bfc loop as before)
    // ...
    // The final content height needs to account for the initial pen position (padding).
    content_size.height += bfc_root_props.padding.main_sum(writing_mode);
    // ...

    Ok(LayoutResult {
        positions,
        overflow_size: Some(content_size),
        ..Default::default()
    })
}

/// Lays out a single in-flow, block-level child within a BFC.
fn layout_in_flow_block_child(
    child_index: usize,
    state: &mut BfcLayoutState,
    constraints: &LayoutConstraints,
    child_size: LogicalSize,
    box_props: BoxProps,
) -> LogicalPosition {
    // 1. Handle `clear` property
    let clearance_applied = apply_clearance(child_index, state);

    // 2. Handle margin collapsing.
    let margin_top = box_props.margin.main_start(state.writing_mode);
    let margin_bottom = box_props.margin.main_end(state.writing_mode);

    // Collapsing is suppressed if clearance was applied.
    let collapsed_margin = if clearance_applied {
        margin_top
    } else {
        state.margins.last_in_flow_margin_bottom.max(margin_top)
    };
    
    // Advance the pen, accounting for the previously applied margin.
    state.pen.y += collapsed_margin - state.margins.last_in_flow_margin_bottom;

    // TODO: Handle empty blocks (height=0, no padding/border), where top and bottom margins collapse together.
    // if child_size.height == 0 && box_props.padding.main_sum(...) == 0 && ... {
    //     let collapsed_self = margin_top.max(margin_bottom);
    //     // This affects the `last_in_flow_margin_bottom` for the *next* sibling.
    // }

    let child_pos = state.pen;
    
    // 4. Update the pen by the element's inner height (content + padding + border).
    let inner_height = child_size.height
        + box_props.padding.main_sum(state.writing_mode)
        + box_props.border.main_sum(state.writing_mode);
    state.pen.y += inner_height;
    
    // 5. Update margin context for the next sibling.
    state.margins.last_in_flow_margin_bottom = margin_bottom;
    
    child_pos
}

/// Adjusts the BFC pen position to clear floats. Returns true if clearance was applied.
fn apply_clearance(child_index: usize, state: &mut BfcLayoutState) -> bool {
    // ... (logic for calculating clear_y remains the same)
    let clear_y = 0.0; // calculated value

    if clear_y > state.pen.y {
        state.pen.y = clear_y;
        state.margins.last_in_flow_margin_bottom = 0.0; // Suppress margin collapse
        true
    } else {
        false
    }
}
```

---

### Summary and Next Steps

The Tier 2 implementation has made the engine significantly more powerful:
*   **Sizing is now much more robust,** handling `box-sizing` and intrinsic keywords correctly. This is a huge step towards CSS compatibility.
*   **`auto` height now works,** which is arguably the most important feature for a document layout engine. The positioning pass correctly calculates content height and feeds it back into the `used_sizes` map.
*   **Margin collapsing is more intelligent,** correctly being contained by parent padding/borders.

The core architecture for block and inline layout is now very solid. You can confidently build upon it.

**The next features to implement are the other major layout modes:**

1.  **Flexbox Layout (`display: flex`):**
    *   **How:** Create a new `layout_flexc` (Flex Formatting Context) function in `fc.rs`.
    *   **Logic:** This function will implement the Flexbox algorithm:
        1.  Determine the flex container's main and cross axes based on `flex-direction` and `writing-mode`.
        2.  Resolve the flexible lengths of all children. This involves calculating their flex base size and then distributing free space according to `flex-grow` and `flex-shrink` factors.
        3.  Position the children along the main and cross axes according to `justify-content` and `align-items`/`align-self`.
    *   **Integration:** In `layout_formatting_context`, simply add a new `match` arm to dispatch to `layout_flexc` when a node has `FormattingContext::Flex`.

2.  **Table Layout (`display: table`):**
    *   **How:** Create a `layout_table_wrapper` function.
    *   **Logic:** This is the most complex layout mode. The `table-layout: auto` algorithm is a multi-step process:
        1.  Determine the number of columns from the table rows and cells.
        2.  Calculate the min-content and max-content width for each column.
        3.  Distribute the table's available width among the columns based on these constraints.
        4.  Lay out each cell, which in turn creates a new BFC for its own content.
        5.  Determine row heights based on the tallest cell in each row.
    *   **Integration:** The anonymous box generation pass already creates the correct `table-wrapper -> table-row-group -> table-row -> table-cell` structure. The layout pass just needs to implement the managers for each of these box types.

Implementing Flexbox first is often the most pragmatic choice, as it's a more common and modern layout mode than `table-layout: auto`. Once you have Flexbox, your engine will be able to handle a vast majority of modern web UI layouts.

---

