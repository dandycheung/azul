//! solver3/layout_tree.rs
//!
//! Layout tree generation and anonymous box handling

use std::{
    collections::BTreeMap,
    hash::{Hash, Hasher},
    sync::Arc,
};

use azul_core::{
    dom::{NodeId, NodeType},
    styled_dom::StyledDom,
    ui_solver::{FormattingContext, ResolvedOffsets},
    window::{LogicalPosition, LogicalRect, LogicalSize},
};
use azul_css::{CssProperty, CssPropertyValue, LayoutDebugMessage, LayoutDisplay}; /* Added CssProperty */

use crate::{
    parsedfont::ParsedFont,
    solver3::{
        geometry::{BoxProps, IntrinsicSizes, PositionedRectangle},
        LayoutContext, Result,
    },
    text3::cache::{FontLoaderTrait, ParsedFontTrait, UnifiedLayout},
};

/// Represents the invalidation state of a layout node.
///
/// The states are ordered by severity, allowing for easy "upgrading" of the dirty state.
/// A node marked for `Layout` does not also need to be marked for `Paint`.
///
/// Because this enum derives `PartialOrd` and `Ord`, you can directly compare variants:
///
/// - `DirtyFlag::Layout > DirtyFlag::Paint` is `true`
/// - `DirtyFlag::Paint >= DirtyFlag::None` is `true`
/// - `DirtyFlag::Paint < DirtyFlag::Layout` is `true`
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default)]
pub enum DirtyFlag {
    /// The node's layout is valid and no repaint is needed. This is the "clean" state.
    #[default]
    None,
    /// The node's geometry is valid, but its appearance (e.g., color) has changed.
    /// Requires a display list update only.
    Paint,
    /// The node's geometry (size or position) is invalid.
    /// Requires a full layout pass and a display list update.
    Layout,
}

/// A hash that represents the content and style of a node PLUS all of its descendants.
/// If two SubtreeHashes are equal, their entire subtrees are considered identical for layout
/// purposes.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Hash)]
pub struct SubtreeHash(pub u64);

/// A layout tree node representing the CSS box model
///
/// Note: An absolute position is a final paint-time value and shouldn't be
/// cached on the node itself, as it can change even if the node's
/// layout is clean (e.g., if a sibling changes size). We will calculate
/// it in a separate map.
#[derive(Debug, Clone)]
pub struct LayoutNode<T: ParsedFontTrait> {
    /// Reference back to the original DOM node (None for anonymous boxes)
    pub dom_node_id: Option<NodeId>,
    /// Whether this is an anonymous box generated by the layout engine
    pub is_anonymous: bool,
    /// Type of anonymous box (if applicable)
    pub anonymous_type: Option<AnonymousBoxType>,
    /// Children indices in the layout tree
    pub children: Vec<usize>,
    /// Parent index (None for root)
    pub parent: Option<usize>,
    /// Dirty flags to track what needs recalculation.
    pub dirty_flag: DirtyFlag,
    /// The resolved box model properties (margin, border, padding)
    /// in logical pixels.
    pub box_props: BoxProps,
    pub node_data_hash: u64,
    /// A hash of this node's data and all of its descendants. Used for
    /// fast reconciliation.
    pub subtree_hash: SubtreeHash,
    pub formatting_context: FormattingContext,
    pub intrinsic_sizes: Option<IntrinsicSizes>,
    pub used_size: Option<LogicalSize>,
    /// The position of this node *relative to its parent's content box*.
    pub relative_position: Option<LogicalPosition>,
    /// The baseline of this box, if applicable, measured from its content-box top edge.
    pub baseline: Option<f32>,
    /// Optional layouted text that this layout node carries
    pub inline_layout_result: Option<Arc<UnifiedLayout<T>>>,
}

/// Types of anonymous boxes that can be generated
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AnonymousBoxType {
    /// Anonymous block box wrapping inline content
    InlineWrapper,
    /// Anonymous table wrapper
    TableWrapper,
    /// Anonymous table row group (tbody)
    TableRowGroup,
    /// Anonymous table row
    TableRow,
    /// Anonymous table cell
    TableCell,
}

/// The complete layout tree structure
#[derive(Debug, Clone)]
pub struct LayoutTree<T: ParsedFontTrait> {
    /// Arena-style storage for layout nodes
    pub nodes: Vec<LayoutNode<T>>,
    /// Root node index
    pub root: usize,
    /// Mapping from DOM node IDs to layout node indices
    pub dom_to_layout: BTreeMap<NodeId, Vec<usize>>,
}

impl<T: ParsedFontTrait> LayoutTree<T> {
    pub fn get(&self, index: usize) -> Option<&LayoutNode<T>> {
        self.nodes.get(index)
    }

    pub fn get_mut(&mut self, index: usize) -> Option<&mut LayoutNode<T>> {
        self.nodes.get_mut(index)
    }

    pub fn root_node(&self) -> &LayoutNode<T> {
        &self.nodes[self.root]
    }

    /// Marks a node and its ancestors as dirty with the given flag.
    ///
    /// The dirty state is "upgraded" if the new flag is more severe than the
    /// existing one (e.g., upgrading from `Paint` to `Layout`). Propagation stops
    /// if an ancestor is already marked with an equal or more severe flag.
    pub fn mark_dirty(&mut self, start_index: usize, flag: DirtyFlag) {
        // A "None" flag is a no-op for marking dirty.
        if flag == DirtyFlag::None {
            return;
        }

        let mut current_index = Some(start_index);
        while let Some(index) = current_index {
            if let Some(node) = self.get_mut(index) {
                // If the node's current flag is already as dirty or dirtier,
                // then all ancestors are also sufficiently marked, so we can stop.
                if node.dirty_flag >= flag {
                    break;
                }

                // Upgrade the flag to the new, more severe state.
                node.dirty_flag = flag;
                current_index = node.parent;
            } else {
                break;
            }
        }
    }

    /// Marks a node and its entire subtree of descendants with the given dirty flag.
    ///
    /// This is used for inherited CSS properties. Each node in the subtree
    /// will be upgraded to at least the new flag's severity.
    pub fn mark_subtree_dirty(&mut self, start_index: usize, flag: DirtyFlag) {
        // A "None" flag is a no-op.
        if flag == DirtyFlag::None {
            return;
        }

        // Using a stack for an iterative traversal to avoid deep recursion on large subtrees.
        let mut stack = vec![start_index];
        while let Some(index) = stack.pop() {
            if let Some(node) = self.get_mut(index) {
                // Only update if the new flag is an upgrade.
                if node.dirty_flag < flag {
                    node.dirty_flag = flag;
                }
                // Add all children to be processed.
                stack.extend_from_slice(&node.children);
            }
        }
    }

    /// Resets the dirty flags of all nodes in the tree to `None` after layout is complete.
    pub fn clear_all_dirty_flags(&mut self) {
        for node in &mut self.nodes {
            node.dirty_flag = DirtyFlag::None;
        }
    }
}

/// Generate layout tree from styled DOM with proper anonymous box generation
pub fn generate_layout_tree<T: ParsedFontTrait, Q: FontLoaderTrait<T>>(
    ctx: &mut LayoutContext<T, Q>,
) -> Result<LayoutTree<T>> {
    let mut builder = LayoutTreeBuilder::new();
    let root_id = ctx
        .styled_dom
        .root
        .into_crate_internal()
        .unwrap_or(NodeId::ZERO);
    let root_index = builder.process_node(ctx.styled_dom, root_id, None)?;
    let layout_tree = builder.build(root_index);

    ctx.debug_log(&format!(
        "Generated layout tree with {} nodes (incl. anonymous)",
        layout_tree.nodes.len()
    ));

    Ok(layout_tree)
}

pub struct LayoutTreeBuilder<T: ParsedFontTrait> {
    nodes: Vec<LayoutNode<T>>,
    dom_to_layout: BTreeMap<NodeId, Vec<usize>>,
}

// Represents the CSS `display` property for layout purposes
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum DisplayType {
    Inline,
    Block,
    InlineBlock,
    Table,
    TableRowGroup,
    TableRow,
    TableCell,
    // Add other types like Flex, Grid, etc. as needed
}

impl<T: ParsedFontTrait> LayoutTreeBuilder<T> {
    pub fn new() -> Self {
        Self {
            nodes: Vec::new(),
            dom_to_layout: BTreeMap::new(),
        }
    }

    pub fn get(&self, index: usize) -> Option<&LayoutNode<T>> {
        self.nodes.get(index)
    }

    pub fn get_mut(&mut self, index: usize) -> Option<&mut LayoutNode<T>> {
        self.nodes.get_mut(index)
    }

    /// Main entry point for recursively building the layout tree.
    /// This function dispatches to specialized handlers based on the node's
    /// `display` property to correctly generate anonymous boxes.
    pub fn process_node(
        &mut self,
        styled_dom: &StyledDom,
        dom_id: NodeId,
        parent_idx: Option<usize>,
    ) -> Result<usize> {
        let node_idx = self.create_node_from_dom(styled_dom, dom_id, parent_idx)?;
        let display_type = get_display_type(styled_dom, dom_id);

        match display_type {
            DisplayType::Block | DisplayType::InlineBlock => {
                self.process_block_children(styled_dom, dom_id, node_idx)?
            }
            DisplayType::Table => self.process_table_children(styled_dom, dom_id, node_idx)?,
            DisplayType::TableRowGroup => {
                self.process_table_row_group_children(styled_dom, dom_id, node_idx)?
            }
            DisplayType::TableRow => {
                self.process_table_row_children(styled_dom, dom_id, node_idx)?
            }
            // Inline, TableCell, etc., have their children processed as part of their
            // formatting context layout and don't require anonymous box generation at this stage.
            _ => {
                for child_dom_id in dom_id.children(&styled_dom.node_hierarchy.as_ref()) {
                    self.process_node(styled_dom, child_dom_id, Some(node_idx))?;
                }
            }
        }
        Ok(node_idx)
    }

    /// Handles children of a block-level element, creating anonymous block
    /// wrappers for consecutive runs of inline-level children if necessary.
    fn process_block_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
    ) -> Result<()> {
        let children: Vec<_> = parent_dom_id
            .children(&styled_dom.node_hierarchy.as_ref())
            .collect();

        let has_block_child = children.iter().any(|&id| is_block_level(styled_dom, id));

        if !has_block_child {
            // All children are inline, no anonymous boxes needed.
            for child_id in children {
                self.process_node(styled_dom, child_id, Some(parent_idx))?;
            }
            return Ok(());
        }

        // Mixed block and inline content requires anonymous wrappers.
        let mut inline_run = Vec::new();

        for child_id in children {
            if is_block_level(styled_dom, child_id) {
                // End the current inline run
                if !inline_run.is_empty() {
                    let anon_idx = self.create_anonymous_node(
                        parent_idx,
                        AnonymousBoxType::InlineWrapper,
                        FormattingContext::Block {
                            establishes_new_context: false,
                        },
                    );
                    for inline_child_id in inline_run.drain(..) {
                        self.process_node(styled_dom, inline_child_id, Some(anon_idx))?;
                    }
                }
                // Process the block-level child directly
                self.process_node(styled_dom, child_id, Some(parent_idx))?;
            } else {
                inline_run.push(child_id);
            }
        }
        // Process any remaining inline children at the end
        if !inline_run.is_empty() {
            let anon_idx = self.create_anonymous_node(
                parent_idx,
                AnonymousBoxType::InlineWrapper,
                FormattingContext::Block {
                    establishes_new_context: false,
                },
            );
            for inline_child_id in inline_run {
                self.process_node(styled_dom, inline_child_id, Some(anon_idx))?;
            }
        }

        Ok(())
    }

    /// Handles children of a `display: table`, inserting anonymous `table-row`
    /// wrappers for any direct `table-cell` children.
    fn process_table_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
    ) -> Result<()> {
        let mut row_children = Vec::new();
        for child_id in parent_dom_id.children(&styled_dom.node_hierarchy.as_ref()) {
            let child_display = get_display_type(styled_dom, child_id);
            if child_display == DisplayType::TableCell {
                row_children.push(child_id);
            } else {
                if !row_children.is_empty() {
                    let anon_row_idx = self.create_anonymous_node(
                        parent_idx,
                        AnonymousBoxType::TableRow,
                        FormattingContext::TableRow,
                    );
                    for cell_id in row_children.drain(..) {
                        self.process_node(styled_dom, cell_id, Some(anon_row_idx))?;
                    }
                }
                self.process_node(styled_dom, child_id, Some(parent_idx))?;
            }
        }
        if !row_children.is_empty() {
            let anon_row_idx = self.create_anonymous_node(
                parent_idx,
                AnonymousBoxType::TableRow,
                FormattingContext::TableRow,
            );
            for cell_id in row_children {
                self.process_node(styled_dom, cell_id, Some(anon_row_idx))?;
            }
        }
        Ok(())
    }

    /// Handles children of a `display: table-row-group`, inserting anonymous `table-row`s.
    fn process_table_row_group_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
    ) -> Result<()> {
        // This logic is identical to process_table_children for our purposes
        self.process_table_children(styled_dom, parent_dom_id, parent_idx)
    }

    /// Handles children of a `display: table-row`, inserting anonymous `table-cell` wrappers.
    fn process_table_row_children(
        &mut self,
        styled_dom: &StyledDom,
        parent_dom_id: NodeId,
        parent_idx: usize,
    ) -> Result<()> {
        for child_id in parent_dom_id.children(&styled_dom.node_hierarchy.as_ref()) {
            let child_display = get_display_type(styled_dom, child_id);
            if child_display == DisplayType::TableCell {
                self.process_node(styled_dom, child_id, Some(parent_idx))?;
            } else {
                // Any other child must be wrapped in an anonymous cell
                let anon_cell_idx = self.create_anonymous_node(
                    parent_idx,
                    AnonymousBoxType::TableCell,
                    FormattingContext::Block {
                        establishes_new_context: true,
                    },
                );
                self.process_node(styled_dom, child_id, Some(anon_cell_idx))?;
            }
        }
        Ok(())
    }

    /// Helper to create an anonymous node in the tree.
    fn create_anonymous_node(
        &mut self,
        parent: usize,
        anon_type: AnonymousBoxType,
        fc: FormattingContext,
    ) -> usize {
        let index = self.nodes.len();
        self.nodes.push(LayoutNode {
            dom_node_id: None,
            parent: Some(parent),
            formatting_context: fc,
            box_props: BoxProps::default(),
            is_anonymous: true,
            anonymous_type: Some(anon_type),
            children: Vec::new(),
            dirty_flag: DirtyFlag::Layout,
            node_data_hash: 0, // Anonymous boxes don't have style/data
            subtree_hash: SubtreeHash(0),
            intrinsic_sizes: None,
            used_size: None,
            relative_position: None,
            baseline: None,
            inline_layout_result: None,
        });
        self.nodes[parent].children.push(index);
        index
    }

    pub fn create_node_from_dom(
        &mut self,
        styled_dom: &StyledDom,
        dom_id: NodeId,
        parent: Option<usize>,
    ) -> Result<usize> {
        let index = self.nodes.len();
        self.nodes.push(LayoutNode {
            dom_node_id: Some(dom_id),
            parent,
            formatting_context: determine_formatting_context(styled_dom, dom_id),
            box_props: resolve_box_props(styled_dom, dom_id),
            is_anonymous: false,
            anonymous_type: None,
            children: Vec::new(),
            dirty_flag: DirtyFlag::Layout,
            node_data_hash: hash_node_data(styled_dom, dom_id),
            subtree_hash: SubtreeHash(0),
            intrinsic_sizes: None,
            used_size: None,
            relative_position: None,
            baseline: None,
            inline_layout_result: None,
        });
        if let Some(p) = parent {
            self.nodes[p].children.push(index);
        }
        self.dom_to_layout.entry(dom_id).or_default().push(index);
        Ok(index)
    }

    pub fn clone_node_from_old(
        &mut self,
        old_node: &LayoutNode<T>,
        parent: Option<usize>,
    ) -> usize {
        let index = self.nodes.len();
        let mut new_node = old_node.clone();
        new_node.parent = parent;
        new_node.children = Vec::new();
        new_node.dirty_flag = DirtyFlag::None;
        self.nodes.push(new_node);
        if let Some(p) = parent {
            self.nodes[p].children.push(index);
        }
        if let Some(dom_id) = old_node.dom_node_id {
            self.dom_to_layout.entry(dom_id).or_default().push(index);
        }
        index
    }

    pub fn build(self, root_idx: usize) -> LayoutTree<T> {
        LayoutTree {
            nodes: self.nodes,
            root: root_idx,
            dom_to_layout: self.dom_to_layout,
        }
    }
}

fn is_block_level(styled_dom: &StyledDom, node_id: NodeId) -> bool {
    matches!(
        get_display_type(styled_dom, node_id),
        DisplayType::Block
            | DisplayType::Table
            | DisplayType::TableRow
            | DisplayType::TableRowGroup
    )
}

fn hash_node_data(dom: &StyledDom, node_id: NodeId) -> u64 {
    let mut hasher = std::hash::DefaultHasher::new();
    if let Some(styled_node) = dom.styled_nodes.as_container().get(node_id) {
        styled_node.state.get_style().hash(&mut hasher);
    }
    if let Some(node_data) = dom.node_data.as_container().get(node_id) {
        node_data.get_node_type().hash(&mut hasher);
    }
    hasher.finish()
}

fn resolve_box_props(styled_dom: &StyledDom, dom_id: NodeId) -> BoxProps {
    // STUB: This would read margin, padding, border properties from the styled_dom
    // and convert them into a BoxProps struct with pixel values.
    let _ = styled_dom;
    let _ = dom_id;
    BoxProps::default()
}

// Determines the display type of a node based on its tag and CSS properties.
fn get_display_type(styled_dom: &StyledDom, node_id: NodeId) -> DisplayType {
    if let Some(styled_node) = styled_dom.styled_nodes.as_container().get(node_id) {
        if let Some(CssProperty::Display(CssPropertyValue::Exact(d))) =
            styled_node.state.get_style().get(&CssProperty::Display)
        {
            return match d {
                LayoutDisplay::Table => DisplayType::Table,
                LayoutDisplay::TableRow => DisplayType::TableRow,
                LayoutDisplay::TableCell => DisplayType::TableCell,
                LayoutDisplay::TableRowGroup => DisplayType::TableRowGroup,
                LayoutDisplay::Inline => DisplayType::Inline,
                LayoutDisplay::Block => DisplayType::Block,
                LayoutDisplay::InlineBlock => DisplayType::InlineBlock,
                _ => DisplayType::Block,
            };
        }
    }

    match styled_dom.node_data.as_container()[node_id].get_node_type() {
        NodeType::Text(_) => DisplayType::Inline,
        NodeType::Table => DisplayType::Table,
        NodeType::Tr => DisplayType::TableRow,
        NodeType::Td | NodeType::Th => DisplayType::TableCell,
        NodeType::TBody | NodeType::THead | NodeType::TFoot => DisplayType::TableRowGroup,
        NodeType::Div
        | NodeType::P
        | NodeType::H1
        | NodeType::H2
        | NodeType::H3
        | NodeType::H4
        | NodeType::H5
        | NodeType::H6 => DisplayType::Block,
        _ => DisplayType::Inline,
    }
}

// The logic can remain relatively simple as it's concerned with the node itself,
// not its children's layout, which is what we fixed above.
fn determine_formatting_context(styled_dom: &StyledDom, node_id: NodeId) -> FormattingContext {
    match get_display_type(styled_dom, node_id) {
        DisplayType::Inline => FormattingContext::Inline,
        DisplayType::Block | DisplayType::TableCell | DisplayType::InlineBlock => {
            FormattingContext::Block {
                establishes_new_context: true,
            }
        }
        DisplayType::Table => FormattingContext::Table,
        DisplayType::TableRowGroup => FormattingContext::TableRowGroup,
        DisplayType::TableRow => FormattingContext::TableRow,
        // Default case
        _ => FormattingContext::Block {
            establishes_new_context: false,
        },
    }
}

fn needs_anonymous_block_wrapper(styled_dom: &StyledDom, children: &[NodeId]) -> bool {
    if children.len() <= 1 {
        return false;
    }

    let has_block = children
        .iter()
        .any(|&id| get_display_type(styled_dom, id) == DisplayType::Block);
    let has_inline = children
        .iter()
        .any(|&id| get_display_type(styled_dom, id) == DisplayType::Inline);

    // Need anonymous boxes when mixing block and inline children
    has_block && has_inline
}

fn is_block_level_element(styled_dom: &StyledDom, node_id: NodeId) -> bool {
    get_display_type(styled_dom, node_id) == DisplayType::Block
}

fn debug_log(debug_messages: &mut Option<Vec<LayoutDebugMessage>>, message: &str) {
    if let Some(messages) = debug_messages {
        messages.push(LayoutDebugMessage {
            message: message.into(),
            location: "layout_tree".into(),
        });
    }
}
