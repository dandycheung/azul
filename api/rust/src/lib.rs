// Mozilla Public License Version 2.0
// ==================================
//
// 1. Definitions
// --------------
//
// 1.1. "Contributor"
//     means each individual or legal entity that creates, contributes to
//     the creation of, or owns Covered Software.
//
// 1.2. "Contributor Version"
//     means the combination of the Contributions of others (if any) used
//     by a Contributor and that particular Contributor's Contribution.
//
// 1.3. "Contribution"
//     means Covered Software of a particular Contributor.
//
// 1.4. "Covered Software"
//     means Source Code Form to which the initial Contributor has attached
//     the notice in Exhibit A, the Executable Form of such Source Code
//     Form, and Modifications of such Source Code Form, in each case
//     including portions thereof.
//
// 1.5. "Incompatible With Secondary Licenses"
//     means
//
//     (a) that the initial Contributor has attached the notice described
//         in Exhibit B to the Covered Software; or
//
//     (b) that the Covered Software was made available under the terms of
//         version 1.1 or earlier of the License, but not also under the
//         terms of a Secondary License.
//
// 1.6. "Executable Form"
//     means any form of the work other than Source Code Form.
//
// 1.7. "Larger Work"
//     means a work that combines Covered Software with other material, in
//     a separate file or files, that is not Covered Software.
//
// 1.8. "License"
//     means this document.
//
// 1.9. "Licensable"
//     means having the right to grant, to the maximum extent possible,
//     whether at the time of the initial grant or subsequently, any and
//     all of the rights conveyed by this License.
//
// 1.10. "Modifications"
//     means any of the following:
//
//     (a) any file in Source Code Form that results from an addition to,
//         deletion from, or modification of the contents of Covered
//         Software; or
//
//     (b) any new file in Source Code Form that contains any Covered
//         Software.
//
// 1.11. "Patent Claims" of a Contributor
//     means any patent claim(s), including without limitation, method,
//     process, and apparatus claims, in any patent Licensable by such
//     Contributor that would be infringed, but for the grant of the
//     License, by the making, using, selling, offering for sale, having
//     made, import, or transfer of either its Contributions or its
//     Contributor Version.
//
// 1.12. "Secondary License"
//     means either the GNU General Public License, Version 2.0, the GNU
//     Lesser General Public License, Version 2.1, the GNU Affero General
//     Public License, Version 3.0, or any later versions of those
//     licenses.
//
// 1.13. "Source Code Form"
//     means the form of the work preferred for making modifications.
//
// 1.14. "You" (or "Your")
//     means an individual or a legal entity exercising rights under this
//     License. For legal entities, "You" includes any entity that
//     controls, is controlled by, or is under common control with You. For
//     purposes of this definition, "control" means (a) the power, direct
//     or indirect, to cause the direction or management of such entity,
//     whether by contract or otherwise, or (b) ownership of more than
//     fifty percent (50%) of the outstanding shares or beneficial
//     ownership of such entity.
//
// 2. License Grants and Conditions
// --------------------------------
//
// 2.1. Grants
//
// Each Contributor hereby grants You a world-wide, royalty-free,
// non-exclusive license:
//
// (a) under intellectual property rights (other than patent or trademark)
//     Licensable by such Contributor to use, reproduce, make available,
//     modify, display, perform, distribute, and otherwise exploit its
//     Contributions, either on an unmodified basis, with Modifications, or
//     as part of a Larger Work; and
//
// (b) under Patent Claims of such Contributor to make, use, sell, offer
//     for sale, have made, import, and otherwise transfer either its
//     Contributions or its Contributor Version.
//
// 2.2. Effective Date
//
// The licenses granted in Section 2.1 with respect to any Contribution
// become effective for each Contribution on the date the Contributor first
// distributes such Contribution.
//
// 2.3. Limitations on Grant Scope
//
// The licenses granted in this Section 2 are the only rights granted under
// this License. No additional rights or licenses will be implied from the
// distribution or licensing of Covered Software under this License.
// Notwithstanding Section 2.1(b) above, no patent license is granted by a
// Contributor:
//
// (a) for any code that a Contributor has removed from Covered Software;
//     or
//
// (b) for infringements caused by: (i) Your and any other third party's
//     modifications of Covered Software, or (ii) the combination of its
//     Contributions with other software (except as part of its Contributor
//     Version); or
//
// (c) under Patent Claims infringed by Covered Software in the absence of
//     its Contributions.
//
// This License does not grant any rights in the trademarks, service marks,
// or logos of any Contributor (except as may be necessary to comply with
// the notice requirements in Section 3.4).
//
// 2.4. Subsequent Licenses
//
// No Contributor makes additional grants as a result of Your choice to
// distribute the Covered Software under a subsequent version of this
// License (see Section 10.2) or under the terms of a Secondary License (if
// permitted under the terms of Section 3.3).
//
// 2.5. Representation
//
// Each Contributor represents that the Contributor believes its
// Contributions are its original creation(s) or it has sufficient rights
// to grant the rights to its Contributions conveyed by this License.
//
// 2.6. Fair Use
//
// This License is not intended to limit any rights You have under
// applicable copyright doctrines of fair use, fair dealing, or other
// equivalents.
//
// 2.7. Conditions
//
// Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
// in Section 2.1.
//
// 3. Responsibilities
// -------------------
//
// 3.1. Distribution of Source Form
//
// All distribution of Covered Software in Source Code Form, including any
// Modifications that You create or to which You contribute, must be under
// the terms of this License. You must inform recipients that the Source
// Code Form of the Covered Software is governed by the terms of this
// License, and how they can obtain a copy of this License. You may not
// attempt to alter or restrict the recipients' rights in the Source Code
// Form.
//
// 3.2. Distribution of Executable Form
//
// If You distribute Covered Software in Executable Form then:
//
// (a) such Covered Software must also be made available in Source Code
//     Form, as described in Section 3.1, and You must inform recipients of
//     the Executable Form how they can obtain a copy of such Source Code
//     Form by reasonable means in a timely manner, at a charge no more
//     than the cost of distribution to the recipient; and
//
// (b) You may distribute such Executable Form under the terms of this
//     License, or sublicense it under different terms, provided that the
//     license for the Executable Form does not attempt to limit or alter
//     the recipients' rights in the Source Code Form under this License.
//
// 3.3. Distribution of a Larger Work
//
// You may create and distribute a Larger Work under terms of Your choice,
// provided that You also comply with the requirements of this License for
// the Covered Software. If the Larger Work is a combination of Covered
// Software with a work governed by one or more Secondary Licenses, and the
// Covered Software is not Incompatible With Secondary Licenses, this
// License permits You to additionally distribute such Covered Software
// under the terms of such Secondary License(s), so that the recipient of
// the Larger Work may, at their option, further distribute the Covered
// Software under the terms of either this License or such Secondary
// License(s).
//
// 3.4. Notices
//
// You may not remove or alter the substance of any license notices
// (including copyright notices, patent notices, disclaimers of warranty,
// or limitations of liability) contained within the Source Code Form of
// the Covered Software, except that You may alter any license notices to
// the extent required to remedy known factual inaccuracies.
//
// 3.5. Application of Additional Terms
//
// You may choose to offer, and to charge a fee for, warranty, support,
// indemnity or liability obligations to one or more recipients of Covered
// Software. However, You may do so only on Your own behalf, and not on
// behalf of any Contributor. You must make it absolutely clear that any
// such warranty, support, indemnity, or liability obligation is offered by
// You alone, and You hereby agree to indemnify every Contributor for any
// liability incurred by such Contributor as a result of warranty, support,
// indemnity or liability terms You offer. You may include additional
// disclaimers of warranty and limitations of liability specific to any
// jurisdiction.
//
// 4. Inability to Comply Due to Statute or Regulation
// ---------------------------------------------------
//
// If it is impossible for You to comply with any of the terms of this
// License with respect to some or all of the Covered Software due to
// statute, judicial order, or regulation then You must: (a) comply with
// the terms of this License to the maximum extent possible; and (b)
// describe the limitations and the code they affect. Such description must
// be placed in a text file included with all distributions of the Covered
// Software under this License. Except to the extent prohibited by statute
// or regulation, such description must be sufficiently detailed for a
// recipient of ordinary skill to be able to understand it.
//
// 5. Termination
// --------------
//
// 5.1. The rights granted under this License will terminate automatically
// if You fail to comply with any of its terms. However, if You become
// compliant, then the rights granted under this License from a particular
// Contributor are reinstated (a) provisionally, unless and until such
// Contributor explicitly and finally terminates Your grants, and (b) on an
// ongoing basis, if such Contributor fails to notify You of the
// non-compliance by some reasonable means prior to 60 days after You have
// come back into compliance. Moreover, Your grants from a particular
// Contributor are reinstated on an ongoing basis if such Contributor
// notifies You of the non-compliance by some reasonable means, this is the
// first time You have received notice of non-compliance with this License
// from such Contributor, and You become compliant prior to 30 days after
// Your receipt of the notice.
//
// 5.2. If You initiate litigation against any entity by asserting a patent
// infringement claim (excluding declaratory judgment actions,
// counter-claims, and cross-claims) alleging that a Contributor Version
// directly or indirectly infringes any patent, then the rights granted to
// You by any and all Contributors for the Covered Software under Section
// 2.1 of this License shall terminate.
//
// 5.3. In the event of termination under Sections 5.1 or 5.2 above, all
// end user license agreements (excluding distributors and resellers) which
// have been validly granted by You or Your distributors under this License
// prior to termination shall survive termination.
//
// ************************************************************************
// * *
// * 6. Disclaimer of Warranty                                           *
// * -------------------------                                           *
// * *
// * Covered Software is provided under this License on an "as is"       *
// * basis, without warranty of any kind, either expressed, implied, or  *
// * statutory, including, without limitation, warranties that the       *
// * Covered Software is free of defects, merchantable, fit for a        *
// * particular purpose or non-infringing. The entire risk as to the     *
// * quality and performance of the Covered Software is with You.        *
// * Should any Covered Software prove defective in any respect, You     *
// * (not any Contributor) assume the cost of any necessary servicing,   *
// * repair, or correction. This disclaimer of warranty constitutes an   *
// * essential part of this License. No use of any Covered Software is   *
// * authorized under this License except under this disclaimer.         *
// * *
// ************************************************************************
//
// ************************************************************************
// * *
// * 7. Limitation of Liability                                          *
// * --------------------------                                          *
// * *
// * Under no circumstances and under no legal theory, whether tort      *
// * (including negligence), contract, or otherwise, shall any           *
// * Contributor, or anyone who distributes Covered Software as          *
// * permitted above, be liable to You for any direct, indirect,         *
// * special, incidental, or consequential damages of any character      *
// * including, without limitation, damages for lost profits, loss of    *
// * goodwill, work stoppage, computer failure or malfunction, or any    *
// * and all other commercial damages or losses, even if such party      *
// * shall have been informed of the possibility of such damages. This   *
// * limitation of liability shall not apply to liability for death or   *
// * personal injury resulting from such party's negligence to the       *
// * extent applicable law prohibits such limitation. Some               *
// * jurisdictions do not allow the exclusion or limitation of           *
// * incidental or consequential damages, so this exclusion and          *
// * limitation may not apply to You.                                    *
// * *
// ************************************************************************
//
// 8. Litigation
// -------------
//
// Any litigation relating to this License may be brought only in the
// courts of a jurisdiction where the defendant maintains its principal
// place of business and such litigation shall be governed by laws of that
// jurisdiction, without reference to its conflict-of-law provisions.
// Nothing in this Section shall prevent a party's ability to bring
// cross-claims or counter-claims.
//
// 9. Miscellaneous
// ----------------
//
// This License represents the complete agreement concerning the subject
// matter hereof. If any provision of this License is held to be
// unenforceable, such provision shall be reformed only to the extent
// necessary to make it enforceable. Any law or regulation which provides
// that the language of a contract shall be construed against the drafter
// shall not be used to construe this License against a Contributor.
//
// 10. Versions of the License
// ---------------------------
//
// 10.1. New Versions
//
// Mozilla Foundation is the license steward. Except as provided in Section
// 10.3, no one other than the license steward has the right to modify or
// publish new versions of this License. Each version will be given a
// distinguishing version number.
//
// 10.2. Effect of New Versions
//
// You may distribute the Covered Software under the terms of the version
// of the License under which You originally received the Covered Software,
// or under the terms of any subsequent version published by the license
// steward.
//
// 10.3. Modified Versions
//
// If you create software not governed by this License, and you want to
// create a new license for such software, you may create and use a
// modified version of this License if you rename the license and remove
// any references to the name of the license steward (except to note that
// such modified license differs from this License).
//
// 10.4. Distributing Source Code Form that is Incompatible With Secondary
// Licenses
//
// If You choose to distribute Source Code Form that is Incompatible With
// Secondary Licenses under the terms of this version of the License, the
// notice described in Exhibit B of this License must be attached.
//
// Exhibit A - Source Code Form License Notice
// -------------------------------------------
//
//   This Source Code Form is subject to the terms of the Mozilla Public
//   License, v. 2.0. If a copy of the MPL was not distributed with this
//   file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// If it is not possible or desirable to put the notice in a particular
// file, then You may include the notice in a location (such as a LICENSE
// file in a relevant directory) where a recipient would be likely to look
// for such a notice.
//
// You may add additional accurate notices of copyright ownership.
//
// Exhibit B - "Incompatible With Secondary Licenses" Notice
// ---------------------------------------------------------
//
//   This Source Code Form is "Incompatible With Secondary Licenses", as
//   defined by the Mozilla Public License, v. 2.0.
#![no_std]
#![allow(non_upper_case_globals)]
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/azul_logo_full_min.svg.png",
    html_favicon_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/favicon.ico"
)]

//! Auto-generated public Rust API for the Azul GUI toolkit version " + version + "

extern crate alloc;
#[cfg(feature = "serde-support")]
extern crate serde;
#[cfg(feature = "serde-support")]
#[macro_use(Serialize, Deserialize)]
extern crate serde_derive;

/// Module to re-export common structs (`App`, `AppConfig`, `Css`, `Dom`, `WindowCreateOptions`,
/// `RefAny`, `LayoutInfo`)
pub mod prelude {
    pub use crate::{
        app::*, callbacks::*, clipboard::*, css::*, dialog::*, dom::*, error::*, font::*, fs::*,
        gl::*, image::*, menu::*, option::*, str::*, style::*, svg::*, task::*, time::*, vec::*,
        window::*, xml::*,
    };
}

mod dll {

    impl AzString {
        #[inline]
        pub fn as_str(&self) -> &str {
            unsafe { core::str::from_utf8_unchecked(self.as_bytes()) }
        }
        #[inline]
        pub fn as_bytes(&self) -> &[u8] {
            unsafe { core::slice::from_raw_parts(self.vec.ptr, self.vec.len) }
        }
    }

    unsafe impl Send for AzThreadSender {}

    impl ::core::fmt::Debug for AzCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzLayoutCallbackInner {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzMarshaledLayoutCallbackInner {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzRenderImageCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzIFrameCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzTimerCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzWriteBackCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzThreadDestructorFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzLibraryReceiveThreadMsgFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzLibrarySendThreadMsgFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzCheckThreadFinishedFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzGetSystemTimeFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzCreateThreadFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzThreadRecvFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzThreadReceiverDestructorFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzThreadSenderDestructorFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzInstantPtrDestructorFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzInstantPtrCloneFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzThreadSendFn {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzFileInputOnPathChangeCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzCheckBoxOnToggleCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzColorInputOnValueChangeCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzTextInputOnTextInputCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzTextInputOnVirtualKeyDownCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzTextInputOnFocusLostCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNumberInputOnFocusLostCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNumberInputOnValueChangeCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeAddedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeRemovedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeDraggedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeGraphDraggedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeConnectedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeInputDisconnectedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeOutputDisconnectedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzNodeGraphOnNodeFieldEditedCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzDropDownOnChoiceChangeCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzTabOnClickCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzListViewOnRowClickCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzListViewOnColumnClickCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl ::core::fmt::Debug for AzListViewOnLazyLoadScrollCallback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            write!(f, "{:x}", self.cb as usize)
        }
    }

    impl PartialEq for AzCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzLayoutCallbackInner {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzMarshaledLayoutCallbackInner {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzRenderImageCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzIFrameCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzTimerCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzWriteBackCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzThreadDestructorFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzLibraryReceiveThreadMsgFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzLibrarySendThreadMsgFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzCheckThreadFinishedFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzGetSystemTimeFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzCreateThreadFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzThreadRecvFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzThreadReceiverDestructorFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzThreadSenderDestructorFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzInstantPtrDestructorFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzInstantPtrCloneFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzThreadSendFn {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzFileInputOnPathChangeCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzCheckBoxOnToggleCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzColorInputOnValueChangeCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzTextInputOnTextInputCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzTextInputOnVirtualKeyDownCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzTextInputOnFocusLostCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNumberInputOnFocusLostCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNumberInputOnValueChangeCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeAddedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeRemovedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeDraggedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeGraphDraggedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeConnectedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeInputDisconnectedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeOutputDisconnectedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzNodeGraphOnNodeFieldEditedCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzDropDownOnChoiceChangeCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzTabOnClickCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzListViewOnLazyLoadScrollCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzListViewOnColumnClickCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialEq for AzListViewOnRowClickCallback {
        fn eq(&self, rhs: &Self) -> bool {
            (self.cb as usize).eq(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzLayoutCallbackInner {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzMarshaledLayoutCallbackInner {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzRenderImageCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzIFrameCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzTimerCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzWriteBackCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzThreadDestructorFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzLibraryReceiveThreadMsgFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzLibrarySendThreadMsgFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzCheckThreadFinishedFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzGetSystemTimeFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzCreateThreadFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzThreadRecvFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzThreadReceiverDestructorFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzThreadSenderDestructorFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzInstantPtrDestructorFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzInstantPtrCloneFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzThreadSendFn {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzFileInputOnPathChangeCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzCheckBoxOnToggleCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzColorInputOnValueChangeCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzTextInputOnTextInputCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzTextInputOnVirtualKeyDownCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzTextInputOnFocusLostCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNumberInputOnFocusLostCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNumberInputOnValueChangeCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeAddedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeRemovedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeDraggedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeGraphDraggedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeConnectedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeInputDisconnectedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeOutputDisconnectedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzNodeGraphOnNodeFieldEditedCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzDropDownOnChoiceChangeCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzTabOnClickCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzListViewOnLazyLoadScrollCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzListViewOnColumnClickCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    impl PartialOrd for AzListViewOnRowClickCallback {
        fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> {
            (self.cb as usize).partial_cmp(&(rhs.cb as usize))
        }
    }

    #[cfg(not(feature = "link-static"))]
    pub use self::dynamic_link::*;
    #[cfg(feature = "link-static")]
    pub use self::static_link::*;
    pub use self::types::*;

    mod types {
        use core::ffi::c_void;

        /// Main application class
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzApp {
            pub(crate) ptr: *const c_void,
            pub run_destructor: bool,
        }

        /// Configuration to set which messages should be logged.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzAppLogLevel {
            Off,
            Error,
            Warn,
            Info,
            Debug,
            Trace,
        }

        /// Version of the layout solver to use - future binary versions of azul may have more
        /// fields here, necessary so that old compiled applications don't break with newer releases
        /// of azul. Newer layout versions are opt-in only.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzLayoutSolver {
            Default,
        }

        /// Whether the renderer has VSync enabled
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzVsync {
            Enabled,
            Disabled,
            DontCare,
        }

        /// Does the renderer render in SRGB color space? By default, azul tries to set it to
        /// `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized
        /// properly
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzSrgb {
            Enabled,
            Disabled,
            DontCare,
        }

        /// Does the renderer render using hardware acceleration? By default, azul tries to set it
        /// to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized
        /// properly
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzHwAcceleration {
            Enabled,
            Disabled,
            DontCare,
        }

        /// Offset in physical pixels (integer units)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzLayoutPoint {
            pub x: isize,
            pub y: isize,
        }

        /// Size in physical pixels (integer units)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzLayoutSize {
            pub width: isize,
            pub height: isize,
        }

        /// Re-export of rust-allocated (stack based) `IOSHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzIOSHandle {
            pub ui_window: *mut c_void,
            pub ui_view: *mut c_void,
            pub ui_view_controller: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `MacOSHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzMacOSHandle {
            pub ns_window: *mut c_void,
            pub ns_view: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `XlibHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzXlibHandle {
            pub window: u64,
            pub display: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `XcbHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzXcbHandle {
            pub window: u32,
            pub connection: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `WaylandHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzWaylandHandle {
            pub surface: *mut c_void,
            pub display: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `WindowsHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzWindowsHandle {
            pub hwnd: *mut c_void,
            pub hinstance: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `WebHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzWebHandle {
            pub id: u32,
        }

        /// Re-export of rust-allocated (stack based) `AndroidHandle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzAndroidHandle {
            pub a_native_window: *mut c_void,
        }

        /// X11 window hint: Type of window
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzXWindowType {
            Desktop,
            Dock,
            Toolbar,
            Menu,
            Utility,
            Splash,
            Dialog,
            DropdownMenu,
            PopupMenu,
            Tooltip,
            Notification,
            Combo,
            Dnd,
            Normal,
        }

        /// Same as `LayoutPoint`, but uses `i32` instead of `isize`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzPhysicalPositionI32 {
            pub x: i32,
            pub y: i32,
        }

        /// Same as `LayoutPoint`, but uses `u32` instead of `isize`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzPhysicalSizeU32 {
            pub width: u32,
            pub height: u32,
        }

        /// Logical position (can differ based on HiDPI settings). Usually this is what you'd want
        /// for hit-testing and positioning elements.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy, Default)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzLogicalPosition {
            pub x: f32,
            pub y: f32,
        }

        /// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzLogicalSize {
            pub width: f32,
            pub height: f32,
        }

        /// Unique hash of a window icon, so that azul does not have to compare the actual bytes to
        /// see wether the window icon has changed.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzIconKey {
            pub id: usize,
        }

        /// Symbolic name for a keyboard key, does **not** take the keyboard locale into account
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzVirtualKeyCode {
            Key1,
            Key2,
            Key3,
            Key4,
            Key5,
            Key6,
            Key7,
            Key8,
            Key9,
            Key0,
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H,
            I,
            J,
            K,
            L,
            M,
            N,
            O,
            P,
            Q,
            R,
            S,
            T,
            U,
            V,
            W,
            X,
            Y,
            Z,
            Escape,
            F1,
            F2,
            F3,
            F4,
            F5,
            F6,
            F7,
            F8,
            F9,
            F10,
            F11,
            F12,
            F13,
            F14,
            F15,
            F16,
            F17,
            F18,
            F19,
            F20,
            F21,
            F22,
            F23,
            F24,
            Snapshot,
            Scroll,
            Pause,
            Insert,
            Home,
            Delete,
            End,
            PageDown,
            PageUp,
            Left,
            Up,
            Right,
            Down,
            Back,
            Return,
            Space,
            Compose,
            Caret,
            Numlock,
            Numpad0,
            Numpad1,
            Numpad2,
            Numpad3,
            Numpad4,
            Numpad5,
            Numpad6,
            Numpad7,
            Numpad8,
            Numpad9,
            NumpadAdd,
            NumpadDivide,
            NumpadDecimal,
            NumpadComma,
            NumpadEnter,
            NumpadEquals,
            NumpadMultiply,
            NumpadSubtract,
            AbntC1,
            AbntC2,
            Apostrophe,
            Apps,
            Asterisk,
            At,
            Ax,
            Backslash,
            Calculator,
            Capital,
            Colon,
            Comma,
            Convert,
            Equals,
            Grave,
            Kana,
            Kanji,
            LAlt,
            LBracket,
            LControl,
            LShift,
            LWin,
            Mail,
            MediaSelect,
            MediaStop,
            Minus,
            Mute,
            MyComputer,
            NavigateForward,
            NavigateBackward,
            NextTrack,
            NoConvert,
            OEM102,
            Period,
            PlayPause,
            Plus,
            Power,
            PrevTrack,
            RAlt,
            RBracket,
            RControl,
            RShift,
            RWin,
            Semicolon,
            Slash,
            Sleep,
            Stop,
            Sysrq,
            Tab,
            Underline,
            Unlabeled,
            VolumeDown,
            VolumeUp,
            Wake,
            WebBack,
            WebFavorites,
            WebForward,
            WebHome,
            WebRefresh,
            WebSearch,
            WebStop,
            Yen,
            Copy,
            Paste,
            Cut,
        }

        /// State of the window frame (minimized, maximized, fullscreen or normal window)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzWindowFrame {
            Normal,
            Minimized,
            Maximized,
            Fullscreen,
        }

        /// Debugging information, will be rendered as an overlay on top of the UI
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzDebugState {
            pub profiler_dbg: bool,
            pub render_target_dbg: bool,
            pub texture_cache_dbg: bool,
            pub gpu_time_queries: bool,
            pub gpu_sample_queries: bool,
            pub disable_batching: bool,
            pub epochs: bool,
            pub echo_driver_messages: bool,
            pub show_overdraw: bool,
            pub gpu_cache_dbg: bool,
            pub texture_cache_dbg_clear_evicted: bool,
            pub picture_caching_dbg: bool,
            pub primitive_dbg: bool,
            pub zoom_dbg: bool,
            pub small_screen: bool,
            pub disable_opaque_pass: bool,
            pub disable_alpha_pass: bool,
            pub disable_clip_masks: bool,
            pub disable_text_prims: bool,
            pub disable_gradient_prims: bool,
            pub obscure_images: bool,
            pub glyph_flashing: bool,
            pub smart_profiler: bool,
            pub invalidation_dbg: bool,
            pub tile_cache_logging_dbg: bool,
            pub profiler_capture: bool,
            pub force_picture_invalidation: bool,
        }

        /// Current icon of the mouse cursor
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzMouseCursorType {
            Default,
            Crosshair,
            Hand,
            Arrow,
            Move,
            Text,
            Wait,
            Help,
            Progress,
            NotAllowed,
            ContextMenu,
            Cell,
            VerticalText,
            Alias,
            Copy,
            NoDrop,
            Grab,
            Grabbing,
            AllScroll,
            ZoomIn,
            ZoomOut,
            EResize,
            NResize,
            NeResize,
            NwResize,
            SResize,
            SeResize,
            SwResize,
            WResize,
            EwResize,
            NsResize,
            NeswResize,
            NwseResize,
            ColResize,
            RowResize,
        }

        /// Renderer type of the current windows OpenGL context
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzRendererType {
            Hardware,
            Software,
        }

        /// Re-export of rust-allocated (stack based) `MacWindowOptions` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzMacWindowOptions {
            pub _reserved: u8,
        }

        /// Re-export of rust-allocated (stack based) `WasmWindowOptions` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzWasmWindowOptions {
            pub _reserved: u8,
        }

        /// Re-export of rust-allocated (stack based) `FullScreenMode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzFullScreenMode {
            SlowFullScreen,
            FastFullScreen,
            SlowWindowed,
            FastWindowed,
        }

        /// Window theme, set by the operating system or `WindowCreateOptions.theme` on startup
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzWindowTheme {
            DarkMode,
            LightMode,
        }

        /// Current state of touch devices / touch inputs
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzTouchState {
            pub unused: u8,
        }

        /// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzMarshaledLayoutCallbackInner {
            pub cb: AzMarshaledLayoutCallbackType,
        }

        /// `AzMarshaledLayoutCallbackType` struct
        pub type AzMarshaledLayoutCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzRefAny, AzLayoutCallbackInfo) -> AzStyledDom;

        /// C-ABI stable wrapper over a `LayoutCallbackType`
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzLayoutCallbackInner {
            pub cb: AzLayoutCallbackType,
        }

        /// `AzLayoutCallbackType` struct
        pub type AzLayoutCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzLayoutCallbackInfo) -> AzStyledDom;

        /// C-ABI stable wrapper over a `CallbackType`
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzCallback {
            pub cb: AzCallbackType,
        }

        /// `AzCallbackType` struct
        pub type AzCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

        /// Which type of image should be updated: background image (the CSS background) or content
        /// image (the <img src=""> content)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzUpdateImageType {
            Background,
            Content,
        }

        /// Specifies if the screen should be updated after the callback function has returned
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzUpdate {
            DoNothing,
            RefreshDom,
            RefreshDomAllWindows,
        }

        /// Index of a Node in the internal `NodeDataContainer`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzNodeId {
            pub inner: usize,
        }

        /// ID of a DOM - one window can contain multiple, nested DOMs (such as iframes)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzDomId {
            pub inner: usize,
        }

        /// Re-export of rust-allocated (stack based) `PositionInfoInner` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzPositionInfoInner {
            pub x_offset: f32,
            pub y_offset: f32,
            pub static_x_offset: f32,
            pub static_y_offset: f32,
        }

        /// Re-export of rust-allocated (stack based) `ScriptType` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzScriptType {
            Mixed,
            LTR,
            RTL,
        }

        /// How should an animation repeat (loop, ping-pong, etc.)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzAnimationRepeat {
            NoRepeat,
            Loop,
            PingPong,
        }

        /// How many times should an animation repeat
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzAnimationRepeatCount {
            Times(usize),
            Infinite,
        }

        /// C-ABI wrapper over an `IFrameCallbackType`
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzIFrameCallback {
            pub cb: AzIFrameCallbackType,
        }

        /// `AzIFrameCallbackType` struct
        pub type AzIFrameCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzIFrameCallbackInfo) -> AzIFrameCallbackReturn;

        /// Re-export of rust-allocated (stack based) `RenderImageCallback` struct
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzRenderImageCallback {
            pub cb: AzRenderImageCallbackType,
        }

        /// `AzRenderImageCallbackType` struct
        pub type AzRenderImageCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzRenderImageCallbackInfo) -> AzImageRef;

        /// Re-export of rust-allocated (stack based) `TimerCallback` struct
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzTimerCallback {
            pub cb: AzTimerCallbackType,
        }

        /// `AzTimerCallbackType` struct
        pub type AzTimerCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzTimerCallbackInfo) -> AzTimerCallbackReturn;

        /// `AzWriteBackCallbackType` struct
        pub type AzWriteBackCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `WriteBackCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzWriteBackCallback {
            pub cb: AzWriteBackCallbackType,
        }

        /// Re-export of rust-allocated (stack based) `ThreadCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzThreadCallback {
            pub cb: AzThreadCallbackType,
        }

        /// `AzThreadCallbackType` struct
        pub type AzThreadCallbackType = extern "C" fn(AzRefAny, AzThreadSender, AzThreadReceiver);

        /// `AzRefAnyDestructorType` struct
        pub type AzRefAnyDestructorType = extern "C" fn(&mut c_void);

        /// Re-export of rust-allocated (stack based) `RefCount` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzRefCount {
            pub(crate) ptr: *const c_void,
            pub run_destructor: bool,
        }

        /// When to call a callback action - `On::MouseOver`, `On::MouseOut`, etc.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOn {
            MouseOver,
            MouseDown,
            LeftMouseDown,
            MiddleMouseDown,
            RightMouseDown,
            MouseUp,
            LeftMouseUp,
            MiddleMouseUp,
            RightMouseUp,
            MouseEnter,
            MouseLeave,
            Scroll,
            TextInput,
            VirtualKeyDown,
            VirtualKeyUp,
            HoveredFile,
            DroppedFile,
            HoveredFileCancelled,
            FocusReceived,
            FocusLost,
        }

        /// Re-export of rust-allocated (stack based) `HoverEventFilter` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzHoverEventFilter {
            MouseOver,
            MouseDown,
            LeftMouseDown,
            RightMouseDown,
            MiddleMouseDown,
            MouseUp,
            LeftMouseUp,
            RightMouseUp,
            MiddleMouseUp,
            MouseEnter,
            MouseLeave,
            Scroll,
            ScrollStart,
            ScrollEnd,
            TextInput,
            VirtualKeyDown,
            VirtualKeyUp,
            HoveredFile,
            DroppedFile,
            HoveredFileCancelled,
            TouchStart,
            TouchMove,
            TouchEnd,
            TouchCancel,
        }

        /// Re-export of rust-allocated (stack based) `FocusEventFilter` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzFocusEventFilter {
            MouseOver,
            MouseDown,
            LeftMouseDown,
            RightMouseDown,
            MiddleMouseDown,
            MouseUp,
            LeftMouseUp,
            RightMouseUp,
            MiddleMouseUp,
            MouseEnter,
            MouseLeave,
            Scroll,
            ScrollStart,
            ScrollEnd,
            TextInput,
            VirtualKeyDown,
            VirtualKeyUp,
            FocusReceived,
            FocusLost,
        }

        /// Re-export of rust-allocated (stack based) `WindowEventFilter` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzWindowEventFilter {
            MouseOver,
            MouseDown,
            LeftMouseDown,
            RightMouseDown,
            MiddleMouseDown,
            MouseUp,
            LeftMouseUp,
            RightMouseUp,
            MiddleMouseUp,
            MouseEnter,
            MouseLeave,
            Scroll,
            ScrollStart,
            ScrollEnd,
            TextInput,
            VirtualKeyDown,
            VirtualKeyUp,
            HoveredFile,
            DroppedFile,
            HoveredFileCancelled,
            Resized,
            Moved,
            TouchStart,
            TouchMove,
            TouchEnd,
            TouchCancel,
            FocusReceived,
            FocusLost,
            CloseRequested,
            ThemeChanged,
        }

        /// Re-export of rust-allocated (stack based) `ComponentEventFilter` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzComponentEventFilter {
            AfterMount,
            BeforeUnmount,
            NodeResized,
            DefaultAction,
            Selected,
        }

        /// Re-export of rust-allocated (stack based) `ApplicationEventFilter` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzApplicationEventFilter {
            DeviceConnected,
            DeviceDisconnected,
        }

        /// MSAA Accessibility role constants. For information on what each role does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-roles">MSDN Role Constants page</a>
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzAccessibilityRole {
            TitleBar,
            MenuBar,
            ScrollBar,
            Grip,
            Sound,
            Cursor,
            Caret,
            Alert,
            Window,
            Client,
            MenuPopup,
            MenuItem,
            Tooltip,
            Application,
            Document,
            Pane,
            Chart,
            Dialog,
            Border,
            Grouping,
            Separator,
            Toolbar,
            StatusBar,
            Table,
            ColumnHeader,
            RowHeader,
            Column,
            Row,
            Cell,
            Link,
            HelpBalloon,
            Character,
            List,
            ListItem,
            Outline,
            OutlineItem,
            Pagetab,
            PropertyPage,
            Indicator,
            Graphic,
            StaticText,
            Text,
            PushButton,
            CheckButton,
            RadioButton,
            ComboBox,
            DropList,
            ProgressBar,
            Dial,
            HotkeyField,
            Slider,
            SpinButton,
            Diagram,
            Animation,
            Equation,
            ButtonDropdown,
            ButtonMenu,
            ButtonDropdownGrid,
            Whitespace,
            PageTabList,
            Clock,
            SplitButton,
            IpAddress,
            Nothing,
        }

        /// MSAA accessibility state. For information on what each state does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants">MSDN State Constants page</a>.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzAccessibilityState {
            Unavailable,
            Selected,
            Focused,
            Checked,
            Readonly,
            Default,
            Expanded,
            Collapsed,
            Busy,
            Offscreen,
            Focusable,
            Selectable,
            Linked,
            Traversed,
            Multiselectable,
            Protected,
        }

        /// Re-export of rust-allocated (stack based) `TabIndex` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzTabIndex {
            Auto,
            OverrideInParent(u32),
            NoKeyboardFocus,
        }

        /// Determines whether this context menu should pop up on a left, right or middle click
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzContextMenuMouseButton {
            Right,
            Middle,
            Left,
        }

        /// Position of where the context menu should pop up
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzMenuPopupPosition {
            BottomLeftOfCursor,
            BottomRightOfCursor,
            TopLeftOfCursor,
            TopRightOfCursor,
            BottomOfHitRect,
            LeftOfHitRect,
            TopOfHitRect,
            RightOfHitRect,
            AutoCursor,
            AutoHitRect,
        }

        /// Describes the state of a menu item
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzMenuItemState {
            Normal,
            Greyed,
            Disabled,
        }

        /// Re-export of rust-allocated (stack based) `NodeTypeKey` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzNodeTypeKey {
            Body,
            Div,
            Br,
            P,
            Img,
            IFrame,
        }

        /// Re-export of rust-allocated (stack based) `CssNthChildPattern` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzCssNthChildPattern {
            pub repeat: u32,
            pub offset: u32,
        }

        /// Re-export of rust-allocated (stack based) `CssPropertyType` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzCssPropertyType {
            TextColor,
            FontSize,
            FontFamily,
            TextAlign,
            LetterSpacing,
            LineHeight,
            WordSpacing,
            TabWidth,
            Cursor,
            Display,
            Float,
            BoxSizing,
            Width,
            Height,
            MinWidth,
            MinHeight,
            MaxWidth,
            MaxHeight,
            Position,
            Top,
            Right,
            Left,
            Bottom,
            FlexWrap,
            FlexDirection,
            FlexGrow,
            FlexShrink,
            JustifyContent,
            AlignItems,
            AlignContent,
            BackgroundContent,
            BackgroundPosition,
            BackgroundSize,
            BackgroundRepeat,
            OverflowX,
            OverflowY,
            PaddingTop,
            PaddingLeft,
            PaddingRight,
            PaddingBottom,
            MarginTop,
            MarginLeft,
            MarginRight,
            MarginBottom,
            BorderTopLeftRadius,
            BorderTopRightRadius,
            BorderBottomLeftRadius,
            BorderBottomRightRadius,
            BorderTopColor,
            BorderRightColor,
            BorderLeftColor,
            BorderBottomColor,
            BorderTopStyle,
            BorderRightStyle,
            BorderLeftStyle,
            BorderBottomStyle,
            BorderTopWidth,
            BorderRightWidth,
            BorderLeftWidth,
            BorderBottomWidth,
            BoxShadowLeft,
            BoxShadowRight,
            BoxShadowTop,
            BoxShadowBottom,
            ScrollbarStyle,
            Opacity,
            Transform,
            TransformOrigin,
            PerspectiveOrigin,
            BackfaceVisibility,
            MixBlendMode,
            Filter,
            BackdropFilter,
            TextShadow,
        }

        /// Re-export of rust-allocated (stack based) `ColorU` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzColorU {
            pub r: u8,
            pub g: u8,
            pub b: u8,
            pub a: u8,
        }

        /// Re-export of rust-allocated (stack based) `SizeMetric` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzSizeMetric {
            Px,
            Pt,
            Em,
            Percent,
        }

        /// Re-export of rust-allocated (stack based) `BoxShadowClipMode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzBoxShadowClipMode {
            Outset,
            Inset,
        }

        /// Re-export of rust-allocated (stack based) `StyleMixBlendMode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleMixBlendMode {
            Normal,
            Multiply,
            Screen,
            Overlay,
            Darken,
            Lighten,
            ColorDodge,
            ColorBurn,
            HardLight,
            SoftLight,
            Difference,
            Exclusion,
            Hue,
            Saturation,
            Color,
            Luminosity,
        }

        /// Re-export of rust-allocated (stack based) `LayoutAlignContent` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutAlignContent {
            Stretch,
            Center,
            Start,
            End,
            SpaceBetween,
            SpaceAround,
        }

        /// Re-export of rust-allocated (stack based) `LayoutAlignItems` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutAlignItems {
            Stretch,
            Center,
            FlexStart,
            FlexEnd,
        }

        /// Re-export of rust-allocated (stack based) `LayoutBoxSizing` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutBoxSizing {
            ContentBox,
            BorderBox,
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexDirection` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFlexDirection {
            Row,
            RowReverse,
            Column,
            ColumnReverse,
        }

        /// Re-export of rust-allocated (stack based) `LayoutDisplay` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutDisplay {
            None,
            Flex,
            Block,
            InlineBlock,
        }

        /// Re-export of rust-allocated (stack based) `LayoutFloat` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFloat {
            Left,
            Right,
            None,
        }

        /// Re-export of rust-allocated (stack based) `LayoutJustifyContent` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutJustifyContent {
            Start,
            End,
            Center,
            SpaceBetween,
            SpaceAround,
            SpaceEvenly,
        }

        /// Re-export of rust-allocated (stack based) `LayoutPosition` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutPosition {
            Static,
            Relative,
            Absolute,
            Fixed,
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexWrap` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFlexWrap {
            Wrap,
            NoWrap,
        }

        /// Re-export of rust-allocated (stack based) `LayoutOverflow` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutOverflow {
            Scroll,
            Auto,
            Hidden,
            Visible,
        }

        /// Re-export of rust-allocated (stack based) `FloatValue` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzFloatValue {
            pub number: isize,
        }

        /// Re-export of rust-allocated (stack based) `AngleMetric` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzAngleMetric {
            Degree,
            Radians,
            Grad,
            Turn,
            Percent,
        }

        /// Re-export of rust-allocated (stack based) `DirectionCorner` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzDirectionCorner {
            Right,
            Left,
            Top,
            Bottom,
            TopRight,
            TopLeft,
            BottomRight,
            BottomLeft,
        }

        /// Re-export of rust-allocated (stack based) `ExtendMode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzExtendMode {
            Clamp,
            Repeat,
        }

        /// Re-export of rust-allocated (stack based) `Shape` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzShape {
            Ellipse,
            Circle,
        }

        /// Re-export of rust-allocated (stack based) `RadialGradientSize` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzRadialGradientSize {
            ClosestSide,
            ClosestCorner,
            FarthestSide,
            FarthestCorner,
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundRepeat` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzStyleBackgroundRepeat {
            NoRepeat,
            Repeat,
            RepeatX,
            RepeatY,
        }

        /// Re-export of rust-allocated (stack based) `BorderStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzBorderStyle {
            None,
            Solid,
            Double,
            Dotted,
            Dashed,
            Hidden,
            Groove,
            Ridge,
            Inset,
            Outset,
        }

        /// Re-export of rust-allocated (stack based) `StyleCursor` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleCursor {
            Alias,
            AllScroll,
            Cell,
            ColResize,
            ContextMenu,
            Copy,
            Crosshair,
            Default,
            EResize,
            EwResize,
            Grab,
            Grabbing,
            Help,
            Move,
            NResize,
            NsResize,
            NeswResize,
            NwseResize,
            Pointer,
            Progress,
            RowResize,
            SResize,
            SeResize,
            Text,
            Unset,
            VerticalText,
            WResize,
            Wait,
            ZoomIn,
            ZoomOut,
        }

        /// Re-export of rust-allocated (stack based) `StyleBackfaceVisibility` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBackfaceVisibility {
            Hidden,
            Visible,
        }

        /// Re-export of rust-allocated (stack based) `StyleTextAlign` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleTextAlign {
            Left,
            Center,
            Right,
            Justify,
        }

        /// Re-export of rust-allocated (stack based) `Ribbon` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzRibbon {
            pub tab_active: i32,
        }

        /// Re-export of rust-allocated (stack based) `RibbonOnTabClickedCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzRibbonOnTabClickedCallback {
            pub cb: AzRibbonOnTabClickedCallbackType,
        }

        /// `AzRibbonOnTabClickedCallbackType` struct
        pub type AzRibbonOnTabClickedCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, i32) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `FileInputOnPathChangeCallback` struct
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzFileInputOnPathChangeCallback {
            pub cb: AzFileInputOnPathChangeCallbackType,
        }

        /// `AzFileInputOnPathChangeCallbackType` struct
        pub type AzFileInputOnPathChangeCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzFileInputState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `CheckBoxOnToggleCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzCheckBoxOnToggleCallback {
            pub cb: AzCheckBoxOnToggleCallbackType,
        }

        /// `AzCheckBoxOnToggleCallbackType` struct
        pub type AzCheckBoxOnToggleCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzCheckBoxState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `CheckBoxState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCheckBoxState {
            pub checked: bool,
        }

        /// Re-export of rust-allocated (stack based) `ColorInputOnValueChangeCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzColorInputOnValueChangeCallback {
            pub cb: AzColorInputOnValueChangeCallbackType,
        }

        /// `AzColorInputOnValueChangeCallbackType` struct
        pub type AzColorInputOnValueChangeCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzColorInputState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `TextInputSelectionRange` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTextInputSelectionRange {
            pub from: usize,
            pub to: usize,
        }

        /// Re-export of rust-allocated (stack based) `TextInputOnTextInputCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzTextInputOnTextInputCallback {
            pub cb: AzTextInputOnTextInputCallbackType,
        }

        /// `AzTextInputOnTextInputCallbackType` struct
        pub type AzTextInputOnTextInputCallbackType = extern "C" fn(
            &mut AzRefAny,
            &mut AzCallbackInfo,
            &AzTextInputState,
        ) -> AzOnTextInputReturn;

        /// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDownCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzTextInputOnVirtualKeyDownCallback {
            pub cb: AzTextInputOnVirtualKeyDownCallbackType,
        }

        /// `AzTextInputOnVirtualKeyDownCallbackType` struct
        pub type AzTextInputOnVirtualKeyDownCallbackType = extern "C" fn(
            &mut AzRefAny,
            &mut AzCallbackInfo,
            &AzTextInputState,
        )
            -> AzOnTextInputReturn;

        /// Re-export of rust-allocated (stack based) `TextInputOnFocusLostCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzTextInputOnFocusLostCallback {
            pub cb: AzTextInputOnFocusLostCallbackType,
        }

        /// `AzTextInputOnFocusLostCallbackType` struct
        pub type AzTextInputOnFocusLostCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `TextInputValid` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzTextInputValid {
            Yes,
            No,
        }

        /// Re-export of rust-allocated (stack based) `NumberInputState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNumberInputState {
            pub previous: f32,
            pub number: f32,
            pub min: f32,
            pub max: f32,
        }

        /// Re-export of rust-allocated (stack based) `NumberInputOnValueChangeCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNumberInputOnValueChangeCallback {
            pub cb: AzNumberInputOnValueChangeCallbackType,
        }

        /// `AzNumberInputOnValueChangeCallbackType` struct
        pub type AzNumberInputOnValueChangeCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NumberInputOnFocusLostCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNumberInputOnFocusLostCallback {
            pub cb: AzNumberInputOnFocusLostCallbackType,
        }

        /// `AzNumberInputOnFocusLostCallbackType` struct
        pub type AzNumberInputOnFocusLostCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `ProgressBarState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzProgressBarState {
            pub percent_done: f32,
            pub display_percentage: bool,
        }

        /// Re-export of rust-allocated (stack based) `TabHeaderState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTabHeaderState {
            pub active_tab: usize,
        }

        /// Re-export of rust-allocated (stack based) `TabOnClickCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzTabOnClickCallback {
            pub cb: AzTabOnClickCallbackType,
        }

        /// `AzTabOnClickCallbackType` struct
        pub type AzTabOnClickCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTabHeaderState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzNodeGraphStyle {
            Default,
        }

        /// `AzNodeGraphOnNodeAddedCallbackType` struct
        pub type AzNodeGraphOnNodeAddedCallbackType = extern "C" fn(
            &mut AzRefAny,
            &mut AzCallbackInfo,
            AzNodeTypeId,
            AzNodeGraphNodeId,
            AzNodePosition,
        ) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAddedCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeAddedCallback {
            pub cb: AzNodeGraphOnNodeAddedCallbackType,
        }

        /// `AzNodeGraphOnNodeRemovedCallbackType` struct
        pub type AzNodeGraphOnNodeRemovedCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemovedCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeRemovedCallback {
            pub cb: AzNodeGraphOnNodeRemovedCallbackType,
        }

        /// `AzNodeGraphOnNodeGraphDraggedCallbackType` struct
        pub type AzNodeGraphOnNodeGraphDraggedCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzGraphDragAmount) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDraggedCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeGraphDraggedCallback {
            pub cb: AzNodeGraphOnNodeGraphDraggedCallbackType,
        }

        /// `AzNodeGraphOnNodeDraggedCallbackType` struct
        pub type AzNodeGraphOnNodeDraggedCallbackType = extern "C" fn(
            &mut AzRefAny,
            &mut AzCallbackInfo,
            AzNodeGraphNodeId,
            AzNodeDragAmount,
        ) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDraggedCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeDraggedCallback {
            pub cb: AzNodeGraphOnNodeDraggedCallbackType,
        }

        /// `AzNodeGraphOnNodeConnectedCallbackType` struct
        pub type AzNodeGraphOnNodeConnectedCallbackType = extern "C" fn(
            &mut AzRefAny,
            &mut AzCallbackInfo,
            AzNodeGraphNodeId,
            usize,
            AzNodeGraphNodeId,
            usize,
        ) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnectedCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeConnectedCallback {
            pub cb: AzNodeGraphOnNodeConnectedCallbackType,
        }

        /// `AzNodeGraphOnNodeInputDisconnectedCallbackType` struct
        pub type AzNodeGraphOnNodeInputDisconnectedCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnectedCallback`
        /// struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeInputDisconnectedCallback {
            pub cb: AzNodeGraphOnNodeInputDisconnectedCallbackType,
        }

        /// `AzNodeGraphOnNodeOutputDisconnectedCallbackType` struct
        pub type AzNodeGraphOnNodeOutputDisconnectedCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnectedCallback`
        /// struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeOutputDisconnectedCallback {
            pub cb: AzNodeGraphOnNodeOutputDisconnectedCallbackType,
        }

        /// `AzNodeGraphOnNodeFieldEditedCallbackType` struct
        pub type AzNodeGraphOnNodeFieldEditedCallbackType = extern "C" fn(
            &mut AzRefAny,
            &mut AzCallbackInfo,
            AzNodeGraphNodeId,
            usize,
            AzNodeTypeId,
            AzNodeTypeFieldValue,
        ) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEditedCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzNodeGraphOnNodeFieldEditedCallback {
            pub cb: AzNodeGraphOnNodeFieldEditedCallbackType,
        }

        /// Re-export of rust-allocated (stack based) `InputOutputTypeId` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy, Eq, Ord, Hash)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        #[cfg_attr(feature = "serde-support", serde(transparent))]
        pub struct AzInputOutputTypeId {
            pub inner: u64,
        }

        /// Re-export of rust-allocated (stack based) `NodeTypeId` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy, Eq, Ord, Hash)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        #[cfg_attr(feature = "serde-support", serde(transparent))]
        pub struct AzNodeTypeId {
            pub inner: u64,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphNodeId` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy, Eq, Ord, Hash)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        #[cfg_attr(feature = "serde-support", serde(transparent))]
        pub struct AzNodeGraphNodeId {
            pub inner: u64,
        }

        /// Re-export of rust-allocated (stack based) `NodePosition` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzNodePosition {
            pub x: f32,
            pub y: f32,
        }

        /// Re-export of rust-allocated (stack based) `GraphDragAmount` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzGraphDragAmount {
            pub x: f32,
            pub y: f32,
        }

        /// Re-export of rust-allocated (stack based) `NodeDragAmount` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzNodeDragAmount {
            pub x: f32,
            pub y: f32,
        }

        /// `AzListViewOnLazyLoadScrollCallbackType` struct
        pub type AzListViewOnLazyLoadScrollCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzListViewState) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `ListViewOnLazyLoadScrollCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzListViewOnLazyLoadScrollCallback {
            pub cb: AzListViewOnLazyLoadScrollCallbackType,
        }

        /// `AzListViewOnColumnClickCallbackType` struct
        pub type AzListViewOnColumnClickCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzListViewState, usize) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `ListViewOnColumnClickCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzListViewOnColumnClickCallback {
            pub cb: AzListViewOnColumnClickCallbackType,
        }

        /// `AzListViewOnRowClickCallbackType` struct
        pub type AzListViewOnRowClickCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzListViewState, usize) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `ListViewOnRowClickCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzListViewOnRowClickCallback {
            pub cb: AzListViewOnRowClickCallbackType,
        }

        /// `AzDropDownOnChoiceChangeCallbackType` struct
        pub type AzDropDownOnChoiceChangeCallbackType =
            extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, usize) -> AzUpdate;

        /// Re-export of rust-allocated (stack based) `DropDownOnChoiceChangeCallback` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzDropDownOnChoiceChangeCallback {
            pub cb: AzDropDownOnChoiceChangeCallbackType,
        }

        /// Re-export of rust-allocated (stack based) `NodeHierarchyItem` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzNodeHierarchyItem {
            pub parent: usize,
            pub previous_sibling: usize,
            pub next_sibling: usize,
            pub last_child: usize,
        }

        /// Re-export of rust-allocated (stack based) `CascadeInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzCascadeInfo {
            pub index_in_parent: u32,
            pub is_last_child: bool,
        }

        /// Re-export of rust-allocated (stack based) `StyledNodeState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyledNodeState {
            pub normal: bool,
            pub hover: bool,
            pub active: bool,
            pub focused: bool,
        }

        /// Re-export of rust-allocated (stack based) `TagId` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzTagId {
            pub inner: u64,
        }

        /// Re-export of rust-allocated (stack based) `CssPropertyCache` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzCssPropertyCache {
            pub(crate) ptr: *mut c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `GlVoidPtrConst` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzGlVoidPtrConst {
            pub(crate) ptr: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `GlVoidPtrMut` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGlVoidPtrMut {
            pub(crate) ptr: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `GlShaderPrecisionFormatReturn` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzGlShaderPrecisionFormatReturn {
            pub _0: i32,
            pub _1: i32,
            pub _2: i32,
        }

        /// Re-export of rust-allocated (stack based) `VertexAttributeType` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzVertexAttributeType {
            Float,
            Double,
            UnsignedByte,
            UnsignedShort,
            UnsignedInt,
        }

        /// Re-export of rust-allocated (stack based) `IndexBufferFormat` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzIndexBufferFormat {
            Points,
            Lines,
            LineStrip,
            Triangles,
            TriangleStrip,
            TriangleFan,
        }

        /// Re-export of rust-allocated (stack based) `GlType` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzGlType {
            Gl,
            Gles,
        }

        /// C-ABI stable reexport of `&[u8]`
        #[repr(C)]
        pub struct AzU8VecRef {
            pub(crate) ptr: *const u8,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&mut [u8]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzU8VecRefMut {
            pub(crate) ptr: *mut u8,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&[f32]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzF32VecRef {
            pub(crate) ptr: *const f32,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&[i32]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzI32VecRef {
            pub(crate) ptr: *const i32,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGLuintVecRef {
            pub(crate) ptr: *const u32,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGLenumVecRef {
            pub(crate) ptr: *const u32,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGLintVecRefMut {
            pub(crate) ptr: *mut i32,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGLint64VecRefMut {
            pub(crate) ptr: *mut i64,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGLbooleanVecRefMut {
            pub(crate) ptr: *mut u8,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGLfloatVecRefMut {
            pub(crate) ptr: *mut f32,
            pub len: usize,
        }

        /// C-ABI stable reexport of `&str`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzRefstr {
            pub(crate) ptr: *const u8,
            pub len: usize,
        }

        /// C-ABI stable reexport of `*const gleam::gl::GLsync`
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzGLsyncPtr {
            pub(crate) ptr: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `TextureFlags` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzTextureFlags {
            pub is_opaque: bool,
            pub is_video_texture: bool,
        }

        /// Re-export of rust-allocated (stack based) `ImageRef` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzImageRef {
            pub data: *const c_void,
            pub copies: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `RawImageFormat` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzRawImageFormat {
            R8,
            RG8,
            RGB8,
            RGBA8,
            R16,
            RG16,
            RGB16,
            RGBA16,
            BGR8,
            BGRA8,
        }

        /// Re-export of rust-allocated (stack based) `EncodeImageError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzEncodeImageError {
            EncoderNotAvailable,
            InsufficientMemory,
            DimensionError,
            InvalidData,
            Unknown,
        }

        /// Re-export of rust-allocated (stack based) `DecodeImageError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzDecodeImageError {
            InsufficientMemory,
            DimensionError,
            UnsupportedImageFormat,
            Unknown,
        }

        /// `AzParsedFontDestructorFnType` struct
        pub type AzParsedFontDestructorFnType = extern "C" fn(&mut c_void);

        /// Atomically reference-counted parsed font data
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzFontRef {
            pub data: *const c_void,
            pub copies: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `Svg` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzSvg {
            pub(crate) ptr: *mut c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `SvgXmlNode` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzSvgXmlNode {
            pub(crate) ptr: *mut c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `SvgCircle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSvgCircle {
            pub center_x: f32,
            pub center_y: f32,
            pub radius: f32,
        }

        /// Re-export of rust-allocated (stack based) `SvgPoint` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgPoint {
            pub x: f32,
            pub y: f32,
        }

        /// Re-export of rust-allocated (stack based) `SvgVector` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgVector {
            pub x: f64,
            pub y: f64,
        }

        /// Re-export of rust-allocated (stack based) `SvgRect` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgRect {
            pub width: f32,
            pub height: f32,
            pub x: f32,
            pub y: f32,
            pub radius_top_left: f32,
            pub radius_top_right: f32,
            pub radius_bottom_left: f32,
            pub radius_bottom_right: f32,
        }

        /// Re-export of rust-allocated (stack based) `SvgColoredVertex` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgColoredVertex {
            pub x: f32,
            pub y: f32,
            pub z: f32,
            pub r: f32,
            pub g: f32,
            pub b: f32,
            pub a: f32,
        }

        /// Re-export of rust-allocated (stack based) `SvgVertex` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgVertex {
            pub x: f32,
            pub y: f32,
        }

        /// Re-export of rust-allocated (stack based) `ShapeRendering` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzShapeRendering {
            OptimizeSpeed,
            CrispEdges,
            GeometricPrecision,
        }

        /// Re-export of rust-allocated (stack based) `TextRendering` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzTextRendering {
            OptimizeSpeed,
            OptimizeLegibility,
            GeometricPrecision,
        }

        /// Re-export of rust-allocated (stack based) `ImageRendering` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzImageRendering {
            OptimizeQuality,
            OptimizeSpeed,
        }

        /// Re-export of rust-allocated (stack based) `FontDatabase` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzFontDatabase {
            Empty,
            System,
        }

        /// Re-export of rust-allocated (stack based) `SvgRenderTransform` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSvgRenderTransform {
            pub sx: f32,
            pub kx: f32,
            pub ky: f32,
            pub sy: f32,
            pub tx: f32,
            pub ty: f32,
        }

        /// Re-export of rust-allocated (stack based) `Indent` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzIndent {
            None,
            Spaces(u8),
            Tabs,
        }

        /// Re-export of rust-allocated (stack based) `SvgFitTo` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzSvgFitTo {
            Original,
            Width(u32),
            Height(u32),
            Zoom(f32),
        }

        /// Re-export of rust-allocated (stack based) `SvgFillRule` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzSvgFillRule {
            Winding,
            EvenOdd,
        }

        /// Re-export of rust-allocated (stack based) `SvgTransform` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSvgTransform {
            pub sx: f32,
            pub kx: f32,
            pub ky: f32,
            pub sy: f32,
            pub tx: f32,
            pub ty: f32,
        }

        /// Re-export of rust-allocated (stack based) `SvgLineJoin` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzSvgLineJoin {
            Miter,
            MiterClip,
            Round,
            Bevel,
        }

        /// Re-export of rust-allocated (stack based) `SvgLineCap` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzSvgLineCap {
            Butt,
            Square,
            Round,
        }

        /// Re-export of rust-allocated (stack based) `SvgDashPattern` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSvgDashPattern {
            pub offset: f32,
            pub length_1: f32,
            pub gap_1: f32,
            pub length_2: f32,
            pub gap_2: f32,
            pub length_3: f32,
            pub gap_3: f32,
        }

        /// Re-export of rust-allocated (stack based) `MsgBox` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzMsgBox {
            pub _reserved: usize,
        }

        /// Type of message box icon
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzMsgBoxIcon {
            Info,
            Warning,
            Error,
            Question,
        }

        /// Value returned from a yes / no message box
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzMsgBoxYesNo {
            Yes,
            No,
        }

        /// Value returned from an ok / cancel message box
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzMsgBoxOkCancel {
            Ok,
            Cancel,
        }

        /// File picker dialog
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFileDialog {
            pub _reserved: usize,
        }

        /// Re-export of rust-allocated (stack based) `ColorPickerDialog` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzColorPickerDialog {
            pub _reserved: usize,
        }

        /// Connection to the system clipboard, on some systems this connection can be cached
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzSystemClipboard {
            pub _native: *const c_void,
            pub run_destructor: bool,
        }

        /// `AzInstantPtrCloneFnType` struct
        pub type AzInstantPtrCloneFnType = extern "C" fn(&AzInstantPtr) -> AzInstantPtr;

        /// Re-export of rust-allocated (stack based) `InstantPtrCloneFn` struct
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzInstantPtrCloneFn {
            pub cb: AzInstantPtrCloneFnType,
        }

        /// `AzInstantPtrDestructorFnType` struct
        pub type AzInstantPtrDestructorFnType = extern "C" fn(&mut AzInstantPtr);

        /// Re-export of rust-allocated (stack based) `InstantPtrDestructorFn` struct
        #[repr(C)]
        #[derive(Clone, Copy)]
        pub struct AzInstantPtrDestructorFn {
            pub cb: AzInstantPtrDestructorFnType,
        }

        /// Re-export of rust-allocated (stack based) `SystemTick` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSystemTick {
            pub tick_counter: u64,
        }

        /// Re-export of rust-allocated (stack based) `SystemTimeDiff` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSystemTimeDiff {
            pub secs: u64,
            pub nanos: u32,
        }

        /// Re-export of rust-allocated (stack based) `SystemTickDiff` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSystemTickDiff {
            pub tick_diff: u64,
        }

        /// Re-export of rust-allocated (stack based) `TimerId` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzTimerId {
            pub id: usize,
        }

        /// Should a timer terminate or not - used to remove active timers
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzTerminateTimer {
            Terminate,
            Continue,
        }

        /// Re-export of rust-allocated (stack based) `ThreadId` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzThreadId {
            pub id: usize,
        }

        /// Re-export of rust-allocated (stack based) `Thread` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzThread {
            pub(crate) ptr: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `ThreadSender` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzThreadSender {
            pub(crate) ptr: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `ThreadReceiver` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzThreadReceiver {
            pub(crate) ptr: *const c_void,
            pub run_destructor: bool,
        }

        /// `AzCreateThreadFnType` struct
        pub type AzCreateThreadFnType =
            extern "C" fn(AzRefAny, AzRefAny, AzThreadCallback) -> AzThread;

        /// Re-export of rust-allocated (stack based) `CreateThreadFn` struct
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzCreateThreadFn {
            pub cb: AzCreateThreadFnType,
        }

        /// `AzGetSystemTimeFnType` struct
        pub type AzGetSystemTimeFnType = extern "C" fn() -> AzInstant;

        /// Get the current system time, equivalent to `std::time::Instant::now()`, except it also
        /// works on systems that work with "ticks" instead of timers
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzGetSystemTimeFn {
            pub cb: AzGetSystemTimeFnType,
        }

        /// `AzCheckThreadFinishedFnType` struct
        pub type AzCheckThreadFinishedFnType = extern "C" fn(&c_void) -> bool;

        /// Function called to check if the thread has finished
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzCheckThreadFinishedFn {
            pub cb: AzCheckThreadFinishedFnType,
        }

        /// `AzLibrarySendThreadMsgFnType` struct
        pub type AzLibrarySendThreadMsgFnType = extern "C" fn(&c_void, AzThreadSendMsg) -> bool;

        /// Function to send a message to the thread
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzLibrarySendThreadMsgFn {
            pub cb: AzLibrarySendThreadMsgFnType,
        }

        /// `AzLibraryReceiveThreadMsgFnType` struct
        pub type AzLibraryReceiveThreadMsgFnType =
            extern "C" fn(&c_void) -> AzOptionThreadReceiveMsg;

        /// Function to receive a message from the thread
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzLibraryReceiveThreadMsgFn {
            pub cb: AzLibraryReceiveThreadMsgFnType,
        }

        /// `AzThreadRecvFnType` struct
        pub type AzThreadRecvFnType = extern "C" fn(&c_void) -> AzOptionThreadSendMsg;

        /// Function that the running `Thread` can call to receive messages from the main UI thread
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzThreadRecvFn {
            pub cb: AzThreadRecvFnType,
        }

        /// `AzThreadSendFnType` struct
        pub type AzThreadSendFnType = extern "C" fn(&c_void, AzThreadReceiveMsg) -> bool;

        /// Function that the running `Thread` can call to receive messages from the main UI thread
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzThreadSendFn {
            pub cb: AzThreadSendFnType,
        }

        /// `AzThreadDestructorFnType` struct
        pub type AzThreadDestructorFnType = extern "C" fn(&mut AzThread);

        /// Destructor of the `Thread`
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzThreadDestructorFn {
            pub cb: AzThreadDestructorFnType,
        }

        /// `AzThreadReceiverDestructorFnType` struct
        pub type AzThreadReceiverDestructorFnType = extern "C" fn(&mut AzThreadReceiver);

        /// Destructor of the `ThreadReceiver`
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzThreadReceiverDestructorFn {
            pub cb: AzThreadReceiverDestructorFnType,
        }

        /// `AzThreadSenderDestructorFnType` struct
        pub type AzThreadSenderDestructorFnType = extern "C" fn(&mut AzThreadSender);

        /// Destructor of the `ThreadSender`
        #[repr(C)]
        #[derive(Clone)]
        pub struct AzThreadSenderDestructorFn {
            pub cb: AzThreadSenderDestructorFnType,
        }

        /// Re-export of rust-allocated (stack based) `StyleFontFamilyVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyleFontFamilyVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyleFontFamilyVecDestructorType),
        }

        /// `AzStyleFontFamilyVecDestructorType` struct
        pub type AzStyleFontFamilyVecDestructorType = extern "C" fn(&mut AzStyleFontFamilyVec);

        /// Re-export of rust-allocated (stack based) `ListViewRowVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzListViewRowVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzListViewRowVecDestructorType),
        }

        /// `AzListViewRowVecDestructorType` struct
        pub type AzListViewRowVecDestructorType = extern "C" fn(&mut AzListViewRowVec);

        /// Re-export of rust-allocated (stack based) `StyleFilterVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyleFilterVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyleFilterVecDestructorType),
        }

        /// `AzStyleFilterVecDestructorType` struct
        pub type AzStyleFilterVecDestructorType = extern "C" fn(&mut AzStyleFilterVec);

        /// Re-export of rust-allocated (stack based) `LogicalRectVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzLogicalRectVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzLogicalRectVecDestructorType),
        }

        /// `AzLogicalRectVecDestructorType` struct
        pub type AzLogicalRectVecDestructorType = extern "C" fn(&mut AzLogicalRectVec);

        /// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMapVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNodeTypeIdInfoMapVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNodeTypeIdInfoMapVecDestructorType),
        }

        /// `AzNodeTypeIdInfoMapVecDestructorType` struct
        pub type AzNodeTypeIdInfoMapVecDestructorType = extern "C" fn(&mut AzNodeTypeIdInfoMapVec);

        /// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMapVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInputOutputTypeIdInfoMapVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInputOutputTypeIdInfoMapVecDestructorType),
        }

        /// `AzInputOutputTypeIdInfoMapVecDestructorType` struct
        pub type AzInputOutputTypeIdInfoMapVecDestructorType =
            extern "C" fn(&mut AzInputOutputTypeIdInfoMapVec);

        /// Re-export of rust-allocated (stack based) `NodeIdNodeMapVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNodeIdNodeMapVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNodeIdNodeMapVecDestructorType),
        }

        /// `AzNodeIdNodeMapVecDestructorType` struct
        pub type AzNodeIdNodeMapVecDestructorType = extern "C" fn(&mut AzNodeIdNodeMapVec);

        /// Re-export of rust-allocated (stack based) `InputOutputTypeIdVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInputOutputTypeIdVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInputOutputTypeIdVecDestructorType),
        }

        /// `AzInputOutputTypeIdVecDestructorType` struct
        pub type AzInputOutputTypeIdVecDestructorType = extern "C" fn(&mut AzInputOutputTypeIdVec);

        /// Re-export of rust-allocated (stack based) `NodeTypeFieldVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNodeTypeFieldVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNodeTypeFieldVecDestructorType),
        }

        /// `AzNodeTypeFieldVecDestructorType` struct
        pub type AzNodeTypeFieldVecDestructorType = extern "C" fn(&mut AzNodeTypeFieldVec);

        /// Re-export of rust-allocated (stack based) `InputConnectionVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInputConnectionVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInputConnectionVecDestructorType),
        }

        /// `AzInputConnectionVecDestructorType` struct
        pub type AzInputConnectionVecDestructorType = extern "C" fn(&mut AzInputConnectionVec);

        /// Re-export of rust-allocated (stack based) `OutputNodeAndIndexVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzOutputNodeAndIndexVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzOutputNodeAndIndexVecDestructorType),
        }

        /// `AzOutputNodeAndIndexVecDestructorType` struct
        pub type AzOutputNodeAndIndexVecDestructorType =
            extern "C" fn(&mut AzOutputNodeAndIndexVec);

        /// Re-export of rust-allocated (stack based) `OutputConnectionVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzOutputConnectionVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzOutputConnectionVecDestructorType),
        }

        /// `AzOutputConnectionVecDestructorType` struct
        pub type AzOutputConnectionVecDestructorType = extern "C" fn(&mut AzOutputConnectionVec);

        /// Re-export of rust-allocated (stack based) `InputNodeAndIndexVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInputNodeAndIndexVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInputNodeAndIndexVecDestructorType),
        }

        /// `AzInputNodeAndIndexVecDestructorType` struct
        pub type AzInputNodeAndIndexVecDestructorType = extern "C" fn(&mut AzInputNodeAndIndexVec);

        /// Re-export of rust-allocated (stack based) `AccessibilityStateVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzAccessibilityStateVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzAccessibilityStateVecDestructorType),
        }

        /// `AzAccessibilityStateVecDestructorType` struct
        pub type AzAccessibilityStateVecDestructorType =
            extern "C" fn(&mut AzAccessibilityStateVec);

        /// Re-export of rust-allocated (stack based) `MenuItemVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzMenuItemVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzMenuItemVecDestructorType),
        }

        /// `AzMenuItemVecDestructorType` struct
        pub type AzMenuItemVecDestructorType = extern "C" fn(&mut AzMenuItemVec);

        /// Re-export of rust-allocated (stack based) `TessellatedSvgNodeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzTessellatedSvgNodeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzTessellatedSvgNodeVecDestructorType),
        }

        /// `AzTessellatedSvgNodeVecDestructorType` struct
        pub type AzTessellatedSvgNodeVecDestructorType =
            extern "C" fn(&mut AzTessellatedSvgNodeVec);

        /// Re-export of rust-allocated (stack based) `TessellatedColoredSvgNodeVecDestructor`
        /// struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzTessellatedColoredSvgNodeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzTessellatedColoredSvgNodeVecDestructorType),
        }

        /// `AzTessellatedColoredSvgNodeVecDestructorType` struct
        pub type AzTessellatedColoredSvgNodeVecDestructorType =
            extern "C" fn(&mut AzTessellatedColoredSvgNodeVec);

        /// Re-export of rust-allocated (stack based) `XmlNodeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzXmlNodeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzXmlNodeVecDestructorType),
        }

        /// `AzXmlNodeVecDestructorType` struct
        pub type AzXmlNodeVecDestructorType = extern "C" fn(&mut AzXmlNodeVec);

        /// Re-export of rust-allocated (stack based) `FmtArgVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzFmtArgVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzFmtArgVecDestructorType),
        }

        /// `AzFmtArgVecDestructorType` struct
        pub type AzFmtArgVecDestructorType = extern "C" fn(&mut AzFmtArgVec);

        /// Re-export of rust-allocated (stack based) `InlineLineVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInlineLineVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInlineLineVecDestructorType),
        }

        /// `AzInlineLineVecDestructorType` struct
        pub type AzInlineLineVecDestructorType = extern "C" fn(&mut AzInlineLineVec);

        /// Re-export of rust-allocated (stack based) `InlineWordVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInlineWordVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInlineWordVecDestructorType),
        }

        /// `AzInlineWordVecDestructorType` struct
        pub type AzInlineWordVecDestructorType = extern "C" fn(&mut AzInlineWordVec);

        /// Re-export of rust-allocated (stack based) `InlineGlyphVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInlineGlyphVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInlineGlyphVecDestructorType),
        }

        /// `AzInlineGlyphVecDestructorType` struct
        pub type AzInlineGlyphVecDestructorType = extern "C" fn(&mut AzInlineGlyphVec);

        /// Re-export of rust-allocated (stack based) `InlineTextHitVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzInlineTextHitVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzInlineTextHitVecDestructorType),
        }

        /// `AzInlineTextHitVecDestructorType` struct
        pub type AzInlineTextHitVecDestructorType = extern "C" fn(&mut AzInlineTextHitVec);

        /// Re-export of rust-allocated (stack based) `MonitorVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzMonitorVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzMonitorVecDestructorType),
        }

        /// `AzMonitorVecDestructorType` struct
        pub type AzMonitorVecDestructorType = extern "C" fn(&mut AzMonitorVec);

        /// Re-export of rust-allocated (stack based) `VideoModeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzVideoModeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzVideoModeVecDestructorType),
        }

        /// `AzVideoModeVecDestructorType` struct
        pub type AzVideoModeVecDestructorType = extern "C" fn(&mut AzVideoModeVec);

        /// Re-export of rust-allocated (stack based) `DomVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzDomVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzDomVecDestructorType),
        }

        /// `AzDomVecDestructorType` struct
        pub type AzDomVecDestructorType = extern "C" fn(&mut AzDomVec);

        /// Re-export of rust-allocated (stack based) `IdOrClassVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzIdOrClassVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzIdOrClassVecDestructorType),
        }

        /// `AzIdOrClassVecDestructorType` struct
        pub type AzIdOrClassVecDestructorType = extern "C" fn(&mut AzIdOrClassVec);

        /// Re-export of rust-allocated (stack based) `NodeDataInlineCssPropertyVecDestructor`
        /// struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNodeDataInlineCssPropertyVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNodeDataInlineCssPropertyVecDestructorType),
        }

        /// `AzNodeDataInlineCssPropertyVecDestructorType` struct
        pub type AzNodeDataInlineCssPropertyVecDestructorType =
            extern "C" fn(&mut AzNodeDataInlineCssPropertyVec);

        /// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyleBackgroundContentVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyleBackgroundContentVecDestructorType),
        }

        /// `AzStyleBackgroundContentVecDestructorType` struct
        pub type AzStyleBackgroundContentVecDestructorType =
            extern "C" fn(&mut AzStyleBackgroundContentVec);

        /// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyleBackgroundPositionVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyleBackgroundPositionVecDestructorType),
        }

        /// `AzStyleBackgroundPositionVecDestructorType` struct
        pub type AzStyleBackgroundPositionVecDestructorType =
            extern "C" fn(&mut AzStyleBackgroundPositionVec);

        /// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyleBackgroundRepeatVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyleBackgroundRepeatVecDestructorType),
        }

        /// `AzStyleBackgroundRepeatVecDestructorType` struct
        pub type AzStyleBackgroundRepeatVecDestructorType =
            extern "C" fn(&mut AzStyleBackgroundRepeatVec);

        /// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyleBackgroundSizeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyleBackgroundSizeVecDestructorType),
        }

        /// `AzStyleBackgroundSizeVecDestructorType` struct
        pub type AzStyleBackgroundSizeVecDestructorType =
            extern "C" fn(&mut AzStyleBackgroundSizeVec);

        /// Re-export of rust-allocated (stack based) `StyleTransformVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyleTransformVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyleTransformVecDestructorType),
        }

        /// `AzStyleTransformVecDestructorType` struct
        pub type AzStyleTransformVecDestructorType = extern "C" fn(&mut AzStyleTransformVec);

        /// Re-export of rust-allocated (stack based) `CssPropertyVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzCssPropertyVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzCssPropertyVecDestructorType),
        }

        /// `AzCssPropertyVecDestructorType` struct
        pub type AzCssPropertyVecDestructorType = extern "C" fn(&mut AzCssPropertyVec);

        /// Re-export of rust-allocated (stack based) `SvgMultiPolygonVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzSvgMultiPolygonVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzSvgMultiPolygonVecDestructorType),
        }

        /// `AzSvgMultiPolygonVecDestructorType` struct
        pub type AzSvgMultiPolygonVecDestructorType = extern "C" fn(&mut AzSvgMultiPolygonVec);

        /// Re-export of rust-allocated (stack based) `SvgSimpleNodeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzSvgSimpleNodeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzSvgSimpleNodeVecDestructorType),
        }

        /// `AzSvgSimpleNodeVecDestructorType` struct
        pub type AzSvgSimpleNodeVecDestructorType = extern "C" fn(&mut AzSvgSimpleNodeVec);

        /// Re-export of rust-allocated (stack based) `SvgPathVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzSvgPathVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzSvgPathVecDestructorType),
        }

        /// `AzSvgPathVecDestructorType` struct
        pub type AzSvgPathVecDestructorType = extern "C" fn(&mut AzSvgPathVec);

        /// Re-export of rust-allocated (stack based) `VertexAttributeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzVertexAttributeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzVertexAttributeVecDestructorType),
        }

        /// `AzVertexAttributeVecDestructorType` struct
        pub type AzVertexAttributeVecDestructorType = extern "C" fn(&mut AzVertexAttributeVec);

        /// Re-export of rust-allocated (stack based) `SvgPathElementVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzSvgPathElementVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzSvgPathElementVecDestructorType),
        }

        /// `AzSvgPathElementVecDestructorType` struct
        pub type AzSvgPathElementVecDestructorType = extern "C" fn(&mut AzSvgPathElementVec);

        /// Re-export of rust-allocated (stack based) `SvgVertexVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzSvgVertexVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzSvgVertexVecDestructorType),
        }

        /// `AzSvgVertexVecDestructorType` struct
        pub type AzSvgVertexVecDestructorType = extern "C" fn(&mut AzSvgVertexVec);

        /// Re-export of rust-allocated (stack based) `SvgColoredVertexVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzSvgColoredVertexVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzSvgColoredVertexVecDestructorType),
        }

        /// `AzSvgColoredVertexVecDestructorType` struct
        pub type AzSvgColoredVertexVecDestructorType = extern "C" fn(&mut AzSvgColoredVertexVec);

        /// Re-export of rust-allocated (stack based) `U32VecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzU32VecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzU32VecDestructorType),
        }

        /// `AzU32VecDestructorType` struct
        pub type AzU32VecDestructorType = extern "C" fn(&mut AzU32Vec);

        /// Re-export of rust-allocated (stack based) `XWindowTypeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzXWindowTypeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzXWindowTypeVecDestructorType),
        }

        /// `AzXWindowTypeVecDestructorType` struct
        pub type AzXWindowTypeVecDestructorType = extern "C" fn(&mut AzXWindowTypeVec);

        /// Re-export of rust-allocated (stack based) `VirtualKeyCodeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzVirtualKeyCodeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzVirtualKeyCodeVecDestructorType),
        }

        /// `AzVirtualKeyCodeVecDestructorType` struct
        pub type AzVirtualKeyCodeVecDestructorType = extern "C" fn(&mut AzVirtualKeyCodeVec);

        /// Re-export of rust-allocated (stack based) `CascadeInfoVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzCascadeInfoVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzCascadeInfoVecDestructorType),
        }

        /// `AzCascadeInfoVecDestructorType` struct
        pub type AzCascadeInfoVecDestructorType = extern "C" fn(&mut AzCascadeInfoVec);

        /// Re-export of rust-allocated (stack based) `ScanCodeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzScanCodeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzScanCodeVecDestructorType),
        }

        /// `AzScanCodeVecDestructorType` struct
        pub type AzScanCodeVecDestructorType = extern "C" fn(&mut AzScanCodeVec);

        /// Re-export of rust-allocated (stack based) `CssDeclarationVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzCssDeclarationVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzCssDeclarationVecDestructorType),
        }

        /// `AzCssDeclarationVecDestructorType` struct
        pub type AzCssDeclarationVecDestructorType = extern "C" fn(&mut AzCssDeclarationVec);

        /// Re-export of rust-allocated (stack based) `CssPathSelectorVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzCssPathSelectorVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzCssPathSelectorVecDestructorType),
        }

        /// `AzCssPathSelectorVecDestructorType` struct
        pub type AzCssPathSelectorVecDestructorType = extern "C" fn(&mut AzCssPathSelectorVec);

        /// Re-export of rust-allocated (stack based) `StylesheetVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStylesheetVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStylesheetVecDestructorType),
        }

        /// `AzStylesheetVecDestructorType` struct
        pub type AzStylesheetVecDestructorType = extern "C" fn(&mut AzStylesheetVec);

        /// Re-export of rust-allocated (stack based) `CssRuleBlockVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzCssRuleBlockVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzCssRuleBlockVecDestructorType),
        }

        /// `AzCssRuleBlockVecDestructorType` struct
        pub type AzCssRuleBlockVecDestructorType = extern "C" fn(&mut AzCssRuleBlockVec);

        /// Re-export of rust-allocated (stack based) `F32VecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzF32VecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzF32VecDestructorType),
        }

        /// `AzF32VecDestructorType` struct
        pub type AzF32VecDestructorType = extern "C" fn(&mut AzF32Vec);

        /// Re-export of rust-allocated (stack based) `U16VecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzU16VecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzU16VecDestructorType),
        }

        /// `AzU16VecDestructorType` struct
        pub type AzU16VecDestructorType = extern "C" fn(&mut AzU16Vec);

        /// Re-export of rust-allocated (stack based) `U8VecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzU8VecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzU8VecDestructorType),
        }

        /// `AzU8VecDestructorType` struct
        pub type AzU8VecDestructorType = extern "C" fn(&mut AzU8Vec);

        /// Re-export of rust-allocated (stack based) `CallbackDataVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzCallbackDataVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzCallbackDataVecDestructorType),
        }

        /// `AzCallbackDataVecDestructorType` struct
        pub type AzCallbackDataVecDestructorType = extern "C" fn(&mut AzCallbackDataVec);

        /// Re-export of rust-allocated (stack based) `DebugMessageVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzDebugMessageVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzDebugMessageVecDestructorType),
        }

        /// `AzDebugMessageVecDestructorType` struct
        pub type AzDebugMessageVecDestructorType = extern "C" fn(&mut AzDebugMessageVec);

        /// Re-export of rust-allocated (stack based) `GLuintVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzGLuintVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzGLuintVecDestructorType),
        }

        /// `AzGLuintVecDestructorType` struct
        pub type AzGLuintVecDestructorType = extern "C" fn(&mut AzGLuintVec);

        /// Re-export of rust-allocated (stack based) `GLintVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzGLintVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzGLintVecDestructorType),
        }

        /// `AzGLintVecDestructorType` struct
        pub type AzGLintVecDestructorType = extern "C" fn(&mut AzGLintVec);

        /// Re-export of rust-allocated (stack based) `StringVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStringVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStringVecDestructorType),
        }

        /// `AzStringVecDestructorType` struct
        pub type AzStringVecDestructorType = extern "C" fn(&mut AzStringVec);

        /// Re-export of rust-allocated (stack based) `StringPairVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStringPairVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStringPairVecDestructorType),
        }

        /// `AzStringPairVecDestructorType` struct
        pub type AzStringPairVecDestructorType = extern "C" fn(&mut AzStringPairVec);

        /// Re-export of rust-allocated (stack based) `NormalizedLinearColorStopVecDestructor`
        /// struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNormalizedLinearColorStopVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNormalizedLinearColorStopVecDestructorType),
        }

        /// `AzNormalizedLinearColorStopVecDestructorType` struct
        pub type AzNormalizedLinearColorStopVecDestructorType =
            extern "C" fn(&mut AzNormalizedLinearColorStopVec);

        /// Re-export of rust-allocated (stack based) `NormalizedRadialColorStopVecDestructor`
        /// struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNormalizedRadialColorStopVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNormalizedRadialColorStopVecDestructorType),
        }

        /// `AzNormalizedRadialColorStopVecDestructorType` struct
        pub type AzNormalizedRadialColorStopVecDestructorType =
            extern "C" fn(&mut AzNormalizedRadialColorStopVec);

        /// Re-export of rust-allocated (stack based) `NodeIdVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNodeIdVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNodeIdVecDestructorType),
        }

        /// `AzNodeIdVecDestructorType` struct
        pub type AzNodeIdVecDestructorType = extern "C" fn(&mut AzNodeIdVec);

        /// Re-export of rust-allocated (stack based) `NodeHierarchyItemVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNodeHierarchyItemVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNodeHierarchyItemVecDestructorType),
        }

        /// `AzNodeHierarchyItemVecDestructorType` struct
        pub type AzNodeHierarchyItemVecDestructorType = extern "C" fn(&mut AzNodeHierarchyItemVec);

        /// Re-export of rust-allocated (stack based) `StyledNodeVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzStyledNodeVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzStyledNodeVecDestructorType),
        }

        /// `AzStyledNodeVecDestructorType` struct
        pub type AzStyledNodeVecDestructorType = extern "C" fn(&mut AzStyledNodeVec);

        /// Re-export of rust-allocated (stack based) `TagIdToNodeIdMappingVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzTagIdToNodeIdMappingVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzTagIdToNodeIdMappingVecDestructorType),
        }

        /// `AzTagIdToNodeIdMappingVecDestructorType` struct
        pub type AzTagIdToNodeIdMappingVecDestructorType =
            extern "C" fn(&mut AzTagIdToNodeIdMappingVec);

        /// Re-export of rust-allocated (stack based) `ParentWithNodeDepthVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzParentWithNodeDepthVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzParentWithNodeDepthVecDestructorType),
        }

        /// `AzParentWithNodeDepthVecDestructorType` struct
        pub type AzParentWithNodeDepthVecDestructorType =
            extern "C" fn(&mut AzParentWithNodeDepthVec);

        /// Re-export of rust-allocated (stack based) `NodeDataVecDestructor` struct
        #[repr(C, u8)]
        #[derive(Clone, Copy)]
        pub enum AzNodeDataVecDestructor {
            DefaultRust,
            NoDestructor,
            External(AzNodeDataVecDestructorType),
        }

        /// `AzNodeDataVecDestructorType` struct
        pub type AzNodeDataVecDestructorType = extern "C" fn(&mut AzNodeDataVec);

        /// Re-export of rust-allocated (stack based) `OptionI16` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionI16 {
            None,
            Some(i16),
        }

        /// Re-export of rust-allocated (stack based) `OptionU16` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionU16 {
            None,
            Some(u16),
        }

        /// Re-export of rust-allocated (stack based) `OptionU32` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionU32 {
            None,
            Some(u32),
        }

        /// Re-export of rust-allocated (stack based) `OptionHwndHandle` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionHwndHandle {
            None,
            Some(*mut c_void),
        }

        /// Re-export of rust-allocated (stack based) `OptionX11Visual` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionX11Visual {
            None,
            Some(*const c_void),
        }

        /// Re-export of rust-allocated (stack based) `OptionI32` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionI32 {
            None,
            Some(i32),
        }

        /// Re-export of rust-allocated (stack based) `OptionF32` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionF32 {
            None,
            Some(f32),
        }

        /// Option<char> but the char is a u32, for C FFI stability reasons
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionChar {
            None,
            Some(u32),
        }

        /// Re-export of rust-allocated (stack based) `OptionUsize` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionUsize {
            None,
            Some(usize),
        }

        /// Re-export of rust-allocated (stack based) `SvgParseErrorPosition` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSvgParseErrorPosition {
            pub row: u32,
            pub col: u32,
        }

        /// External system callbacks to get the system time or create / manage threads
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzSystemCallbacks {
            pub create_thread_fn: AzCreateThreadFn,
            pub get_system_time_fn: AzGetSystemTimeFn,
        }

        /// Force a specific renderer: note that azul will **crash** on startup if the
        /// `RendererOptions` are not satisfied.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzRendererOptions {
            pub vsync: AzVsync,
            pub srgb: AzSrgb,
            pub hw_accel: AzHwAcceleration,
        }

        /// Represents a rectangle in physical pixels (integer units)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzLayoutRect {
            pub origin: AzLayoutPoint,
            pub size: AzLayoutSize,
        }

        /// Raw platform handle, for integration in / with other toolkits and custom non-azul window
        /// extensions
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzRawWindowHandle {
            IOS(AzIOSHandle),
            MacOS(AzMacOSHandle),
            Xlib(AzXlibHandle),
            Xcb(AzXcbHandle),
            Wayland(AzWaylandHandle),
            Windows(AzWindowsHandle),
            Web(AzWebHandle),
            Android(AzAndroidHandle),
            Unsupported,
        }

        /// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd
        /// want for hit-testing and positioning elements.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzLogicalRect {
            pub origin: AzLogicalPosition,
            pub size: AzLogicalSize,
        }

        /// Symbolic accelerator key (ctrl, alt, shift)
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzAcceleratorKey {
            Ctrl,
            Alt,
            Shift,
            Key(AzVirtualKeyCode),
        }

        /// Boolean flags relating to the current window state
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzWindowFlags {
            pub frame: AzWindowFrame,
            pub is_about_to_close: bool,
            pub has_decorations: bool,
            pub is_visible: bool,
            pub is_always_on_top: bool,
            pub is_resizable: bool,
            pub has_focus: bool,
            pub has_extended_window_frame: bool,
            pub has_blur_behind_window: bool,
            pub smooth_scroll_enabled: bool,
            pub autotab_enabled: bool,
        }

        /// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on
        /// startup (gets initialized on the first frame).
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzCursorPosition {
            OutOfWindow(AzLogicalPosition),
            Uninitialized,
            InWindow(AzLogicalPosition),
        }

        /// Position of the top left corner of the window relative to the top left of the monitor
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzWindowPosition {
            Uninitialized,
            Initialized(AzPhysicalPositionI32),
        }

        /// Position of the virtual keyboard necessary to insert CJK characters
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzImePosition {
            Uninitialized,
            Initialized(AzLogicalPosition),
        }

        /// Describes a rendering configuration for a monitor
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzVideoMode {
            pub size: AzLayoutSize,
            pub bit_depth: u16,
            pub refresh_rate: u16,
        }

        /// Combination of node ID + DOM ID, both together can identify a node
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzDomNodeId {
            pub dom: AzDomId,
            pub node: AzNodeId,
        }

        /// Re-export of rust-allocated (stack based) `PositionInfo` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzPositionInfo {
            Static(AzPositionInfoInner),
            Fixed(AzPositionInfoInner),
            Absolute(AzPositionInfoInner),
            Relative(AzPositionInfoInner),
        }

        /// Re-export of rust-allocated (stack based) `HidpiAdjustedBounds` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzHidpiAdjustedBounds {
            pub logical_size: AzLogicalSize,
            pub hidpi_factor: f32,
        }

        /// Re-export of rust-allocated (stack based) `InlineGlyph` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInlineGlyph {
            pub bounds: AzLogicalRect,
            pub unicode_codepoint: AzOptionChar,
            pub glyph_index: u32,
        }

        /// Re-export of rust-allocated (stack based) `InlineTextHit` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInlineTextHit {
            pub unicode_codepoint: AzOptionChar,
            pub hit_relative_to_inline_text: AzLogicalPosition,
            pub hit_relative_to_line: AzLogicalPosition,
            pub hit_relative_to_text_content: AzLogicalPosition,
            pub hit_relative_to_glyph: AzLogicalPosition,
            pub line_index_relative_to_text: usize,
            pub word_index_relative_to_text: usize,
            pub text_content_index_relative_to_text: usize,
            pub glyph_index_relative_to_text: usize,
            pub char_index_relative_to_text: usize,
            pub word_index_relative_to_line: usize,
            pub text_content_index_relative_to_line: usize,
            pub glyph_index_relative_to_line: usize,
            pub char_index_relative_to_line: usize,
            pub glyph_index_relative_to_word: usize,
            pub char_index_relative_to_word: usize,
        }

        /// Re-export of rust-allocated (stack based) `IFrameCallbackInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzIFrameCallbackInfo {
            pub system_fonts: *const c_void,
            pub image_cache: *const c_void,
            pub window_theme: AzWindowTheme,
            pub bounds: AzHidpiAdjustedBounds,
            pub scroll_size: AzLogicalSize,
            pub scroll_offset: AzLogicalPosition,
            pub virtual_scroll_size: AzLogicalSize,
            pub virtual_scroll_offset: AzLogicalPosition,
            pub _reserved_ref: *const c_void,
            pub _reserved_mut: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `TimerCallbackReturn` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTimerCallbackReturn {
            pub should_update: AzUpdate,
            pub should_terminate: AzTerminateTimer,
        }

        /// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct.
        /// `RefAny` can be up- and downcasted (this usually done via generics and can't be
        /// expressed in the Rust API)
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzRefAny {
            pub _internal_ptr: *const c_void,
            pub sharing_info: AzRefCount,
            pub instance_id: u64,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `IFrameNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzIFrameNode {
            pub callback: AzIFrameCallback,
            pub data: AzRefAny,
        }

        /// Re-export of rust-allocated (stack based) `NotEventFilter` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzNotEventFilter {
            Hover(AzHoverEventFilter),
            Focus(AzFocusEventFilter),
        }

        /// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is
        /// activated
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzMenuCallback {
            pub callback: AzCallback,
            pub data: AzRefAny,
        }

        /// Icon of a menu entry
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzMenuItemIcon {
            Checkbox(bool),
            Image(AzImageRef),
        }

        /// Re-export of rust-allocated (stack based) `CssNthChildSelector` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzCssNthChildSelector {
            Number(u32),
            Even,
            Odd,
            Pattern(AzCssNthChildPattern),
        }

        /// Re-export of rust-allocated (stack based) `PixelValue` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzPixelValue {
            pub metric: AzSizeMetric,
            pub number: AzFloatValue,
        }

        /// Re-export of rust-allocated (stack based) `PixelValueNoPercent` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzPixelValueNoPercent {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBoxShadow` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBoxShadow {
            pub offset: [AzPixelValueNoPercent; 2],
            pub color: AzColorU,
            pub blur_radius: AzPixelValueNoPercent,
            pub spread_radius: AzPixelValueNoPercent,
            pub clip_mode: AzBoxShadowClipMode,
        }

        /// Re-export of rust-allocated (stack based) `StyleBlur` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBlur {
            pub width: AzPixelValue,
            pub height: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleColorMatrix` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleColorMatrix {
            pub matrix: [AzFloatValue; 20],
        }

        /// Re-export of rust-allocated (stack based) `StyleFilterOffset` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleFilterOffset {
            pub x: AzPixelValue,
            pub y: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleCompositeFilter` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleCompositeFilter {
            Over,
            In,
            Atop,
            Out,
            Xor,
            Lighter,
            Arithmetic([AzFloatValue; 4]),
        }

        /// Re-export of rust-allocated (stack based) `LayoutBottom` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutBottom {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexGrow` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutFlexGrow {
            pub inner: AzFloatValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexShrink` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutFlexShrink {
            pub inner: AzFloatValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutHeight` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutHeight {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutLeft` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutLeft {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginBottom` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMarginBottom {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginLeft` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMarginLeft {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginRight` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMarginRight {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginTop` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMarginTop {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMaxHeight` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMaxHeight {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMaxWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMaxWidth {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMinHeight` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMinHeight {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutMinWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutMinWidth {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingBottom` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutPaddingBottom {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingLeft` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutPaddingLeft {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingRight` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutPaddingRight {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingTop` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutPaddingTop {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutRight` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutRight {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutTop` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutTop {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `LayoutWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutWidth {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `PercentageValue` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzPercentageValue {
            pub number: AzFloatValue,
        }

        /// Re-export of rust-allocated (stack based) `AngleValue` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzAngleValue {
            pub metric: AzAngleMetric,
            pub number: AzFloatValue,
        }

        /// Re-export of rust-allocated (stack based) `NormalizedLinearColorStop` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzNormalizedLinearColorStop {
            pub offset: AzPercentageValue,
            pub color: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `NormalizedRadialColorStop` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzNormalizedRadialColorStop {
            pub offset: AzAngleValue,
            pub color: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `DirectionCorners` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzDirectionCorners {
            pub from: AzDirectionCorner,
            pub to: AzDirectionCorner,
        }

        /// Re-export of rust-allocated (stack based) `Direction` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzDirection {
            Angle(AzAngleValue),
            FromTo(AzDirectionCorners),
        }

        /// Re-export of rust-allocated (stack based) `BackgroundPositionHorizontal` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzBackgroundPositionHorizontal {
            Left,
            Center,
            Right,
            Exact(AzPixelValue),
        }

        /// Re-export of rust-allocated (stack based) `BackgroundPositionVertical` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzBackgroundPositionVertical {
            Top,
            Center,
            Bottom,
            Exact(AzPixelValue),
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundPosition` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzStyleBackgroundPosition {
            pub horizontal: AzBackgroundPositionHorizontal,
            pub vertical: AzBackgroundPositionVertical,
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundSize` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzStyleBackgroundSize {
            ExactSize([AzPixelValue; 2]),
            Contain,
            Cover,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomColor` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzStyleBorderBottomColor {
            pub inner: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadius` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzStyleBorderBottomLeftRadius {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadius` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzStyleBorderBottomRightRadius {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderBottomStyle {
            pub inner: AzBorderStyle,
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutBorderBottomWidth {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderLeftColor` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderLeftColor {
            pub inner: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderLeftStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderLeftStyle {
            pub inner: AzBorderStyle,
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutBorderLeftWidth {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderRightColor` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderRightColor {
            pub inner: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderRightStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderRightStyle {
            pub inner: AzBorderStyle,
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderRightWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutBorderRightWidth {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopColor` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderTopColor {
            pub inner: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadius` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderTopLeftRadius {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadius` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderTopRightRadius {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleBorderTopStyle {
            pub inner: AzBorderStyle,
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderTopWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzLayoutBorderTopWidth {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleFontSize` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleFontSize {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleLetterSpacing` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleLetterSpacing {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleLineHeight` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleLineHeight {
            pub inner: AzPercentageValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTabWidth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTabWidth {
            pub inner: AzPercentageValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleOpacity` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleOpacity {
            pub inner: AzPercentageValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformOrigin` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformOrigin {
            pub x: AzPixelValue,
            pub y: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StylePerspectiveOrigin` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStylePerspectiveOrigin {
            pub x: AzPixelValue,
            pub y: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformMatrix2D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformMatrix2D {
            pub a: AzPixelValue,
            pub b: AzPixelValue,
            pub c: AzPixelValue,
            pub d: AzPixelValue,
            pub tx: AzPixelValue,
            pub ty: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformMatrix3D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformMatrix3D {
            pub m11: AzPixelValue,
            pub m12: AzPixelValue,
            pub m13: AzPixelValue,
            pub m14: AzPixelValue,
            pub m21: AzPixelValue,
            pub m22: AzPixelValue,
            pub m23: AzPixelValue,
            pub m24: AzPixelValue,
            pub m31: AzPixelValue,
            pub m32: AzPixelValue,
            pub m33: AzPixelValue,
            pub m34: AzPixelValue,
            pub m41: AzPixelValue,
            pub m42: AzPixelValue,
            pub m43: AzPixelValue,
            pub m44: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformTranslate2D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformTranslate2D {
            pub x: AzPixelValue,
            pub y: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformTranslate3D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformTranslate3D {
            pub x: AzPixelValue,
            pub y: AzPixelValue,
            pub z: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformRotate3D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformRotate3D {
            pub x: AzPercentageValue,
            pub y: AzPercentageValue,
            pub z: AzPercentageValue,
            pub angle: AzAngleValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformScale2D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformScale2D {
            pub x: AzPercentageValue,
            pub y: AzPercentageValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformScale3D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformScale3D {
            pub x: AzPercentageValue,
            pub y: AzPercentageValue,
            pub z: AzPercentageValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformSkew2D` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTransformSkew2D {
            pub x: AzPercentageValue,
            pub y: AzPercentageValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleTextColor` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleTextColor {
            pub inner: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `StyleWordSpacing` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzStyleWordSpacing {
            pub inner: AzPixelValue,
        }

        /// Re-export of rust-allocated (stack based) `StyleBoxShadowValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBoxShadowValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBoxShadow),
        }

        /// Re-export of rust-allocated (stack based) `LayoutAlignContentValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutAlignContentValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutAlignContent),
        }

        /// Re-export of rust-allocated (stack based) `LayoutAlignItemsValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutAlignItemsValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutAlignItems),
        }

        /// Re-export of rust-allocated (stack based) `LayoutBottomValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutBottomValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutBottom),
        }

        /// Re-export of rust-allocated (stack based) `LayoutBoxSizingValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutBoxSizingValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutBoxSizing),
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexDirectionValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFlexDirectionValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutFlexDirection),
        }

        /// Re-export of rust-allocated (stack based) `LayoutDisplayValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutDisplayValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutDisplay),
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexGrowValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFlexGrowValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutFlexGrow),
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexShrinkValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFlexShrinkValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutFlexShrink),
        }

        /// Re-export of rust-allocated (stack based) `LayoutFloatValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFloatValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutFloat),
        }

        /// Re-export of rust-allocated (stack based) `LayoutHeightValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutHeightValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutHeight),
        }

        /// Re-export of rust-allocated (stack based) `LayoutJustifyContentValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutJustifyContentValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutJustifyContent),
        }

        /// Re-export of rust-allocated (stack based) `LayoutLeftValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutLeftValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutLeft),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginBottomValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMarginBottomValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMarginBottom),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginLeftValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMarginLeftValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMarginLeft),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginRightValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMarginRightValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMarginRight),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMarginTopValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMarginTopValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMarginTop),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMaxHeightValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMaxHeightValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMaxHeight),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMaxWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMaxWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMaxWidth),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMinHeightValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMinHeightValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMinHeight),
        }

        /// Re-export of rust-allocated (stack based) `LayoutMinWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutMinWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutMinWidth),
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingBottomValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutPaddingBottomValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutPaddingBottom),
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingLeftValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutPaddingLeftValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutPaddingLeft),
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingRightValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutPaddingRightValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutPaddingRight),
        }

        /// Re-export of rust-allocated (stack based) `LayoutPaddingTopValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutPaddingTopValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutPaddingTop),
        }

        /// Re-export of rust-allocated (stack based) `LayoutPositionValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutPositionValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutPosition),
        }

        /// Re-export of rust-allocated (stack based) `LayoutRightValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutRightValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutRight),
        }

        /// Re-export of rust-allocated (stack based) `LayoutTopValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutTopValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutTop),
        }

        /// Re-export of rust-allocated (stack based) `LayoutWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutWidth),
        }

        /// Re-export of rust-allocated (stack based) `LayoutFlexWrapValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutFlexWrapValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutFlexWrap),
        }

        /// Re-export of rust-allocated (stack based) `LayoutOverflowValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutOverflowValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutOverflow),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomColorValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderBottomColorValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderBottomColor),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadiusValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderBottomLeftRadiusValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderBottomLeftRadius),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadiusValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderBottomRightRadiusValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderBottomRightRadius),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderBottomStyleValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderBottomStyleValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderBottomStyle),
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutBorderBottomWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutBorderBottomWidth),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderLeftColorValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderLeftColorValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderLeftColor),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderLeftStyleValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderLeftStyleValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderLeftStyle),
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutBorderLeftWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutBorderLeftWidth),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderRightColorValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderRightColorValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderRightColor),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderRightStyleValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderRightStyleValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderRightStyle),
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderRightWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutBorderRightWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutBorderRightWidth),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopColorValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderTopColorValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderTopColor),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadiusValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderTopLeftRadiusValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderTopLeftRadius),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadiusValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderTopRightRadiusValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderTopRightRadius),
        }

        /// Re-export of rust-allocated (stack based) `StyleBorderTopStyleValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBorderTopStyleValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBorderTopStyle),
        }

        /// Re-export of rust-allocated (stack based) `LayoutBorderTopWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzLayoutBorderTopWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzLayoutBorderTopWidth),
        }

        /// Re-export of rust-allocated (stack based) `StyleCursorValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleCursorValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleCursor),
        }

        /// Re-export of rust-allocated (stack based) `StyleFontSizeValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleFontSizeValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleFontSize),
        }

        /// Re-export of rust-allocated (stack based) `StyleLetterSpacingValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleLetterSpacingValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleLetterSpacing),
        }

        /// Re-export of rust-allocated (stack based) `StyleLineHeightValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleLineHeightValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleLineHeight),
        }

        /// Re-export of rust-allocated (stack based) `StyleTabWidthValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleTabWidthValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleTabWidth),
        }

        /// Re-export of rust-allocated (stack based) `StyleTextAlignValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleTextAlignValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleTextAlign),
        }

        /// Re-export of rust-allocated (stack based) `StyleTextColorValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleTextColorValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleTextColor),
        }

        /// Re-export of rust-allocated (stack based) `StyleWordSpacingValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleWordSpacingValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleWordSpacing),
        }

        /// Re-export of rust-allocated (stack based) `StyleOpacityValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleOpacityValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleOpacity),
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformOriginValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleTransformOriginValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleTransformOrigin),
        }

        /// Re-export of rust-allocated (stack based) `StylePerspectiveOriginValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStylePerspectiveOriginValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStylePerspectiveOrigin),
        }

        /// Re-export of rust-allocated (stack based) `StyleBackfaceVisibilityValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleBackfaceVisibilityValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBackfaceVisibility),
        }

        /// Re-export of rust-allocated (stack based) `StyleMixBlendModeValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleMixBlendModeValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleMixBlendMode),
        }

        /// Re-export of rust-allocated (stack based) `ButtonOnClick` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzButtonOnClick {
            pub data: AzRefAny,
            pub callback: AzCallback,
        }

        /// Re-export of rust-allocated (stack based) `FileInputOnPathChange` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFileInputOnPathChange {
            pub data: AzRefAny,
            pub callback: AzFileInputOnPathChangeCallback,
        }

        /// Re-export of rust-allocated (stack based) `CheckBoxOnToggle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCheckBoxOnToggle {
            pub data: AzRefAny,
            pub callback: AzCheckBoxOnToggleCallback,
        }

        /// Re-export of rust-allocated (stack based) `ColorInputState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzColorInputState {
            pub color: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `ColorInputOnValueChange` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzColorInputOnValueChange {
            pub data: AzRefAny,
            pub callback: AzColorInputOnValueChangeCallback,
        }

        /// Re-export of rust-allocated (stack based) `TextInputSelection` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzTextInputSelection {
            All,
            FromTo(AzTextInputSelectionRange),
        }

        /// Re-export of rust-allocated (stack based) `TextInputOnTextInput` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTextInputOnTextInput {
            pub data: AzRefAny,
            pub callback: AzTextInputOnTextInputCallback,
        }

        /// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDown` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTextInputOnVirtualKeyDown {
            pub data: AzRefAny,
            pub callback: AzTextInputOnVirtualKeyDownCallback,
        }

        /// Re-export of rust-allocated (stack based) `TextInputOnFocusLost` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTextInputOnFocusLost {
            pub data: AzRefAny,
            pub callback: AzTextInputOnFocusLostCallback,
        }

        /// Re-export of rust-allocated (stack based) `OnTextInputReturn` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzOnTextInputReturn {
            pub update: AzUpdate,
            pub valid: AzTextInputValid,
        }

        /// Re-export of rust-allocated (stack based) `NumberInputOnValueChange` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNumberInputOnValueChange {
            pub data: AzRefAny,
            pub callback: AzNumberInputOnValueChangeCallback,
        }

        /// Re-export of rust-allocated (stack based) `NumberInputOnFocusLost` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNumberInputOnFocusLost {
            pub data: AzRefAny,
            pub callback: AzNumberInputOnFocusLostCallback,
        }

        /// Re-export of rust-allocated (stack based) `TabOnClick` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTabOnClick {
            pub data: AzRefAny,
            pub callback: AzTabOnClickCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAdded` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeAdded {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeAddedCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemoved` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeRemoved {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeRemovedCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDragged` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeGraphDragged {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeGraphDraggedCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDragged` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeDragged {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeDraggedCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnected` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeConnected {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeConnectedCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnected` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeInputDisconnected {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeInputDisconnectedCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnected` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeOutputDisconnected {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeOutputDisconnectedCallback,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEdited` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphOnNodeFieldEdited {
            pub data: AzRefAny,
            pub callback: AzNodeGraphOnNodeFieldEditedCallback,
        }

        /// Re-export of rust-allocated (stack based) `OutputNodeAndIndex` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzOutputNodeAndIndex {
            pub node_id: AzNodeGraphNodeId,
            pub output_index: usize,
        }

        /// Re-export of rust-allocated (stack based) `InputNodeAndIndex` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInputNodeAndIndex {
            pub node_id: AzNodeGraphNodeId,
            pub input_index: usize,
        }

        /// Re-export of rust-allocated (stack based) `ListViewOnLazyLoadScroll` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzListViewOnLazyLoadScroll {
            pub data: AzRefAny,
            pub callback: AzListViewOnLazyLoadScrollCallback,
        }

        /// Re-export of rust-allocated (stack based) `ListViewOnColumnClick` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzListViewOnColumnClick {
            pub data: AzRefAny,
            pub callback: AzListViewOnColumnClickCallback,
        }

        /// Re-export of rust-allocated (stack based) `ListViewOnRowClick` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzListViewOnRowClick {
            pub data: AzRefAny,
            pub callback: AzListViewOnRowClickCallback,
        }

        /// Re-export of rust-allocated (stack based) `DropDownOnChoiceChange` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzDropDownOnChoiceChange {
            pub data: AzRefAny,
            pub callback: AzDropDownOnChoiceChangeCallback,
        }

        /// Re-export of rust-allocated (stack based) `ParentWithNodeDepth` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzParentWithNodeDepth {
            pub depth: usize,
            pub node_id: AzNodeId,
        }

        /// Re-export of rust-allocated (stack based) `Gl` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzGl {
            pub(crate) ptr: *const c_void,
            pub renderer_type: AzRendererType,
            pub run_destructor: bool,
        }

        /// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzRefstrVecRef {
            pub(crate) ptr: *const AzRefstr,
            pub len: usize,
        }

        /// Re-export of rust-allocated (stack based) `ImageMask` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzImageMask {
            pub image: AzImageRef,
            pub rect: AzLogicalRect,
            pub repeat: bool,
        }

        /// Re-export of rust-allocated (stack based) `FontMetrics` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFontMetrics {
            pub units_per_em: u16,
            pub font_flags: u16,
            pub x_min: i16,
            pub y_min: i16,
            pub x_max: i16,
            pub y_max: i16,
            pub ascender: i16,
            pub descender: i16,
            pub line_gap: i16,
            pub advance_width_max: u16,
            pub min_left_side_bearing: i16,
            pub min_right_side_bearing: i16,
            pub x_max_extent: i16,
            pub caret_slope_rise: i16,
            pub caret_slope_run: i16,
            pub caret_offset: i16,
            pub num_h_metrics: u16,
            pub x_avg_char_width: i16,
            pub us_weight_class: u16,
            pub us_width_class: u16,
            pub fs_type: u16,
            pub y_subscript_x_size: i16,
            pub y_subscript_y_size: i16,
            pub y_subscript_x_offset: i16,
            pub y_subscript_y_offset: i16,
            pub y_superscript_x_size: i16,
            pub y_superscript_y_size: i16,
            pub y_superscript_x_offset: i16,
            pub y_superscript_y_offset: i16,
            pub y_strikeout_size: i16,
            pub y_strikeout_position: i16,
            pub s_family_class: i16,
            pub panose: [u8; 10],
            pub ul_unicode_range1: u32,
            pub ul_unicode_range2: u32,
            pub ul_unicode_range3: u32,
            pub ul_unicode_range4: u32,
            pub ach_vend_id: u32,
            pub fs_selection: u16,
            pub us_first_char_index: u16,
            pub us_last_char_index: u16,
            pub s_typo_ascender: AzOptionI16,
            pub s_typo_descender: AzOptionI16,
            pub s_typo_line_gap: AzOptionI16,
            pub us_win_ascent: AzOptionU16,
            pub us_win_descent: AzOptionU16,
            pub ul_code_page_range1: AzOptionU32,
            pub ul_code_page_range2: AzOptionU32,
            pub sx_height: AzOptionI16,
            pub s_cap_height: AzOptionI16,
            pub us_default_char: AzOptionU16,
            pub us_break_char: AzOptionU16,
            pub us_max_context: AzOptionU16,
            pub us_lower_optical_point_size: AzOptionU16,
            pub us_upper_optical_point_size: AzOptionU16,
        }

        /// Re-export of rust-allocated (stack based) `SvgLine` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgLine {
            pub start: AzSvgPoint,
            pub end: AzSvgPoint,
        }

        /// Re-export of rust-allocated (stack based) `SvgQuadraticCurve` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgQuadraticCurve {
            pub start: AzSvgPoint,
            pub ctrl: AzSvgPoint,
            pub end: AzSvgPoint,
        }

        /// Re-export of rust-allocated (stack based) `SvgCubicCurve` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgCubicCurve {
            pub start: AzSvgPoint,
            pub ctrl_1: AzSvgPoint,
            pub ctrl_2: AzSvgPoint,
            pub end: AzSvgPoint,
        }

        /// Re-export of rust-allocated (stack based) `SvgStringFormatOptions` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzSvgStringFormatOptions {
            pub use_single_quote: bool,
            pub indent: AzIndent,
            pub attributes_indent: AzIndent,
        }

        /// Re-export of rust-allocated (stack based) `SvgFillStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSvgFillStyle {
            pub line_join: AzSvgLineJoin,
            pub miter_limit: f32,
            pub tolerance: f32,
            pub fill_rule: AzSvgFillRule,
            pub transform: AzSvgTransform,
            pub anti_alias: bool,
            pub high_quality_aa: bool,
        }

        /// Re-export of rust-allocated (stack based) `InstantPtr` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzInstantPtr {
            pub(crate) ptr: *const c_void,
            pub clone_fn: AzInstantPtrCloneFn,
            pub destructor: AzInstantPtrDestructorFn,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `Duration` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzDuration {
            System(AzSystemTimeDiff),
            Tick(AzSystemTickDiff),
        }

        /// Re-export of rust-allocated (stack based) `ThreadSendMsg` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzThreadSendMsg {
            TerminateThread,
            Tick,
            Custom(AzRefAny),
        }

        /// Re-export of rust-allocated (stack based) `ThreadWriteBackMsg` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzThreadWriteBackMsg {
            pub data: AzRefAny,
            pub callback: AzWriteBackCallback,
        }

        /// Wrapper over a Rust-allocated `Vec<LogicalRect>`
        #[repr(C)]
        pub struct AzLogicalRectVec {
            pub(crate) ptr: *const AzLogicalRect,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzLogicalRectVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`
        #[repr(C)]
        pub struct AzInputOutputTypeIdVec {
            pub(crate) ptr: *const AzInputOutputTypeId,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInputOutputTypeIdVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`
        #[repr(C)]
        pub struct AzOutputNodeAndIndexVec {
            pub(crate) ptr: *const AzOutputNodeAndIndex,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzOutputNodeAndIndexVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`
        #[repr(C)]
        pub struct AzInputNodeAndIndexVec {
            pub(crate) ptr: *const AzInputNodeAndIndex,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInputNodeAndIndexVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<AccessibilityState>`
        #[repr(C)]
        pub struct AzAccessibilityStateVec {
            pub(crate) ptr: *const AzAccessibilityState,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzAccessibilityStateVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<MenuItem>`
        #[repr(C)]
        pub struct AzMenuItemVec {
            pub(crate) ptr: *const AzMenuItem,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzMenuItemVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<XmlNode>`
        #[repr(C)]
        pub struct AzXmlNodeVec {
            pub(crate) ptr: *const AzXmlNode,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzXmlNodeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InlineGlyph>`
        #[repr(C)]
        pub struct AzInlineGlyphVec {
            pub(crate) ptr: *const AzInlineGlyph,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInlineGlyphVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InlineTextHit>`
        #[repr(C)]
        pub struct AzInlineTextHitVec {
            pub(crate) ptr: *const AzInlineTextHit,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInlineTextHitVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<VideoMode>`
        #[repr(C)]
        pub struct AzVideoModeVec {
            pub(crate) ptr: *const AzVideoMode,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzVideoModeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<Dom>`
        #[repr(C)]
        pub struct AzDomVec {
            pub(crate) ptr: *const AzDom,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzDomVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`
        #[repr(C)]
        pub struct AzStyleBackgroundPositionVec {
            pub(crate) ptr: *const AzStyleBackgroundPosition,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyleBackgroundPositionVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`
        #[repr(C)]
        pub struct AzStyleBackgroundRepeatVec {
            pub(crate) ptr: *const AzStyleBackgroundRepeat,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyleBackgroundRepeatVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`
        #[repr(C)]
        pub struct AzStyleBackgroundSizeVec {
            pub(crate) ptr: *const AzStyleBackgroundSize,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyleBackgroundSizeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `SvgVertex`
        #[repr(C)]
        pub struct AzSvgVertexVec {
            pub(crate) ptr: *const AzSvgVertex,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzSvgVertexVecDestructor,
        }

        /// Wrapper over a Rust-allocated `SvgColoredVertex`
        #[repr(C)]
        pub struct AzSvgColoredVertexVec {
            pub(crate) ptr: *const AzSvgColoredVertex,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzSvgColoredVertexVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<u32>`
        #[repr(C)]
        pub struct AzU32Vec {
            pub(crate) ptr: *const u32,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzU32VecDestructor,
        }

        /// Wrapper over a Rust-allocated `XWindowType`
        #[repr(C)]
        pub struct AzXWindowTypeVec {
            pub(crate) ptr: *const AzXWindowType,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzXWindowTypeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `VirtualKeyCode`
        #[repr(C)]
        pub struct AzVirtualKeyCodeVec {
            pub(crate) ptr: *const AzVirtualKeyCode,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzVirtualKeyCodeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `CascadeInfo`
        #[repr(C)]
        pub struct AzCascadeInfoVec {
            pub(crate) ptr: *const AzCascadeInfo,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzCascadeInfoVecDestructor,
        }

        /// Wrapper over a Rust-allocated `ScanCode`
        #[repr(C)]
        pub struct AzScanCodeVec {
            pub(crate) ptr: *const u32,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzScanCodeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<u16>`
        #[repr(C)]
        pub struct AzU16Vec {
            pub(crate) ptr: *const u16,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzU16VecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<f32>`
        #[repr(C)]
        pub struct AzF32Vec {
            pub(crate) ptr: *const f32,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzF32VecDestructor,
        }

        /// Wrapper over a Rust-allocated `U8Vec`
        #[repr(C)]
        pub struct AzU8Vec {
            pub(crate) ptr: *const u8,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzU8VecDestructor,
        }

        /// Wrapper over a Rust-allocated `U32Vec`
        #[repr(C)]
        pub struct AzGLuintVec {
            pub(crate) ptr: *const u32,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzGLuintVecDestructor,
        }

        /// Wrapper over a Rust-allocated `GLintVec`
        #[repr(C)]
        pub struct AzGLintVec {
            pub(crate) ptr: *const i32,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzGLintVecDestructor,
        }

        /// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`
        #[repr(C)]
        pub struct AzNormalizedLinearColorStopVec {
            pub(crate) ptr: *const AzNormalizedLinearColorStop,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNormalizedLinearColorStopVecDestructor,
        }

        /// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`
        #[repr(C)]
        pub struct AzNormalizedRadialColorStopVec {
            pub(crate) ptr: *const AzNormalizedRadialColorStop,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNormalizedRadialColorStopVecDestructor,
        }

        /// Wrapper over a Rust-allocated `NodeIdVec`
        #[repr(C)]
        pub struct AzNodeIdVec {
            pub(crate) ptr: *const AzNodeId,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNodeIdVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`
        #[repr(C)]
        pub struct AzNodeHierarchyItemVec {
            pub(crate) ptr: *const AzNodeHierarchyItem,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNodeHierarchyItemVecDestructor,
        }

        /// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`
        #[repr(C)]
        pub struct AzParentWithNodeDepthVec {
            pub(crate) ptr: *const AzParentWithNodeDepth,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzParentWithNodeDepthVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `OptionSvgPoint` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionSvgPoint {
            None,
            Some(AzSvgPoint),
        }

        /// Re-export of rust-allocated (stack based) `OptionStyleTextAlign` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionStyleTextAlign {
            None,
            Some(AzStyleTextAlign),
        }

        /// Re-export of rust-allocated (stack based) `OptionListViewOnRowClick` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionListViewOnRowClick {
            None,
            Some(AzListViewOnRowClick),
        }

        /// Re-export of rust-allocated (stack based) `OptionListViewOnColumnClick` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionListViewOnColumnClick {
            None,
            Some(AzListViewOnColumnClick),
        }

        /// Re-export of rust-allocated (stack based) `OptionListViewOnLazyLoadScroll` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionListViewOnLazyLoadScroll {
            None,
            Some(AzListViewOnLazyLoadScroll),
        }

        /// Re-export of rust-allocated (stack based) `OptionPixelValueNoPercent` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionPixelValueNoPercent {
            None,
            Some(AzPixelValueNoPercent),
        }

        /// Re-export of rust-allocated (stack based) `OptionDropDownOnChoiceChange` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionDropDownOnChoiceChange {
            None,
            Some(AzDropDownOnChoiceChange),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeAdded` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeAdded {
            None,
            Some(AzNodeGraphOnNodeAdded),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeRemoved` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeRemoved {
            None,
            Some(AzNodeGraphOnNodeRemoved),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeGraphDragged` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeGraphDragged {
            None,
            Some(AzNodeGraphOnNodeGraphDragged),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeDragged` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeDragged {
            None,
            Some(AzNodeGraphOnNodeDragged),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeConnected` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeConnected {
            None,
            Some(AzNodeGraphOnNodeConnected),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeInputDisconnected`
        /// struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeInputDisconnected {
            None,
            Some(AzNodeGraphOnNodeInputDisconnected),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeOutputDisconnected`
        /// struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeOutputDisconnected {
            None,
            Some(AzNodeGraphOnNodeOutputDisconnected),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeFieldEdited` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNodeGraphOnNodeFieldEdited {
            None,
            Some(AzNodeGraphOnNodeFieldEdited),
        }

        /// Re-export of rust-allocated (stack based) `OptionColorInputOnValueChange` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionColorInputOnValueChange {
            None,
            Some(AzColorInputOnValueChange),
        }

        /// Re-export of rust-allocated (stack based) `OptionButtonOnClick` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionButtonOnClick {
            None,
            Some(AzButtonOnClick),
        }

        /// Re-export of rust-allocated (stack based) `OptionTabOnClick` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTabOnClick {
            None,
            Some(AzTabOnClick),
        }

        /// Re-export of rust-allocated (stack based) `OptionFileInputOnPathChange` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionFileInputOnPathChange {
            None,
            Some(AzFileInputOnPathChange),
        }

        /// Re-export of rust-allocated (stack based) `OptionCheckBoxOnToggle` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionCheckBoxOnToggle {
            None,
            Some(AzCheckBoxOnToggle),
        }

        /// Re-export of rust-allocated (stack based) `OptionTextInputOnTextInput` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTextInputOnTextInput {
            None,
            Some(AzTextInputOnTextInput),
        }

        /// Re-export of rust-allocated (stack based) `OptionTextInputOnVirtualKeyDown` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTextInputOnVirtualKeyDown {
            None,
            Some(AzTextInputOnVirtualKeyDown),
        }

        /// Re-export of rust-allocated (stack based) `OptionTextInputOnFocusLost` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTextInputOnFocusLost {
            None,
            Some(AzTextInputOnFocusLost),
        }

        /// Re-export of rust-allocated (stack based) `OptionTextInputSelection` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTextInputSelection {
            None,
            Some(AzTextInputSelection),
        }

        /// Re-export of rust-allocated (stack based) `OptionNumberInputOnFocusLost` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNumberInputOnFocusLost {
            None,
            Some(AzNumberInputOnFocusLost),
        }

        /// Re-export of rust-allocated (stack based) `OptionNumberInputOnValueChange` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionNumberInputOnValueChange {
            None,
            Some(AzNumberInputOnValueChange),
        }

        /// Re-export of rust-allocated (stack based) `OptionMenuItemIcon` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionMenuItemIcon {
            None,
            Some(AzMenuItemIcon),
        }

        /// Re-export of rust-allocated (stack based) `OptionMenuCallback` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionMenuCallback {
            None,
            Some(AzMenuCallback),
        }

        /// Re-export of rust-allocated (stack based) `OptionPositionInfo` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionPositionInfo {
            None,
            Some(AzPositionInfo),
        }

        /// Re-export of rust-allocated (stack based) `OptionTimerId` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTimerId {
            None,
            Some(AzTimerId),
        }

        /// Re-export of rust-allocated (stack based) `OptionThreadId` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionThreadId {
            None,
            Some(AzThreadId),
        }

        /// Re-export of rust-allocated (stack based) `OptionImageRef` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionImageRef {
            None,
            Some(AzImageRef),
        }

        /// Re-export of rust-allocated (stack based) `OptionFontRef` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionFontRef {
            None,
            Some(AzFontRef),
        }

        /// Re-export of rust-allocated (stack based) `OptionSystemClipboard` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionSystemClipboard {
            None,
            Some(AzSystemClipboard),
        }

        /// Re-export of rust-allocated (stack based) `OptionGl` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionGl {
            None,
            Some(AzGl),
        }

        /// Re-export of rust-allocated (stack based) `OptionPercentageValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionPercentageValue {
            None,
            Some(AzPercentageValue),
        }

        /// Re-export of rust-allocated (stack based) `OptionAngleValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionAngleValue {
            None,
            Some(AzAngleValue),
        }

        /// Re-export of rust-allocated (stack based) `OptionRendererOptions` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionRendererOptions {
            None,
            Some(AzRendererOptions),
        }

        /// Re-export of rust-allocated (stack based) `OptionCallback` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionCallback {
            None,
            Some(AzCallback),
        }

        /// Re-export of rust-allocated (stack based) `OptionThreadSendMsg` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionThreadSendMsg {
            None,
            Some(AzThreadSendMsg),
        }

        /// Re-export of rust-allocated (stack based) `OptionLayoutRect` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionLayoutRect {
            None,
            Some(AzLayoutRect),
        }

        /// Re-export of rust-allocated (stack based) `OptionRefAny` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionRefAny {
            None,
            Some(AzRefAny),
        }

        /// Re-export of rust-allocated (stack based) `OptionLayoutPoint` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionLayoutPoint {
            None,
            Some(AzLayoutPoint),
        }

        /// Re-export of rust-allocated (stack based) `OptionLayoutSize` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionLayoutSize {
            None,
            Some(AzLayoutSize),
        }

        /// Re-export of rust-allocated (stack based) `OptionWindowTheme` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionWindowTheme {
            None,
            Some(AzWindowTheme),
        }

        /// Re-export of rust-allocated (stack based) `OptionNodeId` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionNodeId {
            None,
            Some(AzNodeId),
        }

        /// Re-export of rust-allocated (stack based) `OptionDomNodeId` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionDomNodeId {
            None,
            Some(AzDomNodeId),
        }

        /// Re-export of rust-allocated (stack based) `OptionColorU` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionColorU {
            None,
            Some(AzColorU),
        }

        /// Re-export of rust-allocated (stack based) `OptionSvgDashPattern` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionSvgDashPattern {
            None,
            Some(AzSvgDashPattern),
        }

        /// Re-export of rust-allocated (stack based) `OptionLogicalPosition` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionLogicalPosition {
            None,
            Some(AzLogicalPosition),
        }

        /// Re-export of rust-allocated (stack based) `OptionPhysicalPositionI32` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionPhysicalPositionI32 {
            None,
            Some(AzPhysicalPositionI32),
        }

        /// Re-export of rust-allocated (stack based) `OptionMouseCursorType` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzOptionMouseCursorType {
            None,
            Some(AzMouseCursorType),
        }

        /// Re-export of rust-allocated (stack based) `OptionLogicalSize` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzOptionLogicalSize {
            None,
            Some(AzLogicalSize),
        }

        /// Re-export of rust-allocated (stack based) `OptionVirtualKeyCode` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionVirtualKeyCode {
            None,
            Some(AzVirtualKeyCode),
        }

        /// Re-export of rust-allocated (stack based) `OptionImageMask` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionImageMask {
            None,
            Some(AzImageMask),
        }

        /// Re-export of rust-allocated (stack based) `OptionTabIndex` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionTabIndex {
            None,
            Some(AzTabIndex),
        }

        /// Re-export of rust-allocated (stack based) `OptionTagId` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionTagId {
            None,
            Some(AzTagId),
        }

        /// Re-export of rust-allocated (stack based) `OptionDuration` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzOptionDuration {
            None,
            Some(AzDuration),
        }

        /// Re-export of rust-allocated (stack based) `OptionU8Vec` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionU8Vec {
            None,
            Some(AzU8Vec),
        }

        /// Re-export of rust-allocated (stack based) `OptionU8VecRef` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionU8VecRef {
            None,
            Some(AzU8VecRef),
        }

        /// Re-export of rust-allocated (stack based) `ResultU8VecEncodeImageError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzResultU8VecEncodeImageError {
            Ok(AzU8Vec),
            Err(AzEncodeImageError),
        }

        /// Re-export of rust-allocated (stack based) `NonXmlCharError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzNonXmlCharError {
            pub ch: u32,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `InvalidCharError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzInvalidCharError {
            pub expected: u8,
            pub got: u8,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `InvalidCharMultipleError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInvalidCharMultipleError {
            pub expected: u8,
            pub got: AzU8Vec,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `InvalidQuoteError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzInvalidQuoteError {
            pub got: u8,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `InvalidSpaceError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzInvalidSpaceError {
            pub got: u8,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Configuration for optional features, such as whether to enable logging or panic hooks
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzAppConfig {
            pub layout_solver: AzLayoutSolver,
            pub log_level: AzAppLogLevel,
            pub enable_visual_panic_hook: bool,
            pub enable_logging_on_panic: bool,
            pub enable_tab_navigation: bool,
            pub system_callbacks: AzSystemCallbacks,
        }

        /// Small (16x16x4) window icon, usually shown in the window titlebar
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzSmallWindowIconBytes {
            pub key: AzIconKey,
            pub rgba_bytes: AzU8Vec,
        }

        /// Large (32x32x4) window icon, usually used on high-resolution displays (instead of
        /// `SmallWindowIcon`)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzLargeWindowIconBytes {
            pub key: AzIconKey,
            pub rgba_bytes: AzU8Vec,
        }

        /// Window "favicon", usually shown in the top left of the window on Windows
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzWindowIcon {
            Small(AzSmallWindowIconBytes),
            Large(AzLargeWindowIconBytes),
        }

        /// Application taskbar icon, 256x256x4 bytes in size
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTaskBarIcon {
            pub key: AzIconKey,
            pub rgba_bytes: AzU8Vec,
        }

        /// Minimum / maximum / current size of the window in logical dimensions
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzWindowSize {
            pub dimensions: AzLogicalSize,
            pub dpi: u32,
            pub min_dimensions: AzOptionLogicalSize,
            pub max_dimensions: AzOptionLogicalSize,
        }

        /// Current keyboard state, stores what keys / characters have been pressed
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzKeyboardState {
            pub current_char: AzOptionChar,
            pub current_virtual_keycode: AzOptionVirtualKeyCode,
            pub pressed_virtual_keycodes: AzVirtualKeyCodeVec,
            pub pressed_scancodes: AzScanCodeVec,
        }

        /// Current mouse / cursor state
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzMouseState {
            pub mouse_cursor_type: AzOptionMouseCursorType,
            pub cursor_position: AzCursorPosition,
            pub is_cursor_locked: bool,
            pub left_down: bool,
            pub right_down: bool,
            pub middle_down: bool,
            pub scroll_x: AzOptionF32,
            pub scroll_y: AzOptionF32,
        }

        /// C-ABI stable wrapper over a `MarshaledLayoutCallback`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzMarshaledLayoutCallback {
            pub marshal_data: AzRefAny,
            pub cb: AzMarshaledLayoutCallbackInner,
        }

        /// Re-export of rust-allocated (stack based) `InlineTextContents` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInlineTextContents {
            pub glyphs: AzInlineGlyphVec,
            pub bounds: AzLogicalRect,
        }

        /// Re-export of rust-allocated (stack based) `ResolvedTextLayoutOptions` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzResolvedTextLayoutOptions {
            pub font_size_px: f32,
            pub line_height: AzOptionF32,
            pub letter_spacing: AzOptionF32,
            pub word_spacing: AzOptionF32,
            pub tab_width: AzOptionF32,
            pub max_horizontal_width: AzOptionF32,
            pub leading: AzOptionF32,
            pub holes: AzLogicalRectVec,
            pub max_vertical_height: AzOptionF32,
            pub can_break: bool,
            pub can_hyphenate: bool,
            pub hyphenation_character: AzOptionChar,
            pub is_rtl: AzScriptType,
            pub text_justify: AzOptionStyleTextAlign,
        }

        /// Easing function of the animation (ease-in, ease-out, ease-in-out, custom)
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzAnimationEasing {
            Ease,
            Linear,
            EaseIn,
            EaseOut,
            EaseInOut,
            CubicBezier(AzSvgCubicCurve),
        }

        /// Re-export of rust-allocated (stack based) `RenderImageCallbackInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzRenderImageCallbackInfo {
            pub callback_node_id: AzDomNodeId,
            pub bounds: AzHidpiAdjustedBounds,
            pub gl_context: *const AzOptionGl,
            pub image_cache: *const c_void,
            pub system_fonts: *const c_void,
            pub node_hierarchy: *const AzNodeHierarchyItemVec,
            pub words_cache: *const c_void,
            pub shaped_words_cache: *const c_void,
            pub positioned_words_cache: *const c_void,
            pub positioned_rects: *const c_void,
            pub _reserved_ref: *const c_void,
            pub _reserved_mut: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `LayoutCallbackInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzLayoutCallbackInfo {
            pub window_size: AzWindowSize,
            pub theme: AzWindowTheme,
            pub image_cache: *const c_void,
            pub gl_context: *const AzOptionGl,
            pub system_fonts: *const c_void,
            pub _reserved_ref: *const c_void,
            pub _reserved_mut: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `EventFilter` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzEventFilter {
            Hover(AzHoverEventFilter),
            Not(AzNotEventFilter),
            Focus(AzFocusEventFilter),
            Window(AzWindowEventFilter),
            Component(AzComponentEventFilter),
            Application(AzApplicationEventFilter),
        }

        /// Menu struct (application / window menu, dropdown menu, context menu). Modeled after the
        /// Windows API
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzMenu {
            pub items: AzMenuItemVec,
            pub position: AzMenuPopupPosition,
            pub context_mouse_btn: AzContextMenuMouseButton,
        }

        /// Combination of virtual key codes that have to be pressed together
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzVirtualKeyCodeCombo {
            pub keys: AzVirtualKeyCodeVec,
        }

        /// Re-export of rust-allocated (stack based) `CssPathPseudoSelector` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzCssPathPseudoSelector {
            First,
            Last,
            NthChild(AzCssNthChildSelector),
            Hover,
            Active,
            Focus,
        }

        /// Re-export of rust-allocated (stack based) `AnimationInterpolationFunction` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzAnimationInterpolationFunction {
            Ease,
            Linear,
            EaseIn,
            EaseOut,
            EaseInOut,
            CubicBezier(AzSvgCubicCurve),
        }

        /// Re-export of rust-allocated (stack based) `InterpolateContext` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzInterpolateContext {
            pub animation_func: AzAnimationInterpolationFunction,
            pub parent_rect_width: f32,
            pub parent_rect_height: f32,
            pub current_rect_width: f32,
            pub current_rect_height: f32,
        }

        /// Re-export of rust-allocated (stack based) `StyleFilter` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleFilter {
            Blend(AzStyleMixBlendMode),
            Flood(AzColorU),
            Blur(AzStyleBlur),
            Opacity(AzPercentageValue),
            ColorMatrix(AzStyleColorMatrix),
            DropShadow(AzStyleBoxShadow),
            ComponentTransfer,
            Offset(AzStyleFilterOffset),
            Composite(AzStyleCompositeFilter),
        }

        /// Re-export of rust-allocated (stack based) `LinearGradient` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzLinearGradient {
            pub direction: AzDirection,
            pub extend_mode: AzExtendMode,
            pub stops: AzNormalizedLinearColorStopVec,
        }

        /// Re-export of rust-allocated (stack based) `RadialGradient` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzRadialGradient {
            pub shape: AzShape,
            pub size: AzRadialGradientSize,
            pub position: AzStyleBackgroundPosition,
            pub extend_mode: AzExtendMode,
            pub stops: AzNormalizedLinearColorStopVec,
        }

        /// Re-export of rust-allocated (stack based) `ConicGradient` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzConicGradient {
            pub extend_mode: AzExtendMode,
            pub center: AzStyleBackgroundPosition,
            pub angle: AzAngleValue,
            pub stops: AzNormalizedRadialColorStopVec,
        }

        /// Re-export of rust-allocated (stack based) `StyleTransform` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzStyleTransform {
            Matrix(AzStyleTransformMatrix2D),
            Matrix3D(AzStyleTransformMatrix3D),
            Translate(AzStyleTransformTranslate2D),
            Translate3D(AzStyleTransformTranslate3D),
            TranslateX(AzPixelValue),
            TranslateY(AzPixelValue),
            TranslateZ(AzPixelValue),
            Rotate(AzAngleValue),
            Rotate3D(AzStyleTransformRotate3D),
            RotateX(AzAngleValue),
            RotateY(AzAngleValue),
            RotateZ(AzAngleValue),
            Scale(AzStyleTransformScale2D),
            Scale3D(AzStyleTransformScale3D),
            ScaleX(AzPercentageValue),
            ScaleY(AzPercentageValue),
            ScaleZ(AzPercentageValue),
            Skew(AzStyleTransformSkew2D),
            SkewX(AzPercentageValue),
            SkewY(AzPercentageValue),
            Perspective(AzPixelValue),
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleBackgroundPositionVecValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBackgroundPositionVec),
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleBackgroundRepeatVecValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBackgroundRepeatVec),
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleBackgroundSizeVecValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBackgroundSizeVec),
        }

        /// Re-export of rust-allocated (stack based) `CheckBoxStateWrapper` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCheckBoxStateWrapper {
            pub inner: AzCheckBoxState,
            pub on_toggle: AzOptionCheckBoxOnToggle,
        }

        /// Re-export of rust-allocated (stack based) `NumberInputStateWrapper` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNumberInputStateWrapper {
            pub inner: AzNumberInputState,
            pub on_value_change: AzOptionNumberInputOnValueChange,
            pub on_focus_lost: AzOptionNumberInputOnFocusLost,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraphCallbacks` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraphCallbacks {
            pub on_node_added: AzOptionNodeGraphOnNodeAdded,
            pub on_node_removed: AzOptionNodeGraphOnNodeRemoved,
            pub on_node_dragged: AzOptionNodeGraphOnNodeDragged,
            pub on_node_graph_dragged: AzOptionNodeGraphOnNodeGraphDragged,
            pub on_node_connected: AzOptionNodeGraphOnNodeConnected,
            pub on_node_input_disconnected: AzOptionNodeGraphOnNodeInputDisconnected,
            pub on_node_output_disconnected: AzOptionNodeGraphOnNodeOutputDisconnected,
            pub on_node_field_edited: AzOptionNodeGraphOnNodeFieldEdited,
        }

        /// Re-export of rust-allocated (stack based) `InputConnection` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInputConnection {
            pub input_index: usize,
            pub connects_to: AzOutputNodeAndIndexVec,
        }

        /// Re-export of rust-allocated (stack based) `OutputConnection` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzOutputConnection {
            pub output_index: usize,
            pub connects_to: AzInputNodeAndIndexVec,
        }

        /// Re-export of rust-allocated (stack based) `ListViewRow` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzListViewRow {
            pub cells: AzDomVec,
            pub height: AzOptionPixelValueNoPercent,
        }

        /// Re-export of rust-allocated (stack based) `StyledNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzStyledNode {
            pub state: AzStyledNodeState,
            pub tag_id: AzOptionTagId,
        }

        /// Re-export of rust-allocated (stack based) `TagIdToNodeIdMapping` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTagIdToNodeIdMapping {
            pub tag_id: AzTagId,
            pub node_id: AzNodeId,
            pub tab_index: AzOptionTabIndex,
            pub parents: AzNodeIdVec,
        }

        /// Re-export of rust-allocated (stack based) `Texture` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzTexture {
            pub texture_id: u32,
            pub flags: AzTextureFlags,
            pub size: AzPhysicalSizeU32,
            pub background_color: AzColorU,
            pub gl_context: AzGl,
            pub format: AzRawImageFormat,
            pub refcount: *const c_void,
            pub run_destructor: bool,
        }

        /// C-ABI stable reexport of `(U8Vec, u32)`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGetProgramBinaryReturn {
            pub _0: AzU8Vec,
            pub _1: u32,
        }

        /// Re-export of rust-allocated (stack based) `RawImageData` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzRawImageData {
            U8(AzU8Vec),
            U16(AzU16Vec),
            F32(AzF32Vec),
        }

        /// Source data of a font file (bytes)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFontSource {
            pub data: AzU8Vec,
            pub font_index: u32,
            pub parse_glyph_outlines: bool,
        }

        /// Re-export of rust-allocated (stack based) `SvgPathElement` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzSvgPathElement {
            Line(AzSvgLine),
            QuadraticCurve(AzSvgQuadraticCurve),
            CubicCurve(AzSvgCubicCurve),
        }

        /// Re-export of rust-allocated (stack based) `TessellatedColoredSvgNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTessellatedColoredSvgNode {
            pub vertices: AzSvgColoredVertexVec,
            pub indices: AzU32Vec,
        }

        /// Rust wrapper over a `&[TessellatedColoredSvgNode]` or `&Vec<TessellatedColoredSvgNode>`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTessellatedColoredSvgNodeVecRef {
            pub(crate) ptr: *const AzTessellatedColoredSvgNode,
            pub len: usize,
        }

        /// Re-export of rust-allocated (stack based) `TessellatedSvgNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTessellatedSvgNode {
            pub vertices: AzSvgVertexVec,
            pub indices: AzU32Vec,
        }

        /// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTessellatedSvgNodeVecRef {
            pub(crate) ptr: *const AzTessellatedSvgNode,
            pub len: usize,
        }

        /// Re-export of rust-allocated (stack based) `SvgRenderOptions` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzSvgRenderOptions {
            pub target_size: AzOptionLayoutSize,
            pub background_color: AzOptionColorU,
            pub fit: AzSvgFitTo,
            pub transform: AzSvgRenderTransform,
        }

        /// Re-export of rust-allocated (stack based) `SvgStrokeStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub struct AzSvgStrokeStyle {
            pub start_cap: AzSvgLineCap,
            pub end_cap: AzSvgLineCap,
            pub line_join: AzSvgLineJoin,
            pub dash_pattern: AzOptionSvgDashPattern,
            pub line_width: f32,
            pub miter_limit: f32,
            pub tolerance: f32,
            pub apply_line_width: bool,
            pub transform: AzSvgTransform,
            pub anti_alias: bool,
            pub high_quality_aa: bool,
        }

        /// Re-export of rust-allocated (stack based) `Xml` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzXml {
            pub root: AzXmlNodeVec,
        }

        /// Re-export of rust-allocated (stack based) `Instant` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzInstant {
            System(AzInstantPtr),
            Tick(AzSystemTick),
        }

        /// Re-export of rust-allocated (stack based) `ThreadReceiveMsg` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzThreadReceiveMsg {
            WriteBack(AzThreadWriteBackMsg),
            Update(AzUpdate),
        }

        /// Re-export of rust-allocated (stack based) `String` struct
        #[repr(C)]
        #[derive(Clone, PartialEq, PartialOrd)]
        pub struct AzString {
            pub vec: AzU8Vec,
        }

        /// Wrapper over a Rust-allocated `Vec<ListViewRow>`
        #[repr(C)]
        pub struct AzListViewRowVec {
            pub(crate) ptr: *const AzListViewRow,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzListViewRowVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<StyleFilter>`
        #[repr(C)]
        pub struct AzStyleFilterVec {
            pub(crate) ptr: *const AzStyleFilter,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyleFilterVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InputConnection>`
        #[repr(C)]
        pub struct AzInputConnectionVec {
            pub(crate) ptr: *const AzInputConnection,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInputConnectionVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<OutputConnection>`
        #[repr(C)]
        pub struct AzOutputConnectionVec {
            pub(crate) ptr: *const AzOutputConnection,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzOutputConnectionVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`
        #[repr(C)]
        pub struct AzTessellatedSvgNodeVec {
            pub(crate) ptr: *const AzTessellatedSvgNode,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzTessellatedSvgNodeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<TessellatedColoredSvgNode>`
        #[repr(C)]
        pub struct AzTessellatedColoredSvgNodeVec {
            pub(crate) ptr: *const AzTessellatedColoredSvgNode,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzTessellatedColoredSvgNodeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<StyleTransform>`
        #[repr(C)]
        pub struct AzStyleTransformVec {
            pub(crate) ptr: *const AzStyleTransform,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyleTransformVecDestructor,
        }

        /// Wrapper over a Rust-allocated `VertexAttribute`
        #[repr(C)]
        pub struct AzSvgPathElementVec {
            pub(crate) ptr: *const AzSvgPathElement,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzSvgPathElementVecDestructor,
        }

        /// Wrapper over a Rust-allocated `StringVec`
        #[repr(C)]
        pub struct AzStringVec {
            pub(crate) ptr: *const AzString,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStringVecDestructor,
        }

        /// Wrapper over a Rust-allocated `StyledNodeVec`
        #[repr(C)]
        pub struct AzStyledNodeVec {
            pub(crate) ptr: *const AzStyledNode,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyledNodeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`
        #[repr(C)]
        pub struct AzTagIdToNodeIdMappingVec {
            pub(crate) ptr: *const AzTagIdToNodeIdMapping,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzTagIdToNodeIdMappingVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `OptionMenu` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionMenu {
            None,
            Some(AzMenu),
        }

        /// Re-export of rust-allocated (stack based) `OptionResolvedTextLayoutOptions` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionResolvedTextLayoutOptions {
            None,
            Some(AzResolvedTextLayoutOptions),
        }

        /// Re-export of rust-allocated (stack based) `OptionVirtualKeyCodeCombo` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionVirtualKeyCodeCombo {
            None,
            Some(AzVirtualKeyCodeCombo),
        }

        /// Re-export of rust-allocated (stack based) `OptionMouseState` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionMouseState {
            None,
            Some(AzMouseState),
        }

        /// Re-export of rust-allocated (stack based) `OptionKeyboardState` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionKeyboardState {
            None,
            Some(AzKeyboardState),
        }

        /// Re-export of rust-allocated (stack based) `OptionStringVec` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionStringVec {
            None,
            Some(AzStringVec),
        }

        /// Re-export of rust-allocated (stack based) `OptionThreadReceiveMsg` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionThreadReceiveMsg {
            None,
            Some(AzThreadReceiveMsg),
        }

        /// Re-export of rust-allocated (stack based) `OptionTaskBarIcon` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTaskBarIcon {
            None,
            Some(AzTaskBarIcon),
        }

        /// Re-export of rust-allocated (stack based) `OptionWindowIcon` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionWindowIcon {
            None,
            Some(AzWindowIcon),
        }

        /// Re-export of rust-allocated (stack based) `OptionString` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzOptionString {
            None,
            Some(AzString),
        }

        /// Re-export of rust-allocated (stack based) `OptionTexture` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionTexture {
            None,
            Some(AzTexture),
        }

        /// Re-export of rust-allocated (stack based) `OptionInstant` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionInstant {
            None,
            Some(AzInstant),
        }

        /// Re-export of rust-allocated (stack based) `DuplicatedNamespaceError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzDuplicatedNamespaceError {
            pub ns: AzString,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `UnknownNamespaceError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzUnknownNamespaceError {
            pub ns: AzString,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `UnexpectedCloseTagError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzUnexpectedCloseTagError {
            pub expected: AzString,
            pub actual: AzString,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `UnknownEntityReferenceError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzUnknownEntityReferenceError {
            pub entity: AzString,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `DuplicatedAttributeError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzDuplicatedAttributeError {
            pub attribute: AzString,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Re-export of rust-allocated (stack based) `InvalidStringError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInvalidStringError {
            pub got: AzString,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Window configuration specific to Win32
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzWindowsWindowOptions {
            pub allow_drag_drop: bool,
            pub no_redirection_bitmap: bool,
            pub window_icon: AzOptionWindowIcon,
            pub taskbar_icon: AzOptionTaskBarIcon,
            pub parent_window: AzOptionHwndHandle,
        }

        /// CSD theme of the window title / button controls
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzWaylandTheme {
            pub title_bar_active_background_color: [u8; 4],
            pub title_bar_active_separator_color: [u8; 4],
            pub title_bar_active_text_color: [u8; 4],
            pub title_bar_inactive_background_color: [u8; 4],
            pub title_bar_inactive_separator_color: [u8; 4],
            pub title_bar_inactive_text_color: [u8; 4],
            pub maximize_idle_foreground_inactive_color: [u8; 4],
            pub minimize_idle_foreground_inactive_color: [u8; 4],
            pub close_idle_foreground_inactive_color: [u8; 4],
            pub maximize_hovered_foreground_inactive_color: [u8; 4],
            pub minimize_hovered_foreground_inactive_color: [u8; 4],
            pub close_hovered_foreground_inactive_color: [u8; 4],
            pub maximize_disabled_foreground_inactive_color: [u8; 4],
            pub minimize_disabled_foreground_inactive_color: [u8; 4],
            pub close_disabled_foreground_inactive_color: [u8; 4],
            pub maximize_idle_background_inactive_color: [u8; 4],
            pub minimize_idle_background_inactive_color: [u8; 4],
            pub close_idle_background_inactive_color: [u8; 4],
            pub maximize_hovered_background_inactive_color: [u8; 4],
            pub minimize_hovered_background_inactive_color: [u8; 4],
            pub close_hovered_background_inactive_color: [u8; 4],
            pub maximize_disabled_background_inactive_color: [u8; 4],
            pub minimize_disabled_background_inactive_color: [u8; 4],
            pub close_disabled_background_inactive_color: [u8; 4],
            pub maximize_idle_foreground_active_color: [u8; 4],
            pub minimize_idle_foreground_active_color: [u8; 4],
            pub close_idle_foreground_active_color: [u8; 4],
            pub maximize_hovered_foreground_active_color: [u8; 4],
            pub minimize_hovered_foreground_active_color: [u8; 4],
            pub close_hovered_foreground_active_color: [u8; 4],
            pub maximize_disabled_foreground_active_color: [u8; 4],
            pub minimize_disabled_foreground_active_color: [u8; 4],
            pub close_disabled_foreground_active_color: [u8; 4],
            pub maximize_idle_background_active_color: [u8; 4],
            pub minimize_idle_background_active_color: [u8; 4],
            pub close_idle_background_active_color: [u8; 4],
            pub maximize_hovered_background_active_color: [u8; 4],
            pub minimize_hovered_background_active_color: [u8; 4],
            pub close_hovered_background_active_color: [u8; 4],
            pub maximize_disabled_background_active_color: [u8; 4],
            pub minimize_disabled_background_active_color: [u8; 4],
            pub close_disabled_background_active_color: [u8; 4],
            pub title_bar_font: AzString,
            pub title_bar_font_size: f32,
        }

        /// Key-value pair, used for setting WM hints values specific to GNOME
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzStringPair {
            pub key: AzString,
            pub value: AzString,
        }

        /// Information about a single (or many) monitors, useful for dock widgets
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzMonitor {
            pub id: usize,
            pub name: AzOptionString,
            pub size: AzLayoutSize,
            pub position: AzLayoutPoint,
            pub scale_factor: f64,
            pub video_modes: AzVideoModeVec,
            pub is_primary_monitor: bool,
        }

        /// Re-export of rust-allocated (stack based) `LayoutCallback` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzLayoutCallback {
            Raw(AzLayoutCallbackInner),
            Marshaled(AzMarshaledLayoutCallback),
        }

        /// Re-export of rust-allocated (stack based) `InlineWord` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzInlineWord {
            Tab,
            Return,
            Space,
            Word(AzInlineTextContents),
        }

        /// Re-export of rust-allocated (stack based) `CallbackData` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCallbackData {
            pub event: AzEventFilter,
            pub callback: AzCallback,
            pub data: AzRefAny,
        }

        /// List of core DOM node types built-into by `azul`
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzNodeType {
            Body,
            Div,
            Br,
            Text(AzString),
            Image(AzImageRef),
            IFrame(AzIFrameNode),
        }

        /// Accessibility information (MSAA wrapper). See `NodeData.set_accessibility_info()`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzAccessibilityInfo {
            pub name: AzOptionString,
            pub value: AzOptionString,
            pub role: AzAccessibilityRole,
            pub states: AzAccessibilityStateVec,
            pub accelerator: AzOptionVirtualKeyCodeCombo,
            pub default_action: AzOptionString,
        }

        /// Re-export of rust-allocated (stack based) `IdOrClass` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzIdOrClass {
            Id(AzString),
            Class(AzString),
        }

        /// Regular labeled menu item
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzStringMenuItem {
            pub label: AzString,
            pub accelerator: AzOptionVirtualKeyCodeCombo,
            pub callback: AzOptionMenuCallback,
            pub state: AzMenuItemState,
            pub icon: AzOptionMenuItemIcon,
            pub children: AzMenuItemVec,
        }

        /// Re-export of rust-allocated (stack based) `CssPathSelector` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzCssPathSelector {
            Global,
            Type(AzNodeTypeKey),
            Class(AzString),
            Id(AzString),
            PseudoSelector(AzCssPathPseudoSelector),
            DirectChildren,
            Children,
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundContent` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleBackgroundContent {
            LinearGradient(AzLinearGradient),
            RadialGradient(AzRadialGradient),
            ConicGradient(AzConicGradient),
            Image(AzString),
            Color(AzColorU),
        }

        /// Re-export of rust-allocated (stack based) `ScrollbarInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzScrollbarInfo {
            pub width: AzLayoutWidth,
            pub padding_left: AzLayoutPaddingLeft,
            pub padding_right: AzLayoutPaddingRight,
            pub track: AzStyleBackgroundContent,
            pub thumb: AzStyleBackgroundContent,
            pub button: AzStyleBackgroundContent,
            pub corner: AzStyleBackgroundContent,
            pub resizer: AzStyleBackgroundContent,
        }

        /// Re-export of rust-allocated (stack based) `ScrollbarStyle` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzScrollbarStyle {
            pub horizontal: AzScrollbarInfo,
            pub vertical: AzScrollbarInfo,
        }

        /// Re-export of rust-allocated (stack based) `StyleFontFamily` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleFontFamily {
            System(AzString),
            File(AzString),
            Ref(AzFontRef),
        }

        /// Re-export of rust-allocated (stack based) `ScrollbarStyleValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzScrollbarStyleValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzScrollbarStyle),
        }

        /// Re-export of rust-allocated (stack based) `StyleTransformVecValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleTransformVecValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleTransformVec),
        }

        /// Re-export of rust-allocated (stack based) `StyleFilterVecValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleFilterVecValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleFilterVec),
        }

        /// Re-export of rust-allocated (stack based) `FileInputState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFileInputState {
            pub path: AzOptionString,
        }

        /// Re-export of rust-allocated (stack based) `ColorInputStateWrapper` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzColorInputStateWrapper {
            pub inner: AzColorInputState,
            pub title: AzString,
            pub on_value_change: AzOptionColorInputOnValueChange,
        }

        /// Re-export of rust-allocated (stack based) `TextInputState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTextInputState {
            pub text: AzU32Vec,
            pub placeholder: AzOptionString,
            pub max_len: usize,
            pub selection: AzOptionTextInputSelection,
            pub cursor_pos: usize,
        }

        /// Re-export of rust-allocated (stack based) `TabHeader` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTabHeader {
            pub tabs: AzStringVec,
            pub active_tab: usize,
            pub on_click: AzOptionTabOnClick,
        }

        /// Re-export of rust-allocated (stack based) `NodeTypeFieldValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub enum AzNodeTypeFieldValue {
            TextInput(AzString),
            NumberInput(f32),
            CheckBox(bool),
            ColorInput(AzColorU),
            FileInput(AzOptionString),
        }

        /// Re-export of rust-allocated (stack based) `NodeTypeInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzNodeTypeInfo {
            pub is_root: bool,
            pub name: AzString,
            pub inputs: AzInputOutputTypeIdVec,
            pub outputs: AzInputOutputTypeIdVec,
        }

        /// Re-export of rust-allocated (stack based) `InputOutputInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzInputOutputInfo {
            pub data_type: AzString,
            pub color: AzColorU,
        }

        /// Re-export of rust-allocated (stack based) `ListView` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzListView {
            pub columns: AzStringVec,
            pub rows: AzListViewRowVec,
            pub sorted_by: AzOptionUsize,
            pub scroll_offset: AzPixelValueNoPercent,
            pub content_height: AzOptionPixelValueNoPercent,
            pub column_context_menu: AzOptionMenu,
            pub on_lazy_load_scroll: AzOptionListViewOnLazyLoadScroll,
            pub on_column_click: AzOptionListViewOnColumnClick,
            pub on_row_click: AzOptionListViewOnRowClick,
        }

        /// Re-export of rust-allocated (stack based) `ListViewState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzListViewState {
            pub columns: AzStringVec,
            pub sorted_by: AzOptionUsize,
            pub current_row_count: usize,
            pub scroll_offset: AzPixelValueNoPercent,
            pub current_scroll_position: AzLogicalPosition,
            pub current_content_height: AzLogicalSize,
        }

        /// Re-export of rust-allocated (stack based) `TreeView` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTreeView {
            pub root: AzString,
        }

        /// Re-export of rust-allocated (stack based) `DropDown` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzDropDown {
            pub choices: AzStringVec,
            pub selected: usize,
            pub on_choice_change: AzOptionDropDownOnChoiceChange,
        }

        /// Re-export of rust-allocated (stack based) `VertexAttribute` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzVertexAttribute {
            pub name: AzString,
            pub layout_location: AzOptionUsize,
            pub attribute_type: AzVertexAttributeType,
            pub item_count: usize,
        }

        /// Re-export of rust-allocated (stack based) `DebugMessage` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzDebugMessage {
            pub message: AzString,
            pub source: u32,
            pub ty: u32,
            pub id: u32,
            pub severity: u32,
        }

        /// C-ABI stable reexport of `(i32, u32, AzString)`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGetActiveAttribReturn {
            pub _0: i32,
            pub _1: u32,
            pub _2: AzString,
        }

        /// C-ABI stable reexport of `(i32, u32, AzString)`
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzGetActiveUniformReturn {
            pub _0: i32,
            pub _1: u32,
            pub _2: AzString,
        }

        /// Re-export of rust-allocated (stack based) `RawImage` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzRawImage {
            pub pixels: AzRawImageData,
            pub width: usize,
            pub height: usize,
            pub alpha_premultiplied: bool,
            pub data_format: AzRawImageFormat,
            pub tag: AzU8Vec,
        }

        /// Re-export of rust-allocated (stack based) `SvgPath` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzSvgPath {
            pub items: AzSvgPathElementVec,
        }

        /// Re-export of rust-allocated (stack based) `SvgParseOptions` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzSvgParseOptions {
            pub relative_image_path: AzOptionString,
            pub dpi: f32,
            pub default_font_family: AzString,
            pub font_size: f32,
            pub languages: AzStringVec,
            pub shape_rendering: AzShapeRendering,
            pub text_rendering: AzTextRendering,
            pub image_rendering: AzImageRendering,
            pub keep_named_groups: bool,
            pub fontdb: AzFontDatabase,
        }

        /// Re-export of rust-allocated (stack based) `SvgStyle` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd, Copy)]
        pub enum AzSvgStyle {
            Fill(AzSvgFillStyle),
            Stroke(AzSvgStrokeStyle),
        }

        /// **Reference-counted** file handle
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzFile {
            pub(crate) ptr: *const c_void,
            pub path: AzString,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `FileTypeList` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFileTypeList {
            pub document_types: AzStringVec,
            pub document_descriptor: AzString,
        }

        /// Re-export of rust-allocated (stack based) `Timer` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTimer {
            pub data: AzRefAny,
            pub node_id: AzOptionDomNodeId,
            pub created: AzInstant,
            pub last_run: AzOptionInstant,
            pub run_count: usize,
            pub delay: AzOptionDuration,
            pub interval: AzOptionDuration,
            pub timeout: AzOptionDuration,
            pub callback: AzTimerCallback,
        }

        /// Re-export of rust-allocated (stack based) `FmtValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzFmtValue {
            Bool(bool),
            Uchar(u8),
            Schar(i8),
            Ushort(u16),
            Sshort(i16),
            Uint(u32),
            Sint(i32),
            Ulong(u64),
            Slong(i64),
            Isize(isize),
            Usize(usize),
            Float(f32),
            Double(f64),
            Str(AzString),
            StrVec(AzStringVec),
        }

        /// Re-export of rust-allocated (stack based) `FmtArg` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFmtArg {
            pub key: AzString,
            pub value: AzFmtValue,
        }

        /// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`
        #[repr(C)]
        pub struct AzStyleFontFamilyVec {
            pub(crate) ptr: *const AzStyleFontFamily,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyleFontFamilyVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<FmtArg>`
        #[repr(C)]
        pub struct AzFmtArgVec {
            pub(crate) ptr: *const AzFmtArg,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzFmtArgVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InlineWord>`
        #[repr(C)]
        pub struct AzInlineWordVec {
            pub(crate) ptr: *const AzInlineWord,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInlineWordVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<Monitor>`
        #[repr(C)]
        pub struct AzMonitorVec {
            pub(crate) ptr: *const AzMonitor,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzMonitorVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<IdOrClass>`
        #[repr(C)]
        pub struct AzIdOrClassVec {
            pub(crate) ptr: *const AzIdOrClass,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzIdOrClassVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`
        #[repr(C)]
        pub struct AzStyleBackgroundContentVec {
            pub(crate) ptr: *const AzStyleBackgroundContent,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStyleBackgroundContentVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<SvgPath>`
        #[repr(C)]
        pub struct AzSvgPathVec {
            pub(crate) ptr: *const AzSvgPath,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzSvgPathVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<VertexAttribute>`
        #[repr(C)]
        pub struct AzVertexAttributeVec {
            pub(crate) ptr: *const AzVertexAttribute,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzVertexAttributeVecDestructor,
        }

        /// Wrapper over a Rust-allocated `CssPathSelector`
        #[repr(C)]
        pub struct AzCssPathSelectorVec {
            pub(crate) ptr: *const AzCssPathSelector,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzCssPathSelectorVecDestructor,
        }

        /// Wrapper over a Rust-allocated `CallbackData`
        #[repr(C)]
        pub struct AzCallbackDataVec {
            pub(crate) ptr: *const AzCallbackData,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzCallbackDataVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<DebugMessage>`
        #[repr(C)]
        pub struct AzDebugMessageVec {
            pub(crate) ptr: *const AzDebugMessage,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzDebugMessageVecDestructor,
        }

        /// Wrapper over a Rust-allocated `StringPairVec`
        #[repr(C)]
        pub struct AzStringPairVec {
            pub(crate) ptr: *const AzStringPair,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStringPairVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `OptionFileTypeList` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionFileTypeList {
            None,
            Some(AzFileTypeList),
        }

        /// Re-export of rust-allocated (stack based) `OptionFile` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionFile {
            None,
            Some(AzFile),
        }

        /// Re-export of rust-allocated (stack based) `OptionRawImage` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionRawImage {
            None,
            Some(AzRawImage),
        }

        /// Re-export of rust-allocated (stack based) `OptionWaylandTheme` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionWaylandTheme {
            None,
            Some(AzWaylandTheme),
        }

        /// Re-export of rust-allocated (stack based) `ResultRawImageDecodeImageError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzResultRawImageDecodeImageError {
            Ok(AzRawImage),
            Err(AzDecodeImageError),
        }

        /// Re-export of rust-allocated (stack based) `XmlStreamError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzXmlStreamError {
            UnexpectedEndOfStream,
            InvalidName,
            NonXmlChar(AzNonXmlCharError),
            InvalidChar(AzInvalidCharError),
            InvalidCharMultiple(AzInvalidCharMultipleError),
            InvalidQuote(AzInvalidQuoteError),
            InvalidSpace(AzInvalidSpaceError),
            InvalidString(AzInvalidStringError),
            InvalidReference,
            InvalidExternalID,
            InvalidCommentData,
            InvalidCommentEnd,
            InvalidCharacterData,
        }

        /// Re-export of rust-allocated (stack based) `LinuxWindowOptions` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzLinuxWindowOptions {
            pub x11_visual: AzOptionX11Visual,
            pub x11_screen: AzOptionI32,
            pub x11_wm_classes: AzStringPairVec,
            pub x11_override_redirect: bool,
            pub x11_window_types: AzXWindowTypeVec,
            pub x11_gtk_theme_variant: AzOptionString,
            pub x11_resize_increments: AzOptionLogicalSize,
            pub x11_base_size: AzOptionLogicalSize,
            pub wayland_app_id: AzOptionString,
            pub wayland_theme: AzOptionWaylandTheme,
            pub request_user_attention: bool,
            pub window_icon: AzOptionWindowIcon,
        }

        /// Re-export of rust-allocated (stack based) `InlineLine` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInlineLine {
            pub words: AzInlineWordVec,
            pub bounds: AzLogicalRect,
        }

        /// Item entry in a menu or menu bar
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzMenuItem {
            String(AzStringMenuItem),
            Separator,
            BreakLine,
        }

        /// Re-export of rust-allocated (stack based) `CssPath` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCssPath {
            pub selectors: AzCssPathSelectorVec,
        }

        /// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleBackgroundContentVecValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleBackgroundContentVec),
        }

        /// Re-export of rust-allocated (stack based) `StyleFontFamilyVecValue` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzStyleFontFamilyVecValue {
            Auto,
            None,
            Inherit,
            Initial,
            Exact(AzStyleFontFamilyVec),
        }

        /// Parsed CSS key-value pair
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzCssProperty {
            TextColor(AzStyleTextColorValue),
            FontSize(AzStyleFontSizeValue),
            FontFamily(AzStyleFontFamilyVecValue),
            TextAlign(AzStyleTextAlignValue),
            LetterSpacing(AzStyleLetterSpacingValue),
            LineHeight(AzStyleLineHeightValue),
            WordSpacing(AzStyleWordSpacingValue),
            TabWidth(AzStyleTabWidthValue),
            Cursor(AzStyleCursorValue),
            Display(AzLayoutDisplayValue),
            Float(AzLayoutFloatValue),
            BoxSizing(AzLayoutBoxSizingValue),
            Width(AzLayoutWidthValue),
            Height(AzLayoutHeightValue),
            MinWidth(AzLayoutMinWidthValue),
            MinHeight(AzLayoutMinHeightValue),
            MaxWidth(AzLayoutMaxWidthValue),
            MaxHeight(AzLayoutMaxHeightValue),
            Position(AzLayoutPositionValue),
            Top(AzLayoutTopValue),
            Right(AzLayoutRightValue),
            Left(AzLayoutLeftValue),
            Bottom(AzLayoutBottomValue),
            FlexWrap(AzLayoutFlexWrapValue),
            FlexDirection(AzLayoutFlexDirectionValue),
            FlexGrow(AzLayoutFlexGrowValue),
            FlexShrink(AzLayoutFlexShrinkValue),
            JustifyContent(AzLayoutJustifyContentValue),
            AlignItems(AzLayoutAlignItemsValue),
            AlignContent(AzLayoutAlignContentValue),
            BackgroundContent(AzStyleBackgroundContentVecValue),
            BackgroundPosition(AzStyleBackgroundPositionVecValue),
            BackgroundSize(AzStyleBackgroundSizeVecValue),
            BackgroundRepeat(AzStyleBackgroundRepeatVecValue),
            OverflowX(AzLayoutOverflowValue),
            OverflowY(AzLayoutOverflowValue),
            PaddingTop(AzLayoutPaddingTopValue),
            PaddingLeft(AzLayoutPaddingLeftValue),
            PaddingRight(AzLayoutPaddingRightValue),
            PaddingBottom(AzLayoutPaddingBottomValue),
            MarginTop(AzLayoutMarginTopValue),
            MarginLeft(AzLayoutMarginLeftValue),
            MarginRight(AzLayoutMarginRightValue),
            MarginBottom(AzLayoutMarginBottomValue),
            BorderTopLeftRadius(AzStyleBorderTopLeftRadiusValue),
            BorderTopRightRadius(AzStyleBorderTopRightRadiusValue),
            BorderBottomLeftRadius(AzStyleBorderBottomLeftRadiusValue),
            BorderBottomRightRadius(AzStyleBorderBottomRightRadiusValue),
            BorderTopColor(AzStyleBorderTopColorValue),
            BorderRightColor(AzStyleBorderRightColorValue),
            BorderLeftColor(AzStyleBorderLeftColorValue),
            BorderBottomColor(AzStyleBorderBottomColorValue),
            BorderTopStyle(AzStyleBorderTopStyleValue),
            BorderRightStyle(AzStyleBorderRightStyleValue),
            BorderLeftStyle(AzStyleBorderLeftStyleValue),
            BorderBottomStyle(AzStyleBorderBottomStyleValue),
            BorderTopWidth(AzLayoutBorderTopWidthValue),
            BorderRightWidth(AzLayoutBorderRightWidthValue),
            BorderLeftWidth(AzLayoutBorderLeftWidthValue),
            BorderBottomWidth(AzLayoutBorderBottomWidthValue),
            BoxShadowLeft(AzStyleBoxShadowValue),
            BoxShadowRight(AzStyleBoxShadowValue),
            BoxShadowTop(AzStyleBoxShadowValue),
            BoxShadowBottom(AzStyleBoxShadowValue),
            ScrollbarStyle(AzScrollbarStyleValue),
            Opacity(AzStyleOpacityValue),
            Transform(AzStyleTransformVecValue),
            TransformOrigin(AzStyleTransformOriginValue),
            PerspectiveOrigin(AzStylePerspectiveOriginValue),
            BackfaceVisibility(AzStyleBackfaceVisibilityValue),
            MixBlendMode(AzStyleMixBlendModeValue),
            Filter(AzStyleFilterVecValue),
            BackdropFilter(AzStyleFilterVecValue),
            TextShadow(AzStyleBoxShadowValue),
        }

        /// Re-export of rust-allocated (stack based) `FileInputStateWrapper` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFileInputStateWrapper {
            pub inner: AzFileInputState,
            pub on_file_path_change: AzOptionFileInputOnPathChange,
            pub file_dialog_title: AzString,
            pub default_dir: AzOptionString,
            pub file_types: AzOptionFileTypeList,
        }

        /// Re-export of rust-allocated (stack based) `TextInputStateWrapper` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTextInputStateWrapper {
            pub inner: AzTextInputState,
            pub on_text_input: AzOptionTextInputOnTextInput,
            pub on_virtual_key_down: AzOptionTextInputOnVirtualKeyDown,
            pub on_focus_lost: AzOptionTextInputOnFocusLost,
            pub update_text_input_before_calling_focus_lost_fn: bool,
            pub update_text_input_before_calling_vk_down_fn: bool,
            pub cursor_animation: AzOptionTimerId,
        }

        /// Re-export of rust-allocated (stack based) `ProgressBar` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzProgressBar {
            pub state: AzProgressBarState,
            pub height: AzPixelValue,
            pub bar_background: AzStyleBackgroundContentVec,
            pub container_background: AzStyleBackgroundContentVec,
        }

        /// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMap` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzNodeTypeIdInfoMap {
            pub node_type_id: AzNodeTypeId,
            pub node_type_info: AzNodeTypeInfo,
        }

        /// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMap` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzInputOutputTypeIdInfoMap {
            pub io_type_id: AzInputOutputTypeId,
            pub io_info: AzInputOutputInfo,
        }

        /// Re-export of rust-allocated (stack based) `NodeTypeField` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
        pub struct AzNodeTypeField {
            pub key: AzString,
            pub value: AzNodeTypeFieldValue,
        }

        /// Re-export of rust-allocated (stack based) `CssPropertySource` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzCssPropertySource {
            Css(AzCssPath),
            Inline,
        }

        /// Re-export of rust-allocated (stack based) `VertexLayout` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzVertexLayout {
            pub fields: AzVertexAttributeVec,
        }

        /// Re-export of rust-allocated (stack based) `VertexArrayObject` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzVertexArrayObject {
            pub vertex_layout: AzVertexLayout,
            pub vao_id: u32,
            pub gl_context: AzGl,
            pub refcount: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `VertexBuffer` struct
        #[repr(C)]
        #[derive(Debug, PartialEq, PartialOrd)]
        pub struct AzVertexBuffer {
            pub vertex_buffer_id: u32,
            pub vertex_buffer_len: usize,
            pub vao: AzVertexArrayObject,
            pub index_buffer_id: u32,
            pub index_buffer_len: usize,
            pub index_buffer_format: AzIndexBufferFormat,
            pub refcount: *const c_void,
            pub run_destructor: bool,
        }

        /// Re-export of rust-allocated (stack based) `SvgMultiPolygon` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzSvgMultiPolygon {
            pub rings: AzSvgPathVec,
        }

        /// Re-export of rust-allocated (stack based) `SvgSimpleNode` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzSvgSimpleNode {
            Path(AzSvgPath),
            Circle(AzSvgCircle),
            Rect(AzSvgRect),
            CircleHole(AzSvgCircle),
            RectHole(AzSvgRect),
        }

        /// Re-export of rust-allocated (stack based) `TessellatedColoredGPUSvgNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTessellatedColoredGPUSvgNode {
            pub vertex_index_buffer: AzVertexBuffer,
        }

        /// Re-export of rust-allocated (stack based) `TessellatedGPUSvgNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTessellatedGPUSvgNode {
            pub vertex_index_buffer: AzVertexBuffer,
        }

        /// Re-export of rust-allocated (stack based) `XmlNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzXmlNode {
            pub tag: AzString,
            pub attributes: AzStringPairVec,
            pub children: AzXmlNodeVec,
            pub text: AzOptionString,
        }

        /// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`
        #[repr(C)]
        pub struct AzNodeTypeIdInfoMapVec {
            pub(crate) ptr: *const AzNodeTypeIdInfoMap,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNodeTypeIdInfoMapVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`
        #[repr(C)]
        pub struct AzInputOutputTypeIdInfoMapVec {
            pub(crate) ptr: *const AzInputOutputTypeIdInfoMap,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInputOutputTypeIdInfoMapVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<NodeTypeField>`
        #[repr(C)]
        pub struct AzNodeTypeFieldVec {
            pub(crate) ptr: *const AzNodeTypeField,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNodeTypeFieldVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<InlineLine>`
        #[repr(C)]
        pub struct AzInlineLineVec {
            pub(crate) ptr: *const AzInlineLine,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzInlineLineVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<CssProperty>`
        #[repr(C)]
        pub struct AzCssPropertyVec {
            pub(crate) ptr: *const AzCssProperty,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzCssPropertyVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`
        #[repr(C)]
        pub struct AzSvgMultiPolygonVec {
            pub(crate) ptr: *const AzSvgMultiPolygon,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzSvgMultiPolygonVecDestructor,
        }

        /// Wrapper over a Rust-allocated `Vec<SvgSimpleNode>`
        #[repr(C)]
        pub struct AzSvgSimpleNodeVec {
            pub(crate) ptr: *const AzSvgSimpleNode,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzSvgSimpleNodeVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `OptionCssProperty` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionCssProperty {
            None,
            Some(AzCssProperty),
        }

        /// Re-export of rust-allocated (stack based) `XmlTextError` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzXmlTextError {
            pub stream_error: AzXmlStreamError,
            pub pos: AzSvgParseErrorPosition,
        }

        /// Platform-specific window configuration, i.e. WM options that are not cross-platform
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzPlatformSpecificOptions {
            pub windows_options: AzWindowsWindowOptions,
            pub linux_options: AzLinuxWindowOptions,
            pub mac_options: AzMacWindowOptions,
            pub wasm_options: AzWasmWindowOptions,
        }

        /// Re-export of rust-allocated (stack based) `WindowState` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzWindowState {
            pub title: AzString,
            pub theme: AzWindowTheme,
            pub size: AzWindowSize,
            pub position: AzWindowPosition,
            pub flags: AzWindowFlags,
            pub debug_state: AzDebugState,
            pub keyboard_state: AzKeyboardState,
            pub mouse_state: AzMouseState,
            pub touch_state: AzTouchState,
            pub ime_position: AzImePosition,
            pub monitor: AzMonitor,
            pub platform_specific_options: AzPlatformSpecificOptions,
            pub renderer_options: AzRendererOptions,
            pub background_color: AzColorU,
            pub layout_callback: AzLayoutCallback,
            pub close_callback: AzOptionCallback,
        }

        /// Re-export of rust-allocated (stack based) `CallbackInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCallbackInfo {
            pub layout_results: *const c_void,
            pub layout_results_count: usize,
            pub renderer_resources: *const c_void,
            pub previous_window_state: *const c_void,
            pub current_window_state: *const c_void,
            pub modifiable_window_state: *mut AzWindowState,
            pub gl_context: *const AzOptionGl,
            pub image_cache: *mut c_void,
            pub system_fonts: *mut c_void,
            pub timers: *mut c_void,
            pub threads: *mut c_void,
            pub timers_removed: *mut c_void,
            pub threads_removed: *mut c_void,
            pub current_window_handle: *const AzRawWindowHandle,
            pub new_windows: *mut c_void,
            pub system_callbacks: *const AzSystemCallbacks,
            pub stop_propagation: *mut bool,
            pub focus_target: *mut c_void,
            pub words_changed_in_callbacks: *mut c_void,
            pub images_changed_in_callbacks: *mut c_void,
            pub image_masks_changed_in_callbacks: *mut c_void,
            pub css_properties_changed_in_callbacks: *mut c_void,
            pub current_scroll_states: *const c_void,
            pub nodes_scrolled_in_callback: *mut c_void,
            pub hit_dom_node: AzDomNodeId,
            pub cursor_relative_to_item: AzOptionLogicalPosition,
            pub cursor_in_viewport: AzOptionLogicalPosition,
            pub _reserved_ref: *const c_void,
            pub _reserved_mut: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `InlineText` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzInlineText {
            pub lines: AzInlineLineVec,
            pub content_size: AzLogicalSize,
            pub font_size_px: f32,
            pub last_word_index: usize,
            pub baseline_descender_px: f32,
        }

        /// CSS path to set the keyboard input focus
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFocusTargetPath {
            pub dom: AzDomId,
            pub css_path: AzCssPath,
        }

        /// Animation struct to start a new animation
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzAnimation {
            pub from: AzCssProperty,
            pub to: AzCssProperty,
            pub duration: AzDuration,
            pub repeat: AzAnimationRepeat,
            pub repeat_count: AzAnimationRepeatCount,
            pub easing: AzAnimationEasing,
            pub relayout_on_finish: bool,
        }

        /// Re-export of rust-allocated (stack based) `TimerCallbackInfo` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTimerCallbackInfo {
            pub callback_info: AzCallbackInfo,
            pub node_id: AzOptionDomNodeId,
            pub frame_start: AzInstant,
            pub call_count: usize,
            pub is_about_to_finish: bool,
            pub _reserved_ref: *const c_void,
            pub _reserved_mut: *mut c_void,
        }

        /// Re-export of rust-allocated (stack based) `NodeDataInlineCssProperty` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzNodeDataInlineCssProperty {
            Normal(AzCssProperty),
            Active(AzCssProperty),
            Focus(AzCssProperty),
            Hover(AzCssProperty),
        }

        /// Re-export of rust-allocated (stack based) `DynamicCssProperty` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzDynamicCssProperty {
            pub dynamic_id: AzString,
            pub default_value: AzCssProperty,
        }

        /// Re-export of rust-allocated (stack based) `Node` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNode {
            pub node_type: AzNodeTypeId,
            pub position: AzNodePosition,
            pub fields: AzNodeTypeFieldVec,
            pub connect_in: AzInputConnectionVec,
            pub connect_out: AzOutputConnectionVec,
        }

        /// Re-export of rust-allocated (stack based) `SvgNode` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzSvgNode {
            MultiPolygonCollection(AzSvgMultiPolygonVec),
            MultiPolygon(AzSvgMultiPolygon),
            MultiShape(AzSvgSimpleNodeVec),
            Path(AzSvgPath),
            Circle(AzSvgCircle),
            Rect(AzSvgRect),
        }

        /// Re-export of rust-allocated (stack based) `SvgStyledNode` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzSvgStyledNode {
            pub geometry: AzSvgNode,
            pub style: AzSvgStyle,
        }

        /// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`
        #[repr(C)]
        pub struct AzNodeDataInlineCssPropertyVec {
            pub(crate) ptr: *const AzNodeDataInlineCssProperty,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNodeDataInlineCssPropertyVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `OptionWindowState` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionWindowState {
            None,
            Some(AzWindowState),
        }

        /// Re-export of rust-allocated (stack based) `OptionInlineText` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionInlineText {
            None,
            Some(AzInlineText),
        }

        /// Re-export of rust-allocated (stack based) `XmlParseError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzXmlParseError {
            InvalidDeclaration(AzXmlTextError),
            InvalidComment(AzXmlTextError),
            InvalidPI(AzXmlTextError),
            InvalidDoctype(AzXmlTextError),
            InvalidEntity(AzXmlTextError),
            InvalidElement(AzXmlTextError),
            InvalidAttribute(AzXmlTextError),
            InvalidCdata(AzXmlTextError),
            InvalidCharData(AzXmlTextError),
            UnknownToken(AzSvgParseErrorPosition),
        }

        /// Options on how to initially create the window
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzWindowCreateOptions {
            pub state: AzWindowState,
            pub size_to_content: bool,
            pub renderer_type: AzOptionRendererOptions,
            pub theme: AzOptionWindowTheme,
            pub create_callback: AzOptionCallback,
            pub hot_reload: bool,
        }

        /// Defines the keyboard input focus target
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzFocusTarget {
            Id(AzDomNodeId),
            Path(AzFocusTargetPath),
            Previous,
            Next,
            First,
            Last,
            NoFocus,
        }

        /// Represents one single DOM node (node type, classes, ids and callbacks are stored here)
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeData {
            pub node_type: AzNodeType,
            pub dataset: AzOptionRefAny,
            pub ids_and_classes: AzIdOrClassVec,
            pub callbacks: AzCallbackDataVec,
            pub inline_css_props: AzNodeDataInlineCssPropertyVec,
            pub tab_index: AzOptionTabIndex,
            pub extra: *const c_void,
        }

        /// Re-export of rust-allocated (stack based) `CssDeclaration` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzCssDeclaration {
            Static(AzCssProperty),
            Dynamic(AzDynamicCssProperty),
        }

        /// Re-export of rust-allocated (stack based) `Button` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzButton {
            pub label: AzString,
            pub image: AzOptionImageRef,
            pub container_style: AzNodeDataInlineCssPropertyVec,
            pub label_style: AzNodeDataInlineCssPropertyVec,
            pub image_style: AzNodeDataInlineCssPropertyVec,
            pub on_click: AzOptionButtonOnClick,
        }

        /// Re-export of rust-allocated (stack based) `FileInput` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFileInput {
            pub state: AzFileInputStateWrapper,
            pub default_text: AzString,
            pub image: AzOptionImageRef,
            pub container_style: AzNodeDataInlineCssPropertyVec,
            pub label_style: AzNodeDataInlineCssPropertyVec,
            pub image_style: AzNodeDataInlineCssPropertyVec,
        }

        /// Re-export of rust-allocated (stack based) `CheckBox` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCheckBox {
            pub state: AzCheckBoxStateWrapper,
            pub container_style: AzNodeDataInlineCssPropertyVec,
            pub content_style: AzNodeDataInlineCssPropertyVec,
        }

        /// Re-export of rust-allocated (stack based) `Label` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzLabel {
            pub text: AzString,
            pub style: AzNodeDataInlineCssPropertyVec,
        }

        /// Re-export of rust-allocated (stack based) `ColorInput` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzColorInput {
            pub state: AzColorInputStateWrapper,
            pub style: AzNodeDataInlineCssPropertyVec,
        }

        /// Re-export of rust-allocated (stack based) `TextInput` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTextInput {
            pub state: AzTextInputStateWrapper,
            pub placeholder_style: AzNodeDataInlineCssPropertyVec,
            pub container_style: AzNodeDataInlineCssPropertyVec,
            pub label_style: AzNodeDataInlineCssPropertyVec,
        }

        /// Re-export of rust-allocated (stack based) `NumberInput` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNumberInput {
            pub text_input: AzTextInput,
            pub state: AzNumberInputStateWrapper,
        }

        /// Re-export of rust-allocated (stack based) `NodeIdNodeMap` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeIdNodeMap {
            pub node_id: AzNodeGraphNodeId,
            pub node: AzNode,
        }

        /// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`
        #[repr(C)]
        pub struct AzNodeIdNodeMapVec {
            pub(crate) ptr: *const AzNodeIdNodeMap,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNodeIdNodeMapVecDestructor,
        }

        /// Wrapper over a Rust-allocated `CssDeclaration`
        #[repr(C)]
        pub struct AzCssDeclarationVec {
            pub(crate) ptr: *const AzCssDeclaration,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzCssDeclarationVecDestructor,
        }

        /// Wrapper over a Rust-allocated `NodeDataVec`
        #[repr(C)]
        pub struct AzNodeDataVec {
            pub(crate) ptr: *const AzNodeData,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzNodeDataVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `XmlError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzXmlError {
            NoParserAvailable,
            InvalidXmlPrefixUri(AzSvgParseErrorPosition),
            UnexpectedXmlUri(AzSvgParseErrorPosition),
            UnexpectedXmlnsUri(AzSvgParseErrorPosition),
            InvalidElementNamePrefix(AzSvgParseErrorPosition),
            DuplicatedNamespace(AzDuplicatedNamespaceError),
            UnknownNamespace(AzUnknownNamespaceError),
            UnexpectedCloseTag(AzUnexpectedCloseTagError),
            UnexpectedEntityCloseTag(AzSvgParseErrorPosition),
            UnknownEntityReference(AzUnknownEntityReferenceError),
            MalformedEntityReference(AzSvgParseErrorPosition),
            EntityReferenceLoop(AzSvgParseErrorPosition),
            InvalidAttributeValue(AzSvgParseErrorPosition),
            DuplicatedAttribute(AzDuplicatedAttributeError),
            NoRootNode,
            SizeLimit,
            ParserError(AzXmlParseError),
        }

        /// Re-export of rust-allocated (stack based) `Dom` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzDom {
            pub root: AzNodeData,
            pub children: AzDomVec,
            pub total_children: usize,
        }

        /// Re-export of rust-allocated (stack based) `CssRuleBlock` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCssRuleBlock {
            pub path: AzCssPath,
            pub declarations: AzCssDeclarationVec,
        }

        /// Re-export of rust-allocated (stack based) `TabContent` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzTabContent {
            pub content: AzDom,
            pub has_padding: bool,
        }

        /// Re-export of rust-allocated (stack based) `Frame` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzFrame {
            pub title: AzString,
            pub flex_grow: f32,
            pub content: AzDom,
        }

        /// Re-export of rust-allocated (stack based) `NodeGraph` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzNodeGraph {
            pub node_types: AzNodeTypeIdInfoMapVec,
            pub input_output_types: AzInputOutputTypeIdInfoMapVec,
            pub nodes: AzNodeIdNodeMapVec,
            pub allow_multiple_root_nodes: bool,
            pub offset: AzLogicalPosition,
            pub style: AzNodeGraphStyle,
            pub callbacks: AzNodeGraphCallbacks,
            pub add_node_str: AzString,
            pub scale_factor: f32,
        }

        /// Re-export of rust-allocated (stack based) `StyledDom` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzStyledDom {
            pub root: AzNodeId,
            pub node_hierarchy: AzNodeHierarchyItemVec,
            pub node_data: AzNodeDataVec,
            pub styled_nodes: AzStyledNodeVec,
            pub cascade_info: AzCascadeInfoVec,
            pub nodes_with_window_callbacks: AzNodeIdVec,
            pub nodes_with_not_callbacks: AzNodeIdVec,
            pub nodes_with_datasets_and_callbacks: AzNodeIdVec,
            pub tag_ids_to_node_ids: AzTagIdToNodeIdMappingVec,
            pub non_leaf_nodes: AzParentWithNodeDepthVec,
            pub css_property_cache: AzCssPropertyCache,
        }

        /// Wrapper over a Rust-allocated `CssRuleBlock`
        #[repr(C)]
        pub struct AzCssRuleBlockVec {
            pub(crate) ptr: *const AzCssRuleBlock,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzCssRuleBlockVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `OptionDom` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzOptionDom {
            None,
            Some(AzDom),
        }

        /// Re-export of rust-allocated (stack based) `ResultXmlXmlError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzResultXmlXmlError {
            Ok(AzXml),
            Err(AzXmlError),
        }

        /// Re-export of rust-allocated (stack based) `SvgParseError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzSvgParseError {
            NoParserAvailable,
            ElementsLimitReached,
            NotAnUtf8Str,
            MalformedGZip,
            InvalidSize,
            ParsingFailed(AzXmlError),
        }

        /// Return value for an IFrame rendering callback.
        ///
        /// # Dual Size Model
        ///
        /// IFrame callbacks return two size/offset pairs to enable lazy loading and virtualization:
        ///
        /// ## Actual Content (`scroll_size` + `scroll_offset`)
        /// 
        /// The size and position of content that has **actually been rendered**.
        ///
        /// ## Virtual Content (`virtual_scroll_size` + `virtual_scroll_offset`)
        ///
        /// The size and position that the IFrame **pretends to have** for scrollbar sizing.
        ///
        /// # Conditional Re-invocation
        ///
        /// The callback will be re-invoked only when necessary:
        ///
        /// 1. **Initial render** - First appearance of IFrame
        /// 2. **Parent DOM recreated** - Parent was rebuilt from scratch
        /// 3. **Window resize (expansion)** - Window grows beyond `scroll_size` (ONCE per expansion)
        /// 4. **Scroll near edge** - User scrolls within 200px of content edge (ONCE per edge)
        /// 5. **Programmatic scroll** - `set_scroll_position()` scrolls beyond `scroll_size`
        ///
        /// See `IFrameCallbackReturn` documentation in `azul_core::callbacks` for detailed
        /// examples and behavior specifications.
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzIFrameCallbackReturn {
            /// The styled DOM with actual rendered content
            pub dom: AzStyledDom,
            /// Size of actual rendered content
            pub scroll_size: AzLogicalSize,
            /// Position of rendered content in virtual space
            pub scroll_offset: AzLogicalPosition,
            /// Size of virtual content (for scrollbar)
            pub virtual_scroll_size: AzLogicalSize,
            /// Position of virtual content (usually zero)
            pub virtual_scroll_offset: AzLogicalPosition,
        }

        /// Re-export of rust-allocated (stack based) `Stylesheet` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzStylesheet {
            pub rules: AzCssRuleBlockVec,
        }

        /// Wrapper over a Rust-allocated `Stylesheet`
        #[repr(C)]
        pub struct AzStylesheetVec {
            pub(crate) ptr: *const AzStylesheet,
            pub len: usize,
            pub cap: usize,
            pub destructor: AzStylesheetVecDestructor,
        }

        /// Re-export of rust-allocated (stack based) `ResultSvgXmlNodeSvgParseError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzResultSvgXmlNodeSvgParseError {
            Ok(AzSvgXmlNode),
            Err(AzSvgParseError),
        }

        /// Re-export of rust-allocated (stack based) `ResultSvgSvgParseError` struct
        #[repr(C, u8)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub enum AzResultSvgSvgParseError {
            Ok(AzSvg),
            Err(AzSvgParseError),
        }

        /// Re-export of rust-allocated (stack based) `Css` struct
        #[repr(C)]
        #[derive(Debug, Clone, PartialEq, PartialOrd)]
        pub struct AzCss {
            pub stylesheets: AzStylesheetVec,
        }
    }

    #[cfg(feature = "link-static")]
    #[allow(non_snake_case)]
    mod static_link {
        use core::{ffi::c_void, mem::transmute};

        use super::types::*;

        pub(crate) fn AzApp_new(data: AzRefAny, config: AzAppConfig) -> AzApp {
            unsafe { transmute(azul_dll::AzApp_new(transmute(data), transmute(config))) }
        }
        pub(crate) fn AzApp_addWindow(app: &mut AzApp, window: AzWindowCreateOptions) {
            unsafe { transmute(azul_dll::AzApp_addWindow(transmute(app), transmute(window))) }
        }
        pub(crate) fn AzApp_addImage(app: &mut AzApp, id: AzString, image: AzImageRef) {
            unsafe {
                transmute(azul_dll::AzApp_addImage(
                    transmute(app),
                    transmute(id),
                    transmute(image),
                ))
            }
        }
        pub(crate) fn AzApp_getMonitors(app: &AzApp) -> AzMonitorVec {
            unsafe { transmute(azul_dll::AzApp_getMonitors(transmute(app))) }
        }
        pub(crate) fn AzApp_run(app: &AzApp, window: AzWindowCreateOptions) {
            unsafe { transmute(azul_dll::AzApp_run(transmute(app), transmute(window))) }
        }
        pub(crate) fn AzApp_delete(object: &mut AzApp) {
            unsafe { transmute(azul_dll::AzApp_delete(transmute(object))) }
        }
        pub(crate) fn AzApp_deepCopy(object: &AzApp) -> AzApp {
            unsafe { transmute(azul_dll::AzApp_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzAppConfig_new(layout_solver: AzLayoutSolver) -> AzAppConfig {
            unsafe { transmute(azul_dll::AzAppConfig_new(transmute(layout_solver))) }
        }
        pub(crate) fn AzSystemCallbacks_libraryInternal() -> AzSystemCallbacks {
            unsafe { transmute(azul_dll::AzSystemCallbacks_libraryInternal()) }
        }
        pub(crate) fn AzWindowCreateOptions_new(
            layout_callback: AzLayoutCallbackType,
        ) -> AzWindowCreateOptions {
            unsafe {
                transmute(azul_dll::AzWindowCreateOptions_new(transmute(
                    layout_callback,
                )))
            }
        }
        pub(crate) fn AzLogicalPosition_new(x: f32, y: f32) -> AzLogicalPosition {
            unsafe { transmute(azul_dll::AzLogicalPosition_new(transmute(x), transmute(y))) }
        }
        pub(crate) fn AzLogicalPosition_zero() -> AzLogicalPosition {
            unsafe { transmute(azul_dll::AzLogicalPosition_zero()) }
        }
        pub(crate) fn AzLogicalSize_toPhysical(
            logicalsize: &AzLogicalSize,
            hidpi_factor: f32,
        ) -> AzPhysicalSizeU32 {
            unsafe {
                transmute(azul_dll::AzLogicalSize_toPhysical(
                    transmute(logicalsize),
                    transmute(hidpi_factor),
                ))
            }
        }
        pub(crate) fn AzWindowSize_getHidpiFactor(windowsize: &AzWindowSize) -> f32 {
            unsafe { transmute(azul_dll::AzWindowSize_getHidpiFactor(transmute(windowsize))) }
        }
        pub(crate) fn AzKeyboardState_shiftDown(keyboardstate: &AzKeyboardState) -> bool {
            unsafe {
                transmute(azul_dll::AzKeyboardState_shiftDown(transmute(
                    keyboardstate,
                )))
            }
        }
        pub(crate) fn AzKeyboardState_ctrlDown(keyboardstate: &AzKeyboardState) -> bool {
            unsafe { transmute(azul_dll::AzKeyboardState_ctrlDown(transmute(keyboardstate))) }
        }
        pub(crate) fn AzKeyboardState_altDown(keyboardstate: &AzKeyboardState) -> bool {
            unsafe { transmute(azul_dll::AzKeyboardState_altDown(transmute(keyboardstate))) }
        }
        pub(crate) fn AzKeyboardState_superDown(keyboardstate: &AzKeyboardState) -> bool {
            unsafe {
                transmute(azul_dll::AzKeyboardState_superDown(transmute(
                    keyboardstate,
                )))
            }
        }
        pub(crate) fn AzKeyboardState_isKeyDown(
            keyboardstate: &AzKeyboardState,
            key: AzVirtualKeyCode,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzKeyboardState_isKeyDown(
                    transmute(keyboardstate),
                    transmute(key),
                ))
            }
        }
        pub(crate) fn AzCursorPosition_getPosition(
            cursorposition: &AzCursorPosition,
        ) -> AzOptionLogicalPosition {
            unsafe {
                transmute(azul_dll::AzCursorPosition_getPosition(transmute(
                    cursorposition,
                )))
            }
        }
        pub(crate) fn AzWindowState_new(layout_callback: AzLayoutCallbackType) -> AzWindowState {
            unsafe { transmute(azul_dll::AzWindowState_new(transmute(layout_callback))) }
        }
        pub(crate) fn AzWindowState_default() -> AzWindowState {
            unsafe { transmute(azul_dll::AzWindowState_default()) }
        }
        pub(crate) fn AzCallbackInfo_getHitNode(callbackinfo: &AzCallbackInfo) -> AzDomNodeId {
            unsafe { transmute(azul_dll::AzCallbackInfo_getHitNode(transmute(callbackinfo))) }
        }
        pub(crate) fn AzCallbackInfo_getSystemTimeFn(
            callbackinfo: &AzCallbackInfo,
        ) -> AzGetSystemTimeFn {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getSystemTimeFn(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getCursorRelativeToViewport(
            callbackinfo: &AzCallbackInfo,
        ) -> AzOptionLogicalPosition {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getCursorRelativeToViewport(
                    transmute(callbackinfo),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getCursorRelativeToNode(
            callbackinfo: &AzCallbackInfo,
        ) -> AzOptionLogicalPosition {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getCursorRelativeToNode(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getCurrentWindowState(
            callbackinfo: &AzCallbackInfo,
        ) -> AzWindowState {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getCurrentWindowState(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getCurrentKeyboardState(
            callbackinfo: &AzCallbackInfo,
        ) -> AzKeyboardState {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getCurrentKeyboardState(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getCurrentMouseState(
            callbackinfo: &AzCallbackInfo,
        ) -> AzMouseState {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getCurrentMouseState(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getPreviousWindowState(
            callbackinfo: &AzCallbackInfo,
        ) -> AzOptionWindowState {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getPreviousWindowState(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getPreviousKeyboardState(
            callbackinfo: &AzCallbackInfo,
        ) -> AzOptionKeyboardState {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getPreviousKeyboardState(
                    transmute(callbackinfo),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getPreviousMouseState(
            callbackinfo: &AzCallbackInfo,
        ) -> AzOptionMouseState {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getPreviousMouseState(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getCurrentWindowHandle(
            callbackinfo: &AzCallbackInfo,
        ) -> AzRawWindowHandle {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getCurrentWindowHandle(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getGlContext(callbackinfo: &AzCallbackInfo) -> AzOptionGl {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getGlContext(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_getScrollPosition(
            callbackinfo: &AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionLogicalPosition {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getScrollPosition(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getDataset(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionRefAny {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getDataset(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getNodeIdOfRootDataset(
            callbackinfo: &mut AzCallbackInfo,
            dataset: AzRefAny,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getNodeIdOfRootDataset(
                    transmute(callbackinfo),
                    transmute(dataset),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getStringContents(
            callbackinfo: &AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionString {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getStringContents(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getInlineText(
            callbackinfo: &AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionInlineText {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getInlineText(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getFontRef(
            callbackinfo: &AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionFontRef {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getFontRef(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getTextLayoutOptions(
            callbackinfo: &AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionResolvedTextLayoutOptions {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getTextLayoutOptions(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_shapeText(
            callbackinfo: &AzCallbackInfo,
            node_id: AzDomNodeId,
            text: AzString,
        ) -> AzOptionInlineText {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_shapeText(
                    transmute(callbackinfo),
                    transmute(node_id),
                    transmute(text),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getIndexInParent(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> usize {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getIndexInParent(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getParent(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getParent(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getPreviousSibling(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getPreviousSibling(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getNextSibling(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getNextSibling(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getFirstChild(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getFirstChild(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getLastChild(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getLastChild(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getNodePosition(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionPositionInfo {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getNodePosition(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getNodeSize(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionLogicalSize {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getNodeSize(
                    transmute(callbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getComputedCssProperty(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
            property_type: AzCssPropertyType,
        ) -> AzOptionCssProperty {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getComputedCssProperty(
                    transmute(callbackinfo),
                    transmute(node_id),
                    transmute(property_type),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_setWindowState(
            callbackinfo: &mut AzCallbackInfo,
            new_state: AzWindowState,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_setWindowState(
                    transmute(callbackinfo),
                    transmute(new_state),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_setFocus(
            callbackinfo: &mut AzCallbackInfo,
            target: AzFocusTarget,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_setFocus(
                    transmute(callbackinfo),
                    transmute(target),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_setCssProperty(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
            new_property: AzCssProperty,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_setCssProperty(
                    transmute(callbackinfo),
                    transmute(node_id),
                    transmute(new_property),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_setScrollPosition(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
            scroll_position: AzLogicalPosition,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_setScrollPosition(
                    transmute(callbackinfo),
                    transmute(node_id),
                    transmute(scroll_position),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_setStringContents(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
            string: AzString,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_setStringContents(
                    transmute(callbackinfo),
                    transmute(node_id),
                    transmute(string),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_addImage(
            callbackinfo: &mut AzCallbackInfo,
            id: AzString,
            image: AzImageRef,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_addImage(
                    transmute(callbackinfo),
                    transmute(id),
                    transmute(image),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_hasImage(callbackinfo: &AzCallbackInfo, id: AzString) -> bool {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_hasImage(
                    transmute(callbackinfo),
                    transmute(id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_getImage(
            callbackinfo: &AzCallbackInfo,
            id: AzString,
        ) -> AzOptionImageRef {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_getImage(
                    transmute(callbackinfo),
                    transmute(id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_updateImage(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
            new_image: AzImageRef,
            image_type: AzUpdateImageType,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_updateImage(
                    transmute(callbackinfo),
                    transmute(node_id),
                    transmute(new_image),
                    transmute(image_type),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_deleteImage(callbackinfo: &mut AzCallbackInfo, id: AzString) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_deleteImage(
                    transmute(callbackinfo),
                    transmute(id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_updateImageMask(
            callbackinfo: &mut AzCallbackInfo,
            node_id: AzDomNodeId,
            new_mask: AzImageMask,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_updateImageMask(
                    transmute(callbackinfo),
                    transmute(node_id),
                    transmute(new_mask),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_stopPropagation(callbackinfo: &mut AzCallbackInfo) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_stopPropagation(transmute(
                    callbackinfo,
                )))
            }
        }
        pub(crate) fn AzCallbackInfo_createWindow(
            callbackinfo: &mut AzCallbackInfo,
            new_window: AzWindowCreateOptions,
        ) {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_createWindow(
                    transmute(callbackinfo),
                    transmute(new_window),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_startTimer(
            callbackinfo: &mut AzCallbackInfo,
            timer: AzTimer,
        ) -> AzTimerId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_startTimer(
                    transmute(callbackinfo),
                    transmute(timer),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_startAnimation(
            callbackinfo: &mut AzCallbackInfo,
            node: AzDomNodeId,
            animation: AzAnimation,
        ) -> AzOptionTimerId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_startAnimation(
                    transmute(callbackinfo),
                    transmute(node),
                    transmute(animation),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_stopTimer(
            callbackinfo: &mut AzCallbackInfo,
            timer_id: AzTimerId,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_stopTimer(
                    transmute(callbackinfo),
                    transmute(timer_id),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_startThread(
            callbackinfo: &mut AzCallbackInfo,
            thread_initialize_data: AzRefAny,
            writeback_data: AzRefAny,
            callback: AzThreadCallbackType,
        ) -> AzOptionThreadId {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_startThread(
                    transmute(callbackinfo),
                    transmute(thread_initialize_data),
                    transmute(writeback_data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_sendThreadMsg(
            callbackinfo: &mut AzCallbackInfo,
            thread_id: AzThreadId,
            msg: AzThreadSendMsg,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_sendThreadMsg(
                    transmute(callbackinfo),
                    transmute(thread_id),
                    transmute(msg),
                ))
            }
        }
        pub(crate) fn AzCallbackInfo_stopThread(
            callbackinfo: &mut AzCallbackInfo,
            thread_id: AzThreadId,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzCallbackInfo_stopThread(
                    transmute(callbackinfo),
                    transmute(thread_id),
                ))
            }
        }
        pub(crate) fn AzPositionInfo_isPositioned(positioninfo: &AzPositionInfo) -> bool {
            unsafe {
                transmute(azul_dll::AzPositionInfo_isPositioned(transmute(
                    positioninfo,
                )))
            }
        }
        pub(crate) fn AzPositionInfo_getStaticOffset(
            positioninfo: &AzPositionInfo,
        ) -> AzLogicalPosition {
            unsafe {
                transmute(azul_dll::AzPositionInfo_getStaticOffset(transmute(
                    positioninfo,
                )))
            }
        }
        pub(crate) fn AzPositionInfo_getRelativeOffset(
            positioninfo: &AzPositionInfo,
        ) -> AzLogicalPosition {
            unsafe {
                transmute(azul_dll::AzPositionInfo_getRelativeOffset(transmute(
                    positioninfo,
                )))
            }
        }
        pub(crate) fn AzHidpiAdjustedBounds_getLogicalSize(
            hidpiadjustedbounds: &AzHidpiAdjustedBounds,
        ) -> AzLogicalSize {
            unsafe {
                transmute(azul_dll::AzHidpiAdjustedBounds_getLogicalSize(transmute(
                    hidpiadjustedbounds,
                )))
            }
        }
        pub(crate) fn AzHidpiAdjustedBounds_getPhysicalSize(
            hidpiadjustedbounds: &AzHidpiAdjustedBounds,
        ) -> AzPhysicalSizeU32 {
            unsafe {
                transmute(azul_dll::AzHidpiAdjustedBounds_getPhysicalSize(transmute(
                    hidpiadjustedbounds,
                )))
            }
        }
        pub(crate) fn AzHidpiAdjustedBounds_getHidpiFactor(
            hidpiadjustedbounds: &AzHidpiAdjustedBounds,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzHidpiAdjustedBounds_getHidpiFactor(transmute(
                    hidpiadjustedbounds,
                )))
            }
        }
        pub(crate) fn AzInlineText_hitTest(
            inlinetext: &AzInlineText,
            position: AzLogicalPosition,
        ) -> AzInlineTextHitVec {
            unsafe {
                transmute(azul_dll::AzInlineText_hitTest(
                    transmute(inlinetext),
                    transmute(position),
                ))
            }
        }
        pub(crate) fn AzResolvedTextLayoutOptions_default() -> AzResolvedTextLayoutOptions {
            unsafe { transmute(azul_dll::AzResolvedTextLayoutOptions_default()) }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getGlContext(
            renderimagecallbackinfo: &AzRenderImageCallbackInfo,
        ) -> AzOptionGl {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getGlContext(transmute(
                    renderimagecallbackinfo,
                )))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getBounds(
            renderimagecallbackinfo: &AzRenderImageCallbackInfo,
        ) -> AzHidpiAdjustedBounds {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getBounds(transmute(
                    renderimagecallbackinfo,
                )))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getCallbackNodeId(
            renderimagecallbackinfo: &AzRenderImageCallbackInfo,
        ) -> AzDomNodeId {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getCallbackNodeId(
                    transmute(renderimagecallbackinfo),
                ))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getInlineText(
            renderimagecallbackinfo: &AzRenderImageCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionInlineText {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getInlineText(
                    transmute(renderimagecallbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getIndexInParent(
            renderimagecallbackinfo: &mut AzRenderImageCallbackInfo,
            node_id: AzDomNodeId,
        ) -> usize {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getIndexInParent(
                    transmute(renderimagecallbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getParent(
            renderimagecallbackinfo: &mut AzRenderImageCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getParent(
                    transmute(renderimagecallbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getPreviousSibling(
            renderimagecallbackinfo: &mut AzRenderImageCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getPreviousSibling(
                    transmute(renderimagecallbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getNextSibling(
            renderimagecallbackinfo: &mut AzRenderImageCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getNextSibling(
                    transmute(renderimagecallbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getFirstChild(
            renderimagecallbackinfo: &mut AzRenderImageCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getFirstChild(
                    transmute(renderimagecallbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzRenderImageCallbackInfo_getLastChild(
            renderimagecallbackinfo: &mut AzRenderImageCallbackInfo,
            node_id: AzDomNodeId,
        ) -> AzOptionDomNodeId {
            unsafe {
                transmute(azul_dll::AzRenderImageCallbackInfo_getLastChild(
                    transmute(renderimagecallbackinfo),
                    transmute(node_id),
                ))
            }
        }
        pub(crate) fn AzRefCount_canBeShared(refcount: &AzRefCount) -> bool {
            unsafe { transmute(azul_dll::AzRefCount_canBeShared(transmute(refcount))) }
        }
        pub(crate) fn AzRefCount_canBeSharedMut(refcount: &AzRefCount) -> bool {
            unsafe { transmute(azul_dll::AzRefCount_canBeSharedMut(transmute(refcount))) }
        }
        pub(crate) fn AzRefCount_increaseRef(refcount: &mut AzRefCount) {
            unsafe { transmute(azul_dll::AzRefCount_increaseRef(transmute(refcount))) }
        }
        pub(crate) fn AzRefCount_decreaseRef(refcount: &mut AzRefCount) {
            unsafe { transmute(azul_dll::AzRefCount_decreaseRef(transmute(refcount))) }
        }
        pub(crate) fn AzRefCount_increaseRefmut(refcount: &mut AzRefCount) {
            unsafe { transmute(azul_dll::AzRefCount_increaseRefmut(transmute(refcount))) }
        }
        pub(crate) fn AzRefCount_decreaseRefmut(refcount: &mut AzRefCount) {
            unsafe { transmute(azul_dll::AzRefCount_decreaseRefmut(transmute(refcount))) }
        }
        pub(crate) fn AzRefCount_delete(object: &mut AzRefCount) {
            unsafe { transmute(azul_dll::AzRefCount_delete(transmute(object))) }
        }
        pub(crate) fn AzRefCount_deepCopy(object: &AzRefCount) -> AzRefCount {
            unsafe { transmute(azul_dll::AzRefCount_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzRefAny_newC(
            ptr: *const c_void,
            len: usize,
            type_id: u64,
            type_name: AzString,
            destructor: AzRefAnyDestructorType,
        ) -> AzRefAny {
            unsafe {
                transmute(azul_dll::AzRefAny_newC(
                    transmute(ptr),
                    transmute(len),
                    transmute(type_id),
                    transmute(type_name),
                    transmute(destructor),
                ))
            }
        }
        pub(crate) fn AzRefAny_getTypeId(refany: &AzRefAny) -> u64 {
            unsafe { transmute(azul_dll::AzRefAny_getTypeId(transmute(refany))) }
        }
        pub(crate) fn AzRefAny_getTypeName(refany: &AzRefAny) -> AzString {
            unsafe { transmute(azul_dll::AzRefAny_getTypeName(transmute(refany))) }
        }
        pub(crate) fn AzRefAny_delete(object: &mut AzRefAny) {
            unsafe { transmute(azul_dll::AzRefAny_delete(transmute(object))) }
        }
        pub(crate) fn AzRefAny_deepCopy(object: &AzRefAny) -> AzRefAny {
            unsafe { transmute(azul_dll::AzRefAny_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzLayoutCallbackInfo_getGlContext(
            layoutcallbackinfo: &AzLayoutCallbackInfo,
        ) -> AzOptionGl {
            unsafe {
                transmute(azul_dll::AzLayoutCallbackInfo_getGlContext(transmute(
                    layoutcallbackinfo,
                )))
            }
        }
        pub(crate) fn AzLayoutCallbackInfo_getSystemFonts(
            layoutcallbackinfo: &AzLayoutCallbackInfo,
        ) -> AzStringPairVec {
            unsafe {
                transmute(azul_dll::AzLayoutCallbackInfo_getSystemFonts(transmute(
                    layoutcallbackinfo,
                )))
            }
        }
        pub(crate) fn AzLayoutCallbackInfo_getImage(
            layoutcallbackinfo: &AzLayoutCallbackInfo,
            id: AzString,
        ) -> AzOptionImageRef {
            unsafe {
                transmute(azul_dll::AzLayoutCallbackInfo_getImage(
                    transmute(layoutcallbackinfo),
                    transmute(id),
                ))
            }
        }
        pub(crate) fn AzDom_new(node_type: AzNodeType) -> AzDom {
            unsafe { transmute(azul_dll::AzDom_new(transmute(node_type))) }
        }
        pub(crate) fn AzDom_body() -> AzDom {
            unsafe { transmute(azul_dll::AzDom_body()) }
        }
        pub(crate) fn AzDom_div() -> AzDom {
            unsafe { transmute(azul_dll::AzDom_div()) }
        }
        pub(crate) fn AzDom_br() -> AzDom {
            unsafe { transmute(azul_dll::AzDom_br()) }
        }
        pub(crate) fn AzDom_text(string: AzString) -> AzDom {
            unsafe { transmute(azul_dll::AzDom_text(transmute(string))) }
        }
        pub(crate) fn AzDom_image(image: AzImageRef) -> AzDom {
            unsafe { transmute(azul_dll::AzDom_image(transmute(image))) }
        }
        pub(crate) fn AzDom_iframe(data: AzRefAny, callback: AzIFrameCallbackType) -> AzDom {
            unsafe { transmute(azul_dll::AzDom_iframe(transmute(data), transmute(callback))) }
        }
        pub(crate) fn AzDom_setNodeType(dom: &mut AzDom, node_type: AzNodeType) {
            unsafe {
                transmute(azul_dll::AzDom_setNodeType(
                    transmute(dom),
                    transmute(node_type),
                ))
            }
        }
        pub(crate) fn AzDom_withNodeType(dom: &mut AzDom, node_type: AzNodeType) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withNodeType(
                    transmute(dom),
                    transmute(node_type),
                ))
            }
        }
        pub(crate) fn AzDom_setDataset(dom: &mut AzDom, dataset: AzRefAny) {
            unsafe {
                transmute(azul_dll::AzDom_setDataset(
                    transmute(dom),
                    transmute(dataset),
                ))
            }
        }
        pub(crate) fn AzDom_withDataset(dom: &mut AzDom, dataset: AzRefAny) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withDataset(
                    transmute(dom),
                    transmute(dataset),
                ))
            }
        }
        pub(crate) fn AzDom_setIdsAndClasses(dom: &mut AzDom, ids_and_classes: AzIdOrClassVec) {
            unsafe {
                transmute(azul_dll::AzDom_setIdsAndClasses(
                    transmute(dom),
                    transmute(ids_and_classes),
                ))
            }
        }
        pub(crate) fn AzDom_withIdsAndClasses(
            dom: &mut AzDom,
            ids_and_classes: AzIdOrClassVec,
        ) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withIdsAndClasses(
                    transmute(dom),
                    transmute(ids_and_classes),
                ))
            }
        }
        pub(crate) fn AzDom_setCallbacks(dom: &mut AzDom, callbacks: AzCallbackDataVec) {
            unsafe {
                transmute(azul_dll::AzDom_setCallbacks(
                    transmute(dom),
                    transmute(callbacks),
                ))
            }
        }
        pub(crate) fn AzDom_withCallbacks(dom: &mut AzDom, callbacks: AzCallbackDataVec) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withCallbacks(
                    transmute(dom),
                    transmute(callbacks),
                ))
            }
        }
        pub(crate) fn AzDom_setInlineCssProps(
            dom: &mut AzDom,
            css_properties: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzDom_setInlineCssProps(
                    transmute(dom),
                    transmute(css_properties),
                ))
            }
        }
        pub(crate) fn AzDom_withInlineCssProps(
            dom: &mut AzDom,
            css_properties: AzNodeDataInlineCssPropertyVec,
        ) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withInlineCssProps(
                    transmute(dom),
                    transmute(css_properties),
                ))
            }
        }
        pub(crate) fn AzDom_addCallback(
            dom: &mut AzDom,
            event: AzEventFilter,
            data: AzRefAny,
            callback: AzCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzDom_addCallback(
                    transmute(dom),
                    transmute(event),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzDom_withCallback(
            dom: &mut AzDom,
            event: AzEventFilter,
            data: AzRefAny,
            callback: AzCallbackType,
        ) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withCallback(
                    transmute(dom),
                    transmute(event),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzDom_addChild(dom: &mut AzDom, child: AzDom) {
            unsafe { transmute(azul_dll::AzDom_addChild(transmute(dom), transmute(child))) }
        }
        pub(crate) fn AzDom_withChild(dom: &mut AzDom, child: AzDom) -> AzDom {
            unsafe { transmute(azul_dll::AzDom_withChild(transmute(dom), transmute(child))) }
        }
        pub(crate) fn AzDom_setChildren(dom: &mut AzDom, children: AzDomVec) {
            unsafe {
                transmute(azul_dll::AzDom_setChildren(
                    transmute(dom),
                    transmute(children),
                ))
            }
        }
        pub(crate) fn AzDom_withChildren(dom: &mut AzDom, children: AzDomVec) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withChildren(
                    transmute(dom),
                    transmute(children),
                ))
            }
        }
        pub(crate) fn AzDom_addId(dom: &mut AzDom, id: AzString) {
            unsafe { transmute(azul_dll::AzDom_addId(transmute(dom), transmute(id))) }
        }
        pub(crate) fn AzDom_withId(dom: &mut AzDom, id: AzString) -> AzDom {
            unsafe { transmute(azul_dll::AzDom_withId(transmute(dom), transmute(id))) }
        }
        pub(crate) fn AzDom_addClass(dom: &mut AzDom, class: AzString) {
            unsafe { transmute(azul_dll::AzDom_addClass(transmute(dom), transmute(class))) }
        }
        pub(crate) fn AzDom_withClass(dom: &mut AzDom, class: AzString) -> AzDom {
            unsafe { transmute(azul_dll::AzDom_withClass(transmute(dom), transmute(class))) }
        }
        pub(crate) fn AzDom_addCssProperty(dom: &mut AzDom, prop: AzCssProperty) {
            unsafe {
                transmute(azul_dll::AzDom_addCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_withCssProperty(dom: &mut AzDom, prop: AzCssProperty) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_addHoverCssProperty(dom: &mut AzDom, prop: AzCssProperty) {
            unsafe {
                transmute(azul_dll::AzDom_addHoverCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_withHoverCssProperty(dom: &mut AzDom, prop: AzCssProperty) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withHoverCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_addActiveCssProperty(dom: &mut AzDom, prop: AzCssProperty) {
            unsafe {
                transmute(azul_dll::AzDom_addActiveCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_withActiveCssProperty(dom: &mut AzDom, prop: AzCssProperty) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withActiveCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_addFocusCssProperty(dom: &mut AzDom, prop: AzCssProperty) {
            unsafe {
                transmute(azul_dll::AzDom_addFocusCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_withFocusCssProperty(dom: &mut AzDom, prop: AzCssProperty) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withFocusCssProperty(
                    transmute(dom),
                    transmute(prop),
                ))
            }
        }
        pub(crate) fn AzDom_setInlineStyle(dom: &mut AzDom, style: AzString) {
            unsafe {
                transmute(azul_dll::AzDom_setInlineStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_withInlineStyle(dom: &mut AzDom, style: AzString) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withInlineStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_setInlineHoverStyle(dom: &mut AzDom, style: AzString) {
            unsafe {
                transmute(azul_dll::AzDom_setInlineHoverStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_withInlineHoverStyle(dom: &mut AzDom, style: AzString) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withInlineHoverStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_setInlineActiveStyle(dom: &mut AzDom, style: AzString) {
            unsafe {
                transmute(azul_dll::AzDom_setInlineActiveStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_withInlineActiveStyle(dom: &mut AzDom, style: AzString) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withInlineActiveStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_setInlineFocusStyle(dom: &mut AzDom, style: AzString) {
            unsafe {
                transmute(azul_dll::AzDom_setInlineFocusStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_withInlineFocusStyle(dom: &mut AzDom, style: AzString) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withInlineFocusStyle(
                    transmute(dom),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzDom_setClipMask(dom: &mut AzDom, clip_mask: AzImageMask) {
            unsafe {
                transmute(azul_dll::AzDom_setClipMask(
                    transmute(dom),
                    transmute(clip_mask),
                ))
            }
        }
        pub(crate) fn AzDom_withClipMask(dom: &mut AzDom, clip_mask: AzImageMask) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withClipMask(
                    transmute(dom),
                    transmute(clip_mask),
                ))
            }
        }
        pub(crate) fn AzDom_setTabIndex(dom: &mut AzDom, tab_index: AzTabIndex) {
            unsafe {
                transmute(azul_dll::AzDom_setTabIndex(
                    transmute(dom),
                    transmute(tab_index),
                ))
            }
        }
        pub(crate) fn AzDom_withTabIndex(dom: &mut AzDom, tab_index: AzTabIndex) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withTabIndex(
                    transmute(dom),
                    transmute(tab_index),
                ))
            }
        }
        pub(crate) fn AzDom_setAccessibilityInfo(
            dom: &mut AzDom,
            accessibility_info: AzAccessibilityInfo,
        ) {
            unsafe {
                transmute(azul_dll::AzDom_setAccessibilityInfo(
                    transmute(dom),
                    transmute(accessibility_info),
                ))
            }
        }
        pub(crate) fn AzDom_withAccessibilityInfo(
            dom: &mut AzDom,
            accessibility_info: AzAccessibilityInfo,
        ) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withAccessibilityInfo(
                    transmute(dom),
                    transmute(accessibility_info),
                ))
            }
        }
        pub(crate) fn AzDom_setMenuBar(dom: &mut AzDom, menu_bar: AzMenu) {
            unsafe {
                transmute(azul_dll::AzDom_setMenuBar(
                    transmute(dom),
                    transmute(menu_bar),
                ))
            }
        }
        pub(crate) fn AzDom_withMenuBar(dom: &mut AzDom, menu_bar: AzMenu) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withMenuBar(
                    transmute(dom),
                    transmute(menu_bar),
                ))
            }
        }
        pub(crate) fn AzDom_setContextMenu(dom: &mut AzDom, context_menu: AzMenu) {
            unsafe {
                transmute(azul_dll::AzDom_setContextMenu(
                    transmute(dom),
                    transmute(context_menu),
                ))
            }
        }
        pub(crate) fn AzDom_withContextMenu(dom: &mut AzDom, context_menu: AzMenu) -> AzDom {
            unsafe {
                transmute(azul_dll::AzDom_withContextMenu(
                    transmute(dom),
                    transmute(context_menu),
                ))
            }
        }
        pub(crate) fn AzDom_hash(dom: &AzDom) -> u64 {
            unsafe { transmute(azul_dll::AzDom_hash(transmute(dom))) }
        }
        pub(crate) fn AzDom_nodeCount(dom: &AzDom) -> usize {
            unsafe { transmute(azul_dll::AzDom_nodeCount(transmute(dom))) }
        }
        pub(crate) fn AzDom_getHtmlString(dom: &mut AzDom) -> AzString {
            unsafe { transmute(azul_dll::AzDom_getHtmlString(transmute(dom))) }
        }
        pub(crate) fn AzDom_getHtmlStringTest(dom: &mut AzDom) -> AzString {
            unsafe { transmute(azul_dll::AzDom_getHtmlStringTest(transmute(dom))) }
        }
        pub(crate) fn AzDom_style(dom: &mut AzDom, css: AzCss) -> AzStyledDom {
            unsafe { transmute(azul_dll::AzDom_style(transmute(dom), transmute(css))) }
        }
        pub(crate) fn AzNodeData_new(node_type: AzNodeType) -> AzNodeData {
            unsafe { transmute(azul_dll::AzNodeData_new(transmute(node_type))) }
        }
        pub(crate) fn AzNodeData_body() -> AzNodeData {
            unsafe { transmute(azul_dll::AzNodeData_body()) }
        }
        pub(crate) fn AzNodeData_div() -> AzNodeData {
            unsafe { transmute(azul_dll::AzNodeData_div()) }
        }
        pub(crate) fn AzNodeData_br() -> AzNodeData {
            unsafe { transmute(azul_dll::AzNodeData_br()) }
        }
        pub(crate) fn AzNodeData_text(string: AzString) -> AzNodeData {
            unsafe { transmute(azul_dll::AzNodeData_text(transmute(string))) }
        }
        pub(crate) fn AzNodeData_image(image: AzImageRef) -> AzNodeData {
            unsafe { transmute(azul_dll::AzNodeData_image(transmute(image))) }
        }
        pub(crate) fn AzNodeData_iframe(
            data: AzRefAny,
            callback: AzIFrameCallbackType,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_iframe(
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNodeData_setNodeType(nodedata: &mut AzNodeData, node_type: AzNodeType) {
            unsafe {
                transmute(azul_dll::AzNodeData_setNodeType(
                    transmute(nodedata),
                    transmute(node_type),
                ))
            }
        }
        pub(crate) fn AzNodeData_withNodeType(
            nodedata: &mut AzNodeData,
            node_type: AzNodeType,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withNodeType(
                    transmute(nodedata),
                    transmute(node_type),
                ))
            }
        }
        pub(crate) fn AzNodeData_setDataset(nodedata: &mut AzNodeData, dataset: AzRefAny) {
            unsafe {
                transmute(azul_dll::AzNodeData_setDataset(
                    transmute(nodedata),
                    transmute(dataset),
                ))
            }
        }
        pub(crate) fn AzNodeData_withDataset(
            nodedata: &mut AzNodeData,
            dataset: AzRefAny,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withDataset(
                    transmute(nodedata),
                    transmute(dataset),
                ))
            }
        }
        pub(crate) fn AzNodeData_setIdsAndClasses(
            nodedata: &mut AzNodeData,
            ids_and_classes: AzIdOrClassVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNodeData_setIdsAndClasses(
                    transmute(nodedata),
                    transmute(ids_and_classes),
                ))
            }
        }
        pub(crate) fn AzNodeData_withIdsAndClasses(
            nodedata: &mut AzNodeData,
            ids_and_classes: AzIdOrClassVec,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withIdsAndClasses(
                    transmute(nodedata),
                    transmute(ids_and_classes),
                ))
            }
        }
        pub(crate) fn AzNodeData_addCallback(
            nodedata: &mut AzNodeData,
            event: AzEventFilter,
            data: AzRefAny,
            callback: AzCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzNodeData_addCallback(
                    transmute(nodedata),
                    transmute(event),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNodeData_withCallback(
            nodedata: &mut AzNodeData,
            event: AzEventFilter,
            data: AzRefAny,
            callback: AzCallbackType,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withCallback(
                    transmute(nodedata),
                    transmute(event),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNodeData_setCallbacks(
            nodedata: &mut AzNodeData,
            callbacks: AzCallbackDataVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNodeData_setCallbacks(
                    transmute(nodedata),
                    transmute(callbacks),
                ))
            }
        }
        pub(crate) fn AzNodeData_withCallbacks(
            nodedata: &mut AzNodeData,
            callbacks: AzCallbackDataVec,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withCallbacks(
                    transmute(nodedata),
                    transmute(callbacks),
                ))
            }
        }
        pub(crate) fn AzNodeData_setInlineCssProps(
            nodedata: &mut AzNodeData,
            css_properties: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNodeData_setInlineCssProps(
                    transmute(nodedata),
                    transmute(css_properties),
                ))
            }
        }
        pub(crate) fn AzNodeData_withInlineCssProps(
            nodedata: &mut AzNodeData,
            css_properties: AzNodeDataInlineCssPropertyVec,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withInlineCssProps(
                    transmute(nodedata),
                    transmute(css_properties),
                ))
            }
        }
        pub(crate) fn AzNodeData_setInlineStyle(nodedata: &mut AzNodeData, style: AzString) {
            unsafe {
                transmute(azul_dll::AzNodeData_setInlineStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_withInlineStyle(
            nodedata: &mut AzNodeData,
            style: AzString,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withInlineStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_setInlineHoverStyle(nodedata: &mut AzNodeData, style: AzString) {
            unsafe {
                transmute(azul_dll::AzNodeData_setInlineHoverStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_withInlineHoverStyle(
            nodedata: &mut AzNodeData,
            style: AzString,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withInlineHoverStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_setInlineActiveStyle(nodedata: &mut AzNodeData, style: AzString) {
            unsafe {
                transmute(azul_dll::AzNodeData_setInlineActiveStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_withInlineActiveStyle(
            nodedata: &mut AzNodeData,
            style: AzString,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withInlineActiveStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_setInlineFocusStyle(nodedata: &mut AzNodeData, style: AzString) {
            unsafe {
                transmute(azul_dll::AzNodeData_setInlineFocusStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_withInlineFocusStyle(
            nodedata: &mut AzNodeData,
            style: AzString,
        ) -> AzNodeData {
            unsafe {
                transmute(azul_dll::AzNodeData_withInlineFocusStyle(
                    transmute(nodedata),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNodeData_setClipMask(nodedata: &mut AzNodeData, image_mask: AzImageMask) {
            unsafe {
                transmute(azul_dll::AzNodeData_setClipMask(
                    transmute(nodedata),
                    transmute(image_mask),
                ))
            }
        }
        pub(crate) fn AzNodeData_setTabIndex(nodedata: &mut AzNodeData, tab_index: AzTabIndex) {
            unsafe {
                transmute(azul_dll::AzNodeData_setTabIndex(
                    transmute(nodedata),
                    transmute(tab_index),
                ))
            }
        }
        pub(crate) fn AzNodeData_setAccessibilityInfo(
            nodedata: &mut AzNodeData,
            accessibility_info: AzAccessibilityInfo,
        ) {
            unsafe {
                transmute(azul_dll::AzNodeData_setAccessibilityInfo(
                    transmute(nodedata),
                    transmute(accessibility_info),
                ))
            }
        }
        pub(crate) fn AzNodeData_setMenuBar(nodedata: &mut AzNodeData, menu_bar: AzMenu) {
            unsafe {
                transmute(azul_dll::AzNodeData_setMenuBar(
                    transmute(nodedata),
                    transmute(menu_bar),
                ))
            }
        }
        pub(crate) fn AzNodeData_setContextMenu(nodedata: &mut AzNodeData, context_menu: AzMenu) {
            unsafe {
                transmute(azul_dll::AzNodeData_setContextMenu(
                    transmute(nodedata),
                    transmute(context_menu),
                ))
            }
        }
        pub(crate) fn AzNodeData_hash(nodedata: &AzNodeData) -> u64 {
            unsafe { transmute(azul_dll::AzNodeData_hash(transmute(nodedata))) }
        }
        pub(crate) fn AzOn_intoEventFilter(on: AzOn) -> AzEventFilter {
            unsafe { transmute(azul_dll::AzOn_intoEventFilter(transmute(on))) }
        }
        pub(crate) fn AzMenu_new(items: AzMenuItemVec) -> AzMenu {
            unsafe { transmute(azul_dll::AzMenu_new(transmute(items))) }
        }
        pub(crate) fn AzMenu_setPopupPosition(menu: &mut AzMenu, position: AzMenuPopupPosition) {
            unsafe {
                transmute(azul_dll::AzMenu_setPopupPosition(
                    transmute(menu),
                    transmute(position),
                ))
            }
        }
        pub(crate) fn AzMenu_withPopupPosition(
            menu: &mut AzMenu,
            position: AzMenuPopupPosition,
        ) -> AzMenu {
            unsafe {
                transmute(azul_dll::AzMenu_withPopupPosition(
                    transmute(menu),
                    transmute(position),
                ))
            }
        }
        pub(crate) fn AzStringMenuItem_new(label: AzString) -> AzStringMenuItem {
            unsafe { transmute(azul_dll::AzStringMenuItem_new(transmute(label))) }
        }
        pub(crate) fn AzStringMenuItem_setCallback(
            stringmenuitem: &mut AzStringMenuItem,
            data: AzRefAny,
            callback: AzCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzStringMenuItem_setCallback(
                    transmute(stringmenuitem),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzStringMenuItem_withCallback(
            stringmenuitem: &mut AzStringMenuItem,
            data: AzRefAny,
            callback: AzCallbackType,
        ) -> AzStringMenuItem {
            unsafe {
                transmute(azul_dll::AzStringMenuItem_withCallback(
                    transmute(stringmenuitem),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzStringMenuItem_addChild(
            stringmenuitem: &mut AzStringMenuItem,
            child: AzMenuItem,
        ) {
            unsafe {
                transmute(azul_dll::AzStringMenuItem_addChild(
                    transmute(stringmenuitem),
                    transmute(child),
                ))
            }
        }
        pub(crate) fn AzStringMenuItem_withChild(
            stringmenuitem: &mut AzStringMenuItem,
            child: AzMenuItem,
        ) -> AzStringMenuItem {
            unsafe {
                transmute(azul_dll::AzStringMenuItem_withChild(
                    transmute(stringmenuitem),
                    transmute(child),
                ))
            }
        }
        pub(crate) fn AzStringMenuItem_setChildren(
            stringmenuitem: &mut AzStringMenuItem,
            children: AzMenuItemVec,
        ) {
            unsafe {
                transmute(azul_dll::AzStringMenuItem_setChildren(
                    transmute(stringmenuitem),
                    transmute(children),
                ))
            }
        }
        pub(crate) fn AzStringMenuItem_withChildren(
            stringmenuitem: &mut AzStringMenuItem,
            children: AzMenuItemVec,
        ) -> AzStringMenuItem {
            unsafe {
                transmute(azul_dll::AzStringMenuItem_withChildren(
                    transmute(stringmenuitem),
                    transmute(children),
                ))
            }
        }
        pub(crate) fn AzMenuCallback_new(
            data: AzRefAny,
            callback: AzCallbackType,
        ) -> AzMenuCallback {
            unsafe {
                transmute(azul_dll::AzMenuCallback_new(
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzCss_empty() -> AzCss {
            unsafe { transmute(azul_dll::AzCss_empty()) }
        }
        pub(crate) fn AzCss_fromString(s: AzString) -> AzCss {
            unsafe { transmute(azul_dll::AzCss_fromString(transmute(s))) }
        }
        pub(crate) fn AzColorU_fromStr(string: AzString) -> AzColorU {
            unsafe { transmute(azul_dll::AzColorU_fromStr(transmute(string))) }
        }
        pub(crate) fn AzColorU_transparent() -> AzColorU {
            unsafe { transmute(azul_dll::AzColorU_transparent()) }
        }
        pub(crate) fn AzColorU_white() -> AzColorU {
            unsafe { transmute(azul_dll::AzColorU_white()) }
        }
        pub(crate) fn AzColorU_black() -> AzColorU {
            unsafe { transmute(azul_dll::AzColorU_black()) }
        }
        pub(crate) fn AzColorU_toHash(coloru: &AzColorU) -> AzString {
            unsafe { transmute(azul_dll::AzColorU_toHash(transmute(coloru))) }
        }
        pub(crate) fn AzAngleValue_getDegrees(anglevalue: &AzAngleValue) -> f32 {
            unsafe { transmute(azul_dll::AzAngleValue_getDegrees(transmute(anglevalue))) }
        }
        pub(crate) fn AzCssProperty_getKeyString(cssproperty: &AzCssProperty) -> AzString {
            unsafe { transmute(azul_dll::AzCssProperty_getKeyString(transmute(cssproperty))) }
        }
        pub(crate) fn AzCssProperty_getValueString(cssproperty: &AzCssProperty) -> AzString {
            unsafe {
                transmute(azul_dll::AzCssProperty_getValueString(transmute(
                    cssproperty,
                )))
            }
        }
        pub(crate) fn AzCssProperty_getKeyValueString(cssproperty: &AzCssProperty) -> AzString {
            unsafe {
                transmute(azul_dll::AzCssProperty_getKeyValueString(transmute(
                    cssproperty,
                )))
            }
        }
        pub(crate) fn AzCssProperty_interpolate(
            cssproperty: &AzCssProperty,
            other: AzCssProperty,
            t: f32,
            context: AzInterpolateContext,
        ) -> AzCssProperty {
            unsafe {
                transmute(azul_dll::AzCssProperty_interpolate(
                    transmute(cssproperty),
                    transmute(other),
                    transmute(t),
                    transmute(context),
                ))
            }
        }
        pub(crate) fn AzRibbon_dom(
            ribbon: &mut AzRibbon,
            callback: AzRibbonOnTabClickedCallback,
            data: AzRefAny,
        ) -> AzDom {
            unsafe {
                transmute(azul_dll::AzRibbon_dom(
                    transmute(ribbon),
                    transmute(callback),
                    transmute(data),
                ))
            }
        }
        pub(crate) fn AzButton_new(label: AzString) -> AzButton {
            unsafe { transmute(azul_dll::AzButton_new(transmute(label))) }
        }
        pub(crate) fn AzButton_setOnClick(
            button: &mut AzButton,
            data: AzRefAny,
            callback: AzCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzButton_setOnClick(
                    transmute(button),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzButton_withOnClick(
            button: &mut AzButton,
            data: AzRefAny,
            callback: AzCallbackType,
        ) -> AzButton {
            unsafe {
                transmute(azul_dll::AzButton_withOnClick(
                    transmute(button),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzButton_dom(button: &mut AzButton) -> AzDom {
            unsafe { transmute(azul_dll::AzButton_dom(transmute(button))) }
        }
        pub(crate) fn AzFileInput_new(path: AzOptionString) -> AzFileInput {
            unsafe { transmute(azul_dll::AzFileInput_new(transmute(path))) }
        }
        pub(crate) fn AzFileInput_setDefaultText(
            fileinput: &mut AzFileInput,
            default_text: AzString,
        ) {
            unsafe {
                transmute(azul_dll::AzFileInput_setDefaultText(
                    transmute(fileinput),
                    transmute(default_text),
                ))
            }
        }
        pub(crate) fn AzFileInput_withDefaultText(
            fileinput: &mut AzFileInput,
            default_text: AzString,
        ) -> AzFileInput {
            unsafe {
                transmute(azul_dll::AzFileInput_withDefaultText(
                    transmute(fileinput),
                    transmute(default_text),
                ))
            }
        }
        pub(crate) fn AzFileInput_setOnPathChange(
            fileinput: &mut AzFileInput,
            data: AzRefAny,
            callback: AzFileInputOnPathChangeCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzFileInput_setOnPathChange(
                    transmute(fileinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzFileInput_withOnPathChange(
            fileinput: &mut AzFileInput,
            data: AzRefAny,
            callback: AzFileInputOnPathChangeCallbackType,
        ) -> AzFileInput {
            unsafe {
                transmute(azul_dll::AzFileInput_withOnPathChange(
                    transmute(fileinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzFileInput_dom(fileinput: &mut AzFileInput) -> AzDom {
            unsafe { transmute(azul_dll::AzFileInput_dom(transmute(fileinput))) }
        }
        pub(crate) fn AzCheckBox_new(checked: bool) -> AzCheckBox {
            unsafe { transmute(azul_dll::AzCheckBox_new(transmute(checked))) }
        }
        pub(crate) fn AzCheckBox_setOnToggle(
            checkbox: &mut AzCheckBox,
            data: AzRefAny,
            callback: AzCheckBoxOnToggleCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzCheckBox_setOnToggle(
                    transmute(checkbox),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzCheckBox_withOnToggle(
            checkbox: &mut AzCheckBox,
            data: AzRefAny,
            callback: AzCheckBoxOnToggleCallbackType,
        ) -> AzCheckBox {
            unsafe {
                transmute(azul_dll::AzCheckBox_withOnToggle(
                    transmute(checkbox),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzCheckBox_dom(checkbox: &mut AzCheckBox) -> AzDom {
            unsafe { transmute(azul_dll::AzCheckBox_dom(transmute(checkbox))) }
        }
        pub(crate) fn AzLabel_new(text: AzString) -> AzLabel {
            unsafe { transmute(azul_dll::AzLabel_new(transmute(text))) }
        }
        pub(crate) fn AzLabel_dom(label: &mut AzLabel) -> AzDom {
            unsafe { transmute(azul_dll::AzLabel_dom(transmute(label))) }
        }
        pub(crate) fn AzColorInput_new(color: AzColorU) -> AzColorInput {
            unsafe { transmute(azul_dll::AzColorInput_new(transmute(color))) }
        }
        pub(crate) fn AzColorInput_setOnValueChange(
            colorinput: &mut AzColorInput,
            data: AzRefAny,
            callback: AzColorInputOnValueChangeCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzColorInput_setOnValueChange(
                    transmute(colorinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzColorInput_withOnValueChange(
            colorinput: &mut AzColorInput,
            data: AzRefAny,
            callback: AzColorInputOnValueChangeCallbackType,
        ) -> AzColorInput {
            unsafe {
                transmute(azul_dll::AzColorInput_withOnValueChange(
                    transmute(colorinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzColorInput_dom(colorinput: &mut AzColorInput) -> AzDom {
            unsafe { transmute(azul_dll::AzColorInput_dom(transmute(colorinput))) }
        }
        pub(crate) fn AzTextInput_new() -> AzTextInput {
            unsafe { transmute(azul_dll::AzTextInput_new()) }
        }
        pub(crate) fn AzTextInput_setText(textinput: &mut AzTextInput, text: AzString) {
            unsafe {
                transmute(azul_dll::AzTextInput_setText(
                    transmute(textinput),
                    transmute(text),
                ))
            }
        }
        pub(crate) fn AzTextInput_withText(
            textinput: &mut AzTextInput,
            text: AzString,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withText(
                    transmute(textinput),
                    transmute(text),
                ))
            }
        }
        pub(crate) fn AzTextInput_setPlaceholder(textinput: &mut AzTextInput, text: AzString) {
            unsafe {
                transmute(azul_dll::AzTextInput_setPlaceholder(
                    transmute(textinput),
                    transmute(text),
                ))
            }
        }
        pub(crate) fn AzTextInput_withPlaceholder(
            textinput: &mut AzTextInput,
            text: AzString,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withPlaceholder(
                    transmute(textinput),
                    transmute(text),
                ))
            }
        }
        pub(crate) fn AzTextInput_setOnTextInput(
            textinput: &mut AzTextInput,
            data: AzRefAny,
            callback: AzTextInputOnTextInputCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzTextInput_setOnTextInput(
                    transmute(textinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTextInput_withOnTextInput(
            textinput: &mut AzTextInput,
            data: AzRefAny,
            callback: AzTextInputOnTextInputCallbackType,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withOnTextInput(
                    transmute(textinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTextInput_setOnVirtualKeyDown(
            textinput: &mut AzTextInput,
            data: AzRefAny,
            callback: AzTextInputOnVirtualKeyDownCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzTextInput_setOnVirtualKeyDown(
                    transmute(textinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTextInput_withOnVirtualKeyDown(
            textinput: &mut AzTextInput,
            data: AzRefAny,
            callback: AzTextInputOnVirtualKeyDownCallbackType,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withOnVirtualKeyDown(
                    transmute(textinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTextInput_setOnFocusLost(
            textinput: &mut AzTextInput,
            data: AzRefAny,
            callback: AzTextInputOnFocusLostCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzTextInput_setOnFocusLost(
                    transmute(textinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTextInput_withOnFocusLost(
            textinput: &mut AzTextInput,
            data: AzRefAny,
            callback: AzTextInputOnFocusLostCallbackType,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withOnFocusLost(
                    transmute(textinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTextInput_setPlaceholderStyle(
            textinput: &mut AzTextInput,
            placeholder_style: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzTextInput_setPlaceholderStyle(
                    transmute(textinput),
                    transmute(placeholder_style),
                ))
            }
        }
        pub(crate) fn AzTextInput_withPlaceholderStyle(
            textinput: &mut AzTextInput,
            placeholder_style: AzNodeDataInlineCssPropertyVec,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withPlaceholderStyle(
                    transmute(textinput),
                    transmute(placeholder_style),
                ))
            }
        }
        pub(crate) fn AzTextInput_setContainerStyle(
            textinput: &mut AzTextInput,
            container_style: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzTextInput_setContainerStyle(
                    transmute(textinput),
                    transmute(container_style),
                ))
            }
        }
        pub(crate) fn AzTextInput_withContainerStyle(
            textinput: &mut AzTextInput,
            container_style: AzNodeDataInlineCssPropertyVec,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withContainerStyle(
                    transmute(textinput),
                    transmute(container_style),
                ))
            }
        }
        pub(crate) fn AzTextInput_setLabelStyle(
            textinput: &mut AzTextInput,
            label_style: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzTextInput_setLabelStyle(
                    transmute(textinput),
                    transmute(label_style),
                ))
            }
        }
        pub(crate) fn AzTextInput_withLabelStyle(
            textinput: &mut AzTextInput,
            label_style: AzNodeDataInlineCssPropertyVec,
        ) -> AzTextInput {
            unsafe {
                transmute(azul_dll::AzTextInput_withLabelStyle(
                    transmute(textinput),
                    transmute(label_style),
                ))
            }
        }
        pub(crate) fn AzTextInput_dom(textinput: &mut AzTextInput) -> AzDom {
            unsafe { transmute(azul_dll::AzTextInput_dom(transmute(textinput))) }
        }
        pub(crate) fn AzTextInputState_getText(textinputstate: &AzTextInputState) -> AzString {
            unsafe {
                transmute(azul_dll::AzTextInputState_getText(transmute(
                    textinputstate,
                )))
            }
        }
        pub(crate) fn AzNumberInput_new(number: f32) -> AzNumberInput {
            unsafe { transmute(azul_dll::AzNumberInput_new(transmute(number))) }
        }
        pub(crate) fn AzNumberInput_setOnTextInput(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzTextInputOnTextInputCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzNumberInput_setOnTextInput(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_withOnTextInput(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzTextInputOnTextInputCallbackType,
        ) -> AzNumberInput {
            unsafe {
                transmute(azul_dll::AzNumberInput_withOnTextInput(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_setOnVirtualKeyDown(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzTextInputOnVirtualKeyDownCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzNumberInput_setOnVirtualKeyDown(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_withOnVirtualKeyDown(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzTextInputOnVirtualKeyDownCallbackType,
        ) -> AzNumberInput {
            unsafe {
                transmute(azul_dll::AzNumberInput_withOnVirtualKeyDown(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_setOnFocusLost(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzNumberInputOnFocusLostCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzNumberInput_setOnFocusLost(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_withOnFocusLost(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzNumberInputOnFocusLostCallbackType,
        ) -> AzNumberInput {
            unsafe {
                transmute(azul_dll::AzNumberInput_withOnFocusLost(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_setPlaceholderStyle(
            numberinput: &mut AzNumberInput,
            style: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNumberInput_setPlaceholderStyle(
                    transmute(numberinput),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNumberInput_withPlaceholderStyle(
            numberinput: &mut AzNumberInput,
            style: AzNodeDataInlineCssPropertyVec,
        ) -> AzNumberInput {
            unsafe {
                transmute(azul_dll::AzNumberInput_withPlaceholderStyle(
                    transmute(numberinput),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNumberInput_setContainerStyle(
            numberinput: &mut AzNumberInput,
            style: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNumberInput_setContainerStyle(
                    transmute(numberinput),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNumberInput_withContainerStyle(
            numberinput: &mut AzNumberInput,
            style: AzNodeDataInlineCssPropertyVec,
        ) -> AzNumberInput {
            unsafe {
                transmute(azul_dll::AzNumberInput_withContainerStyle(
                    transmute(numberinput),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNumberInput_setLabelStyle(
            numberinput: &mut AzNumberInput,
            style: AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNumberInput_setLabelStyle(
                    transmute(numberinput),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNumberInput_withLabelStyle(
            numberinput: &mut AzNumberInput,
            style: AzNodeDataInlineCssPropertyVec,
        ) -> AzNumberInput {
            unsafe {
                transmute(azul_dll::AzNumberInput_withLabelStyle(
                    transmute(numberinput),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzNumberInput_setOnValueChange(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzNumberInputOnValueChangeCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzNumberInput_setOnValueChange(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_withOnValueChange(
            numberinput: &mut AzNumberInput,
            data: AzRefAny,
            callback: AzNumberInputOnValueChangeCallbackType,
        ) -> AzNumberInput {
            unsafe {
                transmute(azul_dll::AzNumberInput_withOnValueChange(
                    transmute(numberinput),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzNumberInput_dom(numberinput: &mut AzNumberInput) -> AzDom {
            unsafe { transmute(azul_dll::AzNumberInput_dom(transmute(numberinput))) }
        }
        pub(crate) fn AzProgressBar_new(percent_done: f32) -> AzProgressBar {
            unsafe { transmute(azul_dll::AzProgressBar_new(transmute(percent_done))) }
        }
        pub(crate) fn AzProgressBar_setHeight(
            progressbar: &mut AzProgressBar,
            height: AzPixelValue,
        ) {
            unsafe {
                transmute(azul_dll::AzProgressBar_setHeight(
                    transmute(progressbar),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzProgressBar_withHeight(
            progressbar: &mut AzProgressBar,
            height: AzPixelValue,
        ) -> AzProgressBar {
            unsafe {
                transmute(azul_dll::AzProgressBar_withHeight(
                    transmute(progressbar),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzProgressBar_setContainerBackground(
            progressbar: &mut AzProgressBar,
            background: AzStyleBackgroundContentVec,
        ) {
            unsafe {
                transmute(azul_dll::AzProgressBar_setContainerBackground(
                    transmute(progressbar),
                    transmute(background),
                ))
            }
        }
        pub(crate) fn AzProgressBar_withContainerStyle(
            progressbar: &mut AzProgressBar,
            background: AzStyleBackgroundContentVec,
        ) -> AzProgressBar {
            unsafe {
                transmute(azul_dll::AzProgressBar_withContainerStyle(
                    transmute(progressbar),
                    transmute(background),
                ))
            }
        }
        pub(crate) fn AzProgressBar_setBarBackground(
            progressbar: &mut AzProgressBar,
            background: AzStyleBackgroundContentVec,
        ) {
            unsafe {
                transmute(azul_dll::AzProgressBar_setBarBackground(
                    transmute(progressbar),
                    transmute(background),
                ))
            }
        }
        pub(crate) fn AzProgressBar_withBarBackground(
            progressbar: &mut AzProgressBar,
            background: AzStyleBackgroundContentVec,
        ) -> AzProgressBar {
            unsafe {
                transmute(azul_dll::AzProgressBar_withBarBackground(
                    transmute(progressbar),
                    transmute(background),
                ))
            }
        }
        pub(crate) fn AzProgressBar_dom(progressbar: &mut AzProgressBar) -> AzDom {
            unsafe { transmute(azul_dll::AzProgressBar_dom(transmute(progressbar))) }
        }
        pub(crate) fn AzTabHeader_new(tabs: AzStringVec) -> AzTabHeader {
            unsafe { transmute(azul_dll::AzTabHeader_new(transmute(tabs))) }
        }
        pub(crate) fn AzTabHeader_setActiveTab(tabheader: &mut AzTabHeader, active_tab: usize) {
            unsafe {
                transmute(azul_dll::AzTabHeader_setActiveTab(
                    transmute(tabheader),
                    transmute(active_tab),
                ))
            }
        }
        pub(crate) fn AzTabHeader_withActiveTab(
            tabheader: &mut AzTabHeader,
            active_tab: usize,
        ) -> AzTabHeader {
            unsafe {
                transmute(azul_dll::AzTabHeader_withActiveTab(
                    transmute(tabheader),
                    transmute(active_tab),
                ))
            }
        }
        pub(crate) fn AzTabHeader_setOnClick(
            tabheader: &mut AzTabHeader,
            data: AzRefAny,
            callback: AzTabOnClickCallbackType,
        ) {
            unsafe {
                transmute(azul_dll::AzTabHeader_setOnClick(
                    transmute(tabheader),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTabHeader_withOnClick(
            tabheader: &mut AzTabHeader,
            data: AzRefAny,
            callback: AzTabOnClickCallbackType,
        ) -> AzTabHeader {
            unsafe {
                transmute(azul_dll::AzTabHeader_withOnClick(
                    transmute(tabheader),
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzTabHeader_dom(tabheader: &mut AzTabHeader) -> AzDom {
            unsafe { transmute(azul_dll::AzTabHeader_dom(transmute(tabheader))) }
        }
        pub(crate) fn AzTabContent_new(content: AzDom) -> AzTabContent {
            unsafe { transmute(azul_dll::AzTabContent_new(transmute(content))) }
        }
        pub(crate) fn AzTabContent_setPadding(tabcontent: &mut AzTabContent, has_padding: bool) {
            unsafe {
                transmute(azul_dll::AzTabContent_setPadding(
                    transmute(tabcontent),
                    transmute(has_padding),
                ))
            }
        }
        pub(crate) fn AzTabContent_withPadding(
            tabcontent: &mut AzTabContent,
            has_padding: bool,
        ) -> AzTabContent {
            unsafe {
                transmute(azul_dll::AzTabContent_withPadding(
                    transmute(tabcontent),
                    transmute(has_padding),
                ))
            }
        }
        pub(crate) fn AzTabContent_dom(tabcontent: &mut AzTabContent) -> AzDom {
            unsafe { transmute(azul_dll::AzTabContent_dom(transmute(tabcontent))) }
        }
        pub(crate) fn AzFrame_new(title: AzString, dom: AzDom) -> AzFrame {
            unsafe { transmute(azul_dll::AzFrame_new(transmute(title), transmute(dom))) }
        }
        pub(crate) fn AzFrame_setFlexGrow(frame: &mut AzFrame, flex_grow: f32) {
            unsafe {
                transmute(azul_dll::AzFrame_setFlexGrow(
                    transmute(frame),
                    transmute(flex_grow),
                ))
            }
        }
        pub(crate) fn AzFrame_withFlexGrow(frame: &mut AzFrame, flex_grow: f32) -> AzFrame {
            unsafe {
                transmute(azul_dll::AzFrame_withFlexGrow(
                    transmute(frame),
                    transmute(flex_grow),
                ))
            }
        }
        pub(crate) fn AzFrame_dom(frame: &mut AzFrame) -> AzDom {
            unsafe { transmute(azul_dll::AzFrame_dom(transmute(frame))) }
        }
        pub(crate) fn AzNodeGraph_dom(nodegraph: &mut AzNodeGraph) -> AzDom {
            unsafe { transmute(azul_dll::AzNodeGraph_dom(transmute(nodegraph))) }
        }
        pub(crate) fn AzListView_new(columns: AzStringVec) -> AzListView {
            unsafe { transmute(azul_dll::AzListView_new(transmute(columns))) }
        }
        pub(crate) fn AzListView_withRows(
            listview: &mut AzListView,
            rows: AzListViewRowVec,
        ) -> AzListView {
            unsafe {
                transmute(azul_dll::AzListView_withRows(
                    transmute(listview),
                    transmute(rows),
                ))
            }
        }
        pub(crate) fn AzListView_dom(listview: &mut AzListView) -> AzDom {
            unsafe { transmute(azul_dll::AzListView_dom(transmute(listview))) }
        }
        pub(crate) fn AzTreeView_new(root: AzString) -> AzTreeView {
            unsafe { transmute(azul_dll::AzTreeView_new(transmute(root))) }
        }
        pub(crate) fn AzTreeView_dom(treeview: &mut AzTreeView) -> AzDom {
            unsafe { transmute(azul_dll::AzTreeView_dom(transmute(treeview))) }
        }
        pub(crate) fn AzDropDown_new(choices: AzStringVec) -> AzDropDown {
            unsafe { transmute(azul_dll::AzDropDown_new(transmute(choices))) }
        }
        pub(crate) fn AzDropDown_dom(dropdown: &mut AzDropDown) -> AzDom {
            unsafe { transmute(azul_dll::AzDropDown_dom(transmute(dropdown))) }
        }
        pub(crate) fn AzCssPropertyCache_delete(object: &mut AzCssPropertyCache) {
            unsafe { transmute(azul_dll::AzCssPropertyCache_delete(transmute(object))) }
        }
        pub(crate) fn AzCssPropertyCache_deepCopy(
            object: &AzCssPropertyCache,
        ) -> AzCssPropertyCache {
            unsafe { transmute(azul_dll::AzCssPropertyCache_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzStyledDom_new(dom: AzDom, css: AzCss) -> AzStyledDom {
            unsafe { transmute(azul_dll::AzStyledDom_new(transmute(dom), transmute(css))) }
        }
        pub(crate) fn AzStyledDom_default() -> AzStyledDom {
            unsafe { transmute(azul_dll::AzStyledDom_default()) }
        }
        pub(crate) fn AzStyledDom_fromXml(xml_string: AzString) -> AzStyledDom {
            unsafe { transmute(azul_dll::AzStyledDom_fromXml(transmute(xml_string))) }
        }
        pub(crate) fn AzStyledDom_fromFile(xml_file_path: AzString) -> AzStyledDom {
            unsafe { transmute(azul_dll::AzStyledDom_fromFile(transmute(xml_file_path))) }
        }
        pub(crate) fn AzStyledDom_appendChild(styleddom: &mut AzStyledDom, dom: AzStyledDom) {
            unsafe {
                transmute(azul_dll::AzStyledDom_appendChild(
                    transmute(styleddom),
                    transmute(dom),
                ))
            }
        }
        pub(crate) fn AzStyledDom_withChild(
            styleddom: &mut AzStyledDom,
            dom: AzStyledDom,
        ) -> AzStyledDom {
            unsafe {
                transmute(azul_dll::AzStyledDom_withChild(
                    transmute(styleddom),
                    transmute(dom),
                ))
            }
        }
        pub(crate) fn AzStyledDom_restyle(styleddom: &mut AzStyledDom, css: AzCss) {
            unsafe {
                transmute(azul_dll::AzStyledDom_restyle(
                    transmute(styleddom),
                    transmute(css),
                ))
            }
        }
        pub(crate) fn AzStyledDom_nodeCount(styleddom: &AzStyledDom) -> usize {
            unsafe { transmute(azul_dll::AzStyledDom_nodeCount(transmute(styleddom))) }
        }
        pub(crate) fn AzStyledDom_getHtmlString(styleddom: &AzStyledDom) -> AzString {
            unsafe { transmute(azul_dll::AzStyledDom_getHtmlString(transmute(styleddom))) }
        }
        pub(crate) fn AzStyledDom_getHtmlStringTest(styleddom: &AzStyledDom) -> AzString {
            unsafe {
                transmute(azul_dll::AzStyledDom_getHtmlStringTest(transmute(
                    styleddom,
                )))
            }
        }
        pub(crate) fn AzStyledDom_setMenuBar(styleddom: &mut AzStyledDom, menu: AzMenu) {
            unsafe {
                transmute(azul_dll::AzStyledDom_setMenuBar(
                    transmute(styleddom),
                    transmute(menu),
                ))
            }
        }
        pub(crate) fn AzStyledDom_withMenuBar(
            styleddom: &mut AzStyledDom,
            menu: AzMenu,
        ) -> AzStyledDom {
            unsafe {
                transmute(azul_dll::AzStyledDom_withMenuBar(
                    transmute(styleddom),
                    transmute(menu),
                ))
            }
        }
        pub(crate) fn AzStyledDom_setContextMenu(styleddom: &mut AzStyledDom, menu: AzMenu) {
            unsafe {
                transmute(azul_dll::AzStyledDom_setContextMenu(
                    transmute(styleddom),
                    transmute(menu),
                ))
            }
        }
        pub(crate) fn AzStyledDom_withContextMenu(
            styleddom: &mut AzStyledDom,
            menu: AzMenu,
        ) -> AzStyledDom {
            unsafe {
                transmute(azul_dll::AzStyledDom_withContextMenu(
                    transmute(styleddom),
                    transmute(menu),
                ))
            }
        }
        pub(crate) fn AzTexture_new(
            texture_id: u32,
            flags: AzTextureFlags,
            size: AzPhysicalSizeU32,
            background_color: AzColorU,
            gl_context: AzGl,
            format: AzRawImageFormat,
        ) -> AzTexture {
            unsafe {
                transmute(azul_dll::AzTexture_new(
                    transmute(texture_id),
                    transmute(flags),
                    transmute(size),
                    transmute(background_color),
                    transmute(gl_context),
                    transmute(format),
                ))
            }
        }
        pub(crate) fn AzTexture_allocateRgba8(
            gl: AzGl,
            size: AzPhysicalSizeU32,
            background: AzColorU,
        ) -> AzTexture {
            unsafe {
                transmute(azul_dll::AzTexture_allocateRgba8(
                    transmute(gl),
                    transmute(size),
                    transmute(background),
                ))
            }
        }
        pub(crate) fn AzTexture_allocateClipMask(
            gl: AzGl,
            size: AzPhysicalSizeU32,
            background: AzColorU,
        ) -> AzTexture {
            unsafe {
                transmute(azul_dll::AzTexture_allocateClipMask(
                    transmute(gl),
                    transmute(size),
                    transmute(background),
                ))
            }
        }
        pub(crate) fn AzTexture_clear(texture: &mut AzTexture) {
            unsafe { transmute(azul_dll::AzTexture_clear(transmute(texture))) }
        }
        pub(crate) fn AzTexture_drawClipMask(
            texture: &mut AzTexture,
            node: AzTessellatedSvgNode,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzTexture_drawClipMask(
                    transmute(texture),
                    transmute(node),
                ))
            }
        }
        pub(crate) fn AzTexture_drawTesselatedSvgGpuNode(
            texture: &mut AzTexture,
            node: *const AzTessellatedGPUSvgNode,
            size: AzPhysicalSizeU32,
            color: AzColorU,
            transforms: AzStyleTransformVec,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzTexture_drawTesselatedSvgGpuNode(
                    transmute(texture),
                    transmute(node),
                    transmute(size),
                    transmute(color),
                    transmute(transforms),
                ))
            }
        }
        pub(crate) fn AzTexture_drawTesselatedColoredSvgGpuNode(
            texture: &mut AzTexture,
            node: *const AzTessellatedColoredGPUSvgNode,
            size: AzPhysicalSizeU32,
            transforms: AzStyleTransformVec,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzTexture_drawTesselatedColoredSvgGpuNode(
                    transmute(texture),
                    transmute(node),
                    transmute(size),
                    transmute(transforms),
                ))
            }
        }
        pub(crate) fn AzTexture_applyFxaa(texture: &mut AzTexture) -> bool {
            unsafe { transmute(azul_dll::AzTexture_applyFxaa(transmute(texture))) }
        }
        pub(crate) fn AzTexture_delete(object: &mut AzTexture) {
            unsafe { transmute(azul_dll::AzTexture_delete(transmute(object))) }
        }
        pub(crate) fn AzTexture_deepCopy(object: &AzTexture) -> AzTexture {
            unsafe { transmute(azul_dll::AzTexture_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzGlVoidPtrConst_delete(object: &mut AzGlVoidPtrConst) {
            unsafe { transmute(azul_dll::AzGlVoidPtrConst_delete(transmute(object))) }
        }
        pub(crate) fn AzGlVoidPtrConst_deepCopy(object: &AzGlVoidPtrConst) -> AzGlVoidPtrConst {
            unsafe { transmute(azul_dll::AzGlVoidPtrConst_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzGl_getType(gl: &AzGl) -> AzGlType {
            unsafe { transmute(azul_dll::AzGl_getType(transmute(gl))) }
        }
        pub(crate) fn AzGl_bufferDataUntyped(
            gl: &AzGl,
            target: u32,
            size: isize,
            data: AzGlVoidPtrConst,
            usage: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_bufferDataUntyped(
                    transmute(gl),
                    transmute(target),
                    transmute(size),
                    transmute(data),
                    transmute(usage),
                ))
            }
        }
        pub(crate) fn AzGl_bufferSubDataUntyped(
            gl: &AzGl,
            target: u32,
            offset: isize,
            size: isize,
            data: AzGlVoidPtrConst,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_bufferSubDataUntyped(
                    transmute(gl),
                    transmute(target),
                    transmute(offset),
                    transmute(size),
                    transmute(data),
                ))
            }
        }
        pub(crate) fn AzGl_mapBuffer(gl: &AzGl, target: u32, access: u32) -> AzGlVoidPtrMut {
            unsafe {
                transmute(azul_dll::AzGl_mapBuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(access),
                ))
            }
        }
        pub(crate) fn AzGl_mapBufferRange(
            gl: &AzGl,
            target: u32,
            offset: isize,
            length: isize,
            access: u32,
        ) -> AzGlVoidPtrMut {
            unsafe {
                transmute(azul_dll::AzGl_mapBufferRange(
                    transmute(gl),
                    transmute(target),
                    transmute(offset),
                    transmute(length),
                    transmute(access),
                ))
            }
        }
        pub(crate) fn AzGl_unmapBuffer(gl: &AzGl, target: u32) -> u8 {
            unsafe { transmute(azul_dll::AzGl_unmapBuffer(transmute(gl), transmute(target))) }
        }
        pub(crate) fn AzGl_texBuffer(gl: &AzGl, target: u32, internal_format: u32, buffer: u32) {
            unsafe {
                transmute(azul_dll::AzGl_texBuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(internal_format),
                    transmute(buffer),
                ))
            }
        }
        pub(crate) fn AzGl_shaderSource(gl: &AzGl, shader: u32, strings: AzStringVec) {
            unsafe {
                transmute(azul_dll::AzGl_shaderSource(
                    transmute(gl),
                    transmute(shader),
                    transmute(strings),
                ))
            }
        }
        pub(crate) fn AzGl_readBuffer(gl: &AzGl, mode: u32) {
            unsafe { transmute(azul_dll::AzGl_readBuffer(transmute(gl), transmute(mode))) }
        }
        pub(crate) fn AzGl_readPixelsIntoBuffer(
            gl: &AzGl,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            format: u32,
            pixel_type: u32,
            dst_buffer: AzU8VecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_readPixelsIntoBuffer(
                    transmute(gl),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                    transmute(format),
                    transmute(pixel_type),
                    transmute(dst_buffer),
                ))
            }
        }
        pub(crate) fn AzGl_readPixels(
            gl: &AzGl,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            format: u32,
            pixel_type: u32,
        ) -> AzU8Vec {
            unsafe {
                transmute(azul_dll::AzGl_readPixels(
                    transmute(gl),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                    transmute(format),
                    transmute(pixel_type),
                ))
            }
        }
        pub(crate) fn AzGl_readPixelsIntoPbo(
            gl: &AzGl,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            format: u32,
            pixel_type: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_readPixelsIntoPbo(
                    transmute(gl),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                    transmute(format),
                    transmute(pixel_type),
                ))
            }
        }
        pub(crate) fn AzGl_sampleCoverage(gl: &AzGl, value: f32, invert: bool) {
            unsafe {
                transmute(azul_dll::AzGl_sampleCoverage(
                    transmute(gl),
                    transmute(value),
                    transmute(invert),
                ))
            }
        }
        pub(crate) fn AzGl_polygonOffset(gl: &AzGl, factor: f32, units: f32) {
            unsafe {
                transmute(azul_dll::AzGl_polygonOffset(
                    transmute(gl),
                    transmute(factor),
                    transmute(units),
                ))
            }
        }
        pub(crate) fn AzGl_pixelStoreI(gl: &AzGl, name: u32, param: i32) {
            unsafe {
                transmute(azul_dll::AzGl_pixelStoreI(
                    transmute(gl),
                    transmute(name),
                    transmute(param),
                ))
            }
        }
        pub(crate) fn AzGl_genBuffers(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe { transmute(azul_dll::AzGl_genBuffers(transmute(gl), transmute(n))) }
        }
        pub(crate) fn AzGl_genRenderbuffers(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe { transmute(azul_dll::AzGl_genRenderbuffers(transmute(gl), transmute(n))) }
        }
        pub(crate) fn AzGl_genFramebuffers(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe { transmute(azul_dll::AzGl_genFramebuffers(transmute(gl), transmute(n))) }
        }
        pub(crate) fn AzGl_genTextures(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe { transmute(azul_dll::AzGl_genTextures(transmute(gl), transmute(n))) }
        }
        pub(crate) fn AzGl_genVertexArrays(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe { transmute(azul_dll::AzGl_genVertexArrays(transmute(gl), transmute(n))) }
        }
        pub(crate) fn AzGl_genQueries(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe { transmute(azul_dll::AzGl_genQueries(transmute(gl), transmute(n))) }
        }
        pub(crate) fn AzGl_beginQuery(gl: &AzGl, target: u32, id: u32) {
            unsafe {
                transmute(azul_dll::AzGl_beginQuery(
                    transmute(gl),
                    transmute(target),
                    transmute(id),
                ))
            }
        }
        pub(crate) fn AzGl_endQuery(gl: &AzGl, target: u32) {
            unsafe { transmute(azul_dll::AzGl_endQuery(transmute(gl), transmute(target))) }
        }
        pub(crate) fn AzGl_queryCounter(gl: &AzGl, id: u32, target: u32) {
            unsafe {
                transmute(azul_dll::AzGl_queryCounter(
                    transmute(gl),
                    transmute(id),
                    transmute(target),
                ))
            }
        }
        pub(crate) fn AzGl_getQueryObjectIv(gl: &AzGl, id: u32, pname: u32) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getQueryObjectIv(
                    transmute(gl),
                    transmute(id),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getQueryObjectUiv(gl: &AzGl, id: u32, pname: u32) -> u32 {
            unsafe {
                transmute(azul_dll::AzGl_getQueryObjectUiv(
                    transmute(gl),
                    transmute(id),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getQueryObjectI64V(gl: &AzGl, id: u32, pname: u32) -> i64 {
            unsafe {
                transmute(azul_dll::AzGl_getQueryObjectI64V(
                    transmute(gl),
                    transmute(id),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getQueryObjectUi64V(gl: &AzGl, id: u32, pname: u32) -> u64 {
            unsafe {
                transmute(azul_dll::AzGl_getQueryObjectUi64V(
                    transmute(gl),
                    transmute(id),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_deleteQueries(gl: &AzGl, queries: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteQueries(
                    transmute(gl),
                    transmute(queries),
                ))
            }
        }
        pub(crate) fn AzGl_deleteVertexArrays(gl: &AzGl, vertex_arrays: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteVertexArrays(
                    transmute(gl),
                    transmute(vertex_arrays),
                ))
            }
        }
        pub(crate) fn AzGl_deleteBuffers(gl: &AzGl, buffers: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteBuffers(
                    transmute(gl),
                    transmute(buffers),
                ))
            }
        }
        pub(crate) fn AzGl_deleteRenderbuffers(gl: &AzGl, renderbuffers: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteRenderbuffers(
                    transmute(gl),
                    transmute(renderbuffers),
                ))
            }
        }
        pub(crate) fn AzGl_deleteFramebuffers(gl: &AzGl, framebuffers: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteFramebuffers(
                    transmute(gl),
                    transmute(framebuffers),
                ))
            }
        }
        pub(crate) fn AzGl_deleteTextures(gl: &AzGl, textures: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteTextures(
                    transmute(gl),
                    transmute(textures),
                ))
            }
        }
        pub(crate) fn AzGl_framebufferRenderbuffer(
            gl: &AzGl,
            target: u32,
            attachment: u32,
            renderbuffertarget: u32,
            renderbuffer: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_framebufferRenderbuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(attachment),
                    transmute(renderbuffertarget),
                    transmute(renderbuffer),
                ))
            }
        }
        pub(crate) fn AzGl_renderbufferStorage(
            gl: &AzGl,
            target: u32,
            internalformat: u32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_renderbufferStorage(
                    transmute(gl),
                    transmute(target),
                    transmute(internalformat),
                    transmute(width),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzGl_depthFunc(gl: &AzGl, func: u32) {
            unsafe { transmute(azul_dll::AzGl_depthFunc(transmute(gl), transmute(func))) }
        }
        pub(crate) fn AzGl_activeTexture(gl: &AzGl, texture: u32) {
            unsafe {
                transmute(azul_dll::AzGl_activeTexture(
                    transmute(gl),
                    transmute(texture),
                ))
            }
        }
        pub(crate) fn AzGl_attachShader(gl: &AzGl, program: u32, shader: u32) {
            unsafe {
                transmute(azul_dll::AzGl_attachShader(
                    transmute(gl),
                    transmute(program),
                    transmute(shader),
                ))
            }
        }
        pub(crate) fn AzGl_bindAttribLocation(gl: &AzGl, program: u32, index: u32, name: AzRefstr) {
            unsafe {
                transmute(azul_dll::AzGl_bindAttribLocation(
                    transmute(gl),
                    transmute(program),
                    transmute(index),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getUniformIv(
            gl: &AzGl,
            program: u32,
            location: i32,
            result: AzGLintVecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getUniformIv(
                    transmute(gl),
                    transmute(program),
                    transmute(location),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getUniformFv(
            gl: &AzGl,
            program: u32,
            location: i32,
            result: AzGLfloatVecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getUniformFv(
                    transmute(gl),
                    transmute(program),
                    transmute(location),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getUniformBlockIndex(gl: &AzGl, program: u32, name: AzRefstr) -> u32 {
            unsafe {
                transmute(azul_dll::AzGl_getUniformBlockIndex(
                    transmute(gl),
                    transmute(program),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getUniformIndices(
            gl: &AzGl,
            program: u32,
            names: AzRefstrVecRef,
        ) -> AzGLuintVec {
            unsafe {
                transmute(azul_dll::AzGl_getUniformIndices(
                    transmute(gl),
                    transmute(program),
                    transmute(names),
                ))
            }
        }
        pub(crate) fn AzGl_bindBufferBase(gl: &AzGl, target: u32, index: u32, buffer: u32) {
            unsafe {
                transmute(azul_dll::AzGl_bindBufferBase(
                    transmute(gl),
                    transmute(target),
                    transmute(index),
                    transmute(buffer),
                ))
            }
        }
        pub(crate) fn AzGl_bindBufferRange(
            gl: &AzGl,
            target: u32,
            index: u32,
            buffer: u32,
            offset: isize,
            size: isize,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_bindBufferRange(
                    transmute(gl),
                    transmute(target),
                    transmute(index),
                    transmute(buffer),
                    transmute(offset),
                    transmute(size),
                ))
            }
        }
        pub(crate) fn AzGl_uniformBlockBinding(
            gl: &AzGl,
            program: u32,
            uniform_block_index: u32,
            uniform_block_binding: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_uniformBlockBinding(
                    transmute(gl),
                    transmute(program),
                    transmute(uniform_block_index),
                    transmute(uniform_block_binding),
                ))
            }
        }
        pub(crate) fn AzGl_bindBuffer(gl: &AzGl, target: u32, buffer: u32) {
            unsafe {
                transmute(azul_dll::AzGl_bindBuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(buffer),
                ))
            }
        }
        pub(crate) fn AzGl_bindVertexArray(gl: &AzGl, vao: u32) {
            unsafe {
                transmute(azul_dll::AzGl_bindVertexArray(
                    transmute(gl),
                    transmute(vao),
                ))
            }
        }
        pub(crate) fn AzGl_bindRenderbuffer(gl: &AzGl, target: u32, renderbuffer: u32) {
            unsafe {
                transmute(azul_dll::AzGl_bindRenderbuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(renderbuffer),
                ))
            }
        }
        pub(crate) fn AzGl_bindFramebuffer(gl: &AzGl, target: u32, framebuffer: u32) {
            unsafe {
                transmute(azul_dll::AzGl_bindFramebuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(framebuffer),
                ))
            }
        }
        pub(crate) fn AzGl_bindTexture(gl: &AzGl, target: u32, texture: u32) {
            unsafe {
                transmute(azul_dll::AzGl_bindTexture(
                    transmute(gl),
                    transmute(target),
                    transmute(texture),
                ))
            }
        }
        pub(crate) fn AzGl_drawBuffers(gl: &AzGl, bufs: AzGLenumVecRef) {
            unsafe { transmute(azul_dll::AzGl_drawBuffers(transmute(gl), transmute(bufs))) }
        }
        pub(crate) fn AzGl_texImage2D(
            gl: &AzGl,
            target: u32,
            level: i32,
            internal_format: i32,
            width: i32,
            height: i32,
            border: i32,
            format: u32,
            ty: u32,
            opt_data: AzOptionU8VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texImage2D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(internal_format),
                    transmute(width),
                    transmute(height),
                    transmute(border),
                    transmute(format),
                    transmute(ty),
                    transmute(opt_data),
                ))
            }
        }
        pub(crate) fn AzGl_compressedTexImage2D(
            gl: &AzGl,
            target: u32,
            level: i32,
            internal_format: u32,
            width: i32,
            height: i32,
            border: i32,
            data: AzU8VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_compressedTexImage2D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(internal_format),
                    transmute(width),
                    transmute(height),
                    transmute(border),
                    transmute(data),
                ))
            }
        }
        pub(crate) fn AzGl_compressedTexSubImage2D(
            gl: &AzGl,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
            format: u32,
            data: AzU8VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_compressedTexSubImage2D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(width),
                    transmute(height),
                    transmute(format),
                    transmute(data),
                ))
            }
        }
        pub(crate) fn AzGl_texImage3D(
            gl: &AzGl,
            target: u32,
            level: i32,
            internal_format: i32,
            width: i32,
            height: i32,
            depth: i32,
            border: i32,
            format: u32,
            ty: u32,
            opt_data: AzOptionU8VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texImage3D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(internal_format),
                    transmute(width),
                    transmute(height),
                    transmute(depth),
                    transmute(border),
                    transmute(format),
                    transmute(ty),
                    transmute(opt_data),
                ))
            }
        }
        pub(crate) fn AzGl_copyTexImage2D(
            gl: &AzGl,
            target: u32,
            level: i32,
            internal_format: u32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            border: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copyTexImage2D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(internal_format),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                    transmute(border),
                ))
            }
        }
        pub(crate) fn AzGl_copyTexSubImage2D(
            gl: &AzGl,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copyTexSubImage2D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzGl_copyTexSubImage3D(
            gl: &AzGl,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            zoffset: i32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copyTexSubImage3D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(zoffset),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzGl_texSubImage2D(
            gl: &AzGl,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
            format: u32,
            ty: u32,
            data: AzU8VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texSubImage2D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(width),
                    transmute(height),
                    transmute(format),
                    transmute(ty),
                    transmute(data),
                ))
            }
        }
        pub(crate) fn AzGl_texSubImage2DPbo(
            gl: &AzGl,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
            format: u32,
            ty: u32,
            offset: usize,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texSubImage2DPbo(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(width),
                    transmute(height),
                    transmute(format),
                    transmute(ty),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzGl_texSubImage3D(
            gl: &AzGl,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            zoffset: i32,
            width: i32,
            height: i32,
            depth: i32,
            format: u32,
            ty: u32,
            data: AzU8VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texSubImage3D(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(zoffset),
                    transmute(width),
                    transmute(height),
                    transmute(depth),
                    transmute(format),
                    transmute(ty),
                    transmute(data),
                ))
            }
        }
        pub(crate) fn AzGl_texSubImage3DPbo(
            gl: &AzGl,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            zoffset: i32,
            width: i32,
            height: i32,
            depth: i32,
            format: u32,
            ty: u32,
            offset: usize,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texSubImage3DPbo(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(zoffset),
                    transmute(width),
                    transmute(height),
                    transmute(depth),
                    transmute(format),
                    transmute(ty),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzGl_texStorage2D(
            gl: &AzGl,
            target: u32,
            levels: i32,
            internal_format: u32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texStorage2D(
                    transmute(gl),
                    transmute(target),
                    transmute(levels),
                    transmute(internal_format),
                    transmute(width),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzGl_texStorage3D(
            gl: &AzGl,
            target: u32,
            levels: i32,
            internal_format: u32,
            width: i32,
            height: i32,
            depth: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_texStorage3D(
                    transmute(gl),
                    transmute(target),
                    transmute(levels),
                    transmute(internal_format),
                    transmute(width),
                    transmute(height),
                    transmute(depth),
                ))
            }
        }
        pub(crate) fn AzGl_getTexImageIntoBuffer(
            gl: &AzGl,
            target: u32,
            level: i32,
            format: u32,
            ty: u32,
            output: AzU8VecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getTexImageIntoBuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(level),
                    transmute(format),
                    transmute(ty),
                    transmute(output),
                ))
            }
        }
        pub(crate) fn AzGl_copyImageSubData(
            gl: &AzGl,
            src_name: u32,
            src_target: u32,
            src_level: i32,
            src_x: i32,
            src_y: i32,
            src_z: i32,
            dst_name: u32,
            dst_target: u32,
            dst_level: i32,
            dst_x: i32,
            dst_y: i32,
            dst_z: i32,
            src_width: i32,
            src_height: i32,
            src_depth: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copyImageSubData(
                    transmute(gl),
                    transmute(src_name),
                    transmute(src_target),
                    transmute(src_level),
                    transmute(src_x),
                    transmute(src_y),
                    transmute(src_z),
                    transmute(dst_name),
                    transmute(dst_target),
                    transmute(dst_level),
                    transmute(dst_x),
                    transmute(dst_y),
                    transmute(dst_z),
                    transmute(src_width),
                    transmute(src_height),
                    transmute(src_depth),
                ))
            }
        }
        pub(crate) fn AzGl_invalidateFramebuffer(
            gl: &AzGl,
            target: u32,
            attachments: AzGLenumVecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_invalidateFramebuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(attachments),
                ))
            }
        }
        pub(crate) fn AzGl_invalidateSubFramebuffer(
            gl: &AzGl,
            target: u32,
            attachments: AzGLenumVecRef,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_invalidateSubFramebuffer(
                    transmute(gl),
                    transmute(target),
                    transmute(attachments),
                    transmute(xoffset),
                    transmute(yoffset),
                    transmute(width),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzGl_getIntegerV(gl: &AzGl, name: u32, result: AzGLintVecRefMut) {
            unsafe {
                transmute(azul_dll::AzGl_getIntegerV(
                    transmute(gl),
                    transmute(name),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getInteger64V(gl: &AzGl, name: u32, result: AzGLint64VecRefMut) {
            unsafe {
                transmute(azul_dll::AzGl_getInteger64V(
                    transmute(gl),
                    transmute(name),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getIntegerIv(
            gl: &AzGl,
            name: u32,
            index: u32,
            result: AzGLintVecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getIntegerIv(
                    transmute(gl),
                    transmute(name),
                    transmute(index),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getInteger64Iv(
            gl: &AzGl,
            name: u32,
            index: u32,
            result: AzGLint64VecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getInteger64Iv(
                    transmute(gl),
                    transmute(name),
                    transmute(index),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getBooleanV(gl: &AzGl, name: u32, result: AzGLbooleanVecRefMut) {
            unsafe {
                transmute(azul_dll::AzGl_getBooleanV(
                    transmute(gl),
                    transmute(name),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getFloatV(gl: &AzGl, name: u32, result: AzGLfloatVecRefMut) {
            unsafe {
                transmute(azul_dll::AzGl_getFloatV(
                    transmute(gl),
                    transmute(name),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getFramebufferAttachmentParameterIv(
            gl: &AzGl,
            target: u32,
            attachment: u32,
            pname: u32,
        ) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getFramebufferAttachmentParameterIv(
                    transmute(gl),
                    transmute(target),
                    transmute(attachment),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getRenderbufferParameterIv(gl: &AzGl, target: u32, pname: u32) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getRenderbufferParameterIv(
                    transmute(gl),
                    transmute(target),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getTexParameterIv(gl: &AzGl, target: u32, name: u32) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getTexParameterIv(
                    transmute(gl),
                    transmute(target),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getTexParameterFv(gl: &AzGl, target: u32, name: u32) -> f32 {
            unsafe {
                transmute(azul_dll::AzGl_getTexParameterFv(
                    transmute(gl),
                    transmute(target),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_texParameterI(gl: &AzGl, target: u32, pname: u32, param: i32) {
            unsafe {
                transmute(azul_dll::AzGl_texParameterI(
                    transmute(gl),
                    transmute(target),
                    transmute(pname),
                    transmute(param),
                ))
            }
        }
        pub(crate) fn AzGl_texParameterF(gl: &AzGl, target: u32, pname: u32, param: f32) {
            unsafe {
                transmute(azul_dll::AzGl_texParameterF(
                    transmute(gl),
                    transmute(target),
                    transmute(pname),
                    transmute(param),
                ))
            }
        }
        pub(crate) fn AzGl_framebufferTexture2D(
            gl: &AzGl,
            target: u32,
            attachment: u32,
            textarget: u32,
            texture: u32,
            level: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_framebufferTexture2D(
                    transmute(gl),
                    transmute(target),
                    transmute(attachment),
                    transmute(textarget),
                    transmute(texture),
                    transmute(level),
                ))
            }
        }
        pub(crate) fn AzGl_framebufferTextureLayer(
            gl: &AzGl,
            target: u32,
            attachment: u32,
            texture: u32,
            level: i32,
            layer: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_framebufferTextureLayer(
                    transmute(gl),
                    transmute(target),
                    transmute(attachment),
                    transmute(texture),
                    transmute(level),
                    transmute(layer),
                ))
            }
        }
        pub(crate) fn AzGl_blitFramebuffer(
            gl: &AzGl,
            src_x0: i32,
            src_y0: i32,
            src_x1: i32,
            src_y1: i32,
            dst_x0: i32,
            dst_y0: i32,
            dst_x1: i32,
            dst_y1: i32,
            mask: u32,
            filter: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_blitFramebuffer(
                    transmute(gl),
                    transmute(src_x0),
                    transmute(src_y0),
                    transmute(src_x1),
                    transmute(src_y1),
                    transmute(dst_x0),
                    transmute(dst_y0),
                    transmute(dst_x1),
                    transmute(dst_y1),
                    transmute(mask),
                    transmute(filter),
                ))
            }
        }
        pub(crate) fn AzGl_vertexAttrib4F(gl: &AzGl, index: u32, x: f32, y: f32, z: f32, w: f32) {
            unsafe {
                transmute(azul_dll::AzGl_vertexAttrib4F(
                    transmute(gl),
                    transmute(index),
                    transmute(x),
                    transmute(y),
                    transmute(z),
                    transmute(w),
                ))
            }
        }
        pub(crate) fn AzGl_vertexAttribPointerF32(
            gl: &AzGl,
            index: u32,
            size: i32,
            normalized: bool,
            stride: i32,
            offset: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_vertexAttribPointerF32(
                    transmute(gl),
                    transmute(index),
                    transmute(size),
                    transmute(normalized),
                    transmute(stride),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzGl_vertexAttribPointer(
            gl: &AzGl,
            index: u32,
            size: i32,
            type_: u32,
            normalized: bool,
            stride: i32,
            offset: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_vertexAttribPointer(
                    transmute(gl),
                    transmute(index),
                    transmute(size),
                    transmute(type_),
                    transmute(normalized),
                    transmute(stride),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzGl_vertexAttribIPointer(
            gl: &AzGl,
            index: u32,
            size: i32,
            type_: u32,
            stride: i32,
            offset: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_vertexAttribIPointer(
                    transmute(gl),
                    transmute(index),
                    transmute(size),
                    transmute(type_),
                    transmute(stride),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzGl_vertexAttribDivisor(gl: &AzGl, index: u32, divisor: u32) {
            unsafe {
                transmute(azul_dll::AzGl_vertexAttribDivisor(
                    transmute(gl),
                    transmute(index),
                    transmute(divisor),
                ))
            }
        }
        pub(crate) fn AzGl_viewport(gl: &AzGl, x: i32, y: i32, width: i32, height: i32) {
            unsafe {
                transmute(azul_dll::AzGl_viewport(
                    transmute(gl),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzGl_scissor(gl: &AzGl, x: i32, y: i32, width: i32, height: i32) {
            unsafe {
                transmute(azul_dll::AzGl_scissor(
                    transmute(gl),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                ))
            }
        }
        pub(crate) fn AzGl_lineWidth(gl: &AzGl, width: f32) {
            unsafe { transmute(azul_dll::AzGl_lineWidth(transmute(gl), transmute(width))) }
        }
        pub(crate) fn AzGl_useProgram(gl: &AzGl, program: u32) {
            unsafe { transmute(azul_dll::AzGl_useProgram(transmute(gl), transmute(program))) }
        }
        pub(crate) fn AzGl_validateProgram(gl: &AzGl, program: u32) {
            unsafe {
                transmute(azul_dll::AzGl_validateProgram(
                    transmute(gl),
                    transmute(program),
                ))
            }
        }
        pub(crate) fn AzGl_drawArrays(gl: &AzGl, mode: u32, first: i32, count: i32) {
            unsafe {
                transmute(azul_dll::AzGl_drawArrays(
                    transmute(gl),
                    transmute(mode),
                    transmute(first),
                    transmute(count),
                ))
            }
        }
        pub(crate) fn AzGl_drawArraysInstanced(
            gl: &AzGl,
            mode: u32,
            first: i32,
            count: i32,
            primcount: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_drawArraysInstanced(
                    transmute(gl),
                    transmute(mode),
                    transmute(first),
                    transmute(count),
                    transmute(primcount),
                ))
            }
        }
        pub(crate) fn AzGl_drawElements(
            gl: &AzGl,
            mode: u32,
            count: i32,
            element_type: u32,
            indices_offset: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_drawElements(
                    transmute(gl),
                    transmute(mode),
                    transmute(count),
                    transmute(element_type),
                    transmute(indices_offset),
                ))
            }
        }
        pub(crate) fn AzGl_drawElementsInstanced(
            gl: &AzGl,
            mode: u32,
            count: i32,
            element_type: u32,
            indices_offset: u32,
            primcount: i32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_drawElementsInstanced(
                    transmute(gl),
                    transmute(mode),
                    transmute(count),
                    transmute(element_type),
                    transmute(indices_offset),
                    transmute(primcount),
                ))
            }
        }
        pub(crate) fn AzGl_blendColor(gl: &AzGl, r: f32, g: f32, b: f32, a: f32) {
            unsafe {
                transmute(azul_dll::AzGl_blendColor(
                    transmute(gl),
                    transmute(r),
                    transmute(g),
                    transmute(b),
                    transmute(a),
                ))
            }
        }
        pub(crate) fn AzGl_blendFunc(gl: &AzGl, sfactor: u32, dfactor: u32) {
            unsafe {
                transmute(azul_dll::AzGl_blendFunc(
                    transmute(gl),
                    transmute(sfactor),
                    transmute(dfactor),
                ))
            }
        }
        pub(crate) fn AzGl_blendFuncSeparate(
            gl: &AzGl,
            src_rgb: u32,
            dest_rgb: u32,
            src_alpha: u32,
            dest_alpha: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_blendFuncSeparate(
                    transmute(gl),
                    transmute(src_rgb),
                    transmute(dest_rgb),
                    transmute(src_alpha),
                    transmute(dest_alpha),
                ))
            }
        }
        pub(crate) fn AzGl_blendEquation(gl: &AzGl, mode: u32) {
            unsafe { transmute(azul_dll::AzGl_blendEquation(transmute(gl), transmute(mode))) }
        }
        pub(crate) fn AzGl_blendEquationSeparate(gl: &AzGl, mode_rgb: u32, mode_alpha: u32) {
            unsafe {
                transmute(azul_dll::AzGl_blendEquationSeparate(
                    transmute(gl),
                    transmute(mode_rgb),
                    transmute(mode_alpha),
                ))
            }
        }
        pub(crate) fn AzGl_colorMask(gl: &AzGl, r: bool, g: bool, b: bool, a: bool) {
            unsafe {
                transmute(azul_dll::AzGl_colorMask(
                    transmute(gl),
                    transmute(r),
                    transmute(g),
                    transmute(b),
                    transmute(a),
                ))
            }
        }
        pub(crate) fn AzGl_cullFace(gl: &AzGl, mode: u32) {
            unsafe { transmute(azul_dll::AzGl_cullFace(transmute(gl), transmute(mode))) }
        }
        pub(crate) fn AzGl_frontFace(gl: &AzGl, mode: u32) {
            unsafe { transmute(azul_dll::AzGl_frontFace(transmute(gl), transmute(mode))) }
        }
        pub(crate) fn AzGl_enable(gl: &AzGl, cap: u32) {
            unsafe { transmute(azul_dll::AzGl_enable(transmute(gl), transmute(cap))) }
        }
        pub(crate) fn AzGl_disable(gl: &AzGl, cap: u32) {
            unsafe { transmute(azul_dll::AzGl_disable(transmute(gl), transmute(cap))) }
        }
        pub(crate) fn AzGl_hint(gl: &AzGl, param_name: u32, param_val: u32) {
            unsafe {
                transmute(azul_dll::AzGl_hint(
                    transmute(gl),
                    transmute(param_name),
                    transmute(param_val),
                ))
            }
        }
        pub(crate) fn AzGl_isEnabled(gl: &AzGl, cap: u32) -> u8 {
            unsafe { transmute(azul_dll::AzGl_isEnabled(transmute(gl), transmute(cap))) }
        }
        pub(crate) fn AzGl_isShader(gl: &AzGl, shader: u32) -> u8 {
            unsafe { transmute(azul_dll::AzGl_isShader(transmute(gl), transmute(shader))) }
        }
        pub(crate) fn AzGl_isTexture(gl: &AzGl, texture: u32) -> u8 {
            unsafe { transmute(azul_dll::AzGl_isTexture(transmute(gl), transmute(texture))) }
        }
        pub(crate) fn AzGl_isFramebuffer(gl: &AzGl, framebuffer: u32) -> u8 {
            unsafe {
                transmute(azul_dll::AzGl_isFramebuffer(
                    transmute(gl),
                    transmute(framebuffer),
                ))
            }
        }
        pub(crate) fn AzGl_isRenderbuffer(gl: &AzGl, renderbuffer: u32) -> u8 {
            unsafe {
                transmute(azul_dll::AzGl_isRenderbuffer(
                    transmute(gl),
                    transmute(renderbuffer),
                ))
            }
        }
        pub(crate) fn AzGl_checkFrameBufferStatus(gl: &AzGl, target: u32) -> u32 {
            unsafe {
                transmute(azul_dll::AzGl_checkFrameBufferStatus(
                    transmute(gl),
                    transmute(target),
                ))
            }
        }
        pub(crate) fn AzGl_enableVertexAttribArray(gl: &AzGl, index: u32) {
            unsafe {
                transmute(azul_dll::AzGl_enableVertexAttribArray(
                    transmute(gl),
                    transmute(index),
                ))
            }
        }
        pub(crate) fn AzGl_disableVertexAttribArray(gl: &AzGl, index: u32) {
            unsafe {
                transmute(azul_dll::AzGl_disableVertexAttribArray(
                    transmute(gl),
                    transmute(index),
                ))
            }
        }
        pub(crate) fn AzGl_uniform1F(gl: &AzGl, location: i32, v0: f32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform1F(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                ))
            }
        }
        pub(crate) fn AzGl_uniform1Fv(gl: &AzGl, location: i32, values: AzF32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform1Fv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniform1I(gl: &AzGl, location: i32, v0: i32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform1I(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                ))
            }
        }
        pub(crate) fn AzGl_uniform1Iv(gl: &AzGl, location: i32, values: AzI32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform1Iv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniform1Ui(gl: &AzGl, location: i32, v0: u32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform1Ui(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                ))
            }
        }
        pub(crate) fn AzGl_uniform2F(gl: &AzGl, location: i32, v0: f32, v1: f32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform2F(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                    transmute(v1),
                ))
            }
        }
        pub(crate) fn AzGl_uniform2Fv(gl: &AzGl, location: i32, values: AzF32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform2Fv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniform2I(gl: &AzGl, location: i32, v0: i32, v1: i32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform2I(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                    transmute(v1),
                ))
            }
        }
        pub(crate) fn AzGl_uniform2Iv(gl: &AzGl, location: i32, values: AzI32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform2Iv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniform2Ui(gl: &AzGl, location: i32, v0: u32, v1: u32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform2Ui(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                    transmute(v1),
                ))
            }
        }
        pub(crate) fn AzGl_uniform3F(gl: &AzGl, location: i32, v0: f32, v1: f32, v2: f32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform3F(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                    transmute(v1),
                    transmute(v2),
                ))
            }
        }
        pub(crate) fn AzGl_uniform3Fv(gl: &AzGl, location: i32, values: AzF32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform3Fv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniform3I(gl: &AzGl, location: i32, v0: i32, v1: i32, v2: i32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform3I(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                    transmute(v1),
                    transmute(v2),
                ))
            }
        }
        pub(crate) fn AzGl_uniform3Iv(gl: &AzGl, location: i32, values: AzI32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform3Iv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniform3Ui(gl: &AzGl, location: i32, v0: u32, v1: u32, v2: u32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform3Ui(
                    transmute(gl),
                    transmute(location),
                    transmute(v0),
                    transmute(v1),
                    transmute(v2),
                ))
            }
        }
        pub(crate) fn AzGl_uniform4F(gl: &AzGl, location: i32, x: f32, y: f32, z: f32, w: f32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform4F(
                    transmute(gl),
                    transmute(location),
                    transmute(x),
                    transmute(y),
                    transmute(z),
                    transmute(w),
                ))
            }
        }
        pub(crate) fn AzGl_uniform4I(gl: &AzGl, location: i32, x: i32, y: i32, z: i32, w: i32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform4I(
                    transmute(gl),
                    transmute(location),
                    transmute(x),
                    transmute(y),
                    transmute(z),
                    transmute(w),
                ))
            }
        }
        pub(crate) fn AzGl_uniform4Iv(gl: &AzGl, location: i32, values: AzI32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform4Iv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniform4Ui(gl: &AzGl, location: i32, x: u32, y: u32, z: u32, w: u32) {
            unsafe {
                transmute(azul_dll::AzGl_uniform4Ui(
                    transmute(gl),
                    transmute(location),
                    transmute(x),
                    transmute(y),
                    transmute(z),
                    transmute(w),
                ))
            }
        }
        pub(crate) fn AzGl_uniform4Fv(gl: &AzGl, location: i32, values: AzF32VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_uniform4Fv(
                    transmute(gl),
                    transmute(location),
                    transmute(values),
                ))
            }
        }
        pub(crate) fn AzGl_uniformMatrix2Fv(
            gl: &AzGl,
            location: i32,
            transpose: bool,
            value: AzF32VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_uniformMatrix2Fv(
                    transmute(gl),
                    transmute(location),
                    transmute(transpose),
                    transmute(value),
                ))
            }
        }
        pub(crate) fn AzGl_uniformMatrix3Fv(
            gl: &AzGl,
            location: i32,
            transpose: bool,
            value: AzF32VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_uniformMatrix3Fv(
                    transmute(gl),
                    transmute(location),
                    transmute(transpose),
                    transmute(value),
                ))
            }
        }
        pub(crate) fn AzGl_uniformMatrix4Fv(
            gl: &AzGl,
            location: i32,
            transpose: bool,
            value: AzF32VecRef,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_uniformMatrix4Fv(
                    transmute(gl),
                    transmute(location),
                    transmute(transpose),
                    transmute(value),
                ))
            }
        }
        pub(crate) fn AzGl_depthMask(gl: &AzGl, flag: bool) {
            unsafe { transmute(azul_dll::AzGl_depthMask(transmute(gl), transmute(flag))) }
        }
        pub(crate) fn AzGl_depthRange(gl: &AzGl, near: f64, far: f64) {
            unsafe {
                transmute(azul_dll::AzGl_depthRange(
                    transmute(gl),
                    transmute(near),
                    transmute(far),
                ))
            }
        }
        pub(crate) fn AzGl_getActiveAttrib(
            gl: &AzGl,
            program: u32,
            index: u32,
        ) -> AzGetActiveAttribReturn {
            unsafe {
                transmute(azul_dll::AzGl_getActiveAttrib(
                    transmute(gl),
                    transmute(program),
                    transmute(index),
                ))
            }
        }
        pub(crate) fn AzGl_getActiveUniform(
            gl: &AzGl,
            program: u32,
            index: u32,
        ) -> AzGetActiveUniformReturn {
            unsafe {
                transmute(azul_dll::AzGl_getActiveUniform(
                    transmute(gl),
                    transmute(program),
                    transmute(index),
                ))
            }
        }
        pub(crate) fn AzGl_getActiveUniformsIv(
            gl: &AzGl,
            program: u32,
            indices: AzGLuintVec,
            pname: u32,
        ) -> AzGLintVec {
            unsafe {
                transmute(azul_dll::AzGl_getActiveUniformsIv(
                    transmute(gl),
                    transmute(program),
                    transmute(indices),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getActiveUniformBlockI(
            gl: &AzGl,
            program: u32,
            index: u32,
            pname: u32,
        ) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getActiveUniformBlockI(
                    transmute(gl),
                    transmute(program),
                    transmute(index),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getActiveUniformBlockIv(
            gl: &AzGl,
            program: u32,
            index: u32,
            pname: u32,
        ) -> AzGLintVec {
            unsafe {
                transmute(azul_dll::AzGl_getActiveUniformBlockIv(
                    transmute(gl),
                    transmute(program),
                    transmute(index),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getActiveUniformBlockName(
            gl: &AzGl,
            program: u32,
            index: u32,
        ) -> AzString {
            unsafe {
                transmute(azul_dll::AzGl_getActiveUniformBlockName(
                    transmute(gl),
                    transmute(program),
                    transmute(index),
                ))
            }
        }
        pub(crate) fn AzGl_getAttribLocation(gl: &AzGl, program: u32, name: AzRefstr) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getAttribLocation(
                    transmute(gl),
                    transmute(program),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getFragDataLocation(gl: &AzGl, program: u32, name: AzRefstr) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getFragDataLocation(
                    transmute(gl),
                    transmute(program),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getUniformLocation(gl: &AzGl, program: u32, name: AzRefstr) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getUniformLocation(
                    transmute(gl),
                    transmute(program),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getProgramInfoLog(gl: &AzGl, program: u32) -> AzString {
            unsafe {
                transmute(azul_dll::AzGl_getProgramInfoLog(
                    transmute(gl),
                    transmute(program),
                ))
            }
        }
        pub(crate) fn AzGl_getProgramIv(
            gl: &AzGl,
            program: u32,
            pname: u32,
            result: AzGLintVecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getProgramIv(
                    transmute(gl),
                    transmute(program),
                    transmute(pname),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getProgramBinary(gl: &AzGl, program: u32) -> AzGetProgramBinaryReturn {
            unsafe {
                transmute(azul_dll::AzGl_getProgramBinary(
                    transmute(gl),
                    transmute(program),
                ))
            }
        }
        pub(crate) fn AzGl_programBinary(gl: &AzGl, program: u32, format: u32, binary: AzU8VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_programBinary(
                    transmute(gl),
                    transmute(program),
                    transmute(format),
                    transmute(binary),
                ))
            }
        }
        pub(crate) fn AzGl_programParameterI(gl: &AzGl, program: u32, pname: u32, value: i32) {
            unsafe {
                transmute(azul_dll::AzGl_programParameterI(
                    transmute(gl),
                    transmute(program),
                    transmute(pname),
                    transmute(value),
                ))
            }
        }
        pub(crate) fn AzGl_getVertexAttribIv(
            gl: &AzGl,
            index: u32,
            pname: u32,
            result: AzGLintVecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getVertexAttribIv(
                    transmute(gl),
                    transmute(index),
                    transmute(pname),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getVertexAttribFv(
            gl: &AzGl,
            index: u32,
            pname: u32,
            result: AzGLfloatVecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getVertexAttribFv(
                    transmute(gl),
                    transmute(index),
                    transmute(pname),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getVertexAttribPointerV(gl: &AzGl, index: u32, pname: u32) -> isize {
            unsafe {
                transmute(azul_dll::AzGl_getVertexAttribPointerV(
                    transmute(gl),
                    transmute(index),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getBufferParameterIv(gl: &AzGl, target: u32, pname: u32) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getBufferParameterIv(
                    transmute(gl),
                    transmute(target),
                    transmute(pname),
                ))
            }
        }
        pub(crate) fn AzGl_getShaderInfoLog(gl: &AzGl, shader: u32) -> AzString {
            unsafe {
                transmute(azul_dll::AzGl_getShaderInfoLog(
                    transmute(gl),
                    transmute(shader),
                ))
            }
        }
        pub(crate) fn AzGl_getString(gl: &AzGl, which: u32) -> AzString {
            unsafe { transmute(azul_dll::AzGl_getString(transmute(gl), transmute(which))) }
        }
        pub(crate) fn AzGl_getStringI(gl: &AzGl, which: u32, index: u32) -> AzString {
            unsafe {
                transmute(azul_dll::AzGl_getStringI(
                    transmute(gl),
                    transmute(which),
                    transmute(index),
                ))
            }
        }
        pub(crate) fn AzGl_getShaderIv(
            gl: &AzGl,
            shader: u32,
            pname: u32,
            result: AzGLintVecRefMut,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_getShaderIv(
                    transmute(gl),
                    transmute(shader),
                    transmute(pname),
                    transmute(result),
                ))
            }
        }
        pub(crate) fn AzGl_getShaderPrecisionFormat(
            gl: &AzGl,
            shader_type: u32,
            precision_type: u32,
        ) -> AzGlShaderPrecisionFormatReturn {
            unsafe {
                transmute(azul_dll::AzGl_getShaderPrecisionFormat(
                    transmute(gl),
                    transmute(shader_type),
                    transmute(precision_type),
                ))
            }
        }
        pub(crate) fn AzGl_compileShader(gl: &AzGl, shader: u32) {
            unsafe {
                transmute(azul_dll::AzGl_compileShader(
                    transmute(gl),
                    transmute(shader),
                ))
            }
        }
        pub(crate) fn AzGl_createProgram(gl: &AzGl) -> u32 {
            unsafe { transmute(azul_dll::AzGl_createProgram(transmute(gl))) }
        }
        pub(crate) fn AzGl_deleteProgram(gl: &AzGl, program: u32) {
            unsafe {
                transmute(azul_dll::AzGl_deleteProgram(
                    transmute(gl),
                    transmute(program),
                ))
            }
        }
        pub(crate) fn AzGl_createShader(gl: &AzGl, shader_type: u32) -> u32 {
            unsafe {
                transmute(azul_dll::AzGl_createShader(
                    transmute(gl),
                    transmute(shader_type),
                ))
            }
        }
        pub(crate) fn AzGl_deleteShader(gl: &AzGl, shader: u32) {
            unsafe {
                transmute(azul_dll::AzGl_deleteShader(
                    transmute(gl),
                    transmute(shader),
                ))
            }
        }
        pub(crate) fn AzGl_detachShader(gl: &AzGl, program: u32, shader: u32) {
            unsafe {
                transmute(azul_dll::AzGl_detachShader(
                    transmute(gl),
                    transmute(program),
                    transmute(shader),
                ))
            }
        }
        pub(crate) fn AzGl_linkProgram(gl: &AzGl, program: u32) {
            unsafe {
                transmute(azul_dll::AzGl_linkProgram(
                    transmute(gl),
                    transmute(program),
                ))
            }
        }
        pub(crate) fn AzGl_clearColor(gl: &AzGl, r: f32, g: f32, b: f32, a: f32) {
            unsafe {
                transmute(azul_dll::AzGl_clearColor(
                    transmute(gl),
                    transmute(r),
                    transmute(g),
                    transmute(b),
                    transmute(a),
                ))
            }
        }
        pub(crate) fn AzGl_clear(gl: &AzGl, buffer_mask: u32) {
            unsafe { transmute(azul_dll::AzGl_clear(transmute(gl), transmute(buffer_mask))) }
        }
        pub(crate) fn AzGl_clearDepth(gl: &AzGl, depth: f64) {
            unsafe { transmute(azul_dll::AzGl_clearDepth(transmute(gl), transmute(depth))) }
        }
        pub(crate) fn AzGl_clearStencil(gl: &AzGl, s: i32) {
            unsafe { transmute(azul_dll::AzGl_clearStencil(transmute(gl), transmute(s))) }
        }
        pub(crate) fn AzGl_flush(gl: &AzGl) {
            unsafe { transmute(azul_dll::AzGl_flush(transmute(gl))) }
        }
        pub(crate) fn AzGl_finish(gl: &AzGl) {
            unsafe { transmute(azul_dll::AzGl_finish(transmute(gl))) }
        }
        pub(crate) fn AzGl_getError(gl: &AzGl) -> u32 {
            unsafe { transmute(azul_dll::AzGl_getError(transmute(gl))) }
        }
        pub(crate) fn AzGl_stencilMask(gl: &AzGl, mask: u32) {
            unsafe { transmute(azul_dll::AzGl_stencilMask(transmute(gl), transmute(mask))) }
        }
        pub(crate) fn AzGl_stencilMaskSeparate(gl: &AzGl, face: u32, mask: u32) {
            unsafe {
                transmute(azul_dll::AzGl_stencilMaskSeparate(
                    transmute(gl),
                    transmute(face),
                    transmute(mask),
                ))
            }
        }
        pub(crate) fn AzGl_stencilFunc(gl: &AzGl, func: u32, ref_: i32, mask: u32) {
            unsafe {
                transmute(azul_dll::AzGl_stencilFunc(
                    transmute(gl),
                    transmute(func),
                    transmute(ref_),
                    transmute(mask),
                ))
            }
        }
        pub(crate) fn AzGl_stencilFuncSeparate(
            gl: &AzGl,
            face: u32,
            func: u32,
            ref_: i32,
            mask: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_stencilFuncSeparate(
                    transmute(gl),
                    transmute(face),
                    transmute(func),
                    transmute(ref_),
                    transmute(mask),
                ))
            }
        }
        pub(crate) fn AzGl_stencilOp(gl: &AzGl, sfail: u32, dpfail: u32, dppass: u32) {
            unsafe {
                transmute(azul_dll::AzGl_stencilOp(
                    transmute(gl),
                    transmute(sfail),
                    transmute(dpfail),
                    transmute(dppass),
                ))
            }
        }
        pub(crate) fn AzGl_stencilOpSeparate(
            gl: &AzGl,
            face: u32,
            sfail: u32,
            dpfail: u32,
            dppass: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_stencilOpSeparate(
                    transmute(gl),
                    transmute(face),
                    transmute(sfail),
                    transmute(dpfail),
                    transmute(dppass),
                ))
            }
        }
        pub(crate) fn AzGl_eglImageTargetTexture2DOes(
            gl: &AzGl,
            target: u32,
            image: AzGlVoidPtrConst,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_eglImageTargetTexture2DOes(
                    transmute(gl),
                    transmute(target),
                    transmute(image),
                ))
            }
        }
        pub(crate) fn AzGl_generateMipmap(gl: &AzGl, target: u32) {
            unsafe {
                transmute(azul_dll::AzGl_generateMipmap(
                    transmute(gl),
                    transmute(target),
                ))
            }
        }
        pub(crate) fn AzGl_insertEventMarkerExt(gl: &AzGl, message: AzRefstr) {
            unsafe {
                transmute(azul_dll::AzGl_insertEventMarkerExt(
                    transmute(gl),
                    transmute(message),
                ))
            }
        }
        pub(crate) fn AzGl_pushGroupMarkerExt(gl: &AzGl, message: AzRefstr) {
            unsafe {
                transmute(azul_dll::AzGl_pushGroupMarkerExt(
                    transmute(gl),
                    transmute(message),
                ))
            }
        }
        pub(crate) fn AzGl_popGroupMarkerExt(gl: &AzGl) {
            unsafe { transmute(azul_dll::AzGl_popGroupMarkerExt(transmute(gl))) }
        }
        pub(crate) fn AzGl_debugMessageInsertKhr(
            gl: &AzGl,
            source: u32,
            type_: u32,
            id: u32,
            severity: u32,
            message: AzRefstr,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_debugMessageInsertKhr(
                    transmute(gl),
                    transmute(source),
                    transmute(type_),
                    transmute(id),
                    transmute(severity),
                    transmute(message),
                ))
            }
        }
        pub(crate) fn AzGl_pushDebugGroupKhr(gl: &AzGl, source: u32, id: u32, message: AzRefstr) {
            unsafe {
                transmute(azul_dll::AzGl_pushDebugGroupKhr(
                    transmute(gl),
                    transmute(source),
                    transmute(id),
                    transmute(message),
                ))
            }
        }
        pub(crate) fn AzGl_popDebugGroupKhr(gl: &AzGl) {
            unsafe { transmute(azul_dll::AzGl_popDebugGroupKhr(transmute(gl))) }
        }
        pub(crate) fn AzGl_fenceSync(gl: &AzGl, condition: u32, flags: u32) -> AzGLsyncPtr {
            unsafe {
                transmute(azul_dll::AzGl_fenceSync(
                    transmute(gl),
                    transmute(condition),
                    transmute(flags),
                ))
            }
        }
        pub(crate) fn AzGl_clientWaitSync(
            gl: &AzGl,
            sync: AzGLsyncPtr,
            flags: u32,
            timeout: u64,
        ) -> u32 {
            unsafe {
                transmute(azul_dll::AzGl_clientWaitSync(
                    transmute(gl),
                    transmute(sync),
                    transmute(flags),
                    transmute(timeout),
                ))
            }
        }
        pub(crate) fn AzGl_waitSync(gl: &AzGl, sync: AzGLsyncPtr, flags: u32, timeout: u64) {
            unsafe {
                transmute(azul_dll::AzGl_waitSync(
                    transmute(gl),
                    transmute(sync),
                    transmute(flags),
                    transmute(timeout),
                ))
            }
        }
        pub(crate) fn AzGl_deleteSync(gl: &AzGl, sync: AzGLsyncPtr) {
            unsafe { transmute(azul_dll::AzGl_deleteSync(transmute(gl), transmute(sync))) }
        }
        pub(crate) fn AzGl_textureRangeApple(gl: &AzGl, target: u32, data: AzU8VecRef) {
            unsafe {
                transmute(azul_dll::AzGl_textureRangeApple(
                    transmute(gl),
                    transmute(target),
                    transmute(data),
                ))
            }
        }
        pub(crate) fn AzGl_genFencesApple(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe { transmute(azul_dll::AzGl_genFencesApple(transmute(gl), transmute(n))) }
        }
        pub(crate) fn AzGl_deleteFencesApple(gl: &AzGl, fences: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteFencesApple(
                    transmute(gl),
                    transmute(fences),
                ))
            }
        }
        pub(crate) fn AzGl_setFenceApple(gl: &AzGl, fence: u32) {
            unsafe {
                transmute(azul_dll::AzGl_setFenceApple(
                    transmute(gl),
                    transmute(fence),
                ))
            }
        }
        pub(crate) fn AzGl_finishFenceApple(gl: &AzGl, fence: u32) {
            unsafe {
                transmute(azul_dll::AzGl_finishFenceApple(
                    transmute(gl),
                    transmute(fence),
                ))
            }
        }
        pub(crate) fn AzGl_testFenceApple(gl: &AzGl, fence: u32) {
            unsafe {
                transmute(azul_dll::AzGl_testFenceApple(
                    transmute(gl),
                    transmute(fence),
                ))
            }
        }
        pub(crate) fn AzGl_testObjectApple(gl: &AzGl, object: u32, name: u32) -> u8 {
            unsafe {
                transmute(azul_dll::AzGl_testObjectApple(
                    transmute(gl),
                    transmute(object),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_finishObjectApple(gl: &AzGl, object: u32, name: u32) {
            unsafe {
                transmute(azul_dll::AzGl_finishObjectApple(
                    transmute(gl),
                    transmute(object),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getFragDataIndex(gl: &AzGl, program: u32, name: AzRefstr) -> i32 {
            unsafe {
                transmute(azul_dll::AzGl_getFragDataIndex(
                    transmute(gl),
                    transmute(program),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_blendBarrierKhr(gl: &AzGl) {
            unsafe { transmute(azul_dll::AzGl_blendBarrierKhr(transmute(gl))) }
        }
        pub(crate) fn AzGl_bindFragDataLocationIndexed(
            gl: &AzGl,
            program: u32,
            color_number: u32,
            index: u32,
            name: AzRefstr,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_bindFragDataLocationIndexed(
                    transmute(gl),
                    transmute(program),
                    transmute(color_number),
                    transmute(index),
                    transmute(name),
                ))
            }
        }
        pub(crate) fn AzGl_getDebugMessages(gl: &AzGl) -> AzDebugMessageVec {
            unsafe { transmute(azul_dll::AzGl_getDebugMessages(transmute(gl))) }
        }
        pub(crate) fn AzGl_provokingVertexAngle(gl: &AzGl, mode: u32) {
            unsafe {
                transmute(azul_dll::AzGl_provokingVertexAngle(
                    transmute(gl),
                    transmute(mode),
                ))
            }
        }
        pub(crate) fn AzGl_genVertexArraysApple(gl: &AzGl, n: i32) -> AzGLuintVec {
            unsafe {
                transmute(azul_dll::AzGl_genVertexArraysApple(
                    transmute(gl),
                    transmute(n),
                ))
            }
        }
        pub(crate) fn AzGl_bindVertexArrayApple(gl: &AzGl, vao: u32) {
            unsafe {
                transmute(azul_dll::AzGl_bindVertexArrayApple(
                    transmute(gl),
                    transmute(vao),
                ))
            }
        }
        pub(crate) fn AzGl_deleteVertexArraysApple(gl: &AzGl, vertex_arrays: AzGLuintVecRef) {
            unsafe {
                transmute(azul_dll::AzGl_deleteVertexArraysApple(
                    transmute(gl),
                    transmute(vertex_arrays),
                ))
            }
        }
        pub(crate) fn AzGl_copyTextureChromium(
            gl: &AzGl,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            internal_format: i32,
            dest_type: u32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copyTextureChromium(
                    transmute(gl),
                    transmute(source_id),
                    transmute(source_level),
                    transmute(dest_target),
                    transmute(dest_id),
                    transmute(dest_level),
                    transmute(internal_format),
                    transmute(dest_type),
                    transmute(unpack_flip_y),
                    transmute(unpack_premultiply_alpha),
                    transmute(unpack_unmultiply_alpha),
                ))
            }
        }
        pub(crate) fn AzGl_copySubTextureChromium(
            gl: &AzGl,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            x_offset: i32,
            y_offset: i32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copySubTextureChromium(
                    transmute(gl),
                    transmute(source_id),
                    transmute(source_level),
                    transmute(dest_target),
                    transmute(dest_id),
                    transmute(dest_level),
                    transmute(x_offset),
                    transmute(y_offset),
                    transmute(x),
                    transmute(y),
                    transmute(width),
                    transmute(height),
                    transmute(unpack_flip_y),
                    transmute(unpack_premultiply_alpha),
                    transmute(unpack_unmultiply_alpha),
                ))
            }
        }
        pub(crate) fn AzGl_eglImageTargetRenderbufferStorageOes(
            gl: &AzGl,
            target: u32,
            image: AzGlVoidPtrConst,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_eglImageTargetRenderbufferStorageOes(
                    transmute(gl),
                    transmute(target),
                    transmute(image),
                ))
            }
        }
        pub(crate) fn AzGl_copyTexture3DAngle(
            gl: &AzGl,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            internal_format: i32,
            dest_type: u32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copyTexture3DAngle(
                    transmute(gl),
                    transmute(source_id),
                    transmute(source_level),
                    transmute(dest_target),
                    transmute(dest_id),
                    transmute(dest_level),
                    transmute(internal_format),
                    transmute(dest_type),
                    transmute(unpack_flip_y),
                    transmute(unpack_premultiply_alpha),
                    transmute(unpack_unmultiply_alpha),
                ))
            }
        }
        pub(crate) fn AzGl_copySubTexture3DAngle(
            gl: &AzGl,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            x_offset: i32,
            y_offset: i32,
            z_offset: i32,
            x: i32,
            y: i32,
            z: i32,
            width: i32,
            height: i32,
            depth: i32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_copySubTexture3DAngle(
                    transmute(gl),
                    transmute(source_id),
                    transmute(source_level),
                    transmute(dest_target),
                    transmute(dest_id),
                    transmute(dest_level),
                    transmute(x_offset),
                    transmute(y_offset),
                    transmute(z_offset),
                    transmute(x),
                    transmute(y),
                    transmute(z),
                    transmute(width),
                    transmute(height),
                    transmute(depth),
                    transmute(unpack_flip_y),
                    transmute(unpack_premultiply_alpha),
                    transmute(unpack_unmultiply_alpha),
                ))
            }
        }
        pub(crate) fn AzGl_bufferStorage(
            gl: &AzGl,
            target: u32,
            size: isize,
            data: AzGlVoidPtrConst,
            flags: u32,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_bufferStorage(
                    transmute(gl),
                    transmute(target),
                    transmute(size),
                    transmute(data),
                    transmute(flags),
                ))
            }
        }
        pub(crate) fn AzGl_flushMappedBufferRange(
            gl: &AzGl,
            target: u32,
            offset: isize,
            length: isize,
        ) {
            unsafe {
                transmute(azul_dll::AzGl_flushMappedBufferRange(
                    transmute(gl),
                    transmute(target),
                    transmute(offset),
                    transmute(length),
                ))
            }
        }
        pub(crate) fn AzGl_delete(object: &mut AzGl) {
            unsafe { transmute(azul_dll::AzGl_delete(transmute(object))) }
        }
        pub(crate) fn AzGl_deepCopy(object: &AzGl) -> AzGl {
            unsafe { transmute(azul_dll::AzGl_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzVertexArrayObject_new(
            vertex_layout: AzVertexLayout,
            vao_id: u32,
            gl_context: AzGl,
        ) -> AzVertexArrayObject {
            unsafe {
                transmute(azul_dll::AzVertexArrayObject_new(
                    transmute(vertex_layout),
                    transmute(vao_id),
                    transmute(gl_context),
                ))
            }
        }
        pub(crate) fn AzVertexArrayObject_delete(object: &mut AzVertexArrayObject) {
            unsafe { transmute(azul_dll::AzVertexArrayObject_delete(transmute(object))) }
        }
        pub(crate) fn AzVertexArrayObject_deepCopy(
            object: &AzVertexArrayObject,
        ) -> AzVertexArrayObject {
            unsafe { transmute(azul_dll::AzVertexArrayObject_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzVertexBuffer_new(
            vertex_buffer_id: u32,
            vertex_buffer_len: usize,
            vao: AzVertexArrayObject,
            index_buffer_id: u32,
            index_buffer_len: usize,
            index_buffer_format: AzIndexBufferFormat,
        ) -> AzVertexBuffer {
            unsafe {
                transmute(azul_dll::AzVertexBuffer_new(
                    transmute(vertex_buffer_id),
                    transmute(vertex_buffer_len),
                    transmute(vao),
                    transmute(index_buffer_id),
                    transmute(index_buffer_len),
                    transmute(index_buffer_format),
                ))
            }
        }
        pub(crate) fn AzVertexBuffer_delete(object: &mut AzVertexBuffer) {
            unsafe { transmute(azul_dll::AzVertexBuffer_delete(transmute(object))) }
        }
        pub(crate) fn AzVertexBuffer_deepCopy(object: &AzVertexBuffer) -> AzVertexBuffer {
            unsafe { transmute(azul_dll::AzVertexBuffer_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzGLsyncPtr_delete(object: &mut AzGLsyncPtr) {
            unsafe { transmute(azul_dll::AzGLsyncPtr_delete(transmute(object))) }
        }
        pub(crate) fn AzGLsyncPtr_deepCopy(object: &AzGLsyncPtr) -> AzGLsyncPtr {
            unsafe { transmute(azul_dll::AzGLsyncPtr_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzTextureFlags_default() -> AzTextureFlags {
            unsafe { transmute(azul_dll::AzTextureFlags_default()) }
        }
        pub(crate) fn AzImageRef_nullImage(
            width: usize,
            height: usize,
            format: AzRawImageFormat,
            tag: AzU8Vec,
        ) -> AzImageRef {
            unsafe {
                transmute(azul_dll::AzImageRef_nullImage(
                    transmute(width),
                    transmute(height),
                    transmute(format),
                    transmute(tag),
                ))
            }
        }
        pub(crate) fn AzImageRef_rawImage(data: AzRawImage) -> AzOptionImageRef {
            unsafe { transmute(azul_dll::AzImageRef_rawImage(transmute(data))) }
        }
        pub(crate) fn AzImageRef_glTexture(texture: AzTexture) -> AzImageRef {
            unsafe { transmute(azul_dll::AzImageRef_glTexture(transmute(texture))) }
        }
        pub(crate) fn AzImageRef_callback(
            data: AzRefAny,
            callback: AzRenderImageCallbackType,
        ) -> AzImageRef {
            unsafe {
                transmute(azul_dll::AzImageRef_callback(
                    transmute(data),
                    transmute(callback),
                ))
            }
        }
        pub(crate) fn AzImageRef_cloneBytes(imageref: &AzImageRef) -> AzImageRef {
            unsafe { transmute(azul_dll::AzImageRef_cloneBytes(transmute(imageref))) }
        }
        pub(crate) fn AzImageRef_isInvalid(imageref: &AzImageRef) -> bool {
            unsafe { transmute(azul_dll::AzImageRef_isInvalid(transmute(imageref))) }
        }
        pub(crate) fn AzImageRef_isGlTexture(imageref: &AzImageRef) -> bool {
            unsafe { transmute(azul_dll::AzImageRef_isGlTexture(transmute(imageref))) }
        }
        pub(crate) fn AzImageRef_isRawImage(imageref: &AzImageRef) -> bool {
            unsafe { transmute(azul_dll::AzImageRef_isRawImage(transmute(imageref))) }
        }
        pub(crate) fn AzImageRef_isCallback(imageref: &AzImageRef) -> bool {
            unsafe { transmute(azul_dll::AzImageRef_isCallback(transmute(imageref))) }
        }
        pub(crate) fn AzImageRef_getRawImage(imageref: &AzImageRef) -> AzOptionRawImage {
            unsafe { transmute(azul_dll::AzImageRef_getRawImage(transmute(imageref))) }
        }
        pub(crate) fn AzImageRef_getHash(imageref: &AzImageRef) -> u64 {
            unsafe { transmute(azul_dll::AzImageRef_getHash(transmute(imageref))) }
        }
        pub(crate) fn AzImageRef_delete(object: &mut AzImageRef) {
            unsafe { transmute(azul_dll::AzImageRef_delete(transmute(object))) }
        }
        pub(crate) fn AzImageRef_deepCopy(object: &AzImageRef) -> AzImageRef {
            unsafe { transmute(azul_dll::AzImageRef_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzRawImage_empty() -> AzRawImage {
            unsafe { transmute(azul_dll::AzRawImage_empty()) }
        }
        pub(crate) fn AzRawImage_allocateClipMask(size: AzLayoutSize) -> AzRawImage {
            unsafe { transmute(azul_dll::AzRawImage_allocateClipMask(transmute(size))) }
        }
        pub(crate) fn AzRawImage_decodeImageBytesAny(
            bytes: AzU8VecRef,
        ) -> AzResultRawImageDecodeImageError {
            unsafe { transmute(azul_dll::AzRawImage_decodeImageBytesAny(transmute(bytes))) }
        }
        pub(crate) fn AzRawImage_drawClipMask(
            rawimage: &mut AzRawImage,
            node: AzSvgNode,
            style: AzSvgStyle,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzRawImage_drawClipMask(
                    transmute(rawimage),
                    transmute(node),
                    transmute(style),
                ))
            }
        }
        pub(crate) fn AzRawImage_encodeBmp(rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError {
            unsafe { transmute(azul_dll::AzRawImage_encodeBmp(transmute(rawimage))) }
        }
        pub(crate) fn AzRawImage_encodePng(rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError {
            unsafe { transmute(azul_dll::AzRawImage_encodePng(transmute(rawimage))) }
        }
        pub(crate) fn AzRawImage_encodeJpeg(
            rawimage: &AzRawImage,
            quality: u8,
        ) -> AzResultU8VecEncodeImageError {
            unsafe {
                transmute(azul_dll::AzRawImage_encodeJpeg(
                    transmute(rawimage),
                    transmute(quality),
                ))
            }
        }
        pub(crate) fn AzRawImage_encodeTga(rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError {
            unsafe { transmute(azul_dll::AzRawImage_encodeTga(transmute(rawimage))) }
        }
        pub(crate) fn AzRawImage_encodePnm(rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError {
            unsafe { transmute(azul_dll::AzRawImage_encodePnm(transmute(rawimage))) }
        }
        pub(crate) fn AzRawImage_encodeGif(rawimage: &AzRawImage) -> AzResultU8VecEncodeImageError {
            unsafe { transmute(azul_dll::AzRawImage_encodeGif(transmute(rawimage))) }
        }
        pub(crate) fn AzRawImage_encodeTiff(
            rawimage: &AzRawImage,
        ) -> AzResultU8VecEncodeImageError {
            unsafe { transmute(azul_dll::AzRawImage_encodeTiff(transmute(rawimage))) }
        }
        pub(crate) fn AzFontMetrics_zero() -> AzFontMetrics {
            unsafe { transmute(azul_dll::AzFontMetrics_zero()) }
        }
        pub(crate) fn AzFontMetrics_useTypoMetrics(fontmetrics: &AzFontMetrics) -> bool {
            unsafe {
                transmute(azul_dll::AzFontMetrics_useTypoMetrics(transmute(
                    fontmetrics,
                )))
            }
        }
        pub(crate) fn AzFontMetrics_getAscender(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getAscender(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getDescender(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getDescender(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getLineGap(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getLineGap(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getXMin(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getXMin(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYMin(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYMin(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getXMax(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getXMax(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYMax(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYMax(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getAdvanceWidthMax(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getAdvanceWidthMax(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getMinLeftSideBearing(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getMinLeftSideBearing(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getMinRightSideBearing(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getMinRightSideBearing(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getXMaxExtent(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getXMaxExtent(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getXAvgCharWidth(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getXAvgCharWidth(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSubscriptXSize(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSubscriptXSize(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSubscriptYSize(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSubscriptYSize(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSubscriptXOffset(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSubscriptXOffset(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSubscriptYOffset(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSubscriptYOffset(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSuperscriptXSize(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSuperscriptXSize(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSuperscriptYSize(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSuperscriptYSize(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSuperscriptXOffset(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSuperscriptXOffset(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYSuperscriptYOffset(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYSuperscriptYOffset(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYStrikeoutSize(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYStrikeoutSize(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontMetrics_getYStrikeoutPosition(
            fontmetrics: &AzFontMetrics,
            target_font_size: f32,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzFontMetrics_getYStrikeoutPosition(
                    transmute(fontmetrics),
                    transmute(target_font_size),
                ))
            }
        }
        pub(crate) fn AzFontRef_parse(source: AzFontSource) -> AzOptionFontRef {
            unsafe { transmute(azul_dll::AzFontRef_parse(transmute(source))) }
        }
        pub(crate) fn AzFontRef_getBytes(fontref: &AzFontRef) -> AzU8Vec {
            unsafe { transmute(azul_dll::AzFontRef_getBytes(transmute(fontref))) }
        }
        pub(crate) fn AzFontRef_getFontMetrics(fontref: &AzFontRef) -> AzFontMetrics {
            unsafe { transmute(azul_dll::AzFontRef_getFontMetrics(transmute(fontref))) }
        }
        pub(crate) fn AzFontRef_shapeText(
            fontref: &AzFontRef,
            text: AzRefstr,
            options: AzResolvedTextLayoutOptions,
        ) -> AzInlineText {
            unsafe {
                transmute(azul_dll::AzFontRef_shapeText(
                    transmute(fontref),
                    transmute(text),
                    transmute(options),
                ))
            }
        }
        pub(crate) fn AzFontRef_getHash(fontref: &AzFontRef) -> u64 {
            unsafe { transmute(azul_dll::AzFontRef_getHash(transmute(fontref))) }
        }
        pub(crate) fn AzFontRef_delete(object: &mut AzFontRef) {
            unsafe { transmute(azul_dll::AzFontRef_delete(transmute(object))) }
        }
        pub(crate) fn AzFontRef_deepCopy(object: &AzFontRef) -> AzFontRef {
            unsafe { transmute(azul_dll::AzFontRef_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzSvg_fromString(
            svg_string: AzString,
            parse_options: AzSvgParseOptions,
        ) -> AzResultSvgSvgParseError {
            unsafe {
                transmute(azul_dll::AzSvg_fromString(
                    transmute(svg_string),
                    transmute(parse_options),
                ))
            }
        }
        pub(crate) fn AzSvg_fromBytes(
            svg_bytes: AzU8VecRef,
            parse_options: AzSvgParseOptions,
        ) -> AzResultSvgSvgParseError {
            unsafe {
                transmute(azul_dll::AzSvg_fromBytes(
                    transmute(svg_bytes),
                    transmute(parse_options),
                ))
            }
        }
        pub(crate) fn AzSvg_getRoot(svg: &AzSvg) -> AzSvgXmlNode {
            unsafe { transmute(azul_dll::AzSvg_getRoot(transmute(svg))) }
        }
        pub(crate) fn AzSvg_render(svg: &AzSvg, options: AzSvgRenderOptions) -> AzOptionRawImage {
            unsafe { transmute(azul_dll::AzSvg_render(transmute(svg), transmute(options))) }
        }
        pub(crate) fn AzSvg_toString(svg: &AzSvg, options: AzSvgStringFormatOptions) -> AzString {
            unsafe { transmute(azul_dll::AzSvg_toString(transmute(svg), transmute(options))) }
        }
        pub(crate) fn AzSvg_delete(object: &mut AzSvg) {
            unsafe { transmute(azul_dll::AzSvg_delete(transmute(object))) }
        }
        pub(crate) fn AzSvg_deepCopy(object: &AzSvg) -> AzSvg {
            unsafe { transmute(azul_dll::AzSvg_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzSvgXmlNode_parseFrom(
            svg_bytes: AzU8VecRef,
            parse_options: AzSvgParseOptions,
        ) -> AzResultSvgXmlNodeSvgParseError {
            unsafe {
                transmute(azul_dll::AzSvgXmlNode_parseFrom(
                    transmute(svg_bytes),
                    transmute(parse_options),
                ))
            }
        }
        pub(crate) fn AzSvgXmlNode_delete(object: &mut AzSvgXmlNode) {
            unsafe { transmute(azul_dll::AzSvgXmlNode_delete(transmute(object))) }
        }
        pub(crate) fn AzSvgXmlNode_deepCopy(object: &AzSvgXmlNode) -> AzSvgXmlNode {
            unsafe { transmute(azul_dll::AzSvgXmlNode_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzSvgMultiPolygon_getBounds(
            svgmultipolygon: &AzSvgMultiPolygon,
        ) -> AzSvgRect {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_getBounds(transmute(
                    svgmultipolygon,
                )))
            }
        }
        pub(crate) fn AzSvgMultiPolygon_containsPoint(
            svgmultipolygon: &AzSvgMultiPolygon,
            point: AzSvgPoint,
            fill_rule: AzSvgFillRule,
            tolerance: f32,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_containsPoint(
                    transmute(svgmultipolygon),
                    transmute(point),
                    transmute(fill_rule),
                    transmute(tolerance),
                ))
            }
        }
        pub(crate) fn AzSvgMultiPolygon_union(
            svgmultipolygon: &AzSvgMultiPolygon,
            other: AzSvgMultiPolygon,
        ) -> AzSvgMultiPolygon {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_union(
                    transmute(svgmultipolygon),
                    transmute(other),
                ))
            }
        }
        pub(crate) fn AzSvgMultiPolygon_intersection(
            svgmultipolygon: &AzSvgMultiPolygon,
            other: AzSvgMultiPolygon,
        ) -> AzSvgMultiPolygon {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_intersection(
                    transmute(svgmultipolygon),
                    transmute(other),
                ))
            }
        }
        pub(crate) fn AzSvgMultiPolygon_difference(
            svgmultipolygon: &AzSvgMultiPolygon,
            other: AzSvgMultiPolygon,
        ) -> AzSvgMultiPolygon {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_difference(
                    transmute(svgmultipolygon),
                    transmute(other),
                ))
            }
        }
        pub(crate) fn AzSvgMultiPolygon_xor(
            svgmultipolygon: &AzSvgMultiPolygon,
            other: AzSvgMultiPolygon,
        ) -> AzSvgMultiPolygon {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_xor(
                    transmute(svgmultipolygon),
                    transmute(other),
                ))
            }
        }
        pub(crate) fn AzSvgMultiPolygon_tessellateFill(
            svgmultipolygon: &AzSvgMultiPolygon,
            fill_style: AzSvgFillStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_tessellateFill(
                    transmute(svgmultipolygon),
                    transmute(fill_style),
                ))
            }
        }
        pub(crate) fn AzSvgMultiPolygon_tessellateStroke(
            svgmultipolygon: &AzSvgMultiPolygon,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgMultiPolygon_tessellateStroke(
                    transmute(svgmultipolygon),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgNode_tessellateFill(
            svgnode: &AzSvgNode,
            fill_style: AzSvgFillStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgNode_tessellateFill(
                    transmute(svgnode),
                    transmute(fill_style),
                ))
            }
        }
        pub(crate) fn AzSvgNode_tessellateStroke(
            svgnode: &AzSvgNode,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgNode_tessellateStroke(
                    transmute(svgnode),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgNode_isClosed(svgnode: &AzSvgNode) -> bool {
            unsafe { transmute(azul_dll::AzSvgNode_isClosed(transmute(svgnode))) }
        }
        pub(crate) fn AzSvgNode_containsPoint(
            svgnode: &AzSvgNode,
            point: AzSvgPoint,
            fill_rule: AzSvgFillRule,
            tolerance: f32,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzSvgNode_containsPoint(
                    transmute(svgnode),
                    transmute(point),
                    transmute(fill_rule),
                    transmute(tolerance),
                ))
            }
        }
        pub(crate) fn AzSvgNode_getBounds(svgnode: &AzSvgNode) -> AzSvgRect {
            unsafe { transmute(azul_dll::AzSvgNode_getBounds(transmute(svgnode))) }
        }
        pub(crate) fn AzSvgSimpleNode_getBounds(svgsimplenode: &AzSvgSimpleNode) -> AzSvgRect {
            unsafe {
                transmute(azul_dll::AzSvgSimpleNode_getBounds(transmute(
                    svgsimplenode,
                )))
            }
        }
        pub(crate) fn AzSvgStyledNode_tessellate(
            svgstylednode: &AzSvgStyledNode,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgStyledNode_tessellate(transmute(
                    svgstylednode,
                )))
            }
        }
        pub(crate) fn AzSvgCircle_tessellateFill(
            svgcircle: &AzSvgCircle,
            fill_style: AzSvgFillStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgCircle_tessellateFill(
                    transmute(svgcircle),
                    transmute(fill_style),
                ))
            }
        }
        pub(crate) fn AzSvgCircle_tessellateStroke(
            svgcircle: &AzSvgCircle,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgCircle_tessellateStroke(
                    transmute(svgcircle),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgPath_isClosed(svgpath: &AzSvgPath) -> bool {
            unsafe { transmute(azul_dll::AzSvgPath_isClosed(transmute(svgpath))) }
        }
        pub(crate) fn AzSvgPath_reverse(svgpath: &mut AzSvgPath) {
            unsafe { transmute(azul_dll::AzSvgPath_reverse(transmute(svgpath))) }
        }
        pub(crate) fn AzSvgPath_getStart(svgpath: &AzSvgPath) -> AzOptionSvgPoint {
            unsafe { transmute(azul_dll::AzSvgPath_getStart(transmute(svgpath))) }
        }
        pub(crate) fn AzSvgPath_getEnd(svgpath: &AzSvgPath) -> AzOptionSvgPoint {
            unsafe { transmute(azul_dll::AzSvgPath_getEnd(transmute(svgpath))) }
        }
        pub(crate) fn AzSvgPath_getBounds(svgpath: &mut AzSvgPath) -> AzSvgRect {
            unsafe { transmute(azul_dll::AzSvgPath_getBounds(transmute(svgpath))) }
        }
        pub(crate) fn AzSvgPath_joinWith(svgpath: &mut AzSvgPath, path: AzSvgPath) {
            unsafe {
                transmute(azul_dll::AzSvgPath_joinWith(
                    transmute(svgpath),
                    transmute(path),
                ))
            }
        }
        pub(crate) fn AzSvgPath_offset(
            svgpath: &mut AzSvgPath,
            distance: f32,
            join: AzSvgLineJoin,
            cap: AzSvgLineCap,
        ) -> AzSvgPath {
            unsafe {
                transmute(azul_dll::AzSvgPath_offset(
                    transmute(svgpath),
                    transmute(distance),
                    transmute(join),
                    transmute(cap),
                ))
            }
        }
        pub(crate) fn AzSvgPath_bevel(svgpath: &mut AzSvgPath, distance: f32) -> AzSvgPath {
            unsafe {
                transmute(azul_dll::AzSvgPath_bevel(
                    transmute(svgpath),
                    transmute(distance),
                ))
            }
        }
        pub(crate) fn AzSvgPath_tessellateFill(
            svgpath: &AzSvgPath,
            fill_style: AzSvgFillStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgPath_tessellateFill(
                    transmute(svgpath),
                    transmute(fill_style),
                ))
            }
        }
        pub(crate) fn AzSvgPath_tessellateStroke(
            svgpath: &AzSvgPath,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgPath_tessellateStroke(
                    transmute(svgpath),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgPathElement_reverse(svgpathelement: &mut AzSvgPathElement) {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_reverse(transmute(
                    svgpathelement,
                )))
            }
        }
        pub(crate) fn AzSvgPathElement_getStart(svgpathelement: &AzSvgPathElement) -> AzSvgPoint {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_getStart(transmute(
                    svgpathelement,
                )))
            }
        }
        pub(crate) fn AzSvgPathElement_getEnd(svgpathelement: &AzSvgPathElement) -> AzSvgPoint {
            unsafe { transmute(azul_dll::AzSvgPathElement_getEnd(transmute(svgpathelement))) }
        }
        pub(crate) fn AzSvgPathElement_getBounds(svgpathelement: &AzSvgPathElement) -> AzSvgRect {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_getBounds(transmute(
                    svgpathelement,
                )))
            }
        }
        pub(crate) fn AzSvgPathElement_getLength(svgpathelement: &AzSvgPathElement) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_getLength(transmute(
                    svgpathelement,
                )))
            }
        }
        pub(crate) fn AzSvgPathElement_getTAtOffset(
            svgpathelement: &AzSvgPathElement,
            offset: f64,
        ) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_getTAtOffset(
                    transmute(svgpathelement),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzSvgPathElement_getXAtT(svgpathelement: &AzSvgPathElement, t: f64) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_getXAtT(
                    transmute(svgpathelement),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgPathElement_getYAtT(svgpathelement: &AzSvgPathElement, t: f64) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_getYAtT(
                    transmute(svgpathelement),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgPathElement_getTangentVectorAtT(
            svgpathelement: &AzSvgPathElement,
            t: f64,
        ) -> AzSvgVector {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_getTangentVectorAtT(
                    transmute(svgpathelement),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgPathElement_tessellateStroke(
            svgpathelement: &AzSvgPathElement,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgPathElement_tessellateStroke(
                    transmute(svgpathelement),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgPoint_distance(svgpoint: &AzSvgPoint, other: AzSvgPoint) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgPoint_distance(
                    transmute(svgpoint),
                    transmute(other),
                ))
            }
        }
        pub(crate) fn AzSvgVector_angleDegrees(svgvector: &AzSvgVector) -> f64 {
            unsafe { transmute(azul_dll::AzSvgVector_angleDegrees(transmute(svgvector))) }
        }
        pub(crate) fn AzSvgVector_normalize(svgvector: &AzSvgVector) -> AzSvgVector {
            unsafe { transmute(azul_dll::AzSvgVector_normalize(transmute(svgvector))) }
        }
        pub(crate) fn AzSvgVector_rotate90DegCcw(svgvector: &AzSvgVector) -> AzSvgVector {
            unsafe { transmute(azul_dll::AzSvgVector_rotate90DegCcw(transmute(svgvector))) }
        }
        pub(crate) fn AzSvgLine_reverse(svgline: &mut AzSvgLine) {
            unsafe { transmute(azul_dll::AzSvgLine_reverse(transmute(svgline))) }
        }
        pub(crate) fn AzSvgLine_getStart(svgline: &AzSvgLine) -> AzSvgPoint {
            unsafe { transmute(azul_dll::AzSvgLine_getStart(transmute(svgline))) }
        }
        pub(crate) fn AzSvgLine_getEnd(svgline: &AzSvgLine) -> AzSvgPoint {
            unsafe { transmute(azul_dll::AzSvgLine_getEnd(transmute(svgline))) }
        }
        pub(crate) fn AzSvgLine_getBounds(svgline: &AzSvgLine) -> AzSvgRect {
            unsafe { transmute(azul_dll::AzSvgLine_getBounds(transmute(svgline))) }
        }
        pub(crate) fn AzSvgLine_getLength(svgline: &AzSvgLine) -> f64 {
            unsafe { transmute(azul_dll::AzSvgLine_getLength(transmute(svgline))) }
        }
        pub(crate) fn AzSvgLine_getTAtOffset(svgline: &AzSvgLine, offset: f64) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgLine_getTAtOffset(
                    transmute(svgline),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzSvgLine_getXAtT(svgline: &AzSvgLine, t: f64) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgLine_getXAtT(
                    transmute(svgline),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgLine_getYAtT(svgline: &AzSvgLine, t: f64) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgLine_getYAtT(
                    transmute(svgline),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgLine_getTangentVectorAtT(svgline: &AzSvgLine, t: f64) -> AzSvgVector {
            unsafe {
                transmute(azul_dll::AzSvgLine_getTangentVectorAtT(
                    transmute(svgline),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgLine_intersect(
            svgline: &AzSvgLine,
            other: AzSvgLine,
        ) -> AzOptionSvgPoint {
            unsafe {
                transmute(azul_dll::AzSvgLine_intersect(
                    transmute(svgline),
                    transmute(other),
                ))
            }
        }
        pub(crate) fn AzSvgLine_tessellateStroke(
            svgline: &AzSvgLine,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgLine_tessellateStroke(
                    transmute(svgline),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_reverse(svgquadraticcurve: &mut AzSvgQuadraticCurve) {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_reverse(transmute(
                    svgquadraticcurve,
                )))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getStart(
            svgquadraticcurve: &AzSvgQuadraticCurve,
        ) -> AzSvgPoint {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getStart(transmute(
                    svgquadraticcurve,
                )))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getEnd(
            svgquadraticcurve: &AzSvgQuadraticCurve,
        ) -> AzSvgPoint {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getEnd(transmute(
                    svgquadraticcurve,
                )))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getBounds(
            svgquadraticcurve: &AzSvgQuadraticCurve,
        ) -> AzSvgRect {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getBounds(transmute(
                    svgquadraticcurve,
                )))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getLength(
            svgquadraticcurve: &AzSvgQuadraticCurve,
        ) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getLength(transmute(
                    svgquadraticcurve,
                )))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getTAtOffset(
            svgquadraticcurve: &AzSvgQuadraticCurve,
            offset: f64,
        ) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getTAtOffset(
                    transmute(svgquadraticcurve),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getXAtT(
            svgquadraticcurve: &AzSvgQuadraticCurve,
            t: f64,
        ) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getXAtT(
                    transmute(svgquadraticcurve),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getYAtT(
            svgquadraticcurve: &AzSvgQuadraticCurve,
            t: f64,
        ) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getYAtT(
                    transmute(svgquadraticcurve),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_getTangentVectorAtT(
            svgquadraticcurve: &AzSvgQuadraticCurve,
            t: f64,
        ) -> AzSvgVector {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_getTangentVectorAtT(
                    transmute(svgquadraticcurve),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgQuadraticCurve_tessellateStroke(
            svgquadraticcurve: &AzSvgQuadraticCurve,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgQuadraticCurve_tessellateStroke(
                    transmute(svgquadraticcurve),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgCubicCurve_reverse(svgcubiccurve: &mut AzSvgCubicCurve) {
            unsafe { transmute(azul_dll::AzSvgCubicCurve_reverse(transmute(svgcubiccurve))) }
        }
        pub(crate) fn AzSvgCubicCurve_getStart(svgcubiccurve: &AzSvgCubicCurve) -> AzSvgPoint {
            unsafe { transmute(azul_dll::AzSvgCubicCurve_getStart(transmute(svgcubiccurve))) }
        }
        pub(crate) fn AzSvgCubicCurve_getEnd(svgcubiccurve: &AzSvgCubicCurve) -> AzSvgPoint {
            unsafe { transmute(azul_dll::AzSvgCubicCurve_getEnd(transmute(svgcubiccurve))) }
        }
        pub(crate) fn AzSvgCubicCurve_getBounds(svgcubiccurve: &AzSvgCubicCurve) -> AzSvgRect {
            unsafe {
                transmute(azul_dll::AzSvgCubicCurve_getBounds(transmute(
                    svgcubiccurve,
                )))
            }
        }
        pub(crate) fn AzSvgCubicCurve_getLength(svgcubiccurve: &AzSvgCubicCurve) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgCubicCurve_getLength(transmute(
                    svgcubiccurve,
                )))
            }
        }
        pub(crate) fn AzSvgCubicCurve_getTAtOffset(
            svgcubiccurve: &AzSvgCubicCurve,
            offset: f64,
        ) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgCubicCurve_getTAtOffset(
                    transmute(svgcubiccurve),
                    transmute(offset),
                ))
            }
        }
        pub(crate) fn AzSvgCubicCurve_getXAtT(svgcubiccurve: &AzSvgCubicCurve, t: f64) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgCubicCurve_getXAtT(
                    transmute(svgcubiccurve),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgCubicCurve_getYAtT(svgcubiccurve: &AzSvgCubicCurve, t: f64) -> f64 {
            unsafe {
                transmute(azul_dll::AzSvgCubicCurve_getYAtT(
                    transmute(svgcubiccurve),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgCubicCurve_getTangentVectorAtT(
            svgcubiccurve: &AzSvgCubicCurve,
            t: f64,
        ) -> AzSvgVector {
            unsafe {
                transmute(azul_dll::AzSvgCubicCurve_getTangentVectorAtT(
                    transmute(svgcubiccurve),
                    transmute(t),
                ))
            }
        }
        pub(crate) fn AzSvgCubicCurve_tessellateStroke(
            svgcubiccurve: &AzSvgCubicCurve,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgCubicCurve_tessellateStroke(
                    transmute(svgcubiccurve),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzSvgRect_getCenter(svgrect: &AzSvgRect) -> AzSvgPoint {
            unsafe { transmute(azul_dll::AzSvgRect_getCenter(transmute(svgrect))) }
        }
        pub(crate) fn AzSvgRect_containsPoint(svgrect: &AzSvgRect, point: AzSvgPoint) -> bool {
            unsafe {
                transmute(azul_dll::AzSvgRect_containsPoint(
                    transmute(svgrect),
                    transmute(point),
                ))
            }
        }
        pub(crate) fn AzSvgRect_expand(
            svgrect: &AzSvgRect,
            padding_top: f32,
            padding_bottom: f32,
            padding_left: f32,
            padding_right: f32,
        ) -> AzSvgRect {
            unsafe {
                transmute(azul_dll::AzSvgRect_expand(
                    transmute(svgrect),
                    transmute(padding_top),
                    transmute(padding_bottom),
                    transmute(padding_left),
                    transmute(padding_right),
                ))
            }
        }
        pub(crate) fn AzSvgRect_tessellateFill(
            svgrect: &AzSvgRect,
            fill_style: AzSvgFillStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgRect_tessellateFill(
                    transmute(svgrect),
                    transmute(fill_style),
                ))
            }
        }
        pub(crate) fn AzSvgRect_tessellateStroke(
            svgrect: &AzSvgRect,
            stroke_style: AzSvgStrokeStyle,
        ) -> AzTessellatedSvgNode {
            unsafe {
                transmute(azul_dll::AzSvgRect_tessellateStroke(
                    transmute(svgrect),
                    transmute(stroke_style),
                ))
            }
        }
        pub(crate) fn AzTessellatedColoredSvgNode_empty() -> AzTessellatedColoredSvgNode {
            unsafe { transmute(azul_dll::AzTessellatedColoredSvgNode_empty()) }
        }
        pub(crate) fn AzTessellatedColoredSvgNode_fromNodes(
            nodes: AzTessellatedColoredSvgNodeVecRef,
        ) -> AzTessellatedColoredSvgNode {
            unsafe {
                transmute(azul_dll::AzTessellatedColoredSvgNode_fromNodes(transmute(
                    nodes,
                )))
            }
        }
        pub(crate) fn AzTessellatedColoredGPUSvgNode_new(
            tessellated_node: *const AzTessellatedColoredSvgNode,
            gl: AzGl,
        ) -> AzTessellatedColoredGPUSvgNode {
            unsafe {
                transmute(azul_dll::AzTessellatedColoredGPUSvgNode_new(
                    transmute(tessellated_node),
                    transmute(gl),
                ))
            }
        }
        pub(crate) fn AzTessellatedSvgNode_empty() -> AzTessellatedSvgNode {
            unsafe { transmute(azul_dll::AzTessellatedSvgNode_empty()) }
        }
        pub(crate) fn AzTessellatedSvgNode_fromNodes(
            nodes: AzTessellatedSvgNodeVecRef,
        ) -> AzTessellatedSvgNode {
            unsafe { transmute(azul_dll::AzTessellatedSvgNode_fromNodes(transmute(nodes))) }
        }
        pub(crate) fn AzTessellatedGPUSvgNode_new(
            tessellated_node: *const AzTessellatedSvgNode,
            gl: AzGl,
        ) -> AzTessellatedGPUSvgNode {
            unsafe {
                transmute(azul_dll::AzTessellatedGPUSvgNode_new(
                    transmute(tessellated_node),
                    transmute(gl),
                ))
            }
        }
        pub(crate) fn AzSvgParseOptions_default() -> AzSvgParseOptions {
            unsafe { transmute(azul_dll::AzSvgParseOptions_default()) }
        }
        pub(crate) fn AzSvgRenderOptions_default() -> AzSvgRenderOptions {
            unsafe { transmute(azul_dll::AzSvgRenderOptions_default()) }
        }
        pub(crate) fn AzSvgFillStyle_default() -> AzSvgFillStyle {
            unsafe { transmute(azul_dll::AzSvgFillStyle_default()) }
        }
        pub(crate) fn AzSvgStrokeStyle_default() -> AzSvgStrokeStyle {
            unsafe { transmute(azul_dll::AzSvgStrokeStyle_default()) }
        }
        pub(crate) fn AzXml_fromStr(xml_string: AzRefstr) -> AzResultXmlXmlError {
            unsafe { transmute(azul_dll::AzXml_fromStr(transmute(xml_string))) }
        }
        pub(crate) fn AzFile_open(path: AzString) -> AzOptionFile {
            unsafe { transmute(azul_dll::AzFile_open(transmute(path))) }
        }
        pub(crate) fn AzFile_create(path: AzString) -> AzOptionFile {
            unsafe { transmute(azul_dll::AzFile_create(transmute(path))) }
        }
        pub(crate) fn AzFile_readToString(file: &mut AzFile) -> AzOptionString {
            unsafe { transmute(azul_dll::AzFile_readToString(transmute(file))) }
        }
        pub(crate) fn AzFile_readToBytes(file: &mut AzFile) -> AzOptionU8Vec {
            unsafe { transmute(azul_dll::AzFile_readToBytes(transmute(file))) }
        }
        pub(crate) fn AzFile_writeString(file: &mut AzFile, bytes: AzRefstr) -> bool {
            unsafe {
                transmute(azul_dll::AzFile_writeString(
                    transmute(file),
                    transmute(bytes),
                ))
            }
        }
        pub(crate) fn AzFile_writeBytes(file: &mut AzFile, bytes: AzU8VecRef) -> bool {
            unsafe {
                transmute(azul_dll::AzFile_writeBytes(
                    transmute(file),
                    transmute(bytes),
                ))
            }
        }
        pub(crate) fn AzFile_close(file: &mut AzFile) {
            unsafe { transmute(azul_dll::AzFile_close(transmute(file))) }
        }
        pub(crate) fn AzFile_delete(object: &mut AzFile) {
            unsafe { transmute(azul_dll::AzFile_delete(transmute(object))) }
        }
        pub(crate) fn AzFile_deepCopy(object: &AzFile) -> AzFile {
            unsafe { transmute(azul_dll::AzFile_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzMsgBox_ok(icon: AzMsgBoxIcon, title: AzString, message: AzString) -> bool {
            unsafe {
                transmute(azul_dll::AzMsgBox_ok(
                    transmute(icon),
                    transmute(title),
                    transmute(message),
                ))
            }
        }
        pub(crate) fn AzMsgBox_info(message: AzString) -> bool {
            unsafe { transmute(azul_dll::AzMsgBox_info(transmute(message))) }
        }
        pub(crate) fn AzMsgBox_warning(message: AzString) -> bool {
            unsafe { transmute(azul_dll::AzMsgBox_warning(transmute(message))) }
        }
        pub(crate) fn AzMsgBox_error(message: AzString) -> bool {
            unsafe { transmute(azul_dll::AzMsgBox_error(transmute(message))) }
        }
        pub(crate) fn AzMsgBox_question(message: AzString) -> bool {
            unsafe { transmute(azul_dll::AzMsgBox_question(transmute(message))) }
        }
        pub(crate) fn AzMsgBox_okCancel(
            icon: AzMsgBoxIcon,
            title: AzString,
            message: AzString,
            default_value: AzMsgBoxOkCancel,
        ) -> AzMsgBoxOkCancel {
            unsafe {
                transmute(azul_dll::AzMsgBox_okCancel(
                    transmute(icon),
                    transmute(title),
                    transmute(message),
                    transmute(default_value),
                ))
            }
        }
        pub(crate) fn AzMsgBox_yesNo(
            icon: AzMsgBoxIcon,
            title: AzString,
            message: AzString,
            default_value: AzMsgBoxYesNo,
        ) -> AzMsgBoxYesNo {
            unsafe {
                transmute(azul_dll::AzMsgBox_yesNo(
                    transmute(icon),
                    transmute(title),
                    transmute(message),
                    transmute(default_value),
                ))
            }
        }
        pub(crate) fn AzFileDialog_selectFile(
            title: AzString,
            default_path: AzOptionString,
            filter_list: AzOptionFileTypeList,
        ) -> AzOptionString {
            unsafe {
                transmute(azul_dll::AzFileDialog_selectFile(
                    transmute(title),
                    transmute(default_path),
                    transmute(filter_list),
                ))
            }
        }
        pub(crate) fn AzFileDialog_selectMultipleFiles(
            title: AzString,
            default_path: AzOptionString,
            filter_list: AzOptionFileTypeList,
        ) -> AzOptionStringVec {
            unsafe {
                transmute(azul_dll::AzFileDialog_selectMultipleFiles(
                    transmute(title),
                    transmute(default_path),
                    transmute(filter_list),
                ))
            }
        }
        pub(crate) fn AzFileDialog_selectFolder(
            title: AzString,
            default_path: AzOptionString,
        ) -> AzOptionString {
            unsafe {
                transmute(azul_dll::AzFileDialog_selectFolder(
                    transmute(title),
                    transmute(default_path),
                ))
            }
        }
        pub(crate) fn AzFileDialog_saveFile(
            title: AzString,
            default_path: AzOptionString,
        ) -> AzOptionString {
            unsafe {
                transmute(azul_dll::AzFileDialog_saveFile(
                    transmute(title),
                    transmute(default_path),
                ))
            }
        }
        pub(crate) fn AzColorPickerDialog_open(
            title: AzString,
            default_color: AzOptionColorU,
        ) -> AzOptionColorU {
            unsafe {
                transmute(azul_dll::AzColorPickerDialog_open(
                    transmute(title),
                    transmute(default_color),
                ))
            }
        }
        pub(crate) fn AzSystemClipboard_new() -> AzOptionSystemClipboard {
            unsafe { transmute(azul_dll::AzSystemClipboard_new()) }
        }
        pub(crate) fn AzSystemClipboard_getStringContents(
            systemclipboard: &AzSystemClipboard,
        ) -> AzOptionString {
            unsafe {
                transmute(azul_dll::AzSystemClipboard_getStringContents(transmute(
                    systemclipboard,
                )))
            }
        }
        pub(crate) fn AzSystemClipboard_setStringContents(
            systemclipboard: &mut AzSystemClipboard,
            contents: AzString,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzSystemClipboard_setStringContents(
                    transmute(systemclipboard),
                    transmute(contents),
                ))
            }
        }
        pub(crate) fn AzSystemClipboard_delete(object: &mut AzSystemClipboard) {
            unsafe { transmute(azul_dll::AzSystemClipboard_delete(transmute(object))) }
        }
        pub(crate) fn AzSystemClipboard_deepCopy(object: &AzSystemClipboard) -> AzSystemClipboard {
            unsafe { transmute(azul_dll::AzSystemClipboard_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzInstant_durationSince(
            instant: &AzInstant,
            earlier: AzInstant,
        ) -> AzOptionDuration {
            unsafe {
                transmute(azul_dll::AzInstant_durationSince(
                    transmute(instant),
                    transmute(earlier),
                ))
            }
        }
        pub(crate) fn AzInstant_addDuration(
            instant: &mut AzInstant,
            duration: AzDuration,
        ) -> AzInstant {
            unsafe {
                transmute(azul_dll::AzInstant_addDuration(
                    transmute(instant),
                    transmute(duration),
                ))
            }
        }
        pub(crate) fn AzInstant_linearInterpolate(
            instant: &AzInstant,
            start: AzInstant,
            end: AzInstant,
        ) -> f32 {
            unsafe {
                transmute(azul_dll::AzInstant_linearInterpolate(
                    transmute(instant),
                    transmute(start),
                    transmute(end),
                ))
            }
        }
        pub(crate) fn AzInstantPtr_delete(object: &mut AzInstantPtr) {
            unsafe { transmute(azul_dll::AzInstantPtr_delete(transmute(object))) }
        }
        pub(crate) fn AzInstantPtr_deepCopy(object: &AzInstantPtr) -> AzInstantPtr {
            unsafe { transmute(azul_dll::AzInstantPtr_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzTimer_new(
            timer_data: AzRefAny,
            callback: AzTimerCallbackType,
            get_system_time_fn: AzGetSystemTimeFn,
        ) -> AzTimer {
            unsafe {
                transmute(azul_dll::AzTimer_new(
                    transmute(timer_data),
                    transmute(callback),
                    transmute(get_system_time_fn),
                ))
            }
        }
        pub(crate) fn AzTimer_withDelay(timer: &AzTimer, delay: AzDuration) -> AzTimer {
            unsafe {
                transmute(azul_dll::AzTimer_withDelay(
                    transmute(timer),
                    transmute(delay),
                ))
            }
        }
        pub(crate) fn AzTimer_withInterval(timer: &AzTimer, interval: AzDuration) -> AzTimer {
            unsafe {
                transmute(azul_dll::AzTimer_withInterval(
                    transmute(timer),
                    transmute(interval),
                ))
            }
        }
        pub(crate) fn AzTimer_withTimeout(timer: &AzTimer, timeout: AzDuration) -> AzTimer {
            unsafe {
                transmute(azul_dll::AzTimer_withTimeout(
                    transmute(timer),
                    transmute(timeout),
                ))
            }
        }
        pub(crate) fn AzThread_delete(object: &mut AzThread) {
            unsafe { transmute(azul_dll::AzThread_delete(transmute(object))) }
        }
        pub(crate) fn AzThread_deepCopy(object: &AzThread) -> AzThread {
            unsafe { transmute(azul_dll::AzThread_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzThreadSender_send(
            threadsender: &mut AzThreadSender,
            msg: AzThreadReceiveMsg,
        ) -> bool {
            unsafe {
                transmute(azul_dll::AzThreadSender_send(
                    transmute(threadsender),
                    transmute(msg),
                ))
            }
        }
        pub(crate) fn AzThreadSender_delete(object: &mut AzThreadSender) {
            unsafe { transmute(azul_dll::AzThreadSender_delete(transmute(object))) }
        }
        pub(crate) fn AzThreadSender_deepCopy(object: &AzThreadSender) -> AzThreadSender {
            unsafe { transmute(azul_dll::AzThreadSender_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzThreadReceiver_receive(
            threadreceiver: &mut AzThreadReceiver,
        ) -> AzOptionThreadSendMsg {
            unsafe {
                transmute(azul_dll::AzThreadReceiver_receive(transmute(
                    threadreceiver,
                )))
            }
        }
        pub(crate) fn AzThreadReceiver_delete(object: &mut AzThreadReceiver) {
            unsafe { transmute(azul_dll::AzThreadReceiver_delete(transmute(object))) }
        }
        pub(crate) fn AzThreadReceiver_deepCopy(object: &AzThreadReceiver) -> AzThreadReceiver {
            unsafe { transmute(azul_dll::AzThreadReceiver_deepCopy(transmute(object))) }
        }
        pub(crate) fn AzString_format(format: AzString, args: AzFmtArgVec) -> AzString {
            unsafe {
                transmute(azul_dll::AzString_format(
                    transmute(format),
                    transmute(args),
                ))
            }
        }
        pub(crate) fn AzString_copyFromBytes(ptr: *const u8, start: usize, len: usize) -> AzString {
            unsafe {
                transmute(azul_dll::AzString_copyFromBytes(
                    transmute(ptr),
                    transmute(start),
                    transmute(len),
                ))
            }
        }
        pub(crate) fn AzString_trim(string: &AzString) -> AzString {
            unsafe { transmute(azul_dll::AzString_trim(transmute(string))) }
        }
        pub(crate) fn AzString_asRefstr(string: &AzString) -> AzRefstr {
            unsafe { transmute(azul_dll::AzString_asRefstr(transmute(string))) }
        }
        pub(crate) fn AzListViewRowVec_delete(object: &mut AzListViewRowVec) {
            unsafe { transmute(azul_dll::AzListViewRowVec_delete(transmute(object))) }
        }
        pub(crate) fn AzStyleFilterVec_delete(object: &mut AzStyleFilterVec) {
            unsafe { transmute(azul_dll::AzStyleFilterVec_delete(transmute(object))) }
        }
        pub(crate) fn AzLogicalRectVec_delete(object: &mut AzLogicalRectVec) {
            unsafe { transmute(azul_dll::AzLogicalRectVec_delete(transmute(object))) }
        }
        pub(crate) fn AzNodeTypeIdInfoMapVec_delete(object: &mut AzNodeTypeIdInfoMapVec) {
            unsafe { transmute(azul_dll::AzNodeTypeIdInfoMapVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInputOutputTypeIdInfoMapVec_delete(
            object: &mut AzInputOutputTypeIdInfoMapVec,
        ) {
            unsafe {
                transmute(azul_dll::AzInputOutputTypeIdInfoMapVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzNodeIdNodeMapVec_delete(object: &mut AzNodeIdNodeMapVec) {
            unsafe { transmute(azul_dll::AzNodeIdNodeMapVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInputOutputTypeIdVec_delete(object: &mut AzInputOutputTypeIdVec) {
            unsafe { transmute(azul_dll::AzInputOutputTypeIdVec_delete(transmute(object))) }
        }
        pub(crate) fn AzNodeTypeFieldVec_delete(object: &mut AzNodeTypeFieldVec) {
            unsafe { transmute(azul_dll::AzNodeTypeFieldVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInputConnectionVec_delete(object: &mut AzInputConnectionVec) {
            unsafe { transmute(azul_dll::AzInputConnectionVec_delete(transmute(object))) }
        }
        pub(crate) fn AzOutputNodeAndIndexVec_delete(object: &mut AzOutputNodeAndIndexVec) {
            unsafe { transmute(azul_dll::AzOutputNodeAndIndexVec_delete(transmute(object))) }
        }
        pub(crate) fn AzOutputConnectionVec_delete(object: &mut AzOutputConnectionVec) {
            unsafe { transmute(azul_dll::AzOutputConnectionVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInputNodeAndIndexVec_delete(object: &mut AzInputNodeAndIndexVec) {
            unsafe { transmute(azul_dll::AzInputNodeAndIndexVec_delete(transmute(object))) }
        }
        pub(crate) fn AzAccessibilityStateVec_delete(object: &mut AzAccessibilityStateVec) {
            unsafe { transmute(azul_dll::AzAccessibilityStateVec_delete(transmute(object))) }
        }
        pub(crate) fn AzMenuItemVec_delete(object: &mut AzMenuItemVec) {
            unsafe { transmute(azul_dll::AzMenuItemVec_delete(transmute(object))) }
        }
        pub(crate) fn AzTessellatedSvgNodeVec_asRefVec(
            tessellatedsvgnodevec: &AzTessellatedSvgNodeVec,
        ) -> AzTessellatedSvgNodeVecRef {
            unsafe {
                transmute(azul_dll::AzTessellatedSvgNodeVec_asRefVec(transmute(
                    tessellatedsvgnodevec,
                )))
            }
        }
        pub(crate) fn AzTessellatedSvgNodeVec_delete(object: &mut AzTessellatedSvgNodeVec) {
            unsafe { transmute(azul_dll::AzTessellatedSvgNodeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzTessellatedColoredSvgNodeVec_asRefVec(
            tessellatedcoloredsvgnodevec: &AzTessellatedColoredSvgNodeVec,
        ) -> AzTessellatedColoredSvgNodeVecRef {
            unsafe {
                transmute(azul_dll::AzTessellatedColoredSvgNodeVec_asRefVec(
                    transmute(tessellatedcoloredsvgnodevec),
                ))
            }
        }
        pub(crate) fn AzTessellatedColoredSvgNodeVec_delete(
            object: &mut AzTessellatedColoredSvgNodeVec,
        ) {
            unsafe {
                transmute(azul_dll::AzTessellatedColoredSvgNodeVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzStyleFontFamilyVec_delete(object: &mut AzStyleFontFamilyVec) {
            unsafe { transmute(azul_dll::AzStyleFontFamilyVec_delete(transmute(object))) }
        }
        pub(crate) fn AzXmlNodeVec_delete(object: &mut AzXmlNodeVec) {
            unsafe { transmute(azul_dll::AzXmlNodeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzFmtArgVec_delete(object: &mut AzFmtArgVec) {
            unsafe { transmute(azul_dll::AzFmtArgVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInlineLineVec_delete(object: &mut AzInlineLineVec) {
            unsafe { transmute(azul_dll::AzInlineLineVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInlineWordVec_delete(object: &mut AzInlineWordVec) {
            unsafe { transmute(azul_dll::AzInlineWordVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInlineGlyphVec_delete(object: &mut AzInlineGlyphVec) {
            unsafe { transmute(azul_dll::AzInlineGlyphVec_delete(transmute(object))) }
        }
        pub(crate) fn AzInlineTextHitVec_delete(object: &mut AzInlineTextHitVec) {
            unsafe { transmute(azul_dll::AzInlineTextHitVec_delete(transmute(object))) }
        }
        pub(crate) fn AzMonitorVec_delete(object: &mut AzMonitorVec) {
            unsafe { transmute(azul_dll::AzMonitorVec_delete(transmute(object))) }
        }
        pub(crate) fn AzVideoModeVec_delete(object: &mut AzVideoModeVec) {
            unsafe { transmute(azul_dll::AzVideoModeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzDomVec_delete(object: &mut AzDomVec) {
            unsafe { transmute(azul_dll::AzDomVec_delete(transmute(object))) }
        }
        pub(crate) fn AzIdOrClassVec_delete(object: &mut AzIdOrClassVec) {
            unsafe { transmute(azul_dll::AzIdOrClassVec_delete(transmute(object))) }
        }
        pub(crate) fn AzNodeDataInlineCssPropertyVec_delete(
            object: &mut AzNodeDataInlineCssPropertyVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNodeDataInlineCssPropertyVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzStyleBackgroundContentVec_delete(object: &mut AzStyleBackgroundContentVec) {
            unsafe {
                transmute(azul_dll::AzStyleBackgroundContentVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzStyleBackgroundPositionVec_delete(
            object: &mut AzStyleBackgroundPositionVec,
        ) {
            unsafe {
                transmute(azul_dll::AzStyleBackgroundPositionVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzStyleBackgroundRepeatVec_delete(object: &mut AzStyleBackgroundRepeatVec) {
            unsafe {
                transmute(azul_dll::AzStyleBackgroundRepeatVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzStyleBackgroundSizeVec_delete(object: &mut AzStyleBackgroundSizeVec) {
            unsafe { transmute(azul_dll::AzStyleBackgroundSizeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzStyleTransformVec_delete(object: &mut AzStyleTransformVec) {
            unsafe { transmute(azul_dll::AzStyleTransformVec_delete(transmute(object))) }
        }
        pub(crate) fn AzCssPropertyVec_delete(object: &mut AzCssPropertyVec) {
            unsafe { transmute(azul_dll::AzCssPropertyVec_delete(transmute(object))) }
        }
        pub(crate) fn AzSvgMultiPolygonVec_delete(object: &mut AzSvgMultiPolygonVec) {
            unsafe { transmute(azul_dll::AzSvgMultiPolygonVec_delete(transmute(object))) }
        }
        pub(crate) fn AzSvgSimpleNodeVec_delete(object: &mut AzSvgSimpleNodeVec) {
            unsafe { transmute(azul_dll::AzSvgSimpleNodeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzSvgPathVec_delete(object: &mut AzSvgPathVec) {
            unsafe { transmute(azul_dll::AzSvgPathVec_delete(transmute(object))) }
        }
        pub(crate) fn AzVertexAttributeVec_delete(object: &mut AzVertexAttributeVec) {
            unsafe { transmute(azul_dll::AzVertexAttributeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzSvgPathElementVec_delete(object: &mut AzSvgPathElementVec) {
            unsafe { transmute(azul_dll::AzSvgPathElementVec_delete(transmute(object))) }
        }
        pub(crate) fn AzSvgVertexVec_delete(object: &mut AzSvgVertexVec) {
            unsafe { transmute(azul_dll::AzSvgVertexVec_delete(transmute(object))) }
        }
        pub(crate) fn AzSvgColoredVertexVec_delete(object: &mut AzSvgColoredVertexVec) {
            unsafe { transmute(azul_dll::AzSvgColoredVertexVec_delete(transmute(object))) }
        }
        pub(crate) fn AzU32Vec_delete(object: &mut AzU32Vec) {
            unsafe { transmute(azul_dll::AzU32Vec_delete(transmute(object))) }
        }
        pub(crate) fn AzXWindowTypeVec_delete(object: &mut AzXWindowTypeVec) {
            unsafe { transmute(azul_dll::AzXWindowTypeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzVirtualKeyCodeVec_delete(object: &mut AzVirtualKeyCodeVec) {
            unsafe { transmute(azul_dll::AzVirtualKeyCodeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzCascadeInfoVec_delete(object: &mut AzCascadeInfoVec) {
            unsafe { transmute(azul_dll::AzCascadeInfoVec_delete(transmute(object))) }
        }
        pub(crate) fn AzScanCodeVec_delete(object: &mut AzScanCodeVec) {
            unsafe { transmute(azul_dll::AzScanCodeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzCssDeclarationVec_delete(object: &mut AzCssDeclarationVec) {
            unsafe { transmute(azul_dll::AzCssDeclarationVec_delete(transmute(object))) }
        }
        pub(crate) fn AzCssPathSelectorVec_delete(object: &mut AzCssPathSelectorVec) {
            unsafe { transmute(azul_dll::AzCssPathSelectorVec_delete(transmute(object))) }
        }
        pub(crate) fn AzStylesheetVec_delete(object: &mut AzStylesheetVec) {
            unsafe { transmute(azul_dll::AzStylesheetVec_delete(transmute(object))) }
        }
        pub(crate) fn AzCssRuleBlockVec_delete(object: &mut AzCssRuleBlockVec) {
            unsafe { transmute(azul_dll::AzCssRuleBlockVec_delete(transmute(object))) }
        }
        pub(crate) fn AzU16Vec_delete(object: &mut AzU16Vec) {
            unsafe { transmute(azul_dll::AzU16Vec_delete(transmute(object))) }
        }
        pub(crate) fn AzF32Vec_delete(object: &mut AzF32Vec) {
            unsafe { transmute(azul_dll::AzF32Vec_delete(transmute(object))) }
        }
        pub(crate) fn AzU8Vec_copyFromBytes(ptr: *const u8, start: usize, len: usize) -> AzU8Vec {
            unsafe {
                transmute(azul_dll::AzU8Vec_copyFromBytes(
                    transmute(ptr),
                    transmute(start),
                    transmute(len),
                ))
            }
        }
        pub(crate) fn AzU8Vec_asRefVec(u8vec: &AzU8Vec) -> AzU8VecRef {
            unsafe { transmute(azul_dll::AzU8Vec_asRefVec(transmute(u8vec))) }
        }
        pub(crate) fn AzU8Vec_delete(object: &mut AzU8Vec) {
            unsafe { transmute(azul_dll::AzU8Vec_delete(transmute(object))) }
        }
        pub(crate) fn AzCallbackDataVec_delete(object: &mut AzCallbackDataVec) {
            unsafe { transmute(azul_dll::AzCallbackDataVec_delete(transmute(object))) }
        }
        pub(crate) fn AzDebugMessageVec_delete(object: &mut AzDebugMessageVec) {
            unsafe { transmute(azul_dll::AzDebugMessageVec_delete(transmute(object))) }
        }
        pub(crate) fn AzGLuintVec_delete(object: &mut AzGLuintVec) {
            unsafe { transmute(azul_dll::AzGLuintVec_delete(transmute(object))) }
        }
        pub(crate) fn AzGLintVec_delete(object: &mut AzGLintVec) {
            unsafe { transmute(azul_dll::AzGLintVec_delete(transmute(object))) }
        }
        pub(crate) fn AzStringVec_delete(object: &mut AzStringVec) {
            unsafe { transmute(azul_dll::AzStringVec_delete(transmute(object))) }
        }
        pub(crate) fn AzStringPairVec_delete(object: &mut AzStringPairVec) {
            unsafe { transmute(azul_dll::AzStringPairVec_delete(transmute(object))) }
        }
        pub(crate) fn AzNormalizedLinearColorStopVec_delete(
            object: &mut AzNormalizedLinearColorStopVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNormalizedLinearColorStopVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzNormalizedRadialColorStopVec_delete(
            object: &mut AzNormalizedRadialColorStopVec,
        ) {
            unsafe {
                transmute(azul_dll::AzNormalizedRadialColorStopVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzNodeIdVec_delete(object: &mut AzNodeIdVec) {
            unsafe { transmute(azul_dll::AzNodeIdVec_delete(transmute(object))) }
        }
        pub(crate) fn AzNodeHierarchyItemVec_delete(object: &mut AzNodeHierarchyItemVec) {
            unsafe { transmute(azul_dll::AzNodeHierarchyItemVec_delete(transmute(object))) }
        }
        pub(crate) fn AzStyledNodeVec_delete(object: &mut AzStyledNodeVec) {
            unsafe { transmute(azul_dll::AzStyledNodeVec_delete(transmute(object))) }
        }
        pub(crate) fn AzTagIdToNodeIdMappingVec_delete(object: &mut AzTagIdToNodeIdMappingVec) {
            unsafe {
                transmute(azul_dll::AzTagIdToNodeIdMappingVec_delete(transmute(
                    object,
                )))
            }
        }
        pub(crate) fn AzParentWithNodeDepthVec_delete(object: &mut AzParentWithNodeDepthVec) {
            unsafe { transmute(azul_dll::AzParentWithNodeDepthVec_delete(transmute(object))) }
        }
        pub(crate) fn AzNodeDataVec_delete(object: &mut AzNodeDataVec) {
            unsafe { transmute(azul_dll::AzNodeDataVec_delete(transmute(object))) }
        }
    }

    #[cfg(not(feature = "link-static"))]
    mod dynamic_link {
        use core::ffi::c_void;

        use super::types::*;

        #[cfg_attr(target_os = "windows", link(name = "azul.dll"))] // https://github.com/rust-lang/cargo/issues/9082
        #[cfg_attr(not(target_os = "windows"), link(name = "azul"))] // https://github.com/rust-lang/cargo/issues/9082
        extern "C" {
            pub(crate) fn AzApp_new(_: AzRefAny, _: AzAppConfig) -> AzApp;
            pub(crate) fn AzApp_addWindow(_: &mut AzApp, _: AzWindowCreateOptions);
            pub(crate) fn AzApp_addImage(_: &mut AzApp, _: AzString, _: AzImageRef);
            pub(crate) fn AzApp_getMonitors(_: &AzApp) -> AzMonitorVec;
            pub(crate) fn AzApp_run(_: &AzApp, _: AzWindowCreateOptions);
            pub(crate) fn AzApp_delete(_: &mut AzApp);
            pub(crate) fn AzApp_deepCopy(_: &AzApp) -> AzApp;
            pub(crate) fn AzAppConfig_new(_: AzLayoutSolver) -> AzAppConfig;
            pub(crate) fn AzSystemCallbacks_libraryInternal() -> AzSystemCallbacks;
            pub(crate) fn AzWindowCreateOptions_new(
                _: AzLayoutCallbackType,
            ) -> AzWindowCreateOptions;
            pub(crate) fn AzLogicalPosition_new(_: f32, _: f32) -> AzLogicalPosition;
            pub(crate) fn AzLogicalPosition_zero() -> AzLogicalPosition;
            pub(crate) fn AzLogicalSize_toPhysical(_: &AzLogicalSize, _: f32) -> AzPhysicalSizeU32;
            pub(crate) fn AzWindowSize_getHidpiFactor(_: &AzWindowSize) -> f32;
            pub(crate) fn AzKeyboardState_shiftDown(_: &AzKeyboardState) -> bool;
            pub(crate) fn AzKeyboardState_ctrlDown(_: &AzKeyboardState) -> bool;
            pub(crate) fn AzKeyboardState_altDown(_: &AzKeyboardState) -> bool;
            pub(crate) fn AzKeyboardState_superDown(_: &AzKeyboardState) -> bool;
            pub(crate) fn AzKeyboardState_isKeyDown(
                _: &AzKeyboardState,
                _: AzVirtualKeyCode,
            ) -> bool;
            pub(crate) fn AzCursorPosition_getPosition(
                _: &AzCursorPosition,
            ) -> AzOptionLogicalPosition;
            pub(crate) fn AzWindowState_new(_: AzLayoutCallbackType) -> AzWindowState;
            pub(crate) fn AzWindowState_default() -> AzWindowState;
            pub(crate) fn AzCallbackInfo_getHitNode(_: &AzCallbackInfo) -> AzDomNodeId;
            pub(crate) fn AzCallbackInfo_getSystemTimeFn(_: &AzCallbackInfo) -> AzGetSystemTimeFn;
            pub(crate) fn AzCallbackInfo_getCursorRelativeToViewport(
                _: &AzCallbackInfo,
            ) -> AzOptionLogicalPosition;
            pub(crate) fn AzCallbackInfo_getCursorRelativeToNode(
                _: &AzCallbackInfo,
            ) -> AzOptionLogicalPosition;
            pub(crate) fn AzCallbackInfo_getCurrentWindowState(_: &AzCallbackInfo)
                -> AzWindowState;
            pub(crate) fn AzCallbackInfo_getCurrentKeyboardState(
                _: &AzCallbackInfo,
            ) -> AzKeyboardState;
            pub(crate) fn AzCallbackInfo_getCurrentMouseState(_: &AzCallbackInfo) -> AzMouseState;
            pub(crate) fn AzCallbackInfo_getPreviousWindowState(
                _: &AzCallbackInfo,
            ) -> AzOptionWindowState;
            pub(crate) fn AzCallbackInfo_getPreviousKeyboardState(
                _: &AzCallbackInfo,
            ) -> AzOptionKeyboardState;
            pub(crate) fn AzCallbackInfo_getPreviousMouseState(
                _: &AzCallbackInfo,
            ) -> AzOptionMouseState;
            pub(crate) fn AzCallbackInfo_getCurrentWindowHandle(
                _: &AzCallbackInfo,
            ) -> AzRawWindowHandle;
            pub(crate) fn AzCallbackInfo_getGlContext(_: &AzCallbackInfo) -> AzOptionGl;
            pub(crate) fn AzCallbackInfo_getScrollPosition(
                _: &AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionLogicalPosition;
            pub(crate) fn AzCallbackInfo_getDataset(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionRefAny;
            pub(crate) fn AzCallbackInfo_getNodeIdOfRootDataset(
                _: &mut AzCallbackInfo,
                _: AzRefAny,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzCallbackInfo_getStringContents(
                _: &AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionString;
            pub(crate) fn AzCallbackInfo_getInlineText(
                _: &AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionInlineText;
            pub(crate) fn AzCallbackInfo_getFontRef(
                _: &AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionFontRef;
            pub(crate) fn AzCallbackInfo_getTextLayoutOptions(
                _: &AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionResolvedTextLayoutOptions;
            pub(crate) fn AzCallbackInfo_shapeText(
                _: &AzCallbackInfo,
                _: AzDomNodeId,
                _: AzString,
            ) -> AzOptionInlineText;
            pub(crate) fn AzCallbackInfo_getIndexInParent(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> usize;
            pub(crate) fn AzCallbackInfo_getParent(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzCallbackInfo_getPreviousSibling(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzCallbackInfo_getNextSibling(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzCallbackInfo_getFirstChild(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzCallbackInfo_getLastChild(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzCallbackInfo_getNodePosition(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionPositionInfo;
            pub(crate) fn AzCallbackInfo_getNodeSize(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionLogicalSize;
            pub(crate) fn AzCallbackInfo_getComputedCssProperty(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
                _: AzCssPropertyType,
            ) -> AzOptionCssProperty;
            pub(crate) fn AzCallbackInfo_setWindowState(_: &mut AzCallbackInfo, _: AzWindowState);
            pub(crate) fn AzCallbackInfo_setFocus(_: &mut AzCallbackInfo, _: AzFocusTarget);
            pub(crate) fn AzCallbackInfo_setCssProperty(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
                _: AzCssProperty,
            );
            pub(crate) fn AzCallbackInfo_setScrollPosition(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
                _: AzLogicalPosition,
            );
            pub(crate) fn AzCallbackInfo_setStringContents(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
                _: AzString,
            );
            pub(crate) fn AzCallbackInfo_addImage(
                _: &mut AzCallbackInfo,
                _: AzString,
                _: AzImageRef,
            );
            pub(crate) fn AzCallbackInfo_hasImage(_: &AzCallbackInfo, _: AzString) -> bool;
            pub(crate) fn AzCallbackInfo_getImage(
                _: &AzCallbackInfo,
                _: AzString,
            ) -> AzOptionImageRef;
            pub(crate) fn AzCallbackInfo_updateImage(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
                _: AzImageRef,
                _: AzUpdateImageType,
            );
            pub(crate) fn AzCallbackInfo_deleteImage(_: &mut AzCallbackInfo, _: AzString);
            pub(crate) fn AzCallbackInfo_updateImageMask(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
                _: AzImageMask,
            );
            pub(crate) fn AzCallbackInfo_stopPropagation(_: &mut AzCallbackInfo);
            pub(crate) fn AzCallbackInfo_createWindow(
                _: &mut AzCallbackInfo,
                _: AzWindowCreateOptions,
            );
            pub(crate) fn AzCallbackInfo_startTimer(
                _: &mut AzCallbackInfo,
                _: AzTimer,
            ) -> AzTimerId;
            pub(crate) fn AzCallbackInfo_startAnimation(
                _: &mut AzCallbackInfo,
                _: AzDomNodeId,
                _: AzAnimation,
            ) -> AzOptionTimerId;
            pub(crate) fn AzCallbackInfo_stopTimer(_: &mut AzCallbackInfo, _: AzTimerId) -> bool;
            pub(crate) fn AzCallbackInfo_startThread(
                _: &mut AzCallbackInfo,
                _: AzRefAny,
                _: AzRefAny,
                _: AzThreadCallbackType,
            ) -> AzOptionThreadId;
            pub(crate) fn AzCallbackInfo_sendThreadMsg(
                _: &mut AzCallbackInfo,
                _: AzThreadId,
                _: AzThreadSendMsg,
            ) -> bool;
            pub(crate) fn AzCallbackInfo_stopThread(_: &mut AzCallbackInfo, _: AzThreadId) -> bool;
            pub(crate) fn AzPositionInfo_isPositioned(_: &AzPositionInfo) -> bool;
            pub(crate) fn AzPositionInfo_getStaticOffset(_: &AzPositionInfo) -> AzLogicalPosition;
            pub(crate) fn AzPositionInfo_getRelativeOffset(_: &AzPositionInfo)
                -> AzLogicalPosition;
            pub(crate) fn AzHidpiAdjustedBounds_getLogicalSize(
                _: &AzHidpiAdjustedBounds,
            ) -> AzLogicalSize;
            pub(crate) fn AzHidpiAdjustedBounds_getPhysicalSize(
                _: &AzHidpiAdjustedBounds,
            ) -> AzPhysicalSizeU32;
            pub(crate) fn AzHidpiAdjustedBounds_getHidpiFactor(_: &AzHidpiAdjustedBounds) -> f32;
            pub(crate) fn AzInlineText_hitTest(
                _: &AzInlineText,
                _: AzLogicalPosition,
            ) -> AzInlineTextHitVec;
            pub(crate) fn AzResolvedTextLayoutOptions_default() -> AzResolvedTextLayoutOptions;
            pub(crate) fn AzRenderImageCallbackInfo_getGlContext(
                _: &AzRenderImageCallbackInfo,
            ) -> AzOptionGl;
            pub(crate) fn AzRenderImageCallbackInfo_getBounds(
                _: &AzRenderImageCallbackInfo,
            ) -> AzHidpiAdjustedBounds;
            pub(crate) fn AzRenderImageCallbackInfo_getCallbackNodeId(
                _: &AzRenderImageCallbackInfo,
            ) -> AzDomNodeId;
            pub(crate) fn AzRenderImageCallbackInfo_getInlineText(
                _: &AzRenderImageCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionInlineText;
            pub(crate) fn AzRenderImageCallbackInfo_getIndexInParent(
                _: &mut AzRenderImageCallbackInfo,
                _: AzDomNodeId,
            ) -> usize;
            pub(crate) fn AzRenderImageCallbackInfo_getParent(
                _: &mut AzRenderImageCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzRenderImageCallbackInfo_getPreviousSibling(
                _: &mut AzRenderImageCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzRenderImageCallbackInfo_getNextSibling(
                _: &mut AzRenderImageCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzRenderImageCallbackInfo_getFirstChild(
                _: &mut AzRenderImageCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzRenderImageCallbackInfo_getLastChild(
                _: &mut AzRenderImageCallbackInfo,
                _: AzDomNodeId,
            ) -> AzOptionDomNodeId;
            pub(crate) fn AzRefCount_canBeShared(_: &AzRefCount) -> bool;
            pub(crate) fn AzRefCount_canBeSharedMut(_: &AzRefCount) -> bool;
            pub(crate) fn AzRefCount_increaseRef(_: &mut AzRefCount);
            pub(crate) fn AzRefCount_decreaseRef(_: &mut AzRefCount);
            pub(crate) fn AzRefCount_increaseRefmut(_: &mut AzRefCount);
            pub(crate) fn AzRefCount_decreaseRefmut(_: &mut AzRefCount);
            pub(crate) fn AzRefCount_delete(_: &mut AzRefCount);
            pub(crate) fn AzRefCount_deepCopy(_: &AzRefCount) -> AzRefCount;
            pub(crate) fn AzRefAny_newC(
                _: *const c_void,
                _: usize,
                _: u64,
                _: AzString,
                _: AzRefAnyDestructorType,
            ) -> AzRefAny;
            pub(crate) fn AzRefAny_getTypeId(_: &AzRefAny) -> u64;
            pub(crate) fn AzRefAny_getTypeName(_: &AzRefAny) -> AzString;
            pub(crate) fn AzRefAny_delete(_: &mut AzRefAny);
            pub(crate) fn AzRefAny_deepCopy(_: &AzRefAny) -> AzRefAny;
            pub(crate) fn AzLayoutCallbackInfo_getGlContext(_: &AzLayoutCallbackInfo)
                -> AzOptionGl;
            pub(crate) fn AzLayoutCallbackInfo_getSystemFonts(
                _: &AzLayoutCallbackInfo,
            ) -> AzStringPairVec;
            pub(crate) fn AzLayoutCallbackInfo_getImage(
                _: &AzLayoutCallbackInfo,
                _: AzString,
            ) -> AzOptionImageRef;
            pub(crate) fn AzDom_new(_: AzNodeType) -> AzDom;
            pub(crate) fn AzDom_body() -> AzDom;
            pub(crate) fn AzDom_div() -> AzDom;
            pub(crate) fn AzDom_br() -> AzDom;
            pub(crate) fn AzDom_text(_: AzString) -> AzDom;
            pub(crate) fn AzDom_image(_: AzImageRef) -> AzDom;
            pub(crate) fn AzDom_iframe(_: AzRefAny, _: AzIFrameCallbackType) -> AzDom;
            pub(crate) fn AzDom_setNodeType(_: &mut AzDom, _: AzNodeType);
            pub(crate) fn AzDom_withNodeType(_: &mut AzDom, _: AzNodeType) -> AzDom;
            pub(crate) fn AzDom_setDataset(_: &mut AzDom, _: AzRefAny);
            pub(crate) fn AzDom_withDataset(_: &mut AzDom, _: AzRefAny) -> AzDom;
            pub(crate) fn AzDom_setIdsAndClasses(_: &mut AzDom, _: AzIdOrClassVec);
            pub(crate) fn AzDom_withIdsAndClasses(_: &mut AzDom, _: AzIdOrClassVec) -> AzDom;
            pub(crate) fn AzDom_setCallbacks(_: &mut AzDom, _: AzCallbackDataVec);
            pub(crate) fn AzDom_withCallbacks(_: &mut AzDom, _: AzCallbackDataVec) -> AzDom;
            pub(crate) fn AzDom_setInlineCssProps(_: &mut AzDom, _: AzNodeDataInlineCssPropertyVec);
            pub(crate) fn AzDom_withInlineCssProps(
                _: &mut AzDom,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzDom;
            pub(crate) fn AzDom_addCallback(
                _: &mut AzDom,
                _: AzEventFilter,
                _: AzRefAny,
                _: AzCallbackType,
            );
            pub(crate) fn AzDom_withCallback(
                _: &mut AzDom,
                _: AzEventFilter,
                _: AzRefAny,
                _: AzCallbackType,
            ) -> AzDom;
            pub(crate) fn AzDom_addChild(_: &mut AzDom, _: AzDom);
            pub(crate) fn AzDom_withChild(_: &mut AzDom, _: AzDom) -> AzDom;
            pub(crate) fn AzDom_setChildren(_: &mut AzDom, _: AzDomVec);
            pub(crate) fn AzDom_withChildren(_: &mut AzDom, _: AzDomVec) -> AzDom;
            pub(crate) fn AzDom_addId(_: &mut AzDom, _: AzString);
            pub(crate) fn AzDom_withId(_: &mut AzDom, _: AzString) -> AzDom;
            pub(crate) fn AzDom_addClass(_: &mut AzDom, _: AzString);
            pub(crate) fn AzDom_withClass(_: &mut AzDom, _: AzString) -> AzDom;
            pub(crate) fn AzDom_addCssProperty(_: &mut AzDom, _: AzCssProperty);
            pub(crate) fn AzDom_withCssProperty(_: &mut AzDom, _: AzCssProperty) -> AzDom;
            pub(crate) fn AzDom_addHoverCssProperty(_: &mut AzDom, _: AzCssProperty);
            pub(crate) fn AzDom_withHoverCssProperty(_: &mut AzDom, _: AzCssProperty) -> AzDom;
            pub(crate) fn AzDom_addActiveCssProperty(_: &mut AzDom, _: AzCssProperty);
            pub(crate) fn AzDom_withActiveCssProperty(_: &mut AzDom, _: AzCssProperty) -> AzDom;
            pub(crate) fn AzDom_addFocusCssProperty(_: &mut AzDom, _: AzCssProperty);
            pub(crate) fn AzDom_withFocusCssProperty(_: &mut AzDom, _: AzCssProperty) -> AzDom;
            pub(crate) fn AzDom_setInlineStyle(_: &mut AzDom, _: AzString);
            pub(crate) fn AzDom_withInlineStyle(_: &mut AzDom, _: AzString) -> AzDom;
            pub(crate) fn AzDom_setInlineHoverStyle(_: &mut AzDom, _: AzString);
            pub(crate) fn AzDom_withInlineHoverStyle(_: &mut AzDom, _: AzString) -> AzDom;
            pub(crate) fn AzDom_setInlineActiveStyle(_: &mut AzDom, _: AzString);
            pub(crate) fn AzDom_withInlineActiveStyle(_: &mut AzDom, _: AzString) -> AzDom;
            pub(crate) fn AzDom_setInlineFocusStyle(_: &mut AzDom, _: AzString);
            pub(crate) fn AzDom_withInlineFocusStyle(_: &mut AzDom, _: AzString) -> AzDom;
            pub(crate) fn AzDom_setClipMask(_: &mut AzDom, _: AzImageMask);
            pub(crate) fn AzDom_withClipMask(_: &mut AzDom, _: AzImageMask) -> AzDom;
            pub(crate) fn AzDom_setTabIndex(_: &mut AzDom, _: AzTabIndex);
            pub(crate) fn AzDom_withTabIndex(_: &mut AzDom, _: AzTabIndex) -> AzDom;
            pub(crate) fn AzDom_setAccessibilityInfo(_: &mut AzDom, _: AzAccessibilityInfo);
            pub(crate) fn AzDom_withAccessibilityInfo(
                _: &mut AzDom,
                _: AzAccessibilityInfo,
            ) -> AzDom;
            pub(crate) fn AzDom_setMenuBar(_: &mut AzDom, _: AzMenu);
            pub(crate) fn AzDom_withMenuBar(_: &mut AzDom, _: AzMenu) -> AzDom;
            pub(crate) fn AzDom_setContextMenu(_: &mut AzDom, _: AzMenu);
            pub(crate) fn AzDom_withContextMenu(_: &mut AzDom, _: AzMenu) -> AzDom;
            pub(crate) fn AzDom_hash(_: &AzDom) -> u64;
            pub(crate) fn AzDom_nodeCount(_: &AzDom) -> usize;
            pub(crate) fn AzDom_getHtmlString(_: &mut AzDom) -> AzString;
            pub(crate) fn AzDom_getHtmlStringTest(_: &mut AzDom) -> AzString;
            pub(crate) fn AzDom_style(_: &mut AzDom, _: AzCss) -> AzStyledDom;
            pub(crate) fn AzNodeData_new(_: AzNodeType) -> AzNodeData;
            pub(crate) fn AzNodeData_body() -> AzNodeData;
            pub(crate) fn AzNodeData_div() -> AzNodeData;
            pub(crate) fn AzNodeData_br() -> AzNodeData;
            pub(crate) fn AzNodeData_text(_: AzString) -> AzNodeData;
            pub(crate) fn AzNodeData_image(_: AzImageRef) -> AzNodeData;
            pub(crate) fn AzNodeData_iframe(_: AzRefAny, _: AzIFrameCallbackType) -> AzNodeData;
            pub(crate) fn AzNodeData_setNodeType(_: &mut AzNodeData, _: AzNodeType);
            pub(crate) fn AzNodeData_withNodeType(_: &mut AzNodeData, _: AzNodeType) -> AzNodeData;
            pub(crate) fn AzNodeData_setDataset(_: &mut AzNodeData, _: AzRefAny);
            pub(crate) fn AzNodeData_withDataset(_: &mut AzNodeData, _: AzRefAny) -> AzNodeData;
            pub(crate) fn AzNodeData_setIdsAndClasses(_: &mut AzNodeData, _: AzIdOrClassVec);
            pub(crate) fn AzNodeData_withIdsAndClasses(
                _: &mut AzNodeData,
                _: AzIdOrClassVec,
            ) -> AzNodeData;
            pub(crate) fn AzNodeData_addCallback(
                _: &mut AzNodeData,
                _: AzEventFilter,
                _: AzRefAny,
                _: AzCallbackType,
            );
            pub(crate) fn AzNodeData_withCallback(
                _: &mut AzNodeData,
                _: AzEventFilter,
                _: AzRefAny,
                _: AzCallbackType,
            ) -> AzNodeData;
            pub(crate) fn AzNodeData_setCallbacks(_: &mut AzNodeData, _: AzCallbackDataVec);
            pub(crate) fn AzNodeData_withCallbacks(
                _: &mut AzNodeData,
                _: AzCallbackDataVec,
            ) -> AzNodeData;
            pub(crate) fn AzNodeData_setInlineCssProps(
                _: &mut AzNodeData,
                _: AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzNodeData_withInlineCssProps(
                _: &mut AzNodeData,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzNodeData;
            pub(crate) fn AzNodeData_setInlineStyle(_: &mut AzNodeData, _: AzString);
            pub(crate) fn AzNodeData_withInlineStyle(_: &mut AzNodeData, _: AzString)
                -> AzNodeData;
            pub(crate) fn AzNodeData_setInlineHoverStyle(_: &mut AzNodeData, _: AzString);
            pub(crate) fn AzNodeData_withInlineHoverStyle(
                _: &mut AzNodeData,
                _: AzString,
            ) -> AzNodeData;
            pub(crate) fn AzNodeData_setInlineActiveStyle(_: &mut AzNodeData, _: AzString);
            pub(crate) fn AzNodeData_withInlineActiveStyle(
                _: &mut AzNodeData,
                _: AzString,
            ) -> AzNodeData;
            pub(crate) fn AzNodeData_setInlineFocusStyle(_: &mut AzNodeData, _: AzString);
            pub(crate) fn AzNodeData_withInlineFocusStyle(
                _: &mut AzNodeData,
                _: AzString,
            ) -> AzNodeData;
            pub(crate) fn AzNodeData_setClipMask(_: &mut AzNodeData, _: AzImageMask);
            pub(crate) fn AzNodeData_setTabIndex(_: &mut AzNodeData, _: AzTabIndex);
            pub(crate) fn AzNodeData_setAccessibilityInfo(
                _: &mut AzNodeData,
                _: AzAccessibilityInfo,
            );
            pub(crate) fn AzNodeData_setMenuBar(_: &mut AzNodeData, _: AzMenu);
            pub(crate) fn AzNodeData_setContextMenu(_: &mut AzNodeData, _: AzMenu);
            pub(crate) fn AzNodeData_hash(_: &AzNodeData) -> u64;
            pub(crate) fn AzOn_intoEventFilter(_: AzOn) -> AzEventFilter;
            pub(crate) fn AzMenu_new(_: AzMenuItemVec) -> AzMenu;
            pub(crate) fn AzMenu_setPopupPosition(_: &mut AzMenu, _: AzMenuPopupPosition);
            pub(crate) fn AzMenu_withPopupPosition(
                _: &mut AzMenu,
                _: AzMenuPopupPosition,
            ) -> AzMenu;
            pub(crate) fn AzStringMenuItem_new(_: AzString) -> AzStringMenuItem;
            pub(crate) fn AzStringMenuItem_setCallback(
                _: &mut AzStringMenuItem,
                _: AzRefAny,
                _: AzCallbackType,
            );
            pub(crate) fn AzStringMenuItem_withCallback(
                _: &mut AzStringMenuItem,
                _: AzRefAny,
                _: AzCallbackType,
            ) -> AzStringMenuItem;
            pub(crate) fn AzStringMenuItem_addChild(_: &mut AzStringMenuItem, _: AzMenuItem);
            pub(crate) fn AzStringMenuItem_withChild(
                _: &mut AzStringMenuItem,
                _: AzMenuItem,
            ) -> AzStringMenuItem;
            pub(crate) fn AzStringMenuItem_setChildren(_: &mut AzStringMenuItem, _: AzMenuItemVec);
            pub(crate) fn AzStringMenuItem_withChildren(
                _: &mut AzStringMenuItem,
                _: AzMenuItemVec,
            ) -> AzStringMenuItem;
            pub(crate) fn AzMenuCallback_new(_: AzRefAny, _: AzCallbackType) -> AzMenuCallback;
            pub(crate) fn AzCss_empty() -> AzCss;
            pub(crate) fn AzCss_fromString(_: AzString) -> AzCss;
            pub(crate) fn AzColorU_fromStr(_: AzString) -> AzColorU;
            pub(crate) fn AzColorU_transparent() -> AzColorU;
            pub(crate) fn AzColorU_white() -> AzColorU;
            pub(crate) fn AzColorU_black() -> AzColorU;
            pub(crate) fn AzColorU_toHash(_: &AzColorU) -> AzString;
            pub(crate) fn AzAngleValue_getDegrees(_: &AzAngleValue) -> f32;
            pub(crate) fn AzCssProperty_getKeyString(_: &AzCssProperty) -> AzString;
            pub(crate) fn AzCssProperty_getValueString(_: &AzCssProperty) -> AzString;
            pub(crate) fn AzCssProperty_getKeyValueString(_: &AzCssProperty) -> AzString;
            pub(crate) fn AzCssProperty_interpolate(
                _: &AzCssProperty,
                _: AzCssProperty,
                _: f32,
                _: AzInterpolateContext,
            ) -> AzCssProperty;
            pub(crate) fn AzRibbon_dom(
                _: &mut AzRibbon,
                _: AzRibbonOnTabClickedCallback,
                _: AzRefAny,
            ) -> AzDom;
            pub(crate) fn AzButton_new(_: AzString) -> AzButton;
            pub(crate) fn AzButton_setOnClick(_: &mut AzButton, _: AzRefAny, _: AzCallbackType);
            pub(crate) fn AzButton_withOnClick(
                _: &mut AzButton,
                _: AzRefAny,
                _: AzCallbackType,
            ) -> AzButton;
            pub(crate) fn AzButton_dom(_: &mut AzButton) -> AzDom;
            pub(crate) fn AzFileInput_new(_: AzOptionString) -> AzFileInput;
            pub(crate) fn AzFileInput_setDefaultText(_: &mut AzFileInput, _: AzString);
            pub(crate) fn AzFileInput_withDefaultText(
                _: &mut AzFileInput,
                _: AzString,
            ) -> AzFileInput;
            pub(crate) fn AzFileInput_setOnPathChange(
                _: &mut AzFileInput,
                _: AzRefAny,
                _: AzFileInputOnPathChangeCallbackType,
            );
            pub(crate) fn AzFileInput_withOnPathChange(
                _: &mut AzFileInput,
                _: AzRefAny,
                _: AzFileInputOnPathChangeCallbackType,
            ) -> AzFileInput;
            pub(crate) fn AzFileInput_dom(_: &mut AzFileInput) -> AzDom;
            pub(crate) fn AzCheckBox_new(_: bool) -> AzCheckBox;
            pub(crate) fn AzCheckBox_setOnToggle(
                _: &mut AzCheckBox,
                _: AzRefAny,
                _: AzCheckBoxOnToggleCallbackType,
            );
            pub(crate) fn AzCheckBox_withOnToggle(
                _: &mut AzCheckBox,
                _: AzRefAny,
                _: AzCheckBoxOnToggleCallbackType,
            ) -> AzCheckBox;
            pub(crate) fn AzCheckBox_dom(_: &mut AzCheckBox) -> AzDom;
            pub(crate) fn AzLabel_new(_: AzString) -> AzLabel;
            pub(crate) fn AzLabel_dom(_: &mut AzLabel) -> AzDom;
            pub(crate) fn AzColorInput_new(_: AzColorU) -> AzColorInput;
            pub(crate) fn AzColorInput_setOnValueChange(
                _: &mut AzColorInput,
                _: AzRefAny,
                _: AzColorInputOnValueChangeCallbackType,
            );
            pub(crate) fn AzColorInput_withOnValueChange(
                _: &mut AzColorInput,
                _: AzRefAny,
                _: AzColorInputOnValueChangeCallbackType,
            ) -> AzColorInput;
            pub(crate) fn AzColorInput_dom(_: &mut AzColorInput) -> AzDom;
            pub(crate) fn AzTextInput_new() -> AzTextInput;
            pub(crate) fn AzTextInput_setText(_: &mut AzTextInput, _: AzString);
            pub(crate) fn AzTextInput_withText(_: &mut AzTextInput, _: AzString) -> AzTextInput;
            pub(crate) fn AzTextInput_setPlaceholder(_: &mut AzTextInput, _: AzString);
            pub(crate) fn AzTextInput_withPlaceholder(
                _: &mut AzTextInput,
                _: AzString,
            ) -> AzTextInput;
            pub(crate) fn AzTextInput_setOnTextInput(
                _: &mut AzTextInput,
                _: AzRefAny,
                _: AzTextInputOnTextInputCallbackType,
            );
            pub(crate) fn AzTextInput_withOnTextInput(
                _: &mut AzTextInput,
                _: AzRefAny,
                _: AzTextInputOnTextInputCallbackType,
            ) -> AzTextInput;
            pub(crate) fn AzTextInput_setOnVirtualKeyDown(
                _: &mut AzTextInput,
                _: AzRefAny,
                _: AzTextInputOnVirtualKeyDownCallbackType,
            );
            pub(crate) fn AzTextInput_withOnVirtualKeyDown(
                _: &mut AzTextInput,
                _: AzRefAny,
                _: AzTextInputOnVirtualKeyDownCallbackType,
            ) -> AzTextInput;
            pub(crate) fn AzTextInput_setOnFocusLost(
                _: &mut AzTextInput,
                _: AzRefAny,
                _: AzTextInputOnFocusLostCallbackType,
            );
            pub(crate) fn AzTextInput_withOnFocusLost(
                _: &mut AzTextInput,
                _: AzRefAny,
                _: AzTextInputOnFocusLostCallbackType,
            ) -> AzTextInput;
            pub(crate) fn AzTextInput_setPlaceholderStyle(
                _: &mut AzTextInput,
                _: AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzTextInput_withPlaceholderStyle(
                _: &mut AzTextInput,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzTextInput;
            pub(crate) fn AzTextInput_setContainerStyle(
                _: &mut AzTextInput,
                _: AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzTextInput_withContainerStyle(
                _: &mut AzTextInput,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzTextInput;
            pub(crate) fn AzTextInput_setLabelStyle(
                _: &mut AzTextInput,
                _: AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzTextInput_withLabelStyle(
                _: &mut AzTextInput,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzTextInput;
            pub(crate) fn AzTextInput_dom(_: &mut AzTextInput) -> AzDom;
            pub(crate) fn AzTextInputState_getText(_: &AzTextInputState) -> AzString;
            pub(crate) fn AzNumberInput_new(_: f32) -> AzNumberInput;
            pub(crate) fn AzNumberInput_setOnTextInput(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzTextInputOnTextInputCallbackType,
            );
            pub(crate) fn AzNumberInput_withOnTextInput(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzTextInputOnTextInputCallbackType,
            ) -> AzNumberInput;
            pub(crate) fn AzNumberInput_setOnVirtualKeyDown(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzTextInputOnVirtualKeyDownCallbackType,
            );
            pub(crate) fn AzNumberInput_withOnVirtualKeyDown(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzTextInputOnVirtualKeyDownCallbackType,
            ) -> AzNumberInput;
            pub(crate) fn AzNumberInput_setOnFocusLost(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzNumberInputOnFocusLostCallbackType,
            );
            pub(crate) fn AzNumberInput_withOnFocusLost(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzNumberInputOnFocusLostCallbackType,
            ) -> AzNumberInput;
            pub(crate) fn AzNumberInput_setPlaceholderStyle(
                _: &mut AzNumberInput,
                _: AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzNumberInput_withPlaceholderStyle(
                _: &mut AzNumberInput,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzNumberInput;
            pub(crate) fn AzNumberInput_setContainerStyle(
                _: &mut AzNumberInput,
                _: AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzNumberInput_withContainerStyle(
                _: &mut AzNumberInput,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzNumberInput;
            pub(crate) fn AzNumberInput_setLabelStyle(
                _: &mut AzNumberInput,
                _: AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzNumberInput_withLabelStyle(
                _: &mut AzNumberInput,
                _: AzNodeDataInlineCssPropertyVec,
            ) -> AzNumberInput;
            pub(crate) fn AzNumberInput_setOnValueChange(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzNumberInputOnValueChangeCallbackType,
            );
            pub(crate) fn AzNumberInput_withOnValueChange(
                _: &mut AzNumberInput,
                _: AzRefAny,
                _: AzNumberInputOnValueChangeCallbackType,
            ) -> AzNumberInput;
            pub(crate) fn AzNumberInput_dom(_: &mut AzNumberInput) -> AzDom;
            pub(crate) fn AzProgressBar_new(_: f32) -> AzProgressBar;
            pub(crate) fn AzProgressBar_setHeight(_: &mut AzProgressBar, _: AzPixelValue);
            pub(crate) fn AzProgressBar_withHeight(
                _: &mut AzProgressBar,
                _: AzPixelValue,
            ) -> AzProgressBar;
            pub(crate) fn AzProgressBar_setContainerBackground(
                _: &mut AzProgressBar,
                _: AzStyleBackgroundContentVec,
            );
            pub(crate) fn AzProgressBar_withContainerStyle(
                _: &mut AzProgressBar,
                _: AzStyleBackgroundContentVec,
            ) -> AzProgressBar;
            pub(crate) fn AzProgressBar_setBarBackground(
                _: &mut AzProgressBar,
                _: AzStyleBackgroundContentVec,
            );
            pub(crate) fn AzProgressBar_withBarBackground(
                _: &mut AzProgressBar,
                _: AzStyleBackgroundContentVec,
            ) -> AzProgressBar;
            pub(crate) fn AzProgressBar_dom(_: &mut AzProgressBar) -> AzDom;
            pub(crate) fn AzTabHeader_new(_: AzStringVec) -> AzTabHeader;
            pub(crate) fn AzTabHeader_setActiveTab(_: &mut AzTabHeader, _: usize);
            pub(crate) fn AzTabHeader_withActiveTab(_: &mut AzTabHeader, _: usize) -> AzTabHeader;
            pub(crate) fn AzTabHeader_setOnClick(
                _: &mut AzTabHeader,
                _: AzRefAny,
                _: AzTabOnClickCallbackType,
            );
            pub(crate) fn AzTabHeader_withOnClick(
                _: &mut AzTabHeader,
                _: AzRefAny,
                _: AzTabOnClickCallbackType,
            ) -> AzTabHeader;
            pub(crate) fn AzTabHeader_dom(_: &mut AzTabHeader) -> AzDom;
            pub(crate) fn AzTabContent_new(_: AzDom) -> AzTabContent;
            pub(crate) fn AzTabContent_setPadding(_: &mut AzTabContent, _: bool);
            pub(crate) fn AzTabContent_withPadding(_: &mut AzTabContent, _: bool) -> AzTabContent;
            pub(crate) fn AzTabContent_dom(_: &mut AzTabContent) -> AzDom;
            pub(crate) fn AzFrame_new(_: AzString, _: AzDom) -> AzFrame;
            pub(crate) fn AzFrame_setFlexGrow(_: &mut AzFrame, _: f32);
            pub(crate) fn AzFrame_withFlexGrow(_: &mut AzFrame, _: f32) -> AzFrame;
            pub(crate) fn AzFrame_dom(_: &mut AzFrame) -> AzDom;
            pub(crate) fn AzNodeGraph_dom(_: &mut AzNodeGraph) -> AzDom;
            pub(crate) fn AzListView_new(_: AzStringVec) -> AzListView;
            pub(crate) fn AzListView_withRows(
                _: &mut AzListView,
                _: AzListViewRowVec,
            ) -> AzListView;
            pub(crate) fn AzListView_dom(_: &mut AzListView) -> AzDom;
            pub(crate) fn AzTreeView_new(_: AzString) -> AzTreeView;
            pub(crate) fn AzTreeView_dom(_: &mut AzTreeView) -> AzDom;
            pub(crate) fn AzDropDown_new(_: AzStringVec) -> AzDropDown;
            pub(crate) fn AzDropDown_dom(_: &mut AzDropDown) -> AzDom;
            pub(crate) fn AzCssPropertyCache_delete(_: &mut AzCssPropertyCache);
            pub(crate) fn AzCssPropertyCache_deepCopy(_: &AzCssPropertyCache)
                -> AzCssPropertyCache;
            pub(crate) fn AzStyledDom_new(_: AzDom, _: AzCss) -> AzStyledDom;
            pub(crate) fn AzStyledDom_default() -> AzStyledDom;
            pub(crate) fn AzStyledDom_fromXml(_: AzString) -> AzStyledDom;
            pub(crate) fn AzStyledDom_fromFile(_: AzString) -> AzStyledDom;
            pub(crate) fn AzStyledDom_appendChild(_: &mut AzStyledDom, _: AzStyledDom);
            pub(crate) fn AzStyledDom_withChild(_: &mut AzStyledDom, _: AzStyledDom)
                -> AzStyledDom;
            pub(crate) fn AzStyledDom_restyle(_: &mut AzStyledDom, _: AzCss);
            pub(crate) fn AzStyledDom_nodeCount(_: &AzStyledDom) -> usize;
            pub(crate) fn AzStyledDom_getHtmlString(_: &AzStyledDom) -> AzString;
            pub(crate) fn AzStyledDom_getHtmlStringTest(_: &AzStyledDom) -> AzString;
            pub(crate) fn AzStyledDom_setMenuBar(_: &mut AzStyledDom, _: AzMenu);
            pub(crate) fn AzStyledDom_withMenuBar(_: &mut AzStyledDom, _: AzMenu) -> AzStyledDom;
            pub(crate) fn AzStyledDom_setContextMenu(_: &mut AzStyledDom, _: AzMenu);
            pub(crate) fn AzStyledDom_withContextMenu(
                _: &mut AzStyledDom,
                _: AzMenu,
            ) -> AzStyledDom;
            pub(crate) fn AzTexture_new(
                _: u32,
                _: AzTextureFlags,
                _: AzPhysicalSizeU32,
                _: AzColorU,
                _: AzGl,
                _: AzRawImageFormat,
            ) -> AzTexture;
            pub(crate) fn AzTexture_allocateRgba8(
                _: AzGl,
                _: AzPhysicalSizeU32,
                _: AzColorU,
            ) -> AzTexture;
            pub(crate) fn AzTexture_allocateClipMask(
                _: AzGl,
                _: AzPhysicalSizeU32,
                _: AzColorU,
            ) -> AzTexture;
            pub(crate) fn AzTexture_clear(_: &mut AzTexture);
            pub(crate) fn AzTexture_drawClipMask(
                _: &mut AzTexture,
                _: AzTessellatedSvgNode,
            ) -> bool;
            pub(crate) fn AzTexture_drawTesselatedSvgGpuNode(
                _: &mut AzTexture,
                _: *const AzTessellatedGPUSvgNode,
                _: AzPhysicalSizeU32,
                _: AzColorU,
                _: AzStyleTransformVec,
            ) -> bool;
            pub(crate) fn AzTexture_drawTesselatedColoredSvgGpuNode(
                _: &mut AzTexture,
                _: *const AzTessellatedColoredGPUSvgNode,
                _: AzPhysicalSizeU32,
                _: AzStyleTransformVec,
            ) -> bool;
            pub(crate) fn AzTexture_applyFxaa(_: &mut AzTexture) -> bool;
            pub(crate) fn AzTexture_delete(_: &mut AzTexture);
            pub(crate) fn AzTexture_deepCopy(_: &AzTexture) -> AzTexture;
            pub(crate) fn AzGlVoidPtrConst_delete(_: &mut AzGlVoidPtrConst);
            pub(crate) fn AzGlVoidPtrConst_deepCopy(_: &AzGlVoidPtrConst) -> AzGlVoidPtrConst;
            pub(crate) fn AzGl_getType(_: &AzGl) -> AzGlType;
            pub(crate) fn AzGl_bufferDataUntyped(
                _: &AzGl,
                _: u32,
                _: isize,
                _: AzGlVoidPtrConst,
                _: u32,
            );
            pub(crate) fn AzGl_bufferSubDataUntyped(
                _: &AzGl,
                _: u32,
                _: isize,
                _: isize,
                _: AzGlVoidPtrConst,
            );
            pub(crate) fn AzGl_mapBuffer(_: &AzGl, _: u32, _: u32) -> AzGlVoidPtrMut;
            pub(crate) fn AzGl_mapBufferRange(
                _: &AzGl,
                _: u32,
                _: isize,
                _: isize,
                _: u32,
            ) -> AzGlVoidPtrMut;
            pub(crate) fn AzGl_unmapBuffer(_: &AzGl, _: u32) -> u8;
            pub(crate) fn AzGl_texBuffer(_: &AzGl, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_shaderSource(_: &AzGl, _: u32, _: AzStringVec);
            pub(crate) fn AzGl_readBuffer(_: &AzGl, _: u32);
            pub(crate) fn AzGl_readPixelsIntoBuffer(
                _: &AzGl,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: AzU8VecRefMut,
            );
            pub(crate) fn AzGl_readPixels(
                _: &AzGl,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
            ) -> AzU8Vec;
            pub(crate) fn AzGl_readPixelsIntoPbo(
                _: &AzGl,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
            );
            pub(crate) fn AzGl_sampleCoverage(_: &AzGl, _: f32, _: bool);
            pub(crate) fn AzGl_polygonOffset(_: &AzGl, _: f32, _: f32);
            pub(crate) fn AzGl_pixelStoreI(_: &AzGl, _: u32, _: i32);
            pub(crate) fn AzGl_genBuffers(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_genRenderbuffers(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_genFramebuffers(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_genTextures(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_genVertexArrays(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_genQueries(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_beginQuery(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_endQuery(_: &AzGl, _: u32);
            pub(crate) fn AzGl_queryCounter(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_getQueryObjectIv(_: &AzGl, _: u32, _: u32) -> i32;
            pub(crate) fn AzGl_getQueryObjectUiv(_: &AzGl, _: u32, _: u32) -> u32;
            pub(crate) fn AzGl_getQueryObjectI64V(_: &AzGl, _: u32, _: u32) -> i64;
            pub(crate) fn AzGl_getQueryObjectUi64V(_: &AzGl, _: u32, _: u32) -> u64;
            pub(crate) fn AzGl_deleteQueries(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_deleteVertexArrays(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_deleteBuffers(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_deleteRenderbuffers(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_deleteFramebuffers(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_deleteTextures(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_framebufferRenderbuffer(_: &AzGl, _: u32, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_renderbufferStorage(_: &AzGl, _: u32, _: u32, _: i32, _: i32);
            pub(crate) fn AzGl_depthFunc(_: &AzGl, _: u32);
            pub(crate) fn AzGl_activeTexture(_: &AzGl, _: u32);
            pub(crate) fn AzGl_attachShader(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_bindAttribLocation(_: &AzGl, _: u32, _: u32, _: AzRefstr);
            pub(crate) fn AzGl_getUniformIv(_: &AzGl, _: u32, _: i32, _: AzGLintVecRefMut);
            pub(crate) fn AzGl_getUniformFv(_: &AzGl, _: u32, _: i32, _: AzGLfloatVecRefMut);
            pub(crate) fn AzGl_getUniformBlockIndex(_: &AzGl, _: u32, _: AzRefstr) -> u32;
            pub(crate) fn AzGl_getUniformIndices(
                _: &AzGl,
                _: u32,
                _: AzRefstrVecRef,
            ) -> AzGLuintVec;
            pub(crate) fn AzGl_bindBufferBase(_: &AzGl, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_bindBufferRange(
                _: &AzGl,
                _: u32,
                _: u32,
                _: u32,
                _: isize,
                _: isize,
            );
            pub(crate) fn AzGl_uniformBlockBinding(_: &AzGl, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_bindBuffer(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_bindVertexArray(_: &AzGl, _: u32);
            pub(crate) fn AzGl_bindRenderbuffer(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_bindFramebuffer(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_bindTexture(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_drawBuffers(_: &AzGl, _: AzGLenumVecRef);
            pub(crate) fn AzGl_texImage2D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: AzOptionU8VecRef,
            );
            pub(crate) fn AzGl_compressedTexImage2D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: AzU8VecRef,
            );
            pub(crate) fn AzGl_compressedTexSubImage2D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: AzU8VecRef,
            );
            pub(crate) fn AzGl_texImage3D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: AzOptionU8VecRef,
            );
            pub(crate) fn AzGl_copyTexImage2D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
            );
            pub(crate) fn AzGl_copyTexSubImage2D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
            );
            pub(crate) fn AzGl_copyTexSubImage3D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
            );
            pub(crate) fn AzGl_texSubImage2D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: AzU8VecRef,
            );
            pub(crate) fn AzGl_texSubImage2DPbo(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: usize,
            );
            pub(crate) fn AzGl_texSubImage3D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: AzU8VecRef,
            );
            pub(crate) fn AzGl_texSubImage3DPbo(
                _: &AzGl,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: usize,
            );
            pub(crate) fn AzGl_texStorage2D(_: &AzGl, _: u32, _: i32, _: u32, _: i32, _: i32);
            pub(crate) fn AzGl_texStorage3D(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
            );
            pub(crate) fn AzGl_getTexImageIntoBuffer(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: u32,
                _: AzU8VecRefMut,
            );
            pub(crate) fn AzGl_copyImageSubData(
                _: &AzGl,
                _: u32,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
            );
            pub(crate) fn AzGl_invalidateFramebuffer(_: &AzGl, _: u32, _: AzGLenumVecRef);
            pub(crate) fn AzGl_invalidateSubFramebuffer(
                _: &AzGl,
                _: u32,
                _: AzGLenumVecRef,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
            );
            pub(crate) fn AzGl_getIntegerV(_: &AzGl, _: u32, _: AzGLintVecRefMut);
            pub(crate) fn AzGl_getInteger64V(_: &AzGl, _: u32, _: AzGLint64VecRefMut);
            pub(crate) fn AzGl_getIntegerIv(_: &AzGl, _: u32, _: u32, _: AzGLintVecRefMut);
            pub(crate) fn AzGl_getInteger64Iv(_: &AzGl, _: u32, _: u32, _: AzGLint64VecRefMut);
            pub(crate) fn AzGl_getBooleanV(_: &AzGl, _: u32, _: AzGLbooleanVecRefMut);
            pub(crate) fn AzGl_getFloatV(_: &AzGl, _: u32, _: AzGLfloatVecRefMut);
            pub(crate) fn AzGl_getFramebufferAttachmentParameterIv(
                _: &AzGl,
                _: u32,
                _: u32,
                _: u32,
            ) -> i32;
            pub(crate) fn AzGl_getRenderbufferParameterIv(_: &AzGl, _: u32, _: u32) -> i32;
            pub(crate) fn AzGl_getTexParameterIv(_: &AzGl, _: u32, _: u32) -> i32;
            pub(crate) fn AzGl_getTexParameterFv(_: &AzGl, _: u32, _: u32) -> f32;
            pub(crate) fn AzGl_texParameterI(_: &AzGl, _: u32, _: u32, _: i32);
            pub(crate) fn AzGl_texParameterF(_: &AzGl, _: u32, _: u32, _: f32);
            pub(crate) fn AzGl_framebufferTexture2D(
                _: &AzGl,
                _: u32,
                _: u32,
                _: u32,
                _: u32,
                _: i32,
            );
            pub(crate) fn AzGl_framebufferTextureLayer(
                _: &AzGl,
                _: u32,
                _: u32,
                _: u32,
                _: i32,
                _: i32,
            );
            pub(crate) fn AzGl_blitFramebuffer(
                _: &AzGl,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u32,
                _: u32,
            );
            pub(crate) fn AzGl_vertexAttrib4F(_: &AzGl, _: u32, _: f32, _: f32, _: f32, _: f32);
            pub(crate) fn AzGl_vertexAttribPointerF32(
                _: &AzGl,
                _: u32,
                _: i32,
                _: bool,
                _: i32,
                _: u32,
            );
            pub(crate) fn AzGl_vertexAttribPointer(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: bool,
                _: i32,
                _: u32,
            );
            pub(crate) fn AzGl_vertexAttribIPointer(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: i32,
                _: u32,
            );
            pub(crate) fn AzGl_vertexAttribDivisor(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_viewport(_: &AzGl, _: i32, _: i32, _: i32, _: i32);
            pub(crate) fn AzGl_scissor(_: &AzGl, _: i32, _: i32, _: i32, _: i32);
            pub(crate) fn AzGl_lineWidth(_: &AzGl, _: f32);
            pub(crate) fn AzGl_useProgram(_: &AzGl, _: u32);
            pub(crate) fn AzGl_validateProgram(_: &AzGl, _: u32);
            pub(crate) fn AzGl_drawArrays(_: &AzGl, _: u32, _: i32, _: i32);
            pub(crate) fn AzGl_drawArraysInstanced(_: &AzGl, _: u32, _: i32, _: i32, _: i32);
            pub(crate) fn AzGl_drawElements(_: &AzGl, _: u32, _: i32, _: u32, _: u32);
            pub(crate) fn AzGl_drawElementsInstanced(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: u32,
                _: i32,
            );
            pub(crate) fn AzGl_blendColor(_: &AzGl, _: f32, _: f32, _: f32, _: f32);
            pub(crate) fn AzGl_blendFunc(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_blendFuncSeparate(_: &AzGl, _: u32, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_blendEquation(_: &AzGl, _: u32);
            pub(crate) fn AzGl_blendEquationSeparate(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_colorMask(_: &AzGl, _: bool, _: bool, _: bool, _: bool);
            pub(crate) fn AzGl_cullFace(_: &AzGl, _: u32);
            pub(crate) fn AzGl_frontFace(_: &AzGl, _: u32);
            pub(crate) fn AzGl_enable(_: &AzGl, _: u32);
            pub(crate) fn AzGl_disable(_: &AzGl, _: u32);
            pub(crate) fn AzGl_hint(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_isEnabled(_: &AzGl, _: u32) -> u8;
            pub(crate) fn AzGl_isShader(_: &AzGl, _: u32) -> u8;
            pub(crate) fn AzGl_isTexture(_: &AzGl, _: u32) -> u8;
            pub(crate) fn AzGl_isFramebuffer(_: &AzGl, _: u32) -> u8;
            pub(crate) fn AzGl_isRenderbuffer(_: &AzGl, _: u32) -> u8;
            pub(crate) fn AzGl_checkFrameBufferStatus(_: &AzGl, _: u32) -> u32;
            pub(crate) fn AzGl_enableVertexAttribArray(_: &AzGl, _: u32);
            pub(crate) fn AzGl_disableVertexAttribArray(_: &AzGl, _: u32);
            pub(crate) fn AzGl_uniform1F(_: &AzGl, _: i32, _: f32);
            pub(crate) fn AzGl_uniform1Fv(_: &AzGl, _: i32, _: AzF32VecRef);
            pub(crate) fn AzGl_uniform1I(_: &AzGl, _: i32, _: i32);
            pub(crate) fn AzGl_uniform1Iv(_: &AzGl, _: i32, _: AzI32VecRef);
            pub(crate) fn AzGl_uniform1Ui(_: &AzGl, _: i32, _: u32);
            pub(crate) fn AzGl_uniform2F(_: &AzGl, _: i32, _: f32, _: f32);
            pub(crate) fn AzGl_uniform2Fv(_: &AzGl, _: i32, _: AzF32VecRef);
            pub(crate) fn AzGl_uniform2I(_: &AzGl, _: i32, _: i32, _: i32);
            pub(crate) fn AzGl_uniform2Iv(_: &AzGl, _: i32, _: AzI32VecRef);
            pub(crate) fn AzGl_uniform2Ui(_: &AzGl, _: i32, _: u32, _: u32);
            pub(crate) fn AzGl_uniform3F(_: &AzGl, _: i32, _: f32, _: f32, _: f32);
            pub(crate) fn AzGl_uniform3Fv(_: &AzGl, _: i32, _: AzF32VecRef);
            pub(crate) fn AzGl_uniform3I(_: &AzGl, _: i32, _: i32, _: i32, _: i32);
            pub(crate) fn AzGl_uniform3Iv(_: &AzGl, _: i32, _: AzI32VecRef);
            pub(crate) fn AzGl_uniform3Ui(_: &AzGl, _: i32, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_uniform4F(_: &AzGl, _: i32, _: f32, _: f32, _: f32, _: f32);
            pub(crate) fn AzGl_uniform4I(_: &AzGl, _: i32, _: i32, _: i32, _: i32, _: i32);
            pub(crate) fn AzGl_uniform4Iv(_: &AzGl, _: i32, _: AzI32VecRef);
            pub(crate) fn AzGl_uniform4Ui(_: &AzGl, _: i32, _: u32, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_uniform4Fv(_: &AzGl, _: i32, _: AzF32VecRef);
            pub(crate) fn AzGl_uniformMatrix2Fv(_: &AzGl, _: i32, _: bool, _: AzF32VecRef);
            pub(crate) fn AzGl_uniformMatrix3Fv(_: &AzGl, _: i32, _: bool, _: AzF32VecRef);
            pub(crate) fn AzGl_uniformMatrix4Fv(_: &AzGl, _: i32, _: bool, _: AzF32VecRef);
            pub(crate) fn AzGl_depthMask(_: &AzGl, _: bool);
            pub(crate) fn AzGl_depthRange(_: &AzGl, _: f64, _: f64);
            pub(crate) fn AzGl_getActiveAttrib(_: &AzGl, _: u32, _: u32)
                -> AzGetActiveAttribReturn;
            pub(crate) fn AzGl_getActiveUniform(
                _: &AzGl,
                _: u32,
                _: u32,
            ) -> AzGetActiveUniformReturn;
            pub(crate) fn AzGl_getActiveUniformsIv(
                _: &AzGl,
                _: u32,
                _: AzGLuintVec,
                _: u32,
            ) -> AzGLintVec;
            pub(crate) fn AzGl_getActiveUniformBlockI(_: &AzGl, _: u32, _: u32, _: u32) -> i32;
            pub(crate) fn AzGl_getActiveUniformBlockIv(
                _: &AzGl,
                _: u32,
                _: u32,
                _: u32,
            ) -> AzGLintVec;
            pub(crate) fn AzGl_getActiveUniformBlockName(_: &AzGl, _: u32, _: u32) -> AzString;
            pub(crate) fn AzGl_getAttribLocation(_: &AzGl, _: u32, _: AzRefstr) -> i32;
            pub(crate) fn AzGl_getFragDataLocation(_: &AzGl, _: u32, _: AzRefstr) -> i32;
            pub(crate) fn AzGl_getUniformLocation(_: &AzGl, _: u32, _: AzRefstr) -> i32;
            pub(crate) fn AzGl_getProgramInfoLog(_: &AzGl, _: u32) -> AzString;
            pub(crate) fn AzGl_getProgramIv(_: &AzGl, _: u32, _: u32, _: AzGLintVecRefMut);
            pub(crate) fn AzGl_getProgramBinary(_: &AzGl, _: u32) -> AzGetProgramBinaryReturn;
            pub(crate) fn AzGl_programBinary(_: &AzGl, _: u32, _: u32, _: AzU8VecRef);
            pub(crate) fn AzGl_programParameterI(_: &AzGl, _: u32, _: u32, _: i32);
            pub(crate) fn AzGl_getVertexAttribIv(_: &AzGl, _: u32, _: u32, _: AzGLintVecRefMut);
            pub(crate) fn AzGl_getVertexAttribFv(_: &AzGl, _: u32, _: u32, _: AzGLfloatVecRefMut);
            pub(crate) fn AzGl_getVertexAttribPointerV(_: &AzGl, _: u32, _: u32) -> isize;
            pub(crate) fn AzGl_getBufferParameterIv(_: &AzGl, _: u32, _: u32) -> i32;
            pub(crate) fn AzGl_getShaderInfoLog(_: &AzGl, _: u32) -> AzString;
            pub(crate) fn AzGl_getString(_: &AzGl, _: u32) -> AzString;
            pub(crate) fn AzGl_getStringI(_: &AzGl, _: u32, _: u32) -> AzString;
            pub(crate) fn AzGl_getShaderIv(_: &AzGl, _: u32, _: u32, _: AzGLintVecRefMut);
            pub(crate) fn AzGl_getShaderPrecisionFormat(
                _: &AzGl,
                _: u32,
                _: u32,
            ) -> AzGlShaderPrecisionFormatReturn;
            pub(crate) fn AzGl_compileShader(_: &AzGl, _: u32);
            pub(crate) fn AzGl_createProgram(_: &AzGl) -> u32;
            pub(crate) fn AzGl_deleteProgram(_: &AzGl, _: u32);
            pub(crate) fn AzGl_createShader(_: &AzGl, _: u32) -> u32;
            pub(crate) fn AzGl_deleteShader(_: &AzGl, _: u32);
            pub(crate) fn AzGl_detachShader(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_linkProgram(_: &AzGl, _: u32);
            pub(crate) fn AzGl_clearColor(_: &AzGl, _: f32, _: f32, _: f32, _: f32);
            pub(crate) fn AzGl_clear(_: &AzGl, _: u32);
            pub(crate) fn AzGl_clearDepth(_: &AzGl, _: f64);
            pub(crate) fn AzGl_clearStencil(_: &AzGl, _: i32);
            pub(crate) fn AzGl_flush(_: &AzGl);
            pub(crate) fn AzGl_finish(_: &AzGl);
            pub(crate) fn AzGl_getError(_: &AzGl) -> u32;
            pub(crate) fn AzGl_stencilMask(_: &AzGl, _: u32);
            pub(crate) fn AzGl_stencilMaskSeparate(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_stencilFunc(_: &AzGl, _: u32, _: i32, _: u32);
            pub(crate) fn AzGl_stencilFuncSeparate(_: &AzGl, _: u32, _: u32, _: i32, _: u32);
            pub(crate) fn AzGl_stencilOp(_: &AzGl, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_stencilOpSeparate(_: &AzGl, _: u32, _: u32, _: u32, _: u32);
            pub(crate) fn AzGl_eglImageTargetTexture2DOes(_: &AzGl, _: u32, _: AzGlVoidPtrConst);
            pub(crate) fn AzGl_generateMipmap(_: &AzGl, _: u32);
            pub(crate) fn AzGl_insertEventMarkerExt(_: &AzGl, _: AzRefstr);
            pub(crate) fn AzGl_pushGroupMarkerExt(_: &AzGl, _: AzRefstr);
            pub(crate) fn AzGl_popGroupMarkerExt(_: &AzGl);
            pub(crate) fn AzGl_debugMessageInsertKhr(
                _: &AzGl,
                _: u32,
                _: u32,
                _: u32,
                _: u32,
                _: AzRefstr,
            );
            pub(crate) fn AzGl_pushDebugGroupKhr(_: &AzGl, _: u32, _: u32, _: AzRefstr);
            pub(crate) fn AzGl_popDebugGroupKhr(_: &AzGl);
            pub(crate) fn AzGl_fenceSync(_: &AzGl, _: u32, _: u32) -> AzGLsyncPtr;
            pub(crate) fn AzGl_clientWaitSync(_: &AzGl, _: AzGLsyncPtr, _: u32, _: u64) -> u32;
            pub(crate) fn AzGl_waitSync(_: &AzGl, _: AzGLsyncPtr, _: u32, _: u64);
            pub(crate) fn AzGl_deleteSync(_: &AzGl, _: AzGLsyncPtr);
            pub(crate) fn AzGl_textureRangeApple(_: &AzGl, _: u32, _: AzU8VecRef);
            pub(crate) fn AzGl_genFencesApple(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_deleteFencesApple(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_setFenceApple(_: &AzGl, _: u32);
            pub(crate) fn AzGl_finishFenceApple(_: &AzGl, _: u32);
            pub(crate) fn AzGl_testFenceApple(_: &AzGl, _: u32);
            pub(crate) fn AzGl_testObjectApple(_: &AzGl, _: u32, _: u32) -> u8;
            pub(crate) fn AzGl_finishObjectApple(_: &AzGl, _: u32, _: u32);
            pub(crate) fn AzGl_getFragDataIndex(_: &AzGl, _: u32, _: AzRefstr) -> i32;
            pub(crate) fn AzGl_blendBarrierKhr(_: &AzGl);
            pub(crate) fn AzGl_bindFragDataLocationIndexed(
                _: &AzGl,
                _: u32,
                _: u32,
                _: u32,
                _: AzRefstr,
            );
            pub(crate) fn AzGl_getDebugMessages(_: &AzGl) -> AzDebugMessageVec;
            pub(crate) fn AzGl_provokingVertexAngle(_: &AzGl, _: u32);
            pub(crate) fn AzGl_genVertexArraysApple(_: &AzGl, _: i32) -> AzGLuintVec;
            pub(crate) fn AzGl_bindVertexArrayApple(_: &AzGl, _: u32);
            pub(crate) fn AzGl_deleteVertexArraysApple(_: &AzGl, _: AzGLuintVecRef);
            pub(crate) fn AzGl_copyTextureChromium(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: u32,
                _: i32,
                _: i32,
                _: u32,
                _: u8,
                _: u8,
                _: u8,
            );
            pub(crate) fn AzGl_copySubTextureChromium(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u8,
                _: u8,
                _: u8,
            );
            pub(crate) fn AzGl_eglImageTargetRenderbufferStorageOes(
                _: &AzGl,
                _: u32,
                _: AzGlVoidPtrConst,
            );
            pub(crate) fn AzGl_copyTexture3DAngle(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: u32,
                _: i32,
                _: i32,
                _: u32,
                _: u8,
                _: u8,
                _: u8,
            );
            pub(crate) fn AzGl_copySubTexture3DAngle(
                _: &AzGl,
                _: u32,
                _: i32,
                _: u32,
                _: u32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: i32,
                _: u8,
                _: u8,
                _: u8,
            );
            pub(crate) fn AzGl_bufferStorage(
                _: &AzGl,
                _: u32,
                _: isize,
                _: AzGlVoidPtrConst,
                _: u32,
            );
            pub(crate) fn AzGl_flushMappedBufferRange(_: &AzGl, _: u32, _: isize, _: isize);
            pub(crate) fn AzGl_delete(_: &mut AzGl);
            pub(crate) fn AzGl_deepCopy(_: &AzGl) -> AzGl;
            pub(crate) fn AzVertexArrayObject_new(
                _: AzVertexLayout,
                _: u32,
                _: AzGl,
            ) -> AzVertexArrayObject;
            pub(crate) fn AzVertexArrayObject_delete(_: &mut AzVertexArrayObject);
            pub(crate) fn AzVertexArrayObject_deepCopy(
                _: &AzVertexArrayObject,
            ) -> AzVertexArrayObject;
            pub(crate) fn AzVertexBuffer_new(
                _: u32,
                _: usize,
                _: AzVertexArrayObject,
                _: u32,
                _: usize,
                _: AzIndexBufferFormat,
            ) -> AzVertexBuffer;
            pub(crate) fn AzVertexBuffer_delete(_: &mut AzVertexBuffer);
            pub(crate) fn AzVertexBuffer_deepCopy(_: &AzVertexBuffer) -> AzVertexBuffer;
            pub(crate) fn AzGLsyncPtr_delete(_: &mut AzGLsyncPtr);
            pub(crate) fn AzGLsyncPtr_deepCopy(_: &AzGLsyncPtr) -> AzGLsyncPtr;
            pub(crate) fn AzTextureFlags_default() -> AzTextureFlags;
            pub(crate) fn AzImageRef_nullImage(
                _: usize,
                _: usize,
                _: AzRawImageFormat,
                _: AzU8Vec,
            ) -> AzImageRef;
            pub(crate) fn AzImageRef_rawImage(_: AzRawImage) -> AzOptionImageRef;
            pub(crate) fn AzImageRef_glTexture(_: AzTexture) -> AzImageRef;
            pub(crate) fn AzImageRef_callback(
                _: AzRefAny,
                _: AzRenderImageCallbackType,
            ) -> AzImageRef;
            pub(crate) fn AzImageRef_cloneBytes(_: &AzImageRef) -> AzImageRef;
            pub(crate) fn AzImageRef_isInvalid(_: &AzImageRef) -> bool;
            pub(crate) fn AzImageRef_isGlTexture(_: &AzImageRef) -> bool;
            pub(crate) fn AzImageRef_isRawImage(_: &AzImageRef) -> bool;
            pub(crate) fn AzImageRef_isCallback(_: &AzImageRef) -> bool;
            pub(crate) fn AzImageRef_getRawImage(_: &AzImageRef) -> AzOptionRawImage;
            pub(crate) fn AzImageRef_getHash(_: &AzImageRef) -> u64;
            pub(crate) fn AzImageRef_delete(_: &mut AzImageRef);
            pub(crate) fn AzImageRef_deepCopy(_: &AzImageRef) -> AzImageRef;
            pub(crate) fn AzRawImage_empty() -> AzRawImage;
            pub(crate) fn AzRawImage_allocateClipMask(_: AzLayoutSize) -> AzRawImage;
            pub(crate) fn AzRawImage_decodeImageBytesAny(
                _: AzU8VecRef,
            ) -> AzResultRawImageDecodeImageError;
            pub(crate) fn AzRawImage_drawClipMask(
                _: &mut AzRawImage,
                _: AzSvgNode,
                _: AzSvgStyle,
            ) -> bool;
            pub(crate) fn AzRawImage_encodeBmp(_: &AzRawImage) -> AzResultU8VecEncodeImageError;
            pub(crate) fn AzRawImage_encodePng(_: &AzRawImage) -> AzResultU8VecEncodeImageError;
            pub(crate) fn AzRawImage_encodeJpeg(
                _: &AzRawImage,
                _: u8,
            ) -> AzResultU8VecEncodeImageError;
            pub(crate) fn AzRawImage_encodeTga(_: &AzRawImage) -> AzResultU8VecEncodeImageError;
            pub(crate) fn AzRawImage_encodePnm(_: &AzRawImage) -> AzResultU8VecEncodeImageError;
            pub(crate) fn AzRawImage_encodeGif(_: &AzRawImage) -> AzResultU8VecEncodeImageError;
            pub(crate) fn AzRawImage_encodeTiff(_: &AzRawImage) -> AzResultU8VecEncodeImageError;
            pub(crate) fn AzFontMetrics_zero() -> AzFontMetrics;
            pub(crate) fn AzFontMetrics_useTypoMetrics(_: &AzFontMetrics) -> bool;
            pub(crate) fn AzFontMetrics_getAscender(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getDescender(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getLineGap(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getXMin(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYMin(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getXMax(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYMax(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getAdvanceWidthMax(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getMinLeftSideBearing(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getMinRightSideBearing(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getXMaxExtent(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getXAvgCharWidth(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSubscriptXSize(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSubscriptYSize(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSubscriptXOffset(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSubscriptYOffset(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSuperscriptXSize(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSuperscriptYSize(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSuperscriptXOffset(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYSuperscriptYOffset(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYStrikeoutSize(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontMetrics_getYStrikeoutPosition(_: &AzFontMetrics, _: f32) -> f32;
            pub(crate) fn AzFontRef_parse(_: AzFontSource) -> AzOptionFontRef;
            pub(crate) fn AzFontRef_getBytes(_: &AzFontRef) -> AzU8Vec;
            pub(crate) fn AzFontRef_getFontMetrics(_: &AzFontRef) -> AzFontMetrics;
            pub(crate) fn AzFontRef_shapeText(
                _: &AzFontRef,
                _: AzRefstr,
                _: AzResolvedTextLayoutOptions,
            ) -> AzInlineText;
            pub(crate) fn AzFontRef_getHash(_: &AzFontRef) -> u64;
            pub(crate) fn AzFontRef_delete(_: &mut AzFontRef);
            pub(crate) fn AzFontRef_deepCopy(_: &AzFontRef) -> AzFontRef;
            pub(crate) fn AzSvg_fromString(
                _: AzString,
                _: AzSvgParseOptions,
            ) -> AzResultSvgSvgParseError;
            pub(crate) fn AzSvg_fromBytes(
                _: AzU8VecRef,
                _: AzSvgParseOptions,
            ) -> AzResultSvgSvgParseError;
            pub(crate) fn AzSvg_getRoot(_: &AzSvg) -> AzSvgXmlNode;
            pub(crate) fn AzSvg_render(_: &AzSvg, _: AzSvgRenderOptions) -> AzOptionRawImage;
            pub(crate) fn AzSvg_toString(_: &AzSvg, _: AzSvgStringFormatOptions) -> AzString;
            pub(crate) fn AzSvg_delete(_: &mut AzSvg);
            pub(crate) fn AzSvg_deepCopy(_: &AzSvg) -> AzSvg;
            pub(crate) fn AzSvgXmlNode_parseFrom(
                _: AzU8VecRef,
                _: AzSvgParseOptions,
            ) -> AzResultSvgXmlNodeSvgParseError;
            pub(crate) fn AzSvgXmlNode_delete(_: &mut AzSvgXmlNode);
            pub(crate) fn AzSvgXmlNode_deepCopy(_: &AzSvgXmlNode) -> AzSvgXmlNode;
            pub(crate) fn AzSvgMultiPolygon_getBounds(_: &AzSvgMultiPolygon) -> AzSvgRect;
            pub(crate) fn AzSvgMultiPolygon_containsPoint(
                _: &AzSvgMultiPolygon,
                _: AzSvgPoint,
                _: AzSvgFillRule,
                _: f32,
            ) -> bool;
            pub(crate) fn AzSvgMultiPolygon_union(
                _: &AzSvgMultiPolygon,
                _: AzSvgMultiPolygon,
            ) -> AzSvgMultiPolygon;
            pub(crate) fn AzSvgMultiPolygon_intersection(
                _: &AzSvgMultiPolygon,
                _: AzSvgMultiPolygon,
            ) -> AzSvgMultiPolygon;
            pub(crate) fn AzSvgMultiPolygon_difference(
                _: &AzSvgMultiPolygon,
                _: AzSvgMultiPolygon,
            ) -> AzSvgMultiPolygon;
            pub(crate) fn AzSvgMultiPolygon_xor(
                _: &AzSvgMultiPolygon,
                _: AzSvgMultiPolygon,
            ) -> AzSvgMultiPolygon;
            pub(crate) fn AzSvgMultiPolygon_tessellateFill(
                _: &AzSvgMultiPolygon,
                _: AzSvgFillStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgMultiPolygon_tessellateStroke(
                _: &AzSvgMultiPolygon,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgNode_tessellateFill(
                _: &AzSvgNode,
                _: AzSvgFillStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgNode_tessellateStroke(
                _: &AzSvgNode,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgNode_isClosed(_: &AzSvgNode) -> bool;
            pub(crate) fn AzSvgNode_containsPoint(
                _: &AzSvgNode,
                _: AzSvgPoint,
                _: AzSvgFillRule,
                _: f32,
            ) -> bool;
            pub(crate) fn AzSvgNode_getBounds(_: &AzSvgNode) -> AzSvgRect;
            pub(crate) fn AzSvgSimpleNode_getBounds(_: &AzSvgSimpleNode) -> AzSvgRect;
            pub(crate) fn AzSvgStyledNode_tessellate(_: &AzSvgStyledNode) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgCircle_tessellateFill(
                _: &AzSvgCircle,
                _: AzSvgFillStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgCircle_tessellateStroke(
                _: &AzSvgCircle,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgPath_isClosed(_: &AzSvgPath) -> bool;
            pub(crate) fn AzSvgPath_reverse(_: &mut AzSvgPath);
            pub(crate) fn AzSvgPath_getStart(_: &AzSvgPath) -> AzOptionSvgPoint;
            pub(crate) fn AzSvgPath_getEnd(_: &AzSvgPath) -> AzOptionSvgPoint;
            pub(crate) fn AzSvgPath_getBounds(_: &mut AzSvgPath) -> AzSvgRect;
            pub(crate) fn AzSvgPath_joinWith(_: &mut AzSvgPath, _: AzSvgPath);
            pub(crate) fn AzSvgPath_offset(
                _: &mut AzSvgPath,
                _: f32,
                _: AzSvgLineJoin,
                _: AzSvgLineCap,
            ) -> AzSvgPath;
            pub(crate) fn AzSvgPath_bevel(_: &mut AzSvgPath, _: f32) -> AzSvgPath;
            pub(crate) fn AzSvgPath_tessellateFill(
                _: &AzSvgPath,
                _: AzSvgFillStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgPath_tessellateStroke(
                _: &AzSvgPath,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgPathElement_reverse(_: &mut AzSvgPathElement);
            pub(crate) fn AzSvgPathElement_getStart(_: &AzSvgPathElement) -> AzSvgPoint;
            pub(crate) fn AzSvgPathElement_getEnd(_: &AzSvgPathElement) -> AzSvgPoint;
            pub(crate) fn AzSvgPathElement_getBounds(_: &AzSvgPathElement) -> AzSvgRect;
            pub(crate) fn AzSvgPathElement_getLength(_: &AzSvgPathElement) -> f64;
            pub(crate) fn AzSvgPathElement_getTAtOffset(_: &AzSvgPathElement, _: f64) -> f64;
            pub(crate) fn AzSvgPathElement_getXAtT(_: &AzSvgPathElement, _: f64) -> f64;
            pub(crate) fn AzSvgPathElement_getYAtT(_: &AzSvgPathElement, _: f64) -> f64;
            pub(crate) fn AzSvgPathElement_getTangentVectorAtT(
                _: &AzSvgPathElement,
                _: f64,
            ) -> AzSvgVector;
            pub(crate) fn AzSvgPathElement_tessellateStroke(
                _: &AzSvgPathElement,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgPoint_distance(_: &AzSvgPoint, _: AzSvgPoint) -> f64;
            pub(crate) fn AzSvgVector_angleDegrees(_: &AzSvgVector) -> f64;
            pub(crate) fn AzSvgVector_normalize(_: &AzSvgVector) -> AzSvgVector;
            pub(crate) fn AzSvgVector_rotate90DegCcw(_: &AzSvgVector) -> AzSvgVector;
            pub(crate) fn AzSvgLine_reverse(_: &mut AzSvgLine);
            pub(crate) fn AzSvgLine_getStart(_: &AzSvgLine) -> AzSvgPoint;
            pub(crate) fn AzSvgLine_getEnd(_: &AzSvgLine) -> AzSvgPoint;
            pub(crate) fn AzSvgLine_getBounds(_: &AzSvgLine) -> AzSvgRect;
            pub(crate) fn AzSvgLine_getLength(_: &AzSvgLine) -> f64;
            pub(crate) fn AzSvgLine_getTAtOffset(_: &AzSvgLine, _: f64) -> f64;
            pub(crate) fn AzSvgLine_getXAtT(_: &AzSvgLine, _: f64) -> f64;
            pub(crate) fn AzSvgLine_getYAtT(_: &AzSvgLine, _: f64) -> f64;
            pub(crate) fn AzSvgLine_getTangentVectorAtT(_: &AzSvgLine, _: f64) -> AzSvgVector;
            pub(crate) fn AzSvgLine_intersect(_: &AzSvgLine, _: AzSvgLine) -> AzOptionSvgPoint;
            pub(crate) fn AzSvgLine_tessellateStroke(
                _: &AzSvgLine,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgQuadraticCurve_reverse(_: &mut AzSvgQuadraticCurve);
            pub(crate) fn AzSvgQuadraticCurve_getStart(_: &AzSvgQuadraticCurve) -> AzSvgPoint;
            pub(crate) fn AzSvgQuadraticCurve_getEnd(_: &AzSvgQuadraticCurve) -> AzSvgPoint;
            pub(crate) fn AzSvgQuadraticCurve_getBounds(_: &AzSvgQuadraticCurve) -> AzSvgRect;
            pub(crate) fn AzSvgQuadraticCurve_getLength(_: &AzSvgQuadraticCurve) -> f64;
            pub(crate) fn AzSvgQuadraticCurve_getTAtOffset(_: &AzSvgQuadraticCurve, _: f64) -> f64;
            pub(crate) fn AzSvgQuadraticCurve_getXAtT(_: &AzSvgQuadraticCurve, _: f64) -> f64;
            pub(crate) fn AzSvgQuadraticCurve_getYAtT(_: &AzSvgQuadraticCurve, _: f64) -> f64;
            pub(crate) fn AzSvgQuadraticCurve_getTangentVectorAtT(
                _: &AzSvgQuadraticCurve,
                _: f64,
            ) -> AzSvgVector;
            pub(crate) fn AzSvgQuadraticCurve_tessellateStroke(
                _: &AzSvgQuadraticCurve,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgCubicCurve_reverse(_: &mut AzSvgCubicCurve);
            pub(crate) fn AzSvgCubicCurve_getStart(_: &AzSvgCubicCurve) -> AzSvgPoint;
            pub(crate) fn AzSvgCubicCurve_getEnd(_: &AzSvgCubicCurve) -> AzSvgPoint;
            pub(crate) fn AzSvgCubicCurve_getBounds(_: &AzSvgCubicCurve) -> AzSvgRect;
            pub(crate) fn AzSvgCubicCurve_getLength(_: &AzSvgCubicCurve) -> f64;
            pub(crate) fn AzSvgCubicCurve_getTAtOffset(_: &AzSvgCubicCurve, _: f64) -> f64;
            pub(crate) fn AzSvgCubicCurve_getXAtT(_: &AzSvgCubicCurve, _: f64) -> f64;
            pub(crate) fn AzSvgCubicCurve_getYAtT(_: &AzSvgCubicCurve, _: f64) -> f64;
            pub(crate) fn AzSvgCubicCurve_getTangentVectorAtT(
                _: &AzSvgCubicCurve,
                _: f64,
            ) -> AzSvgVector;
            pub(crate) fn AzSvgCubicCurve_tessellateStroke(
                _: &AzSvgCubicCurve,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgRect_getCenter(_: &AzSvgRect) -> AzSvgPoint;
            pub(crate) fn AzSvgRect_containsPoint(_: &AzSvgRect, _: AzSvgPoint) -> bool;
            pub(crate) fn AzSvgRect_expand(
                _: &AzSvgRect,
                _: f32,
                _: f32,
                _: f32,
                _: f32,
            ) -> AzSvgRect;
            pub(crate) fn AzSvgRect_tessellateFill(
                _: &AzSvgRect,
                _: AzSvgFillStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzSvgRect_tessellateStroke(
                _: &AzSvgRect,
                _: AzSvgStrokeStyle,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzTessellatedColoredSvgNode_empty() -> AzTessellatedColoredSvgNode;
            pub(crate) fn AzTessellatedColoredSvgNode_fromNodes(
                _: AzTessellatedColoredSvgNodeVecRef,
            ) -> AzTessellatedColoredSvgNode;
            pub(crate) fn AzTessellatedColoredGPUSvgNode_new(
                _: *const AzTessellatedColoredSvgNode,
                _: AzGl,
            ) -> AzTessellatedColoredGPUSvgNode;
            pub(crate) fn AzTessellatedSvgNode_empty() -> AzTessellatedSvgNode;
            pub(crate) fn AzTessellatedSvgNode_fromNodes(
                _: AzTessellatedSvgNodeVecRef,
            ) -> AzTessellatedSvgNode;
            pub(crate) fn AzTessellatedGPUSvgNode_new(
                _: *const AzTessellatedSvgNode,
                _: AzGl,
            ) -> AzTessellatedGPUSvgNode;
            pub(crate) fn AzSvgParseOptions_default() -> AzSvgParseOptions;
            pub(crate) fn AzSvgRenderOptions_default() -> AzSvgRenderOptions;
            pub(crate) fn AzSvgFillStyle_default() -> AzSvgFillStyle;
            pub(crate) fn AzSvgStrokeStyle_default() -> AzSvgStrokeStyle;
            pub(crate) fn AzXml_fromStr(_: AzRefstr) -> AzResultXmlXmlError;
            pub(crate) fn AzFile_open(_: AzString) -> AzOptionFile;
            pub(crate) fn AzFile_create(_: AzString) -> AzOptionFile;
            pub(crate) fn AzFile_readToString(_: &mut AzFile) -> AzOptionString;
            pub(crate) fn AzFile_readToBytes(_: &mut AzFile) -> AzOptionU8Vec;
            pub(crate) fn AzFile_writeString(_: &mut AzFile, _: AzRefstr) -> bool;
            pub(crate) fn AzFile_writeBytes(_: &mut AzFile, _: AzU8VecRef) -> bool;
            pub(crate) fn AzFile_close(_: &mut AzFile);
            pub(crate) fn AzFile_delete(_: &mut AzFile);
            pub(crate) fn AzFile_deepCopy(_: &AzFile) -> AzFile;
            pub(crate) fn AzMsgBox_ok(_: AzMsgBoxIcon, _: AzString, _: AzString) -> bool;
            pub(crate) fn AzMsgBox_info(_: AzString) -> bool;
            pub(crate) fn AzMsgBox_warning(_: AzString) -> bool;
            pub(crate) fn AzMsgBox_error(_: AzString) -> bool;
            pub(crate) fn AzMsgBox_question(_: AzString) -> bool;
            pub(crate) fn AzMsgBox_okCancel(
                _: AzMsgBoxIcon,
                _: AzString,
                _: AzString,
                _: AzMsgBoxOkCancel,
            ) -> AzMsgBoxOkCancel;
            pub(crate) fn AzMsgBox_yesNo(
                _: AzMsgBoxIcon,
                _: AzString,
                _: AzString,
                _: AzMsgBoxYesNo,
            ) -> AzMsgBoxYesNo;
            pub(crate) fn AzFileDialog_selectFile(
                _: AzString,
                _: AzOptionString,
                _: AzOptionFileTypeList,
            ) -> AzOptionString;
            pub(crate) fn AzFileDialog_selectMultipleFiles(
                _: AzString,
                _: AzOptionString,
                _: AzOptionFileTypeList,
            ) -> AzOptionStringVec;
            pub(crate) fn AzFileDialog_selectFolder(
                _: AzString,
                _: AzOptionString,
            ) -> AzOptionString;
            pub(crate) fn AzFileDialog_saveFile(_: AzString, _: AzOptionString) -> AzOptionString;
            pub(crate) fn AzColorPickerDialog_open(
                _: AzString,
                _: AzOptionColorU,
            ) -> AzOptionColorU;
            pub(crate) fn AzSystemClipboard_new() -> AzOptionSystemClipboard;
            pub(crate) fn AzSystemClipboard_getStringContents(
                _: &AzSystemClipboard,
            ) -> AzOptionString;
            pub(crate) fn AzSystemClipboard_setStringContents(
                _: &mut AzSystemClipboard,
                _: AzString,
            ) -> bool;
            pub(crate) fn AzSystemClipboard_delete(_: &mut AzSystemClipboard);
            pub(crate) fn AzSystemClipboard_deepCopy(_: &AzSystemClipboard) -> AzSystemClipboard;
            pub(crate) fn AzInstant_durationSince(_: &AzInstant, _: AzInstant) -> AzOptionDuration;
            pub(crate) fn AzInstant_addDuration(_: &mut AzInstant, _: AzDuration) -> AzInstant;
            pub(crate) fn AzInstant_linearInterpolate(
                _: &AzInstant,
                _: AzInstant,
                _: AzInstant,
            ) -> f32;
            pub(crate) fn AzInstantPtr_delete(_: &mut AzInstantPtr);
            pub(crate) fn AzInstantPtr_deepCopy(_: &AzInstantPtr) -> AzInstantPtr;
            pub(crate) fn AzTimer_new(
                _: AzRefAny,
                _: AzTimerCallbackType,
                _: AzGetSystemTimeFn,
            ) -> AzTimer;
            pub(crate) fn AzTimer_withDelay(_: &AzTimer, _: AzDuration) -> AzTimer;
            pub(crate) fn AzTimer_withInterval(_: &AzTimer, _: AzDuration) -> AzTimer;
            pub(crate) fn AzTimer_withTimeout(_: &AzTimer, _: AzDuration) -> AzTimer;
            pub(crate) fn AzThread_delete(_: &mut AzThread);
            pub(crate) fn AzThread_deepCopy(_: &AzThread) -> AzThread;
            pub(crate) fn AzThreadSender_send(
                _: &mut AzThreadSender,
                _: AzThreadReceiveMsg,
            ) -> bool;
            pub(crate) fn AzThreadSender_delete(_: &mut AzThreadSender);
            pub(crate) fn AzThreadSender_deepCopy(_: &AzThreadSender) -> AzThreadSender;
            pub(crate) fn AzThreadReceiver_receive(
                _: &mut AzThreadReceiver,
            ) -> AzOptionThreadSendMsg;
            pub(crate) fn AzThreadReceiver_delete(_: &mut AzThreadReceiver);
            pub(crate) fn AzThreadReceiver_deepCopy(_: &AzThreadReceiver) -> AzThreadReceiver;
            pub(crate) fn AzString_format(_: AzString, _: AzFmtArgVec) -> AzString;
            pub(crate) fn AzString_copyFromBytes(_: *const u8, _: usize, _: usize) -> AzString;
            pub(crate) fn AzString_trim(_: &AzString) -> AzString;
            pub(crate) fn AzString_asRefstr(_: &AzString) -> AzRefstr;
            pub(crate) fn AzListViewRowVec_delete(_: &mut AzListViewRowVec);
            pub(crate) fn AzStyleFilterVec_delete(_: &mut AzStyleFilterVec);
            pub(crate) fn AzLogicalRectVec_delete(_: &mut AzLogicalRectVec);
            pub(crate) fn AzNodeTypeIdInfoMapVec_delete(_: &mut AzNodeTypeIdInfoMapVec);
            pub(crate) fn AzInputOutputTypeIdInfoMapVec_delete(
                _: &mut AzInputOutputTypeIdInfoMapVec,
            );
            pub(crate) fn AzNodeIdNodeMapVec_delete(_: &mut AzNodeIdNodeMapVec);
            pub(crate) fn AzInputOutputTypeIdVec_delete(_: &mut AzInputOutputTypeIdVec);
            pub(crate) fn AzNodeTypeFieldVec_delete(_: &mut AzNodeTypeFieldVec);
            pub(crate) fn AzInputConnectionVec_delete(_: &mut AzInputConnectionVec);
            pub(crate) fn AzOutputNodeAndIndexVec_delete(_: &mut AzOutputNodeAndIndexVec);
            pub(crate) fn AzOutputConnectionVec_delete(_: &mut AzOutputConnectionVec);
            pub(crate) fn AzInputNodeAndIndexVec_delete(_: &mut AzInputNodeAndIndexVec);
            pub(crate) fn AzAccessibilityStateVec_delete(_: &mut AzAccessibilityStateVec);
            pub(crate) fn AzMenuItemVec_delete(_: &mut AzMenuItemVec);
            pub(crate) fn AzTessellatedSvgNodeVec_asRefVec(
                _: &AzTessellatedSvgNodeVec,
            ) -> AzTessellatedSvgNodeVecRef;
            pub(crate) fn AzTessellatedSvgNodeVec_delete(_: &mut AzTessellatedSvgNodeVec);
            pub(crate) fn AzTessellatedColoredSvgNodeVec_asRefVec(
                _: &AzTessellatedColoredSvgNodeVec,
            ) -> AzTessellatedColoredSvgNodeVecRef;
            pub(crate) fn AzTessellatedColoredSvgNodeVec_delete(
                _: &mut AzTessellatedColoredSvgNodeVec,
            );
            pub(crate) fn AzStyleFontFamilyVec_delete(_: &mut AzStyleFontFamilyVec);
            pub(crate) fn AzXmlNodeVec_delete(_: &mut AzXmlNodeVec);
            pub(crate) fn AzFmtArgVec_delete(_: &mut AzFmtArgVec);
            pub(crate) fn AzInlineLineVec_delete(_: &mut AzInlineLineVec);
            pub(crate) fn AzInlineWordVec_delete(_: &mut AzInlineWordVec);
            pub(crate) fn AzInlineGlyphVec_delete(_: &mut AzInlineGlyphVec);
            pub(crate) fn AzInlineTextHitVec_delete(_: &mut AzInlineTextHitVec);
            pub(crate) fn AzMonitorVec_delete(_: &mut AzMonitorVec);
            pub(crate) fn AzVideoModeVec_delete(_: &mut AzVideoModeVec);
            pub(crate) fn AzDomVec_delete(_: &mut AzDomVec);
            pub(crate) fn AzIdOrClassVec_delete(_: &mut AzIdOrClassVec);
            pub(crate) fn AzNodeDataInlineCssPropertyVec_delete(
                _: &mut AzNodeDataInlineCssPropertyVec,
            );
            pub(crate) fn AzStyleBackgroundContentVec_delete(_: &mut AzStyleBackgroundContentVec);
            pub(crate) fn AzStyleBackgroundPositionVec_delete(_: &mut AzStyleBackgroundPositionVec);
            pub(crate) fn AzStyleBackgroundRepeatVec_delete(_: &mut AzStyleBackgroundRepeatVec);
            pub(crate) fn AzStyleBackgroundSizeVec_delete(_: &mut AzStyleBackgroundSizeVec);
            pub(crate) fn AzStyleTransformVec_delete(_: &mut AzStyleTransformVec);
            pub(crate) fn AzCssPropertyVec_delete(_: &mut AzCssPropertyVec);
            pub(crate) fn AzSvgMultiPolygonVec_delete(_: &mut AzSvgMultiPolygonVec);
            pub(crate) fn AzSvgSimpleNodeVec_delete(_: &mut AzSvgSimpleNodeVec);
            pub(crate) fn AzSvgPathVec_delete(_: &mut AzSvgPathVec);
            pub(crate) fn AzVertexAttributeVec_delete(_: &mut AzVertexAttributeVec);
            pub(crate) fn AzSvgPathElementVec_delete(_: &mut AzSvgPathElementVec);
            pub(crate) fn AzSvgVertexVec_delete(_: &mut AzSvgVertexVec);
            pub(crate) fn AzSvgColoredVertexVec_delete(_: &mut AzSvgColoredVertexVec);
            pub(crate) fn AzU32Vec_delete(_: &mut AzU32Vec);
            pub(crate) fn AzXWindowTypeVec_delete(_: &mut AzXWindowTypeVec);
            pub(crate) fn AzVirtualKeyCodeVec_delete(_: &mut AzVirtualKeyCodeVec);
            pub(crate) fn AzCascadeInfoVec_delete(_: &mut AzCascadeInfoVec);
            pub(crate) fn AzScanCodeVec_delete(_: &mut AzScanCodeVec);
            pub(crate) fn AzCssDeclarationVec_delete(_: &mut AzCssDeclarationVec);
            pub(crate) fn AzCssPathSelectorVec_delete(_: &mut AzCssPathSelectorVec);
            pub(crate) fn AzStylesheetVec_delete(_: &mut AzStylesheetVec);
            pub(crate) fn AzCssRuleBlockVec_delete(_: &mut AzCssRuleBlockVec);
            pub(crate) fn AzU16Vec_delete(_: &mut AzU16Vec);
            pub(crate) fn AzF32Vec_delete(_: &mut AzF32Vec);
            pub(crate) fn AzU8Vec_copyFromBytes(_: *const u8, _: usize, _: usize) -> AzU8Vec;
            pub(crate) fn AzU8Vec_asRefVec(_: &AzU8Vec) -> AzU8VecRef;
            pub(crate) fn AzU8Vec_delete(_: &mut AzU8Vec);
            pub(crate) fn AzCallbackDataVec_delete(_: &mut AzCallbackDataVec);
            pub(crate) fn AzDebugMessageVec_delete(_: &mut AzDebugMessageVec);
            pub(crate) fn AzGLuintVec_delete(_: &mut AzGLuintVec);
            pub(crate) fn AzGLintVec_delete(_: &mut AzGLintVec);
            pub(crate) fn AzStringVec_delete(_: &mut AzStringVec);
            pub(crate) fn AzStringPairVec_delete(_: &mut AzStringPairVec);
            pub(crate) fn AzNormalizedLinearColorStopVec_delete(
                _: &mut AzNormalizedLinearColorStopVec,
            );
            pub(crate) fn AzNormalizedRadialColorStopVec_delete(
                _: &mut AzNormalizedRadialColorStopVec,
            );
            pub(crate) fn AzNodeIdVec_delete(_: &mut AzNodeIdVec);
            pub(crate) fn AzNodeHierarchyItemVec_delete(_: &mut AzNodeHierarchyItemVec);
            pub(crate) fn AzStyledNodeVec_delete(_: &mut AzStyledNodeVec);
            pub(crate) fn AzTagIdToNodeIdMappingVec_delete(_: &mut AzTagIdToNodeIdMappingVec);
            pub(crate) fn AzParentWithNodeDepthVec_delete(_: &mut AzParentWithNodeDepthVec);
            pub(crate) fn AzNodeDataVec_delete(_: &mut AzNodeDataVec);
        }
    }
}

pub mod app {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! `App` construction and configuration
    use core::ffi::c_void;

    /// Main application class

    #[doc(inline)]
    pub use crate::dll::AzApp as App;
    use crate::{
        callbacks::RefAny, dll::*, image::ImageRef, str::String, window::WindowCreateOptions,
    };
    impl App {
        /// Creates a new App instance from the given `AppConfig`
        pub fn new<_1: Into<RefAny>, _2: Into<AppConfig>>(data: _1, config: _2) -> Self {
            unsafe { crate::dll::AzApp_new(data.into(), config.into()) }
        }
        /// Spawn a new window on the screen when the app is run.
        pub fn add_window<_1: Into<WindowCreateOptions>>(&mut self, window: _1) {
            unsafe { crate::dll::AzApp_addWindow(self, window.into()) }
        }
        /// Adds a new image identified by an ID to the image cache
        pub fn add_image<_1: Into<String>, _2: Into<ImageRef>>(&mut self, id: _1, image: _2) {
            unsafe { crate::dll::AzApp_addImage(self, id.into(), image.into()) }
        }
        /// Returns a list of monitors - useful for setting the monitor that a window should spawn
        /// on.
        pub fn get_monitors(&self) -> crate::vec::MonitorVec {
            unsafe { crate::dll::AzApp_getMonitors(self) }
        }
        /// Runs the application. Due to platform restrictions (specifically `WinMain` on Windows),
        /// this function never returns.
        pub fn run<_1: Into<WindowCreateOptions>>(&self, window: _1) {
            unsafe { crate::dll::AzApp_run(self, window.into()) }
        }
    }

    impl Clone for App {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzApp_deepCopy(self) }
        }
    }
    impl Drop for App {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzApp_delete(self) }
            }
        }
    }
    /// Configuration for optional features, such as whether to enable logging or panic hooks

    #[doc(inline)]
    pub use crate::dll::AzAppConfig as AppConfig;
    impl AppConfig {
        /// Constructs a default `AppConfig`, uses the layout solver currently available
        pub fn new<_1: Into<LayoutSolver>>(layout_solver: _1) -> Self {
            unsafe { crate::dll::AzAppConfig_new(layout_solver.into()) }
        }
    }

    /// Configuration to set which messages should be logged.

    #[doc(inline)]
    pub use crate::dll::AzAppLogLevel as AppLogLevel;
    /// Version of the layout solver to use - future binary versions of azul may have more
    /// fields here, necessary so that old compiled applications don't break with newer
    /// releases of azul. Newer layout versions are opt-in only.

    #[doc(inline)]
    pub use crate::dll::AzLayoutSolver as LayoutSolver;
    /// External system callbacks to get the system time or create / manage threads

    #[doc(inline)]
    pub use crate::dll::AzSystemCallbacks as SystemCallbacks;
    impl SystemCallbacks {
        /// Use the default, library-internal callbacks instead of providing your own
        pub fn library_internal() -> Self {
            unsafe { crate::dll::AzSystemCallbacks_libraryInternal() }
        }
    }
}

pub mod window {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Window creation / startup configuration
    use core::ffi::c_void;

    use crate::dll::*;

    impl LayoutSize {
        #[inline(always)]
        pub const fn new(width: isize, height: isize) -> Self {
            Self { width, height }
        }
        #[inline(always)]
        pub const fn zero() -> Self {
            Self::new(0, 0)
        }
    }

    impl LayoutPoint {
        #[inline(always)]
        pub const fn new(x: isize, y: isize) -> Self {
            Self { x, y }
        }
        #[inline(always)]
        pub const fn zero() -> Self {
            Self::new(0, 0)
        }
    }

    impl LayoutRect {
        #[inline(always)]
        pub const fn new(origin: LayoutPoint, size: LayoutSize) -> Self {
            Self { origin, size }
        }
        #[inline(always)]
        pub const fn zero() -> Self {
            Self::new(LayoutPoint::zero(), LayoutSize::zero())
        }
        #[inline(always)]
        pub const fn max_x(&self) -> isize {
            self.origin.x + self.size.width
        }
        #[inline(always)]
        pub const fn min_x(&self) -> isize {
            self.origin.x
        }
        #[inline(always)]
        pub const fn max_y(&self) -> isize {
            self.origin.y + self.size.height
        }
        #[inline(always)]
        pub const fn min_y(&self) -> isize {
            self.origin.y
        }

        pub const fn contains(&self, other: &LayoutPoint) -> bool {
            self.min_x() <= other.x
                && other.x < self.max_x()
                && self.min_y() <= other.y
                && other.y < self.max_y()
        }

        pub fn contains_f32(&self, other_x: f32, other_y: f32) -> bool {
            self.min_x() as f32 <= other_x
                && other_x < self.max_x() as f32
                && self.min_y() as f32 <= other_y
                && other_y < self.max_y() as f32
        }

        /// Same as `contains()`, but returns the (x, y) offset of the hit point
        ///
        /// On a regular computer this function takes ~3.2ns to run
        #[inline]
        pub const fn hit_test(&self, other: &LayoutPoint) -> Option<LayoutPoint> {
            let dx_left_edge = other.x - self.min_x();
            let dx_right_edge = self.max_x() - other.x;
            let dy_top_edge = other.y - self.min_y();
            let dy_bottom_edge = self.max_y() - other.y;
            if dx_left_edge > 0 && dx_right_edge > 0 && dy_top_edge > 0 && dy_bottom_edge > 0 {
                Some(LayoutPoint::new(dx_left_edge, dy_top_edge))
            } else {
                None
            }
        }

        // Returns if b overlaps a
        #[inline(always)]
        pub const fn contains_rect(&self, b: &LayoutRect) -> bool {
            let a = self;

            let a_x = a.origin.x;
            let a_y = a.origin.y;
            let a_width = a.size.width;
            let a_height = a.size.height;

            let b_x = b.origin.x;
            let b_y = b.origin.y;
            let b_width = b.size.width;
            let b_height = b.size.height;

            b_x >= a_x
                && b_y >= a_y
                && b_x + b_width <= a_x + a_width
                && b_y + b_height <= a_y + a_height
        }
    }
    use crate::callbacks::LayoutCallbackType;
    /// Options on how to initially create the window

    #[doc(inline)]
    pub use crate::dll::AzWindowCreateOptions as WindowCreateOptions;
    impl WindowCreateOptions {
        /// Creates a new window configuration with a custom layout callback
        pub fn new(layout_callback: LayoutCallbackType) -> Self {
            unsafe { crate::dll::AzWindowCreateOptions_new(layout_callback) }
        }
    }

    /// `AndroidHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzAndroidHandle as AndroidHandle;
    /// Does the renderer render using hardware acceleration? By default, azul tries to set it
    /// to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized
    /// properly

    #[doc(inline)]
    pub use crate::dll::AzHwAcceleration as HwAcceleration;
    /// `IOSHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzIOSHandle as IOSHandle;
    /// Offset in physical pixels (integer units)

    #[doc(inline)]
    pub use crate::dll::AzLayoutPoint as LayoutPoint;
    /// Represents a rectangle in physical pixels (integer units)

    #[doc(inline)]
    pub use crate::dll::AzLayoutRect as LayoutRect;
    /// Size in physical pixels (integer units)

    #[doc(inline)]
    pub use crate::dll::AzLayoutSize as LayoutSize;
    /// Logical position (can differ based on HiDPI settings). Usually this is what you'd want
    /// for hit-testing and positioning elements.

    #[doc(inline)]
    pub use crate::dll::AzLogicalPosition as LogicalPosition;
    /// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd
    /// want for hit-testing and positioning elements.

    #[doc(inline)]
    pub use crate::dll::AzLogicalRect as LogicalRect;
    /// `MacOSHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzMacOSHandle as MacOSHandle;
    /// Same as `LayoutPoint`, but uses `i32` instead of `isize`

    #[doc(inline)]
    pub use crate::dll::AzPhysicalPositionI32 as PhysicalPositionI32;
    /// Same as `LayoutPoint`, but uses `u32` instead of `isize`

    #[doc(inline)]
    pub use crate::dll::AzPhysicalSizeU32 as PhysicalSizeU32;
    /// Raw platform handle, for integration in / with other toolkits and custom non-azul
    /// window extensions

    #[doc(inline)]
    pub use crate::dll::AzRawWindowHandle as RawWindowHandle;
    /// Force a specific renderer: note that azul will **crash** on startup if the
    /// `RendererOptions` are not satisfied.

    #[doc(inline)]
    pub use crate::dll::AzRendererOptions as RendererOptions;
    /// Does the renderer render in SRGB color space? By default, azul tries to set it to
    /// `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized
    /// properly

    #[doc(inline)]
    pub use crate::dll::AzSrgb as Srgb;
    /// Whether the renderer has VSync enabled

    #[doc(inline)]
    pub use crate::dll::AzVsync as Vsync;
    /// `WaylandHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzWaylandHandle as WaylandHandle;
    /// `WebHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzWebHandle as WebHandle;
    /// `WindowsHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzWindowsHandle as WindowsHandle;
    /// X11 window hint: Type of window

    #[doc(inline)]
    pub use crate::dll::AzXWindowType as XWindowType;
    /// `XcbHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzXcbHandle as XcbHandle;
    /// `XlibHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzXlibHandle as XlibHandle;
    impl LogicalPosition {
        /// Creates a new `LogicalPosition` instance.
        pub fn new(x: f32, y: f32) -> Self {
            unsafe { crate::dll::AzLogicalPosition_new(x, y) }
        }
        /// Creates a new `LogicalPosition` instance.
        pub fn zero() -> Self {
            unsafe { crate::dll::AzLogicalPosition_zero() }
        }
    }

    /// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units

    #[doc(inline)]
    pub use crate::dll::AzLogicalSize as LogicalSize;
    impl LogicalSize {
        /// Calls the `LogicalSize::to_physical` function.
        pub fn to_physical(&self, hidpi_factor: f32) -> crate::window::PhysicalSizeU32 {
            unsafe { crate::dll::AzLogicalSize_toPhysical(self, hidpi_factor) }
        }
    }

    /// Symbolic accelerator key (ctrl, alt, shift)

    #[doc(inline)]
    pub use crate::dll::AzAcceleratorKey as AcceleratorKey;
    /// Unique hash of a window icon, so that azul does not have to compare the actual bytes to
    /// see wether the window icon has changed.

    #[doc(inline)]
    pub use crate::dll::AzIconKey as IconKey;
    /// Large (32x32x4) window icon, usually used on high-resolution displays (instead of
    /// `SmallWindowIcon`)

    #[doc(inline)]
    pub use crate::dll::AzLargeWindowIconBytes as LargeWindowIconBytes;
    /// Small (16x16x4) window icon, usually shown in the window titlebar

    #[doc(inline)]
    pub use crate::dll::AzSmallWindowIconBytes as SmallWindowIconBytes;
    /// Application taskbar icon, 256x256x4 bytes in size

    #[doc(inline)]
    pub use crate::dll::AzTaskBarIcon as TaskBarIcon;
    /// Symbolic name for a keyboard key, does **not** take the keyboard locale into account

    #[doc(inline)]
    pub use crate::dll::AzVirtualKeyCode as VirtualKeyCode;
    /// Window "favicon", usually shown in the top left of the window on Windows

    #[doc(inline)]
    pub use crate::dll::AzWindowIcon as WindowIcon;
    /// Minimum / maximum / current size of the window in logical dimensions

    #[doc(inline)]
    pub use crate::dll::AzWindowSize as WindowSize;
    impl WindowSize {
        /// Returns the hidpi factor of the bounds
        pub fn get_hidpi_factor(&self) -> f32 {
            unsafe { crate::dll::AzWindowSize_getHidpiFactor(self) }
        }
    }

    /// Debugging information, will be rendered as an overlay on top of the UI

    #[doc(inline)]
    pub use crate::dll::AzDebugState as DebugState;
    /// Current keyboard state, stores what keys / characters have been pressed

    #[doc(inline)]
    pub use crate::dll::AzKeyboardState as KeyboardState;
    /// Boolean flags relating to the current window state

    #[doc(inline)]
    pub use crate::dll::AzWindowFlags as WindowFlags;
    /// State of the window frame (minimized, maximized, fullscreen or normal window)

    #[doc(inline)]
    pub use crate::dll::AzWindowFrame as WindowFrame;
    impl KeyboardState {
        /// Returns if the `SHIFT` key is held down (left OR right shift)
        pub fn shift_down(&self) -> bool {
            unsafe { crate::dll::AzKeyboardState_shiftDown(self) }
        }
        /// Returns if the `CTRL` key is held down
        pub fn ctrl_down(&self) -> bool {
            unsafe { crate::dll::AzKeyboardState_ctrlDown(self) }
        }
        /// Returns if the `ALT` key is held down
        pub fn alt_down(&self) -> bool {
            unsafe { crate::dll::AzKeyboardState_altDown(self) }
        }
        /// Returns if the `SUPER` ("Windows") key is held down
        pub fn super_down(&self) -> bool {
            unsafe { crate::dll::AzKeyboardState_superDown(self) }
        }
        /// Returns if a key is held down
        pub fn is_key_down<_1: Into<VirtualKeyCode>>(&self, key: _1) -> bool {
            unsafe { crate::dll::AzKeyboardState_isKeyDown(self, key.into()) }
        }
    }

    /// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on
    /// startup (gets initialized on the first frame).

    #[doc(inline)]
    pub use crate::dll::AzCursorPosition as CursorPosition;
    /// Current icon of the mouse cursor

    #[doc(inline)]
    pub use crate::dll::AzMouseCursorType as MouseCursorType;
    impl CursorPosition {
        /// Calls the `CursorPosition::get_position` function.
        pub fn get_position(&self) -> crate::option::OptionLogicalPosition {
            unsafe { crate::dll::AzCursorPosition_getPosition(self) }
        }
    }

    /// `FullScreenMode` struct

    #[doc(inline)]
    pub use crate::dll::AzFullScreenMode as FullScreenMode;
    /// Position of the virtual keyboard necessary to insert CJK characters

    #[doc(inline)]
    pub use crate::dll::AzImePosition as ImePosition;
    /// `LinuxWindowOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzLinuxWindowOptions as LinuxWindowOptions;
    /// `MacWindowOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzMacWindowOptions as MacWindowOptions;
    /// Information about a single (or many) monitors, useful for dock widgets

    #[doc(inline)]
    pub use crate::dll::AzMonitor as Monitor;
    /// Current mouse / cursor state

    #[doc(inline)]
    pub use crate::dll::AzMouseState as MouseState;
    /// Platform-specific window configuration, i.e. WM options that are not cross-platform

    #[doc(inline)]
    pub use crate::dll::AzPlatformSpecificOptions as PlatformSpecificOptions;
    /// Renderer type of the current windows OpenGL context

    #[doc(inline)]
    pub use crate::dll::AzRendererType as RendererType;
    /// Key-value pair, used for setting WM hints values specific to GNOME

    #[doc(inline)]
    pub use crate::dll::AzStringPair as StringPair;
    /// Current state of touch devices / touch inputs

    #[doc(inline)]
    pub use crate::dll::AzTouchState as TouchState;
    /// Describes a rendering configuration for a monitor

    #[doc(inline)]
    pub use crate::dll::AzVideoMode as VideoMode;
    /// `WasmWindowOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzWasmWindowOptions as WasmWindowOptions;
    /// CSD theme of the window title / button controls

    #[doc(inline)]
    pub use crate::dll::AzWaylandTheme as WaylandTheme;
    /// Position of the top left corner of the window relative to the top left of the monitor

    #[doc(inline)]
    pub use crate::dll::AzWindowPosition as WindowPosition;
    /// `WindowState` struct

    #[doc(inline)]
    pub use crate::dll::AzWindowState as WindowState;
    /// Window theme, set by the operating system or `WindowCreateOptions.theme` on startup

    #[doc(inline)]
    pub use crate::dll::AzWindowTheme as WindowTheme;
    /// Window configuration specific to Win32

    #[doc(inline)]
    pub use crate::dll::AzWindowsWindowOptions as WindowsWindowOptions;
    impl WindowState {
        /// Creates a new WindowState with default settings and a custom layout callback
        pub fn new(layout_callback: LayoutCallbackType) -> Self {
            unsafe { crate::dll::AzWindowState_new(layout_callback) }
        }
        /// Creates a default WindowState with an empty layout callback - useful only if you use the
        /// Rust `WindowState { .. WindowState::default() }` intialization syntax.
        pub fn default() -> Self {
            unsafe { crate::dll::AzWindowState_default() }
        }
    }
}

pub mod callbacks {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Callback type definitions + struct definitions of `CallbackInfo`s
    use core::ffi::c_void;

    use crate::dll::*;

    static NULL_REF: [u8; 0] = [];

    #[derive(Debug)]
    #[repr(C)]
    pub struct Ref<'a, T> {
        ptr: &'a T,
        sharing_info: RefCount,
    }

    impl<'a, T> Drop for Ref<'a, T> {
        fn drop(&mut self) {
            self.sharing_info.decrease_ref();
        }
    }

    impl<'a, T> core::ops::Deref for Ref<'a, T> {
        type Target = T;

        fn deref(&self) -> &Self::Target {
            self.ptr
        }
    }

    #[derive(Debug)]
    #[repr(C)]
    pub struct RefMut<'a, T> {
        ptr: &'a mut T,
        sharing_info: RefCount,
    }

    impl<'a, T> Drop for RefMut<'a, T> {
        fn drop(&mut self) {
            self.sharing_info.decrease_refmut();
        }
    }

    impl<'a, T> core::ops::Deref for RefMut<'a, T> {
        type Target = T;

        fn deref(&self) -> &Self::Target {
            &*self.ptr
        }
    }

    impl<'a, T> core::ops::DerefMut for RefMut<'a, T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            self.ptr
        }
    }

    impl RefAny {
        /// Creates a new, type-erased pointer by casting the `T` value into a `Vec<u8>` and saving
        /// the length + type ID
        pub fn new<T: 'static>(value: T) -> Self {
            use crate::dll::*;

            extern "C" fn default_custom_destructor<U: 'static>(ptr: &mut c_void) {
                use core::{mem, ptr};

                // note: in the default constructor, we do not need to check whether U == T

                unsafe {
                    // copy the struct from the heap to the stack and
                    // call mem::drop on U to run the destructor
                    let mut stack_mem = mem::MaybeUninit::<U>::uninit();
                    ptr::copy_nonoverlapping(
                        (ptr as *mut c_void) as *const U,
                        stack_mem.as_mut_ptr(),
                        mem::size_of::<U>(),
                    );
                    let stack_mem = stack_mem.assume_init();
                    mem::drop(stack_mem);
                }
            }

            let type_name_str = ::core::any::type_name::<T>();
            let st = crate::str::String::from_const_str(type_name_str);
            let s = unsafe {
                crate::dll::AzRefAny_newC(
                    (&value as *const T) as *const c_void,
                    ::core::mem::size_of::<T>(),
                    Self::type_id::<T>(),
                    st,
                    default_custom_destructor::<T>,
                )
            };
            ::core::mem::forget(value); // do not run the destructor of T here!
            s
        }

        /// Downcasts the type-erased pointer to a type `&U`, returns `None` if the types don't
        /// match
        #[inline]
        pub fn downcast_ref<'a, U: 'static>(&'a mut self) -> Option<Ref<'a, U>> {
            let is_same_type = self.get_type_id() == Self::type_id::<U>();
            if !is_same_type {
                return None;
            }

            let can_be_shared = self.sharing_info.can_be_shared();
            if !can_be_shared {
                return None;
            }

            self.sharing_info.increase_ref();
            Some(Ref {
                ptr: unsafe {
                    &*(if self._internal_ptr.is_null() {
                        NULL_REF.as_ptr() as *const U
                    } else {
                        self._internal_ptr as *const U
                    })
                },
                sharing_info: self.sharing_info.clone(),
            })
        }

        /// Downcasts the type-erased pointer to a type `&mut U`, returns `None` if the types don't
        /// match
        #[inline]
        pub fn downcast_mut<'a, U: 'static>(&'a mut self) -> Option<RefMut<'a, U>> {
            let is_same_type = self.get_type_id() == Self::type_id::<U>();
            if !is_same_type {
                return None;
            }

            let can_be_shared_mut = self.sharing_info.can_be_shared_mut();
            if !can_be_shared_mut {
                return None;
            }

            // zero-sized structs cannot be mutated
            if self._internal_ptr.is_null() {
                return None;
            }

            self.sharing_info.increase_refmut();

            Some(RefMut {
                ptr: unsafe { &mut *(self._internal_ptr as *mut U) },
                sharing_info: self.sharing_info.clone(),
            })
        }

        // Returns the typeid of `T` as a u64 (necessary because `core::any::TypeId` is not C-ABI
        // compatible)
        #[inline]
        pub fn type_id<T: 'static>() -> u64 {
            use core::{any::TypeId, mem};

            // fast method to serialize the type id into a u64
            let t_id = TypeId::of::<T>();
            let struct_as_bytes = unsafe {
                ::core::slice::from_raw_parts(
                    (&t_id as *const TypeId) as *const u8,
                    mem::size_of::<TypeId>(),
                )
            };
            struct_as_bytes
                .into_iter()
                .enumerate()
                .map(|(s_pos, s)| ((*s as u64) << s_pos))
                .sum()
        }
    }
    /// C-ABI stable wrapper over a `CallbackType`

    #[doc(inline)]
    pub use crate::dll::AzCallback as Callback;
    /// `CallbackInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzCallbackInfo as CallbackInfo;
    /// Generic UI callback function pointer: called when the `EventFilter` is active

    #[doc(inline)]
    pub use crate::dll::AzCallbackType as CallbackType;
    /// `LayoutCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutCallback as LayoutCallback;
    /// C-ABI stable wrapper over a `LayoutCallbackType`

    #[doc(inline)]
    pub use crate::dll::AzLayoutCallbackInner as LayoutCallbackInner;
    /// Main callback to layout the UI. azul will only call this callback when necessary
    /// (usually when one of the callback or timer returns
    /// `RegenerateStyledDomForCurrentWindow`), however azul may also call this callback at any
    /// given time, so it should be performant. This is the main entry point for your app UI.

    #[doc(inline)]
    pub use crate::dll::AzLayoutCallbackType as LayoutCallbackType;
    /// C-ABI stable wrapper over a `MarshaledLayoutCallback`

    #[doc(inline)]
    pub use crate::dll::AzMarshaledLayoutCallback as MarshaledLayoutCallback;
    /// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`

    #[doc(inline)]
    pub use crate::dll::AzMarshaledLayoutCallbackInner as MarshaledLayoutCallbackInner;
    /// Marshaled version of LayoutCallback, carrys an extra "marshal_data" containing the
    /// (usually external) function object

    #[doc(inline)]
    pub use crate::dll::AzMarshaledLayoutCallbackType as MarshaledLayoutCallbackType;
    use crate::{
        css::{CssProperty, CssPropertyType},
        image::{ImageMask, ImageRef},
        str::String,
        task::{ThreadId, ThreadSendMsg, Timer, TimerId},
        window::{LogicalPosition, WindowCreateOptions, WindowState},
    };
    impl CallbackInfo {
        /// Returns the `DomNodeId` of the element that the callback was attached to.
        pub fn get_hit_node(&self) -> crate::callbacks::DomNodeId {
            unsafe { crate::dll::AzCallbackInfo_getHitNode(self) }
        }
        /// Returns the function pointer necessary to query the current time.
        pub fn get_system_time_fn(&self) -> crate::task::GetSystemTimeFn {
            unsafe { crate::dll::AzCallbackInfo_getSystemTimeFn(self) }
        }
        /// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the
        /// `Dom`). Set to `None` if the cursor is not in the current window.
        pub fn get_cursor_relative_to_viewport(&self) -> crate::option::OptionLogicalPosition {
            unsafe { crate::dll::AzCallbackInfo_getCursorRelativeToViewport(self) }
        }
        /// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the
        /// `Dom`). Set to `None` if the cursor is not hovering over the current node.
        pub fn get_cursor_relative_to_node(&self) -> crate::option::OptionLogicalPosition {
            unsafe { crate::dll::AzCallbackInfo_getCursorRelativeToNode(self) }
        }
        /// Returns a copy of the current windows `WindowState`.
        pub fn get_current_window_state(&self) -> crate::window::WindowState {
            unsafe { crate::dll::AzCallbackInfo_getCurrentWindowState(self) }
        }
        /// Returns a copy of the internal `KeyboardState`. Same as
        /// `self.get_window_state().keyboard_state`
        pub fn get_current_keyboard_state(&self) -> crate::window::KeyboardState {
            unsafe { crate::dll::AzCallbackInfo_getCurrentKeyboardState(self) }
        }
        /// Returns a copy of the internal `MouseState`. Same as
        /// `self.get_window_state().mouse_state`
        pub fn get_current_mouse_state(&self) -> crate::window::MouseState {
            unsafe { crate::dll::AzCallbackInfo_getCurrentMouseState(self) }
        }
        /// Returns a copy of the current windows `WindowState`.
        pub fn get_previous_window_state(&self) -> crate::option::OptionWindowState {
            unsafe { crate::dll::AzCallbackInfo_getPreviousWindowState(self) }
        }
        /// Returns a copy of the internal `KeyboardState`. Same as
        /// `self.get_window_state().keyboard_state`
        pub fn get_previous_keyboard_state(&self) -> crate::option::OptionKeyboardState {
            unsafe { crate::dll::AzCallbackInfo_getPreviousKeyboardState(self) }
        }
        /// Returns a copy of the internal `MouseState`. Same as
        /// `self.get_window_state().mouse_state`
        pub fn get_previous_mouse_state(&self) -> crate::option::OptionMouseState {
            unsafe { crate::dll::AzCallbackInfo_getPreviousMouseState(self) }
        }
        /// Returns a copy of the current windows `RawWindowHandle`.
        pub fn get_current_window_handle(&self) -> crate::window::RawWindowHandle {
            unsafe { crate::dll::AzCallbackInfo_getCurrentWindowHandle(self) }
        }
        /// Returns a **reference-counted copy** of the current windows' `Gl` (context). You can use
        /// this to render OpenGL textures.
        pub fn get_gl_context(&self) -> crate::option::OptionGl {
            unsafe { crate::dll::AzCallbackInfo_getGlContext(self) }
        }
        /// Returns the x / y offset that this node has been scrolled to by the user or `None` if
        /// the node has not been scrolled.
        pub fn get_scroll_position<_1: Into<DomNodeId>>(
            &self,
            node_id: _1,
        ) -> crate::option::OptionLogicalPosition {
            unsafe { crate::dll::AzCallbackInfo_getScrollPosition(self, node_id.into()) }
        }
        /// Returns the `dataset` property of the given Node or `None` if the node doesn't have a
        /// `dataset` property.
        pub fn get_dataset<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionRefAny {
            unsafe { crate::dll::AzCallbackInfo_getDataset(self, node_id.into()) }
        }
        /// Given a dataset, returns the node ID of the "root" `RefAny`, i.e. the `RefAny` with the
        /// lowest `instance` count that is set as a `dataset` on any node.
        pub fn get_node_id_of_root_dataset<_1: Into<RefAny>>(
            &mut self,
            dataset: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzCallbackInfo_getNodeIdOfRootDataset(self, dataset.into()) }
        }
        /// If the node is a `Text` node, returns a copy of the internal string contents.
        pub fn get_string_contents<_1: Into<DomNodeId>>(
            &self,
            node_id: _1,
        ) -> crate::option::OptionString {
            unsafe { crate::dll::AzCallbackInfo_getStringContents(self, node_id.into()) }
        }
        /// If the node is a `Text` node, returns the layouted inline glyphs of the text currently
        /// rendered on the screen
        pub fn get_inline_text<_1: Into<DomNodeId>>(
            &self,
            node_id: _1,
        ) -> crate::option::OptionInlineText {
            unsafe { crate::dll::AzCallbackInfo_getInlineText(self, node_id.into()) }
        }
        /// If the node is a `Text` node, returns the `FontRef` that was used to render this node.
        /// Useful for getting font metrics for a text string
        pub fn get_font_ref<_1: Into<DomNodeId>>(
            &self,
            node_id: _1,
        ) -> crate::option::OptionFontRef {
            unsafe { crate::dll::AzCallbackInfo_getFontRef(self, node_id.into()) }
        }
        /// Calls the `CallbackInfo::get_text_layout_options` function.
        pub fn get_text_layout_options<_1: Into<DomNodeId>>(
            &self,
            node_id: _1,
        ) -> crate::option::OptionResolvedTextLayoutOptions {
            unsafe { crate::dll::AzCallbackInfo_getTextLayoutOptions(self, node_id.into()) }
        }
        /// Similar to `get_inline_text()`: If the node is a `Text` node, shape the `text` string
        /// with the same parameters as the current text and return the calculated InlineTextLayout.
        /// Necessary to calculate text cursor offsets and to detect when a line overflows content.
        pub fn shape_text<_1: Into<DomNodeId>, _2: Into<String>>(
            &self,
            node_id: _1,
            text: _2,
        ) -> crate::option::OptionInlineText {
            unsafe { crate::dll::AzCallbackInfo_shapeText(self, node_id.into(), text.into()) }
        }
        /// Returns the index of the node relative to the parent node.
        pub fn get_index_in_parent<_1: Into<DomNodeId>>(&mut self, node_id: _1) -> usize {
            unsafe { crate::dll::AzCallbackInfo_getIndexInParent(self, node_id.into()) }
        }
        /// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid
        /// NodeId.
        pub fn get_parent<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzCallbackInfo_getParent(self, node_id.into()) }
        }
        /// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_previous_sibling<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzCallbackInfo_getPreviousSibling(self, node_id.into()) }
        }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_next_sibling<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzCallbackInfo_getNextSibling(self, node_id.into()) }
        }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_first_child<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzCallbackInfo_getFirstChild(self, node_id.into()) }
        }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_last_child<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzCallbackInfo_getLastChild(self, node_id.into()) }
        }
        /// Returns the position of a given DOM node in the UI
        pub fn get_node_position<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionPositionInfo {
            unsafe { crate::dll::AzCallbackInfo_getNodePosition(self, node_id.into()) }
        }
        /// Returns the size of a given DOM node in the UI
        pub fn get_node_size<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionLogicalSize {
            unsafe { crate::dll::AzCallbackInfo_getNodeSize(self, node_id.into()) }
        }
        /// Returns the current computed CSS property of a given DOM node in the UI
        pub fn get_computed_css_property<_1: Into<DomNodeId>, _2: Into<CssPropertyType>>(
            &mut self,
            node_id: _1,
            property_type: _2,
        ) -> crate::option::OptionCssProperty {
            unsafe {
                crate::dll::AzCallbackInfo_getComputedCssProperty(
                    self,
                    node_id.into(),
                    property_type.into(),
                )
            }
        }
        /// Sets the new `WindowState` for the next frame. The window is updated after all callbacks
        /// are run.
        pub fn set_window_state<_1: Into<WindowState>>(&mut self, new_state: _1) {
            unsafe { crate::dll::AzCallbackInfo_setWindowState(self, new_state.into()) }
        }
        /// Sets the new `FocusTarget` for the next frame. Note that this will emit a
        /// `On::FocusLost` and `On::FocusReceived` event, if the focused node has changed.
        pub fn set_focus<_1: Into<FocusTarget>>(&mut self, target: _1) {
            unsafe { crate::dll::AzCallbackInfo_setFocus(self, target.into()) }
        }
        /// Sets a `CssProperty` on a given node to its new value. If this property change affects
        /// the layout, this will automatically trigger a relayout and redraw of the screen.
        pub fn set_css_property<_1: Into<DomNodeId>, _2: Into<CssProperty>>(
            &mut self,
            node_id: _1,
            new_property: _2,
        ) {
            unsafe {
                crate::dll::AzCallbackInfo_setCssProperty(self, node_id.into(), new_property.into())
            }
        }
        /// Sets the scroll position of the node
        pub fn set_scroll_position<_1: Into<DomNodeId>, _2: Into<LogicalPosition>>(
            &mut self,
            node_id: _1,
            scroll_position: _2,
        ) {
            unsafe {
                crate::dll::AzCallbackInfo_setScrollPosition(
                    self,
                    node_id.into(),
                    scroll_position.into(),
                )
            }
        }
        /// If the node is a `Text` node, overwrites the `Text` content with the new string, without
        /// requiring the entire UI to be rebuilt.
        pub fn set_string_contents<_1: Into<DomNodeId>, _2: Into<String>>(
            &mut self,
            node_id: _1,
            string: _2,
        ) {
            unsafe {
                crate::dll::AzCallbackInfo_setStringContents(self, node_id.into(), string.into())
            }
        }
        /// Adds a new image identified by an ID to the image cache
        pub fn add_image<_1: Into<String>, _2: Into<ImageRef>>(&mut self, id: _1, image: _2) {
            unsafe { crate::dll::AzCallbackInfo_addImage(self, id.into(), image.into()) }
        }
        /// Returns whether an image with a given CSS ID already exists
        pub fn has_image<_1: Into<String>>(&self, id: _1) -> bool {
            unsafe { crate::dll::AzCallbackInfo_hasImage(self, id.into()) }
        }
        /// Returns the image with a given CSS ID
        pub fn get_image<_1: Into<String>>(&self, id: _1) -> crate::option::OptionImageRef {
            unsafe { crate::dll::AzCallbackInfo_getImage(self, id.into()) }
        }
        /// If the node is an `Image`, exchanges the current image with a new source
        pub fn update_image<_1: Into<DomNodeId>, _2: Into<ImageRef>, _3: Into<UpdateImageType>>(
            &mut self,
            node_id: _1,
            new_image: _2,
            image_type: _3,
        ) {
            unsafe {
                crate::dll::AzCallbackInfo_updateImage(
                    self,
                    node_id.into(),
                    new_image.into(),
                    image_type.into(),
                )
            }
        }
        /// Deletes an image identified by a CSS ID from the image cache
        pub fn delete_image<_1: Into<String>>(&mut self, id: _1) {
            unsafe { crate::dll::AzCallbackInfo_deleteImage(self, id.into()) }
        }
        /// If the node has an `ImageMask`, exchanges the current mask for the new mask
        pub fn update_image_mask<_1: Into<DomNodeId>, _2: Into<ImageMask>>(
            &mut self,
            node_id: _1,
            new_mask: _2,
        ) {
            unsafe {
                crate::dll::AzCallbackInfo_updateImageMask(self, node_id.into(), new_mask.into())
            }
        }
        /// Stops the propagation of the current callback event type to the parent. Events are
        /// bubbled from the inside out (children first, then parents), this event stops the
        /// propagation of the event to the parent.
        pub fn stop_propagation(&mut self) {
            unsafe { crate::dll::AzCallbackInfo_stopPropagation(self) }
        }
        /// Spawns a new window with the given `WindowCreateOptions`.
        pub fn create_window<_1: Into<WindowCreateOptions>>(&mut self, new_window: _1) {
            unsafe { crate::dll::AzCallbackInfo_createWindow(self, new_window.into()) }
        }
        /// Adds a new `Timer` to the runtime. See the documentation for `Timer` for more
        /// information.
        pub fn start_timer<_1: Into<Timer>>(&mut self, timer: _1) -> crate::task::TimerId {
            unsafe { crate::dll::AzCallbackInfo_startTimer(self, timer.into()) }
        }
        /// Starts an animation timer on a give NodeId - same as a `Timer`, but uses a
        /// pre-configured interpolation function to drive the animation timer
        pub fn start_animation<_1: Into<DomNodeId>, _2: Into<Animation>>(
            &mut self,
            node: _1,
            animation: _2,
        ) -> crate::option::OptionTimerId {
            unsafe {
                crate::dll::AzCallbackInfo_startAnimation(self, node.into(), animation.into())
            }
        }
        /// Stops / cancels a `Timer`. See the documentation for `Timer` for more information.
        pub fn stop_timer<_1: Into<TimerId>>(&mut self, timer_id: _1) -> bool {
            unsafe { crate::dll::AzCallbackInfo_stopTimer(self, timer_id.into()) }
        }
        /// Starts a new `Thread` to the runtime. See the documentation for `Thread` for more
        /// information.
        pub fn start_thread<_1: Into<RefAny>, _2: Into<RefAny>>(
            &mut self,
            thread_initialize_data: _1,
            writeback_data: _2,
            callback: ThreadCallbackType,
        ) -> crate::option::OptionThreadId {
            unsafe {
                crate::dll::AzCallbackInfo_startThread(
                    self,
                    thread_initialize_data.into(),
                    writeback_data.into(),
                    callback,
                )
            }
        }
        /// Sends a message to a background thread
        pub fn send_thread_msg<_1: Into<ThreadId>, _2: Into<ThreadSendMsg>>(
            &mut self,
            thread_id: _1,
            msg: _2,
        ) -> bool {
            unsafe { crate::dll::AzCallbackInfo_sendThreadMsg(self, thread_id.into(), msg.into()) }
        }
        /// Stops a thread at the nearest possible opportunity. Sends a
        /// `ThreadSendMsg::TerminateThread` message to the thread and joins the thread.
        pub fn stop_thread<_1: Into<ThreadId>>(&mut self, thread_id: _1) -> bool {
            unsafe { crate::dll::AzCallbackInfo_stopThread(self, thread_id.into()) }
        }
    }

    /// ID of a DOM - one window can contain multiple, nested DOMs (such as iframes)

    #[doc(inline)]
    pub use crate::dll::AzDomId as DomId;
    /// Combination of node ID + DOM ID, both together can identify a node

    #[doc(inline)]
    pub use crate::dll::AzDomNodeId as DomNodeId;
    /// Index of a Node in the internal `NodeDataContainer`

    #[doc(inline)]
    pub use crate::dll::AzNodeId as NodeId;
    /// `PositionInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzPositionInfo as PositionInfo;
    /// Specifies if the screen should be updated after the callback function has returned

    #[doc(inline)]
    pub use crate::dll::AzUpdate as Update;
    /// Which type of image should be updated: background image (the CSS background) or content
    /// image (the <img src=""> content)

    #[doc(inline)]
    pub use crate::dll::AzUpdateImageType as UpdateImageType;
    impl PositionInfo {
        /// Calls the `PositionInfo::is_positioned` function.
        pub fn is_positioned(&self) -> bool {
            unsafe { crate::dll::AzPositionInfo_isPositioned(self) }
        }
        /// Calls the `PositionInfo::get_static_offset` function.
        pub fn get_static_offset(&self) -> crate::window::LogicalPosition {
            unsafe { crate::dll::AzPositionInfo_getStaticOffset(self) }
        }
        /// Calls the `PositionInfo::get_relative_offset` function.
        pub fn get_relative_offset(&self) -> crate::window::LogicalPosition {
            unsafe { crate::dll::AzPositionInfo_getRelativeOffset(self) }
        }
    }

    /// `HidpiAdjustedBounds` struct

    #[doc(inline)]
    pub use crate::dll::AzHidpiAdjustedBounds as HidpiAdjustedBounds;
    /// `PositionInfoInner` struct

    #[doc(inline)]
    pub use crate::dll::AzPositionInfoInner as PositionInfoInner;
    impl HidpiAdjustedBounds {
        /// Returns the size of the bounds in logical units
        pub fn get_logical_size(&self) -> crate::window::LogicalSize {
            unsafe { crate::dll::AzHidpiAdjustedBounds_getLogicalSize(self) }
        }
        /// Returns the size of the bounds in physical units
        pub fn get_physical_size(&self) -> crate::window::PhysicalSizeU32 {
            unsafe { crate::dll::AzHidpiAdjustedBounds_getPhysicalSize(self) }
        }
        /// Returns the hidpi factor of the bounds
        pub fn get_hidpi_factor(&self) -> f32 {
            unsafe { crate::dll::AzHidpiAdjustedBounds_getHidpiFactor(self) }
        }
    }

    /// `InlineText` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineText as InlineText;
    impl InlineText {
        /// Hit-tests the inline text, returns detailed information about which glyph / word / line,
        /// etc. the position (usually the mouse cursor) is currently over. Result may be empty (no
        /// hits) or contain more than one result (cursor is hovering over multiple overlapping
        /// glyphs at once).
        pub fn hit_test<_1: Into<LogicalPosition>>(
            &self,
            position: _1,
        ) -> crate::vec::InlineTextHitVec {
            unsafe { crate::dll::AzInlineText_hitTest(self, position.into()) }
        }
    }

    /// Defines the keyboard input focus target

    #[doc(inline)]
    pub use crate::dll::AzFocusTarget as FocusTarget;
    /// CSS path to set the keyboard input focus

    #[doc(inline)]
    pub use crate::dll::AzFocusTargetPath as FocusTargetPath;
    /// `InlineGlyph` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineGlyph as InlineGlyph;
    /// `InlineLine` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineLine as InlineLine;
    /// `InlineTextContents` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineTextContents as InlineTextContents;
    /// `InlineTextHit` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineTextHit as InlineTextHit;
    /// `InlineWord` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineWord as InlineWord;
    /// `ResolvedTextLayoutOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzResolvedTextLayoutOptions as ResolvedTextLayoutOptions;
    /// `ScriptType` struct

    #[doc(inline)]
    pub use crate::dll::AzScriptType as ScriptType;
    impl ResolvedTextLayoutOptions {
        /// Creates a new `ResolvedTextLayoutOptions` instance.
        pub fn default() -> Self {
            unsafe { crate::dll::AzResolvedTextLayoutOptions_default() }
        }
    }

    /// Animation struct to start a new animation

    #[doc(inline)]
    pub use crate::dll::AzAnimation as Animation;
    /// Easing function of the animation (ease-in, ease-out, ease-in-out, custom)

    #[doc(inline)]
    pub use crate::dll::AzAnimationEasing as AnimationEasing;
    /// How should an animation repeat (loop, ping-pong, etc.)

    #[doc(inline)]
    pub use crate::dll::AzAnimationRepeat as AnimationRepeat;
    /// How many times should an animation repeat

    #[doc(inline)]
    pub use crate::dll::AzAnimationRepeatCount as AnimationRepeatCount;
    /// C-ABI wrapper over an `IFrameCallbackType`

    #[doc(inline)]
    pub use crate::dll::AzIFrameCallback as IFrameCallback;
    /// `IFrameCallbackInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzIFrameCallbackInfo as IFrameCallbackInfo;
    /// <img src="../images/scrollbounds.png"/>

    #[doc(inline)]
    pub use crate::dll::AzIFrameCallbackReturn as IFrameCallbackReturn;
    /// For rendering large or infinite datasets such as tables or lists, azul uses
    /// `IFrameCallbacks` that allow the library user to only render the visible portion of DOM
    /// nodes, not the entire set. IFrames are rendered after the screen has been laid out, but
    /// before it gets composited. IFrames can be used recursively (i.e. iframes within iframes
    /// are possible). IFrames are re-rendered once the user scrolls to the bounds (see
    /// `IFrameCallbackReturn` on how to set the bounds) or the parent DOM was recreated.

    #[doc(inline)]
    pub use crate::dll::AzIFrameCallbackType as IFrameCallbackType;
    /// `RenderImageCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzRenderImageCallback as RenderImageCallback;
    /// `RenderImageCallbackInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzRenderImageCallbackInfo as RenderImageCallbackInfo;
    /// `RenderImageCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzRenderImageCallbackType as RenderImageCallbackType;
    impl RenderImageCallbackInfo {
        /// Returns a copy of the internal `Gl`
        pub fn get_gl_context(&self) -> crate::option::OptionGl {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getGlContext(self) }
        }
        /// Returns a copy of the internal `HidpiAdjustedBounds`
        pub fn get_bounds(&self) -> crate::callbacks::HidpiAdjustedBounds {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getBounds(self) }
        }
        /// Returns the `DomNodeId` that this callback was called on
        pub fn get_callback_node_id(&self) -> crate::callbacks::DomNodeId {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getCallbackNodeId(self) }
        }
        /// If the node is a `Text` node, returns the layouted inline glyphs
        pub fn get_inline_text<_1: Into<DomNodeId>>(
            &self,
            node_id: _1,
        ) -> crate::option::OptionInlineText {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getInlineText(self, node_id.into()) }
        }
        /// Returns the index of the node relative to the parent node.
        pub fn get_index_in_parent<_1: Into<DomNodeId>>(&mut self, node_id: _1) -> usize {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getIndexInParent(self, node_id.into()) }
        }
        /// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid
        /// NodeId.
        pub fn get_parent<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getParent(self, node_id.into()) }
        }
        /// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_previous_sibling<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe {
                crate::dll::AzRenderImageCallbackInfo_getPreviousSibling(self, node_id.into())
            }
        }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_next_sibling<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getNextSibling(self, node_id.into()) }
        }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_first_child<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getFirstChild(self, node_id.into()) }
        }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an
        /// invalid NodeId.
        pub fn get_last_child<_1: Into<DomNodeId>>(
            &mut self,
            node_id: _1,
        ) -> crate::option::OptionDomNodeId {
            unsafe { crate::dll::AzRenderImageCallbackInfo_getLastChild(self, node_id.into()) }
        }
    }

    /// `RefAnyDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzRefAnyDestructorType as RefAnyDestructorType;
    /// `RefCount` struct

    #[doc(inline)]
    pub use crate::dll::AzRefCount as RefCount;
    /// `ThreadCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadCallback as ThreadCallback;
    /// `ThreadCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadCallbackType as ThreadCallbackType;
    /// `TimerCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzTimerCallback as TimerCallback;
    /// `TimerCallbackInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzTimerCallbackInfo as TimerCallbackInfo;
    /// `TimerCallbackReturn` struct

    #[doc(inline)]
    pub use crate::dll::AzTimerCallbackReturn as TimerCallbackReturn;
    /// `TimerCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzTimerCallbackType as TimerCallbackType;
    /// `WriteBackCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzWriteBackCallback as WriteBackCallback;
    /// `WriteBackCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzWriteBackCallbackType as WriteBackCallbackType;
    impl RefCount {
        /// Calls the `RefCount::can_be_shared` function.
        pub fn can_be_shared(&self) -> bool {
            unsafe { crate::dll::AzRefCount_canBeShared(self) }
        }
        /// Calls the `RefCount::can_be_shared_mut` function.
        pub fn can_be_shared_mut(&self) -> bool {
            unsafe { crate::dll::AzRefCount_canBeSharedMut(self) }
        }
        /// Calls the `RefCount::increase_ref` function.
        pub fn increase_ref(&mut self) {
            unsafe { crate::dll::AzRefCount_increaseRef(self) }
        }
        /// Calls the `RefCount::decrease_ref` function.
        pub fn decrease_ref(&mut self) {
            unsafe { crate::dll::AzRefCount_decreaseRef(self) }
        }
        /// Calls the `RefCount::increase_refmut` function.
        pub fn increase_refmut(&mut self) {
            unsafe { crate::dll::AzRefCount_increaseRefmut(self) }
        }
        /// Calls the `RefCount::decrease_refmut` function.
        pub fn decrease_refmut(&mut self) {
            unsafe { crate::dll::AzRefCount_decreaseRefmut(self) }
        }
    }

    impl Clone for RefCount {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzRefCount_deepCopy(self) }
        }
    }
    impl Drop for RefCount {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzRefCount_delete(self) }
            }
        }
    }
    /// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct.
    /// `RefAny` can be up- and downcasted (this usually done via generics and can't be
    /// expressed in the Rust API)

    #[doc(inline)]
    pub use crate::dll::AzRefAny as RefAny;
    impl RefAny {
        /// Creates a new `RefAny` instance.
        pub fn new_c<_4: Into<String>>(
            ptr: *const c_void,
            len: usize,
            type_id: u64,
            type_name: _4,
            destructor: RefAnyDestructorType,
        ) -> Self {
            unsafe { crate::dll::AzRefAny_newC(ptr, len, type_id, type_name.into(), destructor) }
        }
        /// Calls the `RefAny::get_type_id` function.
        pub fn get_type_id(&self) -> u64 {
            unsafe { crate::dll::AzRefAny_getTypeId(self) }
        }
        /// Calls the `RefAny::get_type_name` function.
        pub fn get_type_name(&self) -> crate::str::String {
            unsafe { crate::dll::AzRefAny_getTypeName(self) }
        }
    }

    impl Clone for RefAny {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzRefAny_deepCopy(self) }
        }
    }
    impl Drop for RefAny {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzRefAny_delete(self) }
            }
        }
    }
    /// `LayoutCallbackInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutCallbackInfo as LayoutCallbackInfo;
    impl LayoutCallbackInfo {
        /// Returns a copy of the OpenGL context
        pub fn get_gl_context(&self) -> crate::option::OptionGl {
            unsafe { crate::dll::AzLayoutCallbackInfo_getGlContext(self) }
        }
        /// Returns all system-native fonts with their respective file paths as values
        pub fn get_system_fonts(&self) -> crate::vec::StringPairVec {
            unsafe { crate::dll::AzLayoutCallbackInfo_getSystemFonts(self) }
        }
        /// Returns an `ImageRef` referenced by a CSS ID
        pub fn get_image<_1: Into<String>>(&self, id: _1) -> crate::option::OptionImageRef {
            unsafe { crate::dll::AzLayoutCallbackInfo_getImage(self, id.into()) }
        }
    }
}

pub mod dom {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! `Dom` construction and configuration
    use core::ffi::c_void;

    use crate::dll::*;

    impl Default for Dom {
        fn default() -> Self {
            Dom::div()
        }
    }

    impl Default for NodeData {
        fn default() -> Self {
            NodeData::new(NodeType::Div)
        }
    }

    impl Default for TabIndex {
        fn default() -> Self {
            TabIndex::Auto
        }
    }

    impl core::iter::FromIterator<Dom> for Dom {
        fn from_iter<I: IntoIterator<Item = Dom>>(iter: I) -> Self {
            use crate::vec::DomVec;
            let mut total_children = 0;
            let children = iter
                .into_iter()
                .map(|c| {
                    total_children += c.total_children + 1;
                    c
                })
                .collect::<DomVec>();

            Dom {
                root: NodeData::div(),
                children,
                total_children,
            }
        }
    }

    impl core::iter::FromIterator<NodeData> for Dom {
        fn from_iter<I: IntoIterator<Item = NodeData>>(iter: I) -> Self {
            use crate::vec::DomVec;
            let children = iter
                .into_iter()
                .map(|c| Dom {
                    root: c,
                    children: DomVec::from_const_slice(&[]),
                    total_children: 0,
                })
                .collect::<DomVec>();
            let total_children = children.len();

            Dom {
                root: NodeData::div(),
                children,
                total_children,
            }
        }
    }

    impl core::iter::FromIterator<NodeType> for Dom {
        fn from_iter<I: core::iter::IntoIterator<Item = NodeType>>(iter: I) -> Self {
            iter.into_iter()
                .map(|i| {
                    let mut nd = NodeData::default();
                    nd.node_type = i;
                    nd
                })
                .collect()
        }
    }

    impl From<On> for AzEventFilter {
        fn from(on: On) -> AzEventFilter {
            on.into_event_filter()
        }
    }

    impl NodeData {
        pub const fn const_new(node_type: NodeType) -> Self {
            use crate::option::{OptionRefAny, OptionTabIndex};
            Self {
                node_type,
                dataset: OptionRefAny::None,
                ids_and_classes: IdOrClassVec::from_const_slice(&[]),
                callbacks: CallbackDataVec::from_const_slice(&[]),
                inline_css_props: NodeDataInlineCssPropertyVec::from_const_slice(&[]),
                tab_index: OptionTabIndex::None,
                extra: ::core::ptr::null_mut(),
            }
        }

        pub const fn const_body() -> Self {
            Self::const_new(NodeType::Body)
        }

        pub const fn const_div() -> Self {
            Self::const_new(NodeType::Div)
        }

        pub const fn const_text(text: AzString) -> Self {
            Self::const_new(NodeType::Text(text))
        }
    }

    impl Dom {
        pub const fn const_new(node_data: NodeData) -> Self {
            Dom {
                root: node_data,
                children: DomVec::from_const_slice(&[]),
                total_children: 0,
            }
        }

        pub const fn const_body() -> Self {
            Self::const_new(NodeData::const_body())
        }

        pub const fn const_div() -> Self {
            Self::const_new(NodeData::const_div())
        }

        pub const fn const_text(text: AzString) -> Self {
            Self::const_new(NodeData::const_text(text))
        }
    }
    /// `Dom` struct

    #[doc(inline)]
    pub use crate::dll::AzDom as Dom;
    use crate::{
        callbacks::{CallbackType, IFrameCallbackType, RefAny},
        css::{Css, CssProperty},
        image::{ImageMask, ImageRef},
        menu::Menu,
        str::String,
        vec::{CallbackDataVec, DomVec, IdOrClassVec, NodeDataInlineCssPropertyVec},
    };
    impl Dom {
        /// Creates a new `Dom` instance.
        pub fn new<_1: Into<NodeType>>(node_type: _1) -> Self {
            unsafe { crate::dll::AzDom_new(node_type.into()) }
        }
        /// Creates a new `Dom` instance.
        pub fn body() -> Self {
            unsafe { crate::dll::AzDom_body() }
        }
        /// Creates a new `Dom` instance.
        pub fn div() -> Self {
            unsafe { crate::dll::AzDom_div() }
        }
        /// Creates a new `Dom` instance.
        pub fn br() -> Self {
            unsafe { crate::dll::AzDom_br() }
        }
        /// Creates a new `Dom` instance.
        pub fn text<_1: Into<String>>(string: _1) -> Self {
            unsafe { crate::dll::AzDom_text(string.into()) }
        }
        /// Creates a new `Dom` instance.
        pub fn image<_1: Into<ImageRef>>(image: _1) -> Self {
            unsafe { crate::dll::AzDom_image(image.into()) }
        }
        /// Creates a new `Dom` instance.
        pub fn iframe<_1: Into<RefAny>>(data: _1, callback: IFrameCallbackType) -> Self {
            unsafe { crate::dll::AzDom_iframe(data.into(), callback) }
        }
        /// Calls the `Dom::set_node_type` function.
        pub fn set_node_type<_1: Into<NodeType>>(&mut self, node_type: _1) {
            unsafe { crate::dll::AzDom_setNodeType(self, node_type.into()) }
        }
        /// Calls the `Dom::with_node_type` function.
        pub fn with_node_type<_1: Into<NodeType>>(&mut self, node_type: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withNodeType(self, node_type.into()) }
        }
        /// Calls the `Dom::set_dataset` function.
        pub fn set_dataset<_1: Into<RefAny>>(&mut self, dataset: _1) {
            unsafe { crate::dll::AzDom_setDataset(self, dataset.into()) }
        }
        /// Calls the `Dom::with_dataset` function.
        pub fn with_dataset<_1: Into<RefAny>>(&mut self, dataset: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withDataset(self, dataset.into()) }
        }
        /// Calls the `Dom::set_ids_and_classes` function.
        pub fn set_ids_and_classes<_1: Into<IdOrClassVec>>(&mut self, ids_and_classes: _1) {
            unsafe { crate::dll::AzDom_setIdsAndClasses(self, ids_and_classes.into()) }
        }
        /// Calls the `Dom::with_ids_and_classes` function.
        pub fn with_ids_and_classes<_1: Into<IdOrClassVec>>(
            &mut self,
            ids_and_classes: _1,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withIdsAndClasses(self, ids_and_classes.into()) }
        }
        /// Calls the `Dom::set_callbacks` function.
        pub fn set_callbacks<_1: Into<CallbackDataVec>>(&mut self, callbacks: _1) {
            unsafe { crate::dll::AzDom_setCallbacks(self, callbacks.into()) }
        }
        /// Calls the `Dom::with_callbacks` function.
        pub fn with_callbacks<_1: Into<CallbackDataVec>>(
            &mut self,
            callbacks: _1,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withCallbacks(self, callbacks.into()) }
        }
        /// Calls the `Dom::set_inline_css_props` function.
        pub fn set_inline_css_props<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            css_properties: _1,
        ) {
            unsafe { crate::dll::AzDom_setInlineCssProps(self, css_properties.into()) }
        }
        /// Calls the `Dom::with_inline_css_props` function.
        pub fn with_inline_css_props<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            css_properties: _1,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withInlineCssProps(self, css_properties.into()) }
        }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self`
        /// with a default `Dom` in order to prevent accidental copies.
        pub fn add_callback<_1: Into<EventFilter>, _2: Into<RefAny>>(
            &mut self,
            event: _1,
            data: _2,
            callback: CallbackType,
        ) {
            unsafe { crate::dll::AzDom_addCallback(self, event.into(), data.into(), callback) }
        }
        /// Same as add_child, but as a builder method.
        pub fn with_callback<_1: Into<EventFilter>, _2: Into<RefAny>>(
            &mut self,
            event: _1,
            data: _2,
            callback: CallbackType,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withCallback(self, event.into(), data.into(), callback) }
        }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self`
        /// with a default `Dom` in order to prevent accidental copies.
        pub fn add_child<_1: Into<Dom>>(&mut self, child: _1) {
            unsafe { crate::dll::AzDom_addChild(self, child.into()) }
        }
        /// Same as add_child, but as a builder method.
        pub fn with_child<_1: Into<Dom>>(&mut self, child: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withChild(self, child.into()) }
        }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self`
        /// with a default `Dom` in order to prevent accidental copies.
        pub fn set_children<_1: Into<DomVec>>(&mut self, children: _1) {
            unsafe { crate::dll::AzDom_setChildren(self, children.into()) }
        }
        /// Same as set_children, but as a builder method.
        pub fn with_children<_1: Into<DomVec>>(&mut self, children: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withChildren(self, children.into()) }
        }
        /// Adds an CSS ID to the DOM root node.
        pub fn add_id<_1: Into<String>>(&mut self, id: _1) {
            unsafe { crate::dll::AzDom_addId(self, id.into()) }
        }
        /// Same as add_id, but as a builder method
        pub fn with_id<_1: Into<String>>(&mut self, id: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withId(self, id.into()) }
        }
        /// Adds a CSS class to the DOM root node.
        pub fn add_class<_1: Into<String>>(&mut self, class: _1) {
            unsafe { crate::dll::AzDom_addClass(self, class.into()) }
        }
        /// Same as add_class, but as a builder method
        pub fn with_class<_1: Into<String>>(&mut self, class: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withClass(self, class.into()) }
        }
        /// Adds an inline (normal) CSS property to the DOM root node.
        pub fn add_css_property<_1: Into<CssProperty>>(&mut self, prop: _1) {
            unsafe { crate::dll::AzDom_addCssProperty(self, prop.into()) }
        }
        /// Same as add_class, but as a builder method
        pub fn with_css_property<_1: Into<CssProperty>>(&mut self, prop: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withCssProperty(self, prop.into()) }
        }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_hover_css_property<_1: Into<CssProperty>>(&mut self, prop: _1) {
            unsafe { crate::dll::AzDom_addHoverCssProperty(self, prop.into()) }
        }
        /// Same as add_class, but as a builder method
        pub fn with_hover_css_property<_1: Into<CssProperty>>(
            &mut self,
            prop: _1,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withHoverCssProperty(self, prop.into()) }
        }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_active_css_property<_1: Into<CssProperty>>(&mut self, prop: _1) {
            unsafe { crate::dll::AzDom_addActiveCssProperty(self, prop.into()) }
        }
        /// Same as add_class, but as a builder method
        pub fn with_active_css_property<_1: Into<CssProperty>>(
            &mut self,
            prop: _1,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withActiveCssProperty(self, prop.into()) }
        }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_focus_css_property<_1: Into<CssProperty>>(&mut self, prop: _1) {
            unsafe { crate::dll::AzDom_addFocusCssProperty(self, prop.into()) }
        }
        /// Same as add_class, but as a builder method
        pub fn with_focus_css_property<_1: Into<CssProperty>>(
            &mut self,
            prop: _1,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withFocusCssProperty(self, prop.into()) }
        }
        /// Calls the `Dom::set_inline_style` function.
        pub fn set_inline_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzDom_setInlineStyle(self, style.into()) }
        }
        /// Calls the `Dom::with_inline_style` function.
        pub fn with_inline_style<_1: Into<String>>(&mut self, style: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withInlineStyle(self, style.into()) }
        }
        /// Calls the `Dom::set_inline_hover_style` function.
        pub fn set_inline_hover_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzDom_setInlineHoverStyle(self, style.into()) }
        }
        /// Calls the `Dom::with_inline_hover_style` function.
        pub fn with_inline_hover_style<_1: Into<String>>(&mut self, style: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withInlineHoverStyle(self, style.into()) }
        }
        /// Calls the `Dom::set_inline_active_style` function.
        pub fn set_inline_active_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzDom_setInlineActiveStyle(self, style.into()) }
        }
        /// Calls the `Dom::with_inline_active_style` function.
        pub fn with_inline_active_style<_1: Into<String>>(&mut self, style: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withInlineActiveStyle(self, style.into()) }
        }
        /// Calls the `Dom::set_inline_focus_style` function.
        pub fn set_inline_focus_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzDom_setInlineFocusStyle(self, style.into()) }
        }
        /// Calls the `Dom::with_inline_focus_style` function.
        pub fn with_inline_focus_style<_1: Into<String>>(&mut self, style: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withInlineFocusStyle(self, style.into()) }
        }
        /// Sets the clip mask for the DOM root node.
        pub fn set_clip_mask<_1: Into<ImageMask>>(&mut self, clip_mask: _1) {
            unsafe { crate::dll::AzDom_setClipMask(self, clip_mask.into()) }
        }
        /// Same as set_clip_mask, but as a builder method
        pub fn with_clip_mask<_1: Into<ImageMask>>(&mut self, clip_mask: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withClipMask(self, clip_mask.into()) }
        }
        /// Sets the tab index for the DOM root node.
        pub fn set_tab_index<_1: Into<TabIndex>>(&mut self, tab_index: _1) {
            unsafe { crate::dll::AzDom_setTabIndex(self, tab_index.into()) }
        }
        /// Same as set_tab_index, but as a builder method
        pub fn with_tab_index<_1: Into<TabIndex>>(&mut self, tab_index: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withTabIndex(self, tab_index.into()) }
        }
        /// Sets accessibility attributes for the DOM root node.
        pub fn set_accessibility_info<_1: Into<AccessibilityInfo>>(
            &mut self,
            accessibility_info: _1,
        ) {
            unsafe { crate::dll::AzDom_setAccessibilityInfo(self, accessibility_info.into()) }
        }
        /// Same as set_accessibility_info, but as a builder method
        pub fn with_accessibility_info<_1: Into<AccessibilityInfo>>(
            &mut self,
            accessibility_info: _1,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withAccessibilityInfo(self, accessibility_info.into()) }
        }
        /// Sets the menu bar for the DOM root node. See `NodeData::set_menu_bar` for more
        /// information.
        pub fn set_menu_bar<_1: Into<Menu>>(&mut self, menu_bar: _1) {
            unsafe { crate::dll::AzDom_setMenuBar(self, menu_bar.into()) }
        }
        /// Same as set_accessibility_info, but as a builder method
        pub fn with_menu_bar<_1: Into<Menu>>(&mut self, menu_bar: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withMenuBar(self, menu_bar.into()) }
        }
        /// Sets the context menu for the DOM root node. See `NodeData::set_context_menu` for more
        /// information.
        pub fn set_context_menu<_1: Into<Menu>>(&mut self, context_menu: _1) {
            unsafe { crate::dll::AzDom_setContextMenu(self, context_menu.into()) }
        }
        /// Same as set_context_menu, but as a builder method
        pub fn with_context_menu<_1: Into<Menu>>(&mut self, context_menu: _1) -> crate::dom::Dom {
            unsafe { crate::dll::AzDom_withContextMenu(self, context_menu.into()) }
        }
        /// Calculates the hash of this node (note: in order to be truly unique, you also have to
        /// hash the DOM and Node ID).
        pub fn hash(&self) -> u64 {
            unsafe { crate::dll::AzDom_hash(self) }
        }
        /// Returns the number of nodes in the DOM, including all child DOM trees. Result is equal
        /// to `self.total_children + 1` (count of all child trees + the root node)
        pub fn node_count(&self) -> usize {
            unsafe { crate::dll::AzDom_nodeCount(self) }
        }
        /// Returns a HTML string that you can write to a file in order to debug the UI structure
        /// and debug potential cascading issues
        pub fn get_html_string(&mut self) -> crate::str::String {
            unsafe { crate::dll::AzDom_getHtmlString(self) }
        }
        /// Returns a HTML for unit testing
        pub fn get_html_string_test(&mut self) -> crate::str::String {
            unsafe { crate::dll::AzDom_getHtmlStringTest(self) }
        }
        /// Same as `StyledDom::new(dom, css)`: NOTE - replaces self with an empty DOM, in order to
        /// prevent cloning the DOM entirely
        pub fn style<_1: Into<Css>>(&mut self, css: _1) -> crate::style::StyledDom {
            unsafe { crate::dll::AzDom_style(self, css.into()) }
        }
    }

    /// `CallbackData` struct

    #[doc(inline)]
    pub use crate::dll::AzCallbackData as CallbackData;
    /// `IFrameNode` struct

    #[doc(inline)]
    pub use crate::dll::AzIFrameNode as IFrameNode;
    /// Represents one single DOM node (node type, classes, ids and callbacks are stored here)

    #[doc(inline)]
    pub use crate::dll::AzNodeData as NodeData;
    impl NodeData {
        /// Creates an new, empty `NodeData` struct
        pub fn new<_1: Into<NodeType>>(node_type: _1) -> Self {
            unsafe { crate::dll::AzNodeData_new(node_type.into()) }
        }
        /// Creates a new `NodeData` instance.
        pub fn body() -> Self {
            unsafe { crate::dll::AzNodeData_body() }
        }
        /// Creates a new `NodeData` instance.
        pub fn div() -> Self {
            unsafe { crate::dll::AzNodeData_div() }
        }
        /// Creates a new `NodeData` instance.
        pub fn br() -> Self {
            unsafe { crate::dll::AzNodeData_br() }
        }
        /// Creates a new `NodeData` instance.
        pub fn text<_1: Into<String>>(string: _1) -> Self {
            unsafe { crate::dll::AzNodeData_text(string.into()) }
        }
        /// Creates a new `NodeData` instance.
        pub fn image<_1: Into<ImageRef>>(image: _1) -> Self {
            unsafe { crate::dll::AzNodeData_image(image.into()) }
        }
        /// Creates a new `NodeData` instance.
        pub fn iframe<_1: Into<RefAny>>(data: _1, callback: IFrameCallbackType) -> Self {
            unsafe { crate::dll::AzNodeData_iframe(data.into(), callback) }
        }
        /// Calls the `NodeData::set_node_type` function.
        pub fn set_node_type<_1: Into<NodeType>>(&mut self, node_type: _1) {
            unsafe { crate::dll::AzNodeData_setNodeType(self, node_type.into()) }
        }
        /// Calls the `NodeData::with_node_type` function.
        pub fn with_node_type<_1: Into<NodeType>>(
            &mut self,
            node_type: _1,
        ) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withNodeType(self, node_type.into()) }
        }
        /// Calls the `NodeData::set_dataset` function.
        pub fn set_dataset<_1: Into<RefAny>>(&mut self, dataset: _1) {
            unsafe { crate::dll::AzNodeData_setDataset(self, dataset.into()) }
        }
        /// Calls the `NodeData::with_dataset` function.
        pub fn with_dataset<_1: Into<RefAny>>(&mut self, dataset: _1) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withDataset(self, dataset.into()) }
        }
        /// Calls the `NodeData::set_ids_and_classes` function.
        pub fn set_ids_and_classes<_1: Into<IdOrClassVec>>(&mut self, ids_and_classes: _1) {
            unsafe { crate::dll::AzNodeData_setIdsAndClasses(self, ids_and_classes.into()) }
        }
        /// Calls the `NodeData::with_ids_and_classes` function.
        pub fn with_ids_and_classes<_1: Into<IdOrClassVec>>(
            &mut self,
            ids_and_classes: _1,
        ) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withIdsAndClasses(self, ids_and_classes.into()) }
        }
        /// Adds a callback this DOM (potentially heap-allocates in Rust code)
        pub fn add_callback<_1: Into<EventFilter>, _2: Into<RefAny>>(
            &mut self,
            event: _1,
            data: _2,
            callback: CallbackType,
        ) {
            unsafe { crate::dll::AzNodeData_addCallback(self, event.into(), data.into(), callback) }
        }
        /// Same as add_child, but as a builder method.
        pub fn with_callback<_1: Into<EventFilter>, _2: Into<RefAny>>(
            &mut self,
            event: _1,
            data: _2,
            callback: CallbackType,
        ) -> crate::dom::NodeData {
            unsafe {
                crate::dll::AzNodeData_withCallback(self, event.into(), data.into(), callback)
            }
        }
        /// Calls the `NodeData::set_callbacks` function.
        pub fn set_callbacks<_1: Into<CallbackDataVec>>(&mut self, callbacks: _1) {
            unsafe { crate::dll::AzNodeData_setCallbacks(self, callbacks.into()) }
        }
        /// Calls the `NodeData::with_callbacks` function.
        pub fn with_callbacks<_1: Into<CallbackDataVec>>(
            &mut self,
            callbacks: _1,
        ) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withCallbacks(self, callbacks.into()) }
        }
        /// Calls the `NodeData::set_inline_css_props` function.
        pub fn set_inline_css_props<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            css_properties: _1,
        ) {
            unsafe { crate::dll::AzNodeData_setInlineCssProps(self, css_properties.into()) }
        }
        /// Calls the `NodeData::with_inline_css_props` function.
        pub fn with_inline_css_props<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            css_properties: _1,
        ) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withInlineCssProps(self, css_properties.into()) }
        }
        /// Calls the `NodeData::set_inline_style` function.
        pub fn set_inline_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzNodeData_setInlineStyle(self, style.into()) }
        }
        /// Calls the `NodeData::with_inline_style` function.
        pub fn with_inline_style<_1: Into<String>>(&mut self, style: _1) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withInlineStyle(self, style.into()) }
        }
        /// Calls the `NodeData::set_inline_hover_style` function.
        pub fn set_inline_hover_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzNodeData_setInlineHoverStyle(self, style.into()) }
        }
        /// Calls the `NodeData::with_inline_hover_style` function.
        pub fn with_inline_hover_style<_1: Into<String>>(
            &mut self,
            style: _1,
        ) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withInlineHoverStyle(self, style.into()) }
        }
        /// Calls the `NodeData::set_inline_active_style` function.
        pub fn set_inline_active_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzNodeData_setInlineActiveStyle(self, style.into()) }
        }
        /// Calls the `NodeData::with_inline_active_style` function.
        pub fn with_inline_active_style<_1: Into<String>>(
            &mut self,
            style: _1,
        ) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withInlineActiveStyle(self, style.into()) }
        }
        /// Calls the `NodeData::set_inline_focus_style` function.
        pub fn set_inline_focus_style<_1: Into<String>>(&mut self, style: _1) {
            unsafe { crate::dll::AzNodeData_setInlineFocusStyle(self, style.into()) }
        }
        /// Calls the `NodeData::with_inline_focus_style` function.
        pub fn with_inline_focus_style<_1: Into<String>>(
            &mut self,
            style: _1,
        ) -> crate::dom::NodeData {
            unsafe { crate::dll::AzNodeData_withInlineFocusStyle(self, style.into()) }
        }
        /// Sets the `extra.clip_mask` field for this node
        pub fn set_clip_mask<_1: Into<ImageMask>>(&mut self, image_mask: _1) {
            unsafe { crate::dll::AzNodeData_setClipMask(self, image_mask.into()) }
        }
        /// Sets the tab index for this node
        pub fn set_tab_index<_1: Into<TabIndex>>(&mut self, tab_index: _1) {
            unsafe { crate::dll::AzNodeData_setTabIndex(self, tab_index.into()) }
        }
        /// Sets accessibility attributes for this node
        pub fn set_accessibility_info<_1: Into<AccessibilityInfo>>(
            &mut self,
            accessibility_info: _1,
        ) {
            unsafe { crate::dll::AzNodeData_setAccessibilityInfo(self, accessibility_info.into()) }
        }
        /// Adds a (native) menu bar: If this node is the root node the menu bar will be added to
        /// the window, else it will be displayed using the width and position of the bounding
        /// rectangle
        pub fn set_menu_bar<_1: Into<Menu>>(&mut self, menu_bar: _1) {
            unsafe { crate::dll::AzNodeData_setMenuBar(self, menu_bar.into()) }
        }
        /// Signalizes that this node has a (native) context-aware menu. If set, the user can
        /// left-click the node to open the menu
        pub fn set_context_menu<_1: Into<Menu>>(&mut self, context_menu: _1) {
            unsafe { crate::dll::AzNodeData_setContextMenu(self, context_menu.into()) }
        }
        /// Calculates the hash of this node (note: in order to be truly unique, you also have to
        /// hash the DOM and Node ID).
        pub fn hash(&self) -> u64 {
            unsafe { crate::dll::AzNodeData_hash(self) }
        }
    }

    /// List of core DOM node types built-into by `azul`

    #[doc(inline)]
    pub use crate::dll::AzNodeType as NodeType;
    /// When to call a callback action - `On::MouseOver`, `On::MouseOut`, etc.

    #[doc(inline)]
    pub use crate::dll::AzOn as On;
    impl On {
        /// Converts the `On` shorthand into a `EventFilter`
        pub fn into_event_filter(self) -> crate::dom::EventFilter {
            unsafe { crate::dll::AzOn_intoEventFilter(self) }
        }
    }

    /// Accessibility information (MSAA wrapper). See `NodeData.set_accessibility_info()`

    #[doc(inline)]
    pub use crate::dll::AzAccessibilityInfo as AccessibilityInfo;
    /// MSAA Accessibility role constants. For information on what each role does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-roles">MSDN Role Constants page</a>

    #[doc(inline)]
    pub use crate::dll::AzAccessibilityRole as AccessibilityRole;
    /// MSAA accessibility state. For information on what each state does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants">MSDN State Constants page</a>.

    #[doc(inline)]
    pub use crate::dll::AzAccessibilityState as AccessibilityState;
    /// `ApplicationEventFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzApplicationEventFilter as ApplicationEventFilter;
    /// `ComponentEventFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzComponentEventFilter as ComponentEventFilter;
    /// `EventFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzEventFilter as EventFilter;
    /// `FocusEventFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzFocusEventFilter as FocusEventFilter;
    /// `HoverEventFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzHoverEventFilter as HoverEventFilter;
    /// `IdOrClass` struct

    #[doc(inline)]
    pub use crate::dll::AzIdOrClass as IdOrClass;
    /// `NodeDataInlineCssProperty` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeDataInlineCssProperty as NodeDataInlineCssProperty;
    /// `NotEventFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzNotEventFilter as NotEventFilter;
    /// `TabIndex` struct

    #[doc(inline)]
    pub use crate::dll::AzTabIndex as TabIndex;
    /// `WindowEventFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzWindowEventFilter as WindowEventFilter;
}

pub mod menu {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    use core::ffi::c_void;

    /// Menu struct (application / window menu, dropdown menu, context menu). Modeled after the
    /// Windows API

    #[doc(inline)]
    pub use crate::dll::AzMenu as Menu;
    use crate::{
        callbacks::{CallbackType, RefAny},
        dll::*,
        str::String,
        vec::MenuItemVec,
    };
    impl Menu {
        /// Creates an new, empty Menu
        pub fn new<_1: Into<MenuItemVec>>(items: _1) -> Self {
            unsafe { crate::dll::AzMenu_new(items.into()) }
        }
        /// Sets the popup position of the menu, ignored on menu bars
        pub fn set_popup_position<_1: Into<MenuPopupPosition>>(&mut self, position: _1) {
            unsafe { crate::dll::AzMenu_setPopupPosition(self, position.into()) }
        }
        /// Sets the popup position of the menu, ignored on menu bars (builder method)
        pub fn with_popup_position<_1: Into<MenuPopupPosition>>(
            &mut self,
            position: _1,
        ) -> crate::menu::Menu {
            unsafe { crate::dll::AzMenu_withPopupPosition(self, position.into()) }
        }
    }

    /// Determines whether this context menu should pop up on a left, right or middle click

    #[doc(inline)]
    pub use crate::dll::AzContextMenuMouseButton as ContextMenuMouseButton;
    /// Item entry in a menu or menu bar

    #[doc(inline)]
    pub use crate::dll::AzMenuItem as MenuItem;
    /// Position of where the context menu should pop up

    #[doc(inline)]
    pub use crate::dll::AzMenuPopupPosition as MenuPopupPosition;
    /// Regular labeled menu item

    #[doc(inline)]
    pub use crate::dll::AzStringMenuItem as StringMenuItem;
    impl StringMenuItem {
        /// Creates a new menu item
        pub fn new<_1: Into<String>>(label: _1) -> Self {
            unsafe { crate::dll::AzStringMenuItem_new(label.into()) }
        }
        /// Adds a callback to the menu item
        pub fn set_callback<_1: Into<RefAny>>(&mut self, data: _1, callback: CallbackType) {
            unsafe { crate::dll::AzStringMenuItem_setCallback(self, data.into(), callback) }
        }
        /// Adds a callback to the menu item
        pub fn with_callback<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: CallbackType,
        ) -> crate::menu::StringMenuItem {
            unsafe { crate::dll::AzStringMenuItem_withCallback(self, data.into(), callback) }
        }
        /// Adds a single child submenu to the current menu
        pub fn add_child<_1: Into<MenuItem>>(&mut self, child: _1) {
            unsafe { crate::dll::AzStringMenuItem_addChild(self, child.into()) }
        }
        /// Adds a single child submenu to the current menu
        pub fn with_child<_1: Into<MenuItem>>(&mut self, child: _1) -> crate::menu::StringMenuItem {
            unsafe { crate::dll::AzStringMenuItem_withChild(self, child.into()) }
        }
        /// Sets the children of this menu
        pub fn set_children<_1: Into<MenuItemVec>>(&mut self, children: _1) {
            unsafe { crate::dll::AzStringMenuItem_setChildren(self, children.into()) }
        }
        /// Adds a child submenu to the current menu
        pub fn with_children<_1: Into<MenuItemVec>>(
            &mut self,
            children: _1,
        ) -> crate::menu::StringMenuItem {
            unsafe { crate::dll::AzStringMenuItem_withChildren(self, children.into()) }
        }
    }

    /// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is
    /// activated

    #[doc(inline)]
    pub use crate::dll::AzMenuCallback as MenuCallback;
    /// Combination of virtual key codes that have to be pressed together

    #[doc(inline)]
    pub use crate::dll::AzVirtualKeyCodeCombo as VirtualKeyCodeCombo;
    impl MenuCallback {
        /// Creates a new `MenuCallback` instance.
        pub fn new<_1: Into<RefAny>>(data: _1, callback: CallbackType) -> Self {
            unsafe { crate::dll::AzMenuCallback_new(data.into(), callback) }
        }
    }

    /// Icon of a menu entry

    #[doc(inline)]
    pub use crate::dll::AzMenuItemIcon as MenuItemIcon;
    /// Describes the state of a menu item

    #[doc(inline)]
    pub use crate::dll::AzMenuItemState as MenuItemState;
}

pub mod css {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! `Css` parsing module
    use core::ffi::c_void;

    use crate::{
        dll::*,
        vec::{
            StyleBackgroundContentVec, StyleBackgroundPositionVec, StyleBackgroundRepeatVec,
            StyleBackgroundSizeVec, StyleFilterVec, StyleFontFamilyVec, StyleTransformVec,
        },
    };

    macro_rules! css_property_from_type {
        ($prop_type:expr, $content_type:ident) => {{
            match $prop_type {
                CssPropertyType::TextColor => {
                    CssProperty::TextColor(StyleTextColorValue::$content_type)
                }
                CssPropertyType::FontSize => {
                    CssProperty::FontSize(StyleFontSizeValue::$content_type)
                }
                CssPropertyType::FontFamily => {
                    CssProperty::FontFamily(StyleFontFamilyVecValue::$content_type)
                }
                CssPropertyType::TextAlign => {
                    CssProperty::TextAlign(StyleTextAlignValue::$content_type)
                }
                CssPropertyType::LetterSpacing => {
                    CssProperty::LetterSpacing(StyleLetterSpacingValue::$content_type)
                }
                CssPropertyType::LineHeight => {
                    CssProperty::LineHeight(StyleLineHeightValue::$content_type)
                }
                CssPropertyType::WordSpacing => {
                    CssProperty::WordSpacing(StyleWordSpacingValue::$content_type)
                }
                CssPropertyType::TabWidth => {
                    CssProperty::TabWidth(StyleTabWidthValue::$content_type)
                }
                CssPropertyType::Cursor => CssProperty::Cursor(StyleCursorValue::$content_type),
                CssPropertyType::Display => CssProperty::Display(LayoutDisplayValue::$content_type),
                CssPropertyType::Float => CssProperty::Float(LayoutFloatValue::$content_type),
                CssPropertyType::BoxSizing => {
                    CssProperty::BoxSizing(LayoutBoxSizingValue::$content_type)
                }
                CssPropertyType::Width => CssProperty::Width(LayoutWidthValue::$content_type),
                CssPropertyType::Height => CssProperty::Height(LayoutHeightValue::$content_type),
                CssPropertyType::MinWidth => {
                    CssProperty::MinWidth(LayoutMinWidthValue::$content_type)
                }
                CssPropertyType::MinHeight => {
                    CssProperty::MinHeight(LayoutMinHeightValue::$content_type)
                }
                CssPropertyType::MaxWidth => {
                    CssProperty::MaxWidth(LayoutMaxWidthValue::$content_type)
                }
                CssPropertyType::MaxHeight => {
                    CssProperty::MaxHeight(LayoutMaxHeightValue::$content_type)
                }
                CssPropertyType::Position => {
                    CssProperty::Position(LayoutPositionValue::$content_type)
                }
                CssPropertyType::Top => CssProperty::Top(LayoutTopValue::$content_type),
                CssPropertyType::Right => CssProperty::Right(LayoutRightValue::$content_type),
                CssPropertyType::Left => CssProperty::Left(LayoutLeftValue::$content_type),
                CssPropertyType::Bottom => CssProperty::Bottom(LayoutBottomValue::$content_type),
                CssPropertyType::FlexWrap => {
                    CssProperty::FlexWrap(LayoutFlexWrapValue::$content_type)
                }
                CssPropertyType::FlexDirection => {
                    CssProperty::FlexDirection(LayoutFlexDirectionValue::$content_type)
                }
                CssPropertyType::FlexGrow => {
                    CssProperty::FlexGrow(LayoutFlexGrowValue::$content_type)
                }
                CssPropertyType::FlexShrink => {
                    CssProperty::FlexShrink(LayoutFlexShrinkValue::$content_type)
                }
                CssPropertyType::JustifyContent => {
                    CssProperty::JustifyContent(LayoutJustifyContentValue::$content_type)
                }
                CssPropertyType::AlignItems => {
                    CssProperty::AlignItems(LayoutAlignItemsValue::$content_type)
                }
                CssPropertyType::AlignContent => {
                    CssProperty::AlignContent(LayoutAlignContentValue::$content_type)
                }
                CssPropertyType::BackgroundContent => {
                    CssProperty::BackgroundContent(StyleBackgroundContentVecValue::$content_type)
                }
                CssPropertyType::BackgroundPosition => {
                    CssProperty::BackgroundPosition(StyleBackgroundPositionVecValue::$content_type)
                }
                CssPropertyType::BackgroundSize => {
                    CssProperty::BackgroundSize(StyleBackgroundSizeVecValue::$content_type)
                }
                CssPropertyType::BackgroundRepeat => {
                    CssProperty::BackgroundRepeat(StyleBackgroundRepeatVecValue::$content_type)
                }
                CssPropertyType::OverflowX => {
                    CssProperty::OverflowX(LayoutOverflowValue::$content_type)
                }
                CssPropertyType::OverflowY => {
                    CssProperty::OverflowY(LayoutOverflowValue::$content_type)
                }
                CssPropertyType::PaddingTop => {
                    CssProperty::PaddingTop(LayoutPaddingTopValue::$content_type)
                }
                CssPropertyType::PaddingLeft => {
                    CssProperty::PaddingLeft(LayoutPaddingLeftValue::$content_type)
                }
                CssPropertyType::PaddingRight => {
                    CssProperty::PaddingRight(LayoutPaddingRightValue::$content_type)
                }
                CssPropertyType::PaddingBottom => {
                    CssProperty::PaddingBottom(LayoutPaddingBottomValue::$content_type)
                }
                CssPropertyType::MarginTop => {
                    CssProperty::MarginTop(LayoutMarginTopValue::$content_type)
                }
                CssPropertyType::MarginLeft => {
                    CssProperty::MarginLeft(LayoutMarginLeftValue::$content_type)
                }
                CssPropertyType::MarginRight => {
                    CssProperty::MarginRight(LayoutMarginRightValue::$content_type)
                }
                CssPropertyType::MarginBottom => {
                    CssProperty::MarginBottom(LayoutMarginBottomValue::$content_type)
                }
                CssPropertyType::BorderTopLeftRadius => {
                    CssProperty::BorderTopLeftRadius(StyleBorderTopLeftRadiusValue::$content_type)
                }
                CssPropertyType::BorderTopRightRadius => {
                    CssProperty::BorderTopRightRadius(StyleBorderTopRightRadiusValue::$content_type)
                }
                CssPropertyType::BorderBottomLeftRadius => CssProperty::BorderBottomLeftRadius(
                    StyleBorderBottomLeftRadiusValue::$content_type,
                ),
                CssPropertyType::BorderBottomRightRadius => CssProperty::BorderBottomRightRadius(
                    StyleBorderBottomRightRadiusValue::$content_type,
                ),
                CssPropertyType::BorderTopColor => {
                    CssProperty::BorderTopColor(StyleBorderTopColorValue::$content_type)
                }
                CssPropertyType::BorderRightColor => {
                    CssProperty::BorderRightColor(StyleBorderRightColorValue::$content_type)
                }
                CssPropertyType::BorderLeftColor => {
                    CssProperty::BorderLeftColor(StyleBorderLeftColorValue::$content_type)
                }
                CssPropertyType::BorderBottomColor => {
                    CssProperty::BorderBottomColor(StyleBorderBottomColorValue::$content_type)
                }
                CssPropertyType::BorderTopStyle => {
                    CssProperty::BorderTopStyle(StyleBorderTopStyleValue::$content_type)
                }
                CssPropertyType::BorderRightStyle => {
                    CssProperty::BorderRightStyle(StyleBorderRightStyleValue::$content_type)
                }
                CssPropertyType::BorderLeftStyle => {
                    CssProperty::BorderLeftStyle(StyleBorderLeftStyleValue::$content_type)
                }
                CssPropertyType::BorderBottomStyle => {
                    CssProperty::BorderBottomStyle(StyleBorderBottomStyleValue::$content_type)
                }
                CssPropertyType::BorderTopWidth => {
                    CssProperty::BorderTopWidth(LayoutBorderTopWidthValue::$content_type)
                }
                CssPropertyType::BorderRightWidth => {
                    CssProperty::BorderRightWidth(LayoutBorderRightWidthValue::$content_type)
                }
                CssPropertyType::BorderLeftWidth => {
                    CssProperty::BorderLeftWidth(LayoutBorderLeftWidthValue::$content_type)
                }
                CssPropertyType::BorderBottomWidth => {
                    CssProperty::BorderBottomWidth(LayoutBorderBottomWidthValue::$content_type)
                }
                CssPropertyType::BoxShadowLeft => {
                    CssProperty::BoxShadowLeft(StyleBoxShadowValue::$content_type)
                }
                CssPropertyType::BoxShadowRight => {
                    CssProperty::BoxShadowRight(StyleBoxShadowValue::$content_type)
                }
                CssPropertyType::BoxShadowTop => {
                    CssProperty::BoxShadowTop(StyleBoxShadowValue::$content_type)
                }
                CssPropertyType::BoxShadowBottom => {
                    CssProperty::BoxShadowBottom(StyleBoxShadowValue::$content_type)
                }
                CssPropertyType::ScrollbarStyle => {
                    CssProperty::ScrollbarStyle(ScrollbarStyleValue::$content_type)
                }
                CssPropertyType::Opacity => CssProperty::Opacity(StyleOpacityValue::$content_type),
                CssPropertyType::Transform => {
                    CssProperty::Transform(StyleTransformVecValue::$content_type)
                }
                CssPropertyType::PerspectiveOrigin => {
                    CssProperty::PerspectiveOrigin(StylePerspectiveOriginValue::$content_type)
                }
                CssPropertyType::TransformOrigin => {
                    CssProperty::TransformOrigin(StyleTransformOriginValue::$content_type)
                }
                CssPropertyType::BackfaceVisibility => {
                    CssProperty::BackfaceVisibility(StyleBackfaceVisibilityValue::$content_type)
                }
                CssPropertyType::MixBlendMode => {
                    CssProperty::MixBlendMode(StyleMixBlendModeValue::$content_type)
                }
                CssPropertyType::Filter => CssProperty::Filter(StyleFilterVecValue::$content_type),
                CssPropertyType::BackdropFilter => {
                    CssProperty::BackdropFilter(StyleFilterVecValue::$content_type)
                }
                CssPropertyType::TextShadow => {
                    CssProperty::TextShadow(StyleBoxShadowValue::$content_type)
                }
            }
        }};
    }

    impl CssProperty {
        /// Return the type (key) of this property as a statically typed enum
        pub const fn get_type(&self) -> CssPropertyType {
            match &self {
                CssProperty::TextColor(_) => CssPropertyType::TextColor,
                CssProperty::FontSize(_) => CssPropertyType::FontSize,
                CssProperty::FontFamily(_) => CssPropertyType::FontFamily,
                CssProperty::TextAlign(_) => CssPropertyType::TextAlign,
                CssProperty::LetterSpacing(_) => CssPropertyType::LetterSpacing,
                CssProperty::LineHeight(_) => CssPropertyType::LineHeight,
                CssProperty::WordSpacing(_) => CssPropertyType::WordSpacing,
                CssProperty::TabWidth(_) => CssPropertyType::TabWidth,
                CssProperty::Cursor(_) => CssPropertyType::Cursor,
                CssProperty::Display(_) => CssPropertyType::Display,
                CssProperty::Float(_) => CssPropertyType::Float,
                CssProperty::BoxSizing(_) => CssPropertyType::BoxSizing,
                CssProperty::Width(_) => CssPropertyType::Width,
                CssProperty::Height(_) => CssPropertyType::Height,
                CssProperty::MinWidth(_) => CssPropertyType::MinWidth,
                CssProperty::MinHeight(_) => CssPropertyType::MinHeight,
                CssProperty::MaxWidth(_) => CssPropertyType::MaxWidth,
                CssProperty::MaxHeight(_) => CssPropertyType::MaxHeight,
                CssProperty::Position(_) => CssPropertyType::Position,
                CssProperty::Top(_) => CssPropertyType::Top,
                CssProperty::Right(_) => CssPropertyType::Right,
                CssProperty::Left(_) => CssPropertyType::Left,
                CssProperty::Bottom(_) => CssPropertyType::Bottom,
                CssProperty::FlexWrap(_) => CssPropertyType::FlexWrap,
                CssProperty::FlexDirection(_) => CssPropertyType::FlexDirection,
                CssProperty::FlexGrow(_) => CssPropertyType::FlexGrow,
                CssProperty::FlexShrink(_) => CssPropertyType::FlexShrink,
                CssProperty::JustifyContent(_) => CssPropertyType::JustifyContent,
                CssProperty::AlignItems(_) => CssPropertyType::AlignItems,
                CssProperty::AlignContent(_) => CssPropertyType::AlignContent,
                CssProperty::BackgroundContent(_) => CssPropertyType::BackgroundContent,
                CssProperty::BackgroundPosition(_) => CssPropertyType::BackgroundPosition,
                CssProperty::BackgroundSize(_) => CssPropertyType::BackgroundSize,
                CssProperty::BackgroundRepeat(_) => CssPropertyType::BackgroundRepeat,
                CssProperty::OverflowX(_) => CssPropertyType::OverflowX,
                CssProperty::OverflowY(_) => CssPropertyType::OverflowY,
                CssProperty::PaddingTop(_) => CssPropertyType::PaddingTop,
                CssProperty::PaddingLeft(_) => CssPropertyType::PaddingLeft,
                CssProperty::PaddingRight(_) => CssPropertyType::PaddingRight,
                CssProperty::PaddingBottom(_) => CssPropertyType::PaddingBottom,
                CssProperty::MarginTop(_) => CssPropertyType::MarginTop,
                CssProperty::MarginLeft(_) => CssPropertyType::MarginLeft,
                CssProperty::MarginRight(_) => CssPropertyType::MarginRight,
                CssProperty::MarginBottom(_) => CssPropertyType::MarginBottom,
                CssProperty::BorderTopLeftRadius(_) => CssPropertyType::BorderTopLeftRadius,
                CssProperty::BorderTopRightRadius(_) => CssPropertyType::BorderTopRightRadius,
                CssProperty::BorderBottomLeftRadius(_) => CssPropertyType::BorderBottomLeftRadius,
                CssProperty::BorderBottomRightRadius(_) => CssPropertyType::BorderBottomRightRadius,
                CssProperty::BorderTopColor(_) => CssPropertyType::BorderTopColor,
                CssProperty::BorderRightColor(_) => CssPropertyType::BorderRightColor,
                CssProperty::BorderLeftColor(_) => CssPropertyType::BorderLeftColor,
                CssProperty::BorderBottomColor(_) => CssPropertyType::BorderBottomColor,
                CssProperty::BorderTopStyle(_) => CssPropertyType::BorderTopStyle,
                CssProperty::BorderRightStyle(_) => CssPropertyType::BorderRightStyle,
                CssProperty::BorderLeftStyle(_) => CssPropertyType::BorderLeftStyle,
                CssProperty::BorderBottomStyle(_) => CssPropertyType::BorderBottomStyle,
                CssProperty::BorderTopWidth(_) => CssPropertyType::BorderTopWidth,
                CssProperty::BorderRightWidth(_) => CssPropertyType::BorderRightWidth,
                CssProperty::BorderLeftWidth(_) => CssPropertyType::BorderLeftWidth,
                CssProperty::BorderBottomWidth(_) => CssPropertyType::BorderBottomWidth,
                CssProperty::BoxShadowLeft(_) => CssPropertyType::BoxShadowLeft,
                CssProperty::BoxShadowRight(_) => CssPropertyType::BoxShadowRight,
                CssProperty::BoxShadowTop(_) => CssPropertyType::BoxShadowTop,
                CssProperty::BoxShadowBottom(_) => CssPropertyType::BoxShadowBottom,
                CssProperty::ScrollbarStyle(_) => CssPropertyType::ScrollbarStyle,
                CssProperty::Opacity(_) => CssPropertyType::Opacity,
                CssProperty::Transform(_) => CssPropertyType::Transform,
                CssProperty::PerspectiveOrigin(_) => CssPropertyType::PerspectiveOrigin,
                CssProperty::TransformOrigin(_) => CssPropertyType::TransformOrigin,
                CssProperty::BackfaceVisibility(_) => CssPropertyType::BackfaceVisibility,
                CssProperty::MixBlendMode(_) => CssPropertyType::MixBlendMode,
                CssProperty::Filter(_) => CssPropertyType::Filter,
                CssProperty::BackdropFilter(_) => CssPropertyType::BackdropFilter,
                CssProperty::TextShadow(_) => CssPropertyType::TextShadow,
            }
        }

        // const constructors for easier API access

        pub const fn none(prop_type: CssPropertyType) -> Self {
            css_property_from_type!(prop_type, None)
        }
        pub const fn auto(prop_type: CssPropertyType) -> Self {
            css_property_from_type!(prop_type, Auto)
        }
        pub const fn initial(prop_type: CssPropertyType) -> Self {
            css_property_from_type!(prop_type, Initial)
        }
        pub const fn inherit(prop_type: CssPropertyType) -> Self {
            css_property_from_type!(prop_type, Inherit)
        }

        pub const fn text_color(input: StyleTextColor) -> Self {
            CssProperty::TextColor(StyleTextColorValue::Exact(input))
        }
        pub const fn font_size(input: StyleFontSize) -> Self {
            CssProperty::FontSize(StyleFontSizeValue::Exact(input))
        }
        pub const fn font_family(input: StyleFontFamilyVec) -> Self {
            CssProperty::FontFamily(StyleFontFamilyVecValue::Exact(input))
        }
        pub const fn text_align(input: StyleTextAlign) -> Self {
            CssProperty::TextAlign(StyleTextAlignValue::Exact(input))
        }
        pub const fn letter_spacing(input: StyleLetterSpacing) -> Self {
            CssProperty::LetterSpacing(StyleLetterSpacingValue::Exact(input))
        }
        pub const fn line_height(input: StyleLineHeight) -> Self {
            CssProperty::LineHeight(StyleLineHeightValue::Exact(input))
        }
        pub const fn word_spacing(input: StyleWordSpacing) -> Self {
            CssProperty::WordSpacing(StyleWordSpacingValue::Exact(input))
        }
        pub const fn tab_width(input: StyleTabWidth) -> Self {
            CssProperty::TabWidth(StyleTabWidthValue::Exact(input))
        }
        pub const fn cursor(input: StyleCursor) -> Self {
            CssProperty::Cursor(StyleCursorValue::Exact(input))
        }
        pub const fn display(input: LayoutDisplay) -> Self {
            CssProperty::Display(LayoutDisplayValue::Exact(input))
        }
        pub const fn float(input: LayoutFloat) -> Self {
            CssProperty::Float(LayoutFloatValue::Exact(input))
        }
        pub const fn box_sizing(input: LayoutBoxSizing) -> Self {
            CssProperty::BoxSizing(LayoutBoxSizingValue::Exact(input))
        }
        pub const fn width(input: LayoutWidth) -> Self {
            CssProperty::Width(LayoutWidthValue::Exact(input))
        }
        pub const fn height(input: LayoutHeight) -> Self {
            CssProperty::Height(LayoutHeightValue::Exact(input))
        }
        pub const fn min_width(input: LayoutMinWidth) -> Self {
            CssProperty::MinWidth(LayoutMinWidthValue::Exact(input))
        }
        pub const fn min_height(input: LayoutMinHeight) -> Self {
            CssProperty::MinHeight(LayoutMinHeightValue::Exact(input))
        }
        pub const fn max_width(input: LayoutMaxWidth) -> Self {
            CssProperty::MaxWidth(LayoutMaxWidthValue::Exact(input))
        }
        pub const fn max_height(input: LayoutMaxHeight) -> Self {
            CssProperty::MaxHeight(LayoutMaxHeightValue::Exact(input))
        }
        pub const fn position(input: LayoutPosition) -> Self {
            CssProperty::Position(LayoutPositionValue::Exact(input))
        }
        pub const fn top(input: LayoutTop) -> Self {
            CssProperty::Top(LayoutTopValue::Exact(input))
        }
        pub const fn right(input: LayoutRight) -> Self {
            CssProperty::Right(LayoutRightValue::Exact(input))
        }
        pub const fn left(input: LayoutLeft) -> Self {
            CssProperty::Left(LayoutLeftValue::Exact(input))
        }
        pub const fn bottom(input: LayoutBottom) -> Self {
            CssProperty::Bottom(LayoutBottomValue::Exact(input))
        }
        pub const fn flex_wrap(input: LayoutFlexWrap) -> Self {
            CssProperty::FlexWrap(LayoutFlexWrapValue::Exact(input))
        }
        pub const fn flex_direction(input: LayoutFlexDirection) -> Self {
            CssProperty::FlexDirection(LayoutFlexDirectionValue::Exact(input))
        }
        pub const fn flex_grow(input: LayoutFlexGrow) -> Self {
            CssProperty::FlexGrow(LayoutFlexGrowValue::Exact(input))
        }
        pub const fn flex_shrink(input: LayoutFlexShrink) -> Self {
            CssProperty::FlexShrink(LayoutFlexShrinkValue::Exact(input))
        }
        pub const fn justify_content(input: LayoutJustifyContent) -> Self {
            CssProperty::JustifyContent(LayoutJustifyContentValue::Exact(input))
        }
        pub const fn align_items(input: LayoutAlignItems) -> Self {
            CssProperty::AlignItems(LayoutAlignItemsValue::Exact(input))
        }
        pub const fn align_content(input: LayoutAlignContent) -> Self {
            CssProperty::AlignContent(LayoutAlignContentValue::Exact(input))
        }
        pub const fn background_content(input: StyleBackgroundContentVec) -> Self {
            CssProperty::BackgroundContent(StyleBackgroundContentVecValue::Exact(input))
        }
        pub const fn background_position(input: StyleBackgroundPositionVec) -> Self {
            CssProperty::BackgroundPosition(StyleBackgroundPositionVecValue::Exact(input))
        }
        pub const fn background_size(input: StyleBackgroundSizeVec) -> Self {
            CssProperty::BackgroundSize(StyleBackgroundSizeVecValue::Exact(input))
        }
        pub const fn background_repeat(input: StyleBackgroundRepeatVec) -> Self {
            CssProperty::BackgroundRepeat(StyleBackgroundRepeatVecValue::Exact(input))
        }
        pub const fn overflow_x(input: LayoutOverflow) -> Self {
            CssProperty::OverflowX(LayoutOverflowValue::Exact(input))
        }
        pub const fn overflow_y(input: LayoutOverflow) -> Self {
            CssProperty::OverflowY(LayoutOverflowValue::Exact(input))
        }
        pub const fn padding_top(input: LayoutPaddingTop) -> Self {
            CssProperty::PaddingTop(LayoutPaddingTopValue::Exact(input))
        }
        pub const fn padding_left(input: LayoutPaddingLeft) -> Self {
            CssProperty::PaddingLeft(LayoutPaddingLeftValue::Exact(input))
        }
        pub const fn padding_right(input: LayoutPaddingRight) -> Self {
            CssProperty::PaddingRight(LayoutPaddingRightValue::Exact(input))
        }
        pub const fn padding_bottom(input: LayoutPaddingBottom) -> Self {
            CssProperty::PaddingBottom(LayoutPaddingBottomValue::Exact(input))
        }
        pub const fn margin_top(input: LayoutMarginTop) -> Self {
            CssProperty::MarginTop(LayoutMarginTopValue::Exact(input))
        }
        pub const fn margin_left(input: LayoutMarginLeft) -> Self {
            CssProperty::MarginLeft(LayoutMarginLeftValue::Exact(input))
        }
        pub const fn margin_right(input: LayoutMarginRight) -> Self {
            CssProperty::MarginRight(LayoutMarginRightValue::Exact(input))
        }
        pub const fn margin_bottom(input: LayoutMarginBottom) -> Self {
            CssProperty::MarginBottom(LayoutMarginBottomValue::Exact(input))
        }
        pub const fn border_top_left_radius(input: StyleBorderTopLeftRadius) -> Self {
            CssProperty::BorderTopLeftRadius(StyleBorderTopLeftRadiusValue::Exact(input))
        }
        pub const fn border_top_right_radius(input: StyleBorderTopRightRadius) -> Self {
            CssProperty::BorderTopRightRadius(StyleBorderTopRightRadiusValue::Exact(input))
        }
        pub const fn border_bottom_left_radius(input: StyleBorderBottomLeftRadius) -> Self {
            CssProperty::BorderBottomLeftRadius(StyleBorderBottomLeftRadiusValue::Exact(input))
        }
        pub const fn border_bottom_right_radius(input: StyleBorderBottomRightRadius) -> Self {
            CssProperty::BorderBottomRightRadius(StyleBorderBottomRightRadiusValue::Exact(input))
        }
        pub const fn border_top_color(input: StyleBorderTopColor) -> Self {
            CssProperty::BorderTopColor(StyleBorderTopColorValue::Exact(input))
        }
        pub const fn border_right_color(input: StyleBorderRightColor) -> Self {
            CssProperty::BorderRightColor(StyleBorderRightColorValue::Exact(input))
        }
        pub const fn border_left_color(input: StyleBorderLeftColor) -> Self {
            CssProperty::BorderLeftColor(StyleBorderLeftColorValue::Exact(input))
        }
        pub const fn border_bottom_color(input: StyleBorderBottomColor) -> Self {
            CssProperty::BorderBottomColor(StyleBorderBottomColorValue::Exact(input))
        }
        pub const fn border_top_style(input: StyleBorderTopStyle) -> Self {
            CssProperty::BorderTopStyle(StyleBorderTopStyleValue::Exact(input))
        }
        pub const fn border_right_style(input: StyleBorderRightStyle) -> Self {
            CssProperty::BorderRightStyle(StyleBorderRightStyleValue::Exact(input))
        }
        pub const fn border_left_style(input: StyleBorderLeftStyle) -> Self {
            CssProperty::BorderLeftStyle(StyleBorderLeftStyleValue::Exact(input))
        }
        pub const fn border_bottom_style(input: StyleBorderBottomStyle) -> Self {
            CssProperty::BorderBottomStyle(StyleBorderBottomStyleValue::Exact(input))
        }
        pub const fn border_top_width(input: LayoutBorderTopWidth) -> Self {
            CssProperty::BorderTopWidth(LayoutBorderTopWidthValue::Exact(input))
        }
        pub const fn border_right_width(input: LayoutBorderRightWidth) -> Self {
            CssProperty::BorderRightWidth(LayoutBorderRightWidthValue::Exact(input))
        }
        pub const fn border_left_width(input: LayoutBorderLeftWidth) -> Self {
            CssProperty::BorderLeftWidth(LayoutBorderLeftWidthValue::Exact(input))
        }
        pub const fn border_bottom_width(input: LayoutBorderBottomWidth) -> Self {
            CssProperty::BorderBottomWidth(LayoutBorderBottomWidthValue::Exact(input))
        }
        pub const fn box_shadow_left(input: StyleBoxShadow) -> Self {
            CssProperty::BoxShadowLeft(StyleBoxShadowValue::Exact(input))
        }
        pub const fn box_shadow_right(input: StyleBoxShadow) -> Self {
            CssProperty::BoxShadowRight(StyleBoxShadowValue::Exact(input))
        }
        pub const fn box_shadow_top(input: StyleBoxShadow) -> Self {
            CssProperty::BoxShadowTop(StyleBoxShadowValue::Exact(input))
        }
        pub const fn box_shadow_bottom(input: StyleBoxShadow) -> Self {
            CssProperty::BoxShadowBottom(StyleBoxShadowValue::Exact(input))
        }
        pub const fn opacity(input: StyleOpacity) -> Self {
            CssProperty::Opacity(StyleOpacityValue::Exact(input))
        }
        pub const fn transform(input: StyleTransformVec) -> Self {
            CssProperty::Transform(StyleTransformVecValue::Exact(input))
        }
        pub const fn transform_origin(input: StyleTransformOrigin) -> Self {
            CssProperty::TransformOrigin(StyleTransformOriginValue::Exact(input))
        }
        pub const fn perspective_origin(input: StylePerspectiveOrigin) -> Self {
            CssProperty::PerspectiveOrigin(StylePerspectiveOriginValue::Exact(input))
        }
        pub const fn backface_visiblity(input: StyleBackfaceVisibility) -> Self {
            CssProperty::BackfaceVisibility(StyleBackfaceVisibilityValue::Exact(input))
        }
        pub const fn mix_blend_mode(input: StyleMixBlendMode) -> Self {
            CssProperty::MixBlendMode(StyleMixBlendModeValue::Exact(input))
        }
        pub const fn filter(input: StyleFilterVec) -> Self {
            CssProperty::Filter(StyleFilterVecValue::Exact(input))
        }
        pub const fn backdrop_filter(input: StyleFilterVec) -> Self {
            CssProperty::BackdropFilter(StyleFilterVecValue::Exact(input))
        }
        pub const fn text_shadow(input: StyleBoxShadow) -> Self {
            CssProperty::TextShadow(StyleBoxShadowValue::Exact(input))
        }
    }

    const FP_PRECISION_MULTIPLIER: f32 = 1000.0;
    const FP_PRECISION_MULTIPLIER_CONST: isize = FP_PRECISION_MULTIPLIER as isize;

    impl FloatValue {
        /// Same as `FloatValue::new()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        pub const fn const_new(value: isize) -> Self {
            Self {
                number: value * FP_PRECISION_MULTIPLIER_CONST,
            }
        }

        pub fn new(value: f32) -> Self {
            Self {
                number: (value * FP_PRECISION_MULTIPLIER) as isize,
            }
        }

        pub fn get(&self) -> f32 {
            self.number as f32 / FP_PRECISION_MULTIPLIER
        }
    }

    impl From<f32> for FloatValue {
        fn from(val: f32) -> Self {
            Self::new(val)
        }
    }

    impl AngleValue {
        #[inline]
        pub const fn zero() -> Self {
            const ZERO_DEG: AngleValue = AngleValue::const_deg(0);
            ZERO_DEG
        }

        /// Same as `PixelValue::px()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_deg(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Degree, value)
        }

        /// Same as `PixelValue::em()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_rad(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Radians, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_grad(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Grad, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_turn(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Turn, value)
        }

        #[inline]
        pub fn const_percent(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Percent, value)
        }

        #[inline]
        pub const fn const_from_metric(metric: AngleMetric, value: isize) -> Self {
            Self {
                metric,
                number: FloatValue::const_new(value),
            }
        }

        #[inline]
        pub fn deg(value: f32) -> Self {
            Self::from_metric(AngleMetric::Degree, value)
        }

        #[inline]
        pub fn rad(value: f32) -> Self {
            Self::from_metric(AngleMetric::Radians, value)
        }

        #[inline]
        pub fn grad(value: f32) -> Self {
            Self::from_metric(AngleMetric::Grad, value)
        }

        #[inline]
        pub fn turn(value: f32) -> Self {
            Self::from_metric(AngleMetric::Turn, value)
        }

        #[inline]
        pub fn percent(value: f32) -> Self {
            Self::from_metric(AngleMetric::Percent, value)
        }

        #[inline]
        pub fn from_metric(metric: AngleMetric, value: f32) -> Self {
            Self {
                metric,
                number: FloatValue::new(value),
            }
        }
    }

    impl PixelValue {
        #[inline]
        pub const fn zero() -> Self {
            const ZERO_PX: PixelValue = PixelValue::const_px(0);
            ZERO_PX
        }

        /// Same as `PixelValue::px()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_px(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Px, value)
        }

        /// Same as `PixelValue::em()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_em(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Em, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_pt(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Pt, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_percent(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Percent, value)
        }

        #[inline]
        pub const fn const_from_metric(metric: SizeMetric, value: isize) -> Self {
            Self {
                metric,
                number: FloatValue::const_new(value),
            }
        }

        #[inline]
        pub fn px(value: f32) -> Self {
            Self::from_metric(SizeMetric::Px, value)
        }

        #[inline]
        pub fn em(value: f32) -> Self {
            Self::from_metric(SizeMetric::Em, value)
        }

        #[inline]
        pub fn pt(value: f32) -> Self {
            Self::from_metric(SizeMetric::Pt, value)
        }

        #[inline]
        pub fn percent(value: f32) -> Self {
            Self::from_metric(SizeMetric::Percent, value)
        }

        #[inline]
        pub fn from_metric(metric: SizeMetric, value: f32) -> Self {
            Self {
                metric,
                number: FloatValue::new(value),
            }
        }
    }

    impl PixelValueNoPercent {
        #[inline]
        pub const fn zero() -> Self {
            Self {
                inner: PixelValue::zero(),
            }
        }

        /// Same as `PixelValueNoPercent::px()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_px(value: isize) -> Self {
            Self {
                inner: PixelValue::const_px(value),
            }
        }

        /// Same as `PixelValueNoPercent::em()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_em(value: isize) -> Self {
            Self {
                inner: PixelValue::const_em(value),
            }
        }

        /// Same as `PixelValueNoPercent::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_pt(value: isize) -> Self {
            Self {
                inner: PixelValue::const_pt(value),
            }
        }

        #[inline]
        const fn const_from_metric(metric: SizeMetric, value: isize) -> Self {
            Self {
                inner: PixelValue::const_from_metric(metric, value),
            }
        }

        #[inline]
        pub fn px(value: f32) -> Self {
            Self {
                inner: PixelValue::px(value),
            }
        }

        #[inline]
        pub fn em(value: f32) -> Self {
            Self {
                inner: PixelValue::em(value),
            }
        }

        #[inline]
        pub fn pt(value: f32) -> Self {
            Self {
                inner: PixelValue::pt(value),
            }
        }

        #[inline]
        fn from_metric(metric: SizeMetric, value: f32) -> Self {
            Self {
                inner: PixelValue::from_metric(metric, value),
            }
        }
    }

    impl PercentageValue {
        /// Same as `PercentageValue::new()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_new(value: isize) -> Self {
            Self {
                number: FloatValue::const_new(value),
            }
        }

        #[inline]
        pub fn new(value: f32) -> Self {
            Self {
                number: value.into(),
            }
        }

        #[inline]
        pub fn get(&self) -> f32 {
            self.number.get()
        }
    }

    /// Creates `pt`, `px` and `em` constructors for any struct that has a
    /// `PixelValue` as it's self.0 field.
    macro_rules! impl_pixel_value {
        ($struct:ident) => {
            impl $struct {
                #[inline]
                pub const fn zero() -> Self {
                    Self {
                        inner: PixelValue::zero(),
                    }
                }

                /// Same as `PixelValue::px()`, but only accepts whole numbers,
                /// since using `f32` in const fn is not yet stabilized.
                #[inline]
                pub const fn const_px(value: isize) -> Self {
                    Self {
                        inner: PixelValue::const_px(value),
                    }
                }

                /// Same as `PixelValue::em()`, but only accepts whole numbers,
                /// since using `f32` in const fn is not yet stabilized.
                #[inline]
                pub const fn const_em(value: isize) -> Self {
                    Self {
                        inner: PixelValue::const_em(value),
                    }
                }

                /// Same as `PixelValue::pt()`, but only accepts whole numbers,
                /// since using `f32` in const fn is not yet stabilized.
                #[inline]
                pub const fn const_pt(value: isize) -> Self {
                    Self {
                        inner: PixelValue::const_pt(value),
                    }
                }

                /// Same as `PixelValue::pt()`, but only accepts whole numbers,
                /// since using `f32` in const fn is not yet stabilized.
                #[inline]
                pub const fn const_percent(value: isize) -> Self {
                    Self {
                        inner: PixelValue::const_percent(value),
                    }
                }

                #[inline]
                pub const fn const_from_metric(metric: SizeMetric, value: isize) -> Self {
                    Self {
                        inner: PixelValue::const_from_metric(metric, value),
                    }
                }

                #[inline]
                pub fn px(value: f32) -> Self {
                    Self {
                        inner: PixelValue::px(value),
                    }
                }

                #[inline]
                pub fn em(value: f32) -> Self {
                    Self {
                        inner: PixelValue::em(value),
                    }
                }

                #[inline]
                pub fn pt(value: f32) -> Self {
                    Self {
                        inner: PixelValue::pt(value),
                    }
                }

                #[inline]
                pub fn percent(value: f32) -> Self {
                    Self {
                        inner: PixelValue::percent(value),
                    }
                }

                #[inline]
                pub fn from_metric(metric: SizeMetric, value: f32) -> Self {
                    Self {
                        inner: PixelValue::from_metric(metric, value),
                    }
                }
            }
        };
    }

    impl_pixel_value!(StyleBorderTopLeftRadius);
    impl_pixel_value!(StyleBorderBottomLeftRadius);
    impl_pixel_value!(StyleBorderTopRightRadius);
    impl_pixel_value!(StyleBorderBottomRightRadius);
    impl_pixel_value!(LayoutBorderTopWidth);
    impl_pixel_value!(LayoutBorderLeftWidth);
    impl_pixel_value!(LayoutBorderRightWidth);
    impl_pixel_value!(LayoutBorderBottomWidth);
    impl_pixel_value!(LayoutWidth);
    impl_pixel_value!(LayoutHeight);
    impl_pixel_value!(LayoutMinHeight);
    impl_pixel_value!(LayoutMinWidth);
    impl_pixel_value!(LayoutMaxWidth);
    impl_pixel_value!(LayoutMaxHeight);
    impl_pixel_value!(LayoutTop);
    impl_pixel_value!(LayoutBottom);
    impl_pixel_value!(LayoutRight);
    impl_pixel_value!(LayoutLeft);
    impl_pixel_value!(LayoutPaddingTop);
    impl_pixel_value!(LayoutPaddingBottom);
    impl_pixel_value!(LayoutPaddingRight);
    impl_pixel_value!(LayoutPaddingLeft);
    impl_pixel_value!(LayoutMarginTop);
    impl_pixel_value!(LayoutMarginBottom);
    impl_pixel_value!(LayoutMarginRight);
    impl_pixel_value!(LayoutMarginLeft);
    impl_pixel_value!(StyleLetterSpacing);
    impl_pixel_value!(StyleWordSpacing);
    impl_pixel_value!(StyleFontSize);

    macro_rules! impl_float_value {
        ($struct:ident) => {
            impl $struct {
                /// Same as `FloatValue::new()`, but only accepts whole numbers,
                /// since using `f32` in const fn is not yet stabilized.
                pub const fn const_new(value: isize) -> Self {
                    Self {
                        inner: FloatValue::const_new(value),
                    }
                }

                pub fn new(value: f32) -> Self {
                    Self {
                        inner: FloatValue::new(value),
                    }
                }

                pub fn get(&self) -> f32 {
                    self.inner.get()
                }
            }

            impl From<f32> for $struct {
                fn from(val: f32) -> Self {
                    Self {
                        inner: FloatValue::from(val),
                    }
                }
            }
        };
    }

    impl_float_value!(LayoutFlexGrow);
    impl_float_value!(LayoutFlexShrink);

    macro_rules! impl_percentage_value {
        ($struct:ident) => {
            impl $struct {
                /// Same as `PercentageValue::new()`, but only accepts whole numbers,
                /// since using `f32` in const fn is not yet stabilized.
                #[inline]
                pub const fn const_new(value: isize) -> Self {
                    Self {
                        inner: PercentageValue::const_new(value),
                    }
                }
            }
        };
    }

    impl_percentage_value!(StyleLineHeight);
    impl_percentage_value!(StyleTabWidth);
    impl_percentage_value!(StyleOpacity);
    /// `Css` struct

    #[doc(inline)]
    pub use crate::dll::AzCss as Css;
    /// `CssNthChildPattern` struct

    #[doc(inline)]
    pub use crate::dll::AzCssNthChildPattern as CssNthChildPattern;
    /// `CssNthChildSelector` struct

    #[doc(inline)]
    pub use crate::dll::AzCssNthChildSelector as CssNthChildSelector;
    /// `CssPath` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPath as CssPath;
    /// `CssPathPseudoSelector` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPathPseudoSelector as CssPathPseudoSelector;
    /// `CssPathSelector` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPathSelector as CssPathSelector;
    /// `CssRuleBlock` struct

    #[doc(inline)]
    pub use crate::dll::AzCssRuleBlock as CssRuleBlock;
    /// `NodeTypeKey` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeKey as NodeTypeKey;
    /// `Stylesheet` struct

    #[doc(inline)]
    pub use crate::dll::AzStylesheet as Stylesheet;
    use crate::str::String;
    impl Css {
        /// Returns an empty CSS style
        pub fn empty() -> Self {
            unsafe { crate::dll::AzCss_empty() }
        }
        /// Returns a CSS style parsed from a `String`
        pub fn from_string<_1: Into<String>>(s: _1) -> Self {
            unsafe { crate::dll::AzCss_fromString(s.into()) }
        }
    }

    /// `AnimationInterpolationFunction` struct

    #[doc(inline)]
    pub use crate::dll::AzAnimationInterpolationFunction as AnimationInterpolationFunction;
    /// `ColorU` struct

    #[doc(inline)]
    pub use crate::dll::AzColorU as ColorU;
    /// `CssDeclaration` struct

    #[doc(inline)]
    pub use crate::dll::AzCssDeclaration as CssDeclaration;
    /// `CssPropertyType` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPropertyType as CssPropertyType;
    /// `DynamicCssProperty` struct

    #[doc(inline)]
    pub use crate::dll::AzDynamicCssProperty as DynamicCssProperty;
    /// `InterpolateContext` struct

    #[doc(inline)]
    pub use crate::dll::AzInterpolateContext as InterpolateContext;
    impl ColorU {
        /// Creates a new `ColorU` instance.
        pub fn from_str<_1: Into<String>>(string: _1) -> Self {
            unsafe { crate::dll::AzColorU_fromStr(string.into()) }
        }
        /// Creates a new `ColorU` instance.
        pub fn transparent() -> Self {
            unsafe { crate::dll::AzColorU_transparent() }
        }
        /// Creates a new `ColorU` instance.
        pub fn white() -> Self {
            unsafe { crate::dll::AzColorU_white() }
        }
        /// Creates a new `ColorU` instance.
        pub fn black() -> Self {
            unsafe { crate::dll::AzColorU_black() }
        }
        /// Calls the `ColorU::to_hash` function.
        pub fn to_hash(&self) -> crate::str::String {
            unsafe { crate::dll::AzColorU_toHash(self) }
        }
    }

    /// `AngleMetric` struct

    #[doc(inline)]
    pub use crate::dll::AzAngleMetric as AngleMetric;
    /// `AngleValue` struct

    #[doc(inline)]
    pub use crate::dll::AzAngleValue as AngleValue;
    /// `BoxShadowClipMode` struct

    #[doc(inline)]
    pub use crate::dll::AzBoxShadowClipMode as BoxShadowClipMode;
    /// `FloatValue` struct

    #[doc(inline)]
    pub use crate::dll::AzFloatValue as FloatValue;
    /// `LayoutAlignContent` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutAlignContent as LayoutAlignContent;
    /// `LayoutAlignItems` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutAlignItems as LayoutAlignItems;
    /// `LayoutBottom` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBottom as LayoutBottom;
    /// `LayoutBoxSizing` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBoxSizing as LayoutBoxSizing;
    /// `LayoutDisplay` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutDisplay as LayoutDisplay;
    /// `LayoutFlexDirection` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexDirection as LayoutFlexDirection;
    /// `LayoutFlexGrow` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexGrow as LayoutFlexGrow;
    /// `LayoutFlexShrink` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexShrink as LayoutFlexShrink;
    /// `LayoutFlexWrap` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexWrap as LayoutFlexWrap;
    /// `LayoutFloat` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFloat as LayoutFloat;
    /// `LayoutHeight` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutHeight as LayoutHeight;
    /// `LayoutJustifyContent` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutJustifyContent as LayoutJustifyContent;
    /// `LayoutLeft` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutLeft as LayoutLeft;
    /// `LayoutMarginBottom` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginBottom as LayoutMarginBottom;
    /// `LayoutMarginLeft` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginLeft as LayoutMarginLeft;
    /// `LayoutMarginRight` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginRight as LayoutMarginRight;
    /// `LayoutMarginTop` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginTop as LayoutMarginTop;
    /// `LayoutMaxHeight` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMaxHeight as LayoutMaxHeight;
    /// `LayoutMaxWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMaxWidth as LayoutMaxWidth;
    /// `LayoutMinHeight` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMinHeight as LayoutMinHeight;
    /// `LayoutMinWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMinWidth as LayoutMinWidth;
    /// `LayoutOverflow` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutOverflow as LayoutOverflow;
    /// `LayoutPaddingBottom` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingBottom as LayoutPaddingBottom;
    /// `LayoutPaddingLeft` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingLeft as LayoutPaddingLeft;
    /// `LayoutPaddingRight` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingRight as LayoutPaddingRight;
    /// `LayoutPaddingTop` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingTop as LayoutPaddingTop;
    /// `LayoutPosition` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPosition as LayoutPosition;
    /// `LayoutRight` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutRight as LayoutRight;
    /// `LayoutTop` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutTop as LayoutTop;
    /// `LayoutWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutWidth as LayoutWidth;
    /// `PercentageValue` struct

    #[doc(inline)]
    pub use crate::dll::AzPercentageValue as PercentageValue;
    /// `PixelValue` struct

    #[doc(inline)]
    pub use crate::dll::AzPixelValue as PixelValue;
    /// `PixelValueNoPercent` struct

    #[doc(inline)]
    pub use crate::dll::AzPixelValueNoPercent as PixelValueNoPercent;
    /// `SizeMetric` struct

    #[doc(inline)]
    pub use crate::dll::AzSizeMetric as SizeMetric;
    /// `StyleBlur` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBlur as StyleBlur;
    /// `StyleBoxShadow` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBoxShadow as StyleBoxShadow;
    /// `StyleColorMatrix` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleColorMatrix as StyleColorMatrix;
    /// `StyleCompositeFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleCompositeFilter as StyleCompositeFilter;
    /// `StyleFilter` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFilter as StyleFilter;
    /// `StyleFilterOffset` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFilterOffset as StyleFilterOffset;
    /// `StyleMixBlendMode` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleMixBlendMode as StyleMixBlendMode;
    impl AngleValue {
        /// Calls the `AngleValue::get_degrees` function.
        pub fn get_degrees(&self) -> f32 {
            unsafe { crate::dll::AzAngleValue_getDegrees(self) }
        }
    }

    /// `BackgroundPositionHorizontal` struct

    #[doc(inline)]
    pub use crate::dll::AzBackgroundPositionHorizontal as BackgroundPositionHorizontal;
    /// `BackgroundPositionVertical` struct

    #[doc(inline)]
    pub use crate::dll::AzBackgroundPositionVertical as BackgroundPositionVertical;
    /// `BorderStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzBorderStyle as BorderStyle;
    /// `ConicGradient` struct

    #[doc(inline)]
    pub use crate::dll::AzConicGradient as ConicGradient;
    /// Parsed CSS key-value pair

    #[doc(inline)]
    pub use crate::dll::AzCssProperty as CssProperty;
    /// `Direction` struct

    #[doc(inline)]
    pub use crate::dll::AzDirection as Direction;
    /// `DirectionCorner` struct

    #[doc(inline)]
    pub use crate::dll::AzDirectionCorner as DirectionCorner;
    /// `DirectionCorners` struct

    #[doc(inline)]
    pub use crate::dll::AzDirectionCorners as DirectionCorners;
    /// `ExtendMode` struct

    #[doc(inline)]
    pub use crate::dll::AzExtendMode as ExtendMode;
    /// `LayoutAlignContentValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutAlignContentValue as LayoutAlignContentValue;
    /// `LayoutAlignItemsValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutAlignItemsValue as LayoutAlignItemsValue;
    /// `LayoutBorderBottomWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderBottomWidth as LayoutBorderBottomWidth;
    /// `LayoutBorderBottomWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderBottomWidthValue as LayoutBorderBottomWidthValue;
    /// `LayoutBorderLeftWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderLeftWidth as LayoutBorderLeftWidth;
    /// `LayoutBorderLeftWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderLeftWidthValue as LayoutBorderLeftWidthValue;
    /// `LayoutBorderRightWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderRightWidth as LayoutBorderRightWidth;
    /// `LayoutBorderRightWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderRightWidthValue as LayoutBorderRightWidthValue;
    /// `LayoutBorderTopWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderTopWidth as LayoutBorderTopWidth;
    /// `LayoutBorderTopWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBorderTopWidthValue as LayoutBorderTopWidthValue;
    /// `LayoutBottomValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBottomValue as LayoutBottomValue;
    /// `LayoutBoxSizingValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutBoxSizingValue as LayoutBoxSizingValue;
    /// `LayoutDisplayValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutDisplayValue as LayoutDisplayValue;
    /// `LayoutFlexDirectionValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexDirectionValue as LayoutFlexDirectionValue;
    /// `LayoutFlexGrowValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexGrowValue as LayoutFlexGrowValue;
    /// `LayoutFlexShrinkValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexShrinkValue as LayoutFlexShrinkValue;
    /// `LayoutFlexWrapValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFlexWrapValue as LayoutFlexWrapValue;
    /// `LayoutFloatValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutFloatValue as LayoutFloatValue;
    /// `LayoutHeightValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutHeightValue as LayoutHeightValue;
    /// `LayoutJustifyContentValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutJustifyContentValue as LayoutJustifyContentValue;
    /// `LayoutLeftValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutLeftValue as LayoutLeftValue;
    /// `LayoutMarginBottomValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginBottomValue as LayoutMarginBottomValue;
    /// `LayoutMarginLeftValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginLeftValue as LayoutMarginLeftValue;
    /// `LayoutMarginRightValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginRightValue as LayoutMarginRightValue;
    /// `LayoutMarginTopValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMarginTopValue as LayoutMarginTopValue;
    /// `LayoutMaxHeightValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMaxHeightValue as LayoutMaxHeightValue;
    /// `LayoutMaxWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMaxWidthValue as LayoutMaxWidthValue;
    /// `LayoutMinHeightValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMinHeightValue as LayoutMinHeightValue;
    /// `LayoutMinWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutMinWidthValue as LayoutMinWidthValue;
    /// `LayoutOverflowValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutOverflowValue as LayoutOverflowValue;
    /// `LayoutPaddingBottomValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingBottomValue as LayoutPaddingBottomValue;
    /// `LayoutPaddingLeftValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingLeftValue as LayoutPaddingLeftValue;
    /// `LayoutPaddingRightValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingRightValue as LayoutPaddingRightValue;
    /// `LayoutPaddingTopValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPaddingTopValue as LayoutPaddingTopValue;
    /// `LayoutPositionValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutPositionValue as LayoutPositionValue;
    /// `LayoutRightValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutRightValue as LayoutRightValue;
    /// `LayoutTopValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutTopValue as LayoutTopValue;
    /// `LayoutWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzLayoutWidthValue as LayoutWidthValue;
    /// `LinearGradient` struct

    #[doc(inline)]
    pub use crate::dll::AzLinearGradient as LinearGradient;
    /// `NormalizedLinearColorStop` struct

    #[doc(inline)]
    pub use crate::dll::AzNormalizedLinearColorStop as NormalizedLinearColorStop;
    /// `NormalizedRadialColorStop` struct

    #[doc(inline)]
    pub use crate::dll::AzNormalizedRadialColorStop as NormalizedRadialColorStop;
    /// `RadialGradient` struct

    #[doc(inline)]
    pub use crate::dll::AzRadialGradient as RadialGradient;
    /// `RadialGradientSize` struct

    #[doc(inline)]
    pub use crate::dll::AzRadialGradientSize as RadialGradientSize;
    /// `ScrollbarInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzScrollbarInfo as ScrollbarInfo;
    /// `ScrollbarStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzScrollbarStyle as ScrollbarStyle;
    /// `ScrollbarStyleValue` struct

    #[doc(inline)]
    pub use crate::dll::AzScrollbarStyleValue as ScrollbarStyleValue;
    /// `Shape` struct

    #[doc(inline)]
    pub use crate::dll::AzShape as Shape;
    /// `StyleBackfaceVisibility` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackfaceVisibility as StyleBackfaceVisibility;
    /// `StyleBackfaceVisibilityValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackfaceVisibilityValue as StyleBackfaceVisibilityValue;
    /// `StyleBackgroundContent` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundContent as StyleBackgroundContent;
    /// `StyleBackgroundContentVecValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundContentVecValue as StyleBackgroundContentVecValue;
    /// `StyleBackgroundPosition` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundPosition as StyleBackgroundPosition;
    /// `StyleBackgroundPositionVecValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundPositionVecValue as StyleBackgroundPositionVecValue;
    /// `StyleBackgroundRepeat` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundRepeat as StyleBackgroundRepeat;
    /// `StyleBackgroundRepeatVecValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundRepeatVecValue as StyleBackgroundRepeatVecValue;
    /// `StyleBackgroundSize` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundSize as StyleBackgroundSize;
    /// `StyleBackgroundSizeVecValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundSizeVecValue as StyleBackgroundSizeVecValue;
    /// `StyleBorderBottomColor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomColor as StyleBorderBottomColor;
    /// `StyleBorderBottomColorValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomColorValue as StyleBorderBottomColorValue;
    /// `StyleBorderBottomLeftRadius` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomLeftRadius as StyleBorderBottomLeftRadius;
    /// `StyleBorderBottomLeftRadiusValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomLeftRadiusValue as StyleBorderBottomLeftRadiusValue;
    /// `StyleBorderBottomRightRadius` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomRightRadius as StyleBorderBottomRightRadius;
    /// `StyleBorderBottomRightRadiusValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomRightRadiusValue as StyleBorderBottomRightRadiusValue;
    /// `StyleBorderBottomStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomStyle as StyleBorderBottomStyle;
    /// `StyleBorderBottomStyleValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderBottomStyleValue as StyleBorderBottomStyleValue;
    /// `StyleBorderLeftColor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderLeftColor as StyleBorderLeftColor;
    /// `StyleBorderLeftColorValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderLeftColorValue as StyleBorderLeftColorValue;
    /// `StyleBorderLeftStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderLeftStyle as StyleBorderLeftStyle;
    /// `StyleBorderLeftStyleValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderLeftStyleValue as StyleBorderLeftStyleValue;
    /// `StyleBorderRightColor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderRightColor as StyleBorderRightColor;
    /// `StyleBorderRightColorValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderRightColorValue as StyleBorderRightColorValue;
    /// `StyleBorderRightStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderRightStyle as StyleBorderRightStyle;
    /// `StyleBorderRightStyleValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderRightStyleValue as StyleBorderRightStyleValue;
    /// `StyleBorderTopColor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopColor as StyleBorderTopColor;
    /// `StyleBorderTopColorValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopColorValue as StyleBorderTopColorValue;
    /// `StyleBorderTopLeftRadius` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopLeftRadius as StyleBorderTopLeftRadius;
    /// `StyleBorderTopLeftRadiusValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopLeftRadiusValue as StyleBorderTopLeftRadiusValue;
    /// `StyleBorderTopRightRadius` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopRightRadius as StyleBorderTopRightRadius;
    /// `StyleBorderTopRightRadiusValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopRightRadiusValue as StyleBorderTopRightRadiusValue;
    /// `StyleBorderTopStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopStyle as StyleBorderTopStyle;
    /// `StyleBorderTopStyleValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBorderTopStyleValue as StyleBorderTopStyleValue;
    /// `StyleBoxShadowValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBoxShadowValue as StyleBoxShadowValue;
    /// `StyleCursor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleCursor as StyleCursor;
    /// `StyleCursorValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleCursorValue as StyleCursorValue;
    /// `StyleFilterVecValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFilterVecValue as StyleFilterVecValue;
    /// `StyleFontFamily` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFontFamily as StyleFontFamily;
    /// `StyleFontFamilyVecValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFontFamilyVecValue as StyleFontFamilyVecValue;
    /// `StyleFontSize` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFontSize as StyleFontSize;
    /// `StyleFontSizeValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFontSizeValue as StyleFontSizeValue;
    /// `StyleLetterSpacing` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleLetterSpacing as StyleLetterSpacing;
    /// `StyleLetterSpacingValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleLetterSpacingValue as StyleLetterSpacingValue;
    /// `StyleLineHeight` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleLineHeight as StyleLineHeight;
    /// `StyleLineHeightValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleLineHeightValue as StyleLineHeightValue;
    /// `StyleMixBlendModeValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleMixBlendModeValue as StyleMixBlendModeValue;
    /// `StyleOpacity` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleOpacity as StyleOpacity;
    /// `StyleOpacityValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleOpacityValue as StyleOpacityValue;
    /// `StylePerspectiveOrigin` struct

    #[doc(inline)]
    pub use crate::dll::AzStylePerspectiveOrigin as StylePerspectiveOrigin;
    /// `StylePerspectiveOriginValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStylePerspectiveOriginValue as StylePerspectiveOriginValue;
    /// `StyleTabWidth` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTabWidth as StyleTabWidth;
    /// `StyleTabWidthValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTabWidthValue as StyleTabWidthValue;
    /// `StyleTextAlign` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTextAlign as StyleTextAlign;
    /// `StyleTextAlignValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTextAlignValue as StyleTextAlignValue;
    /// `StyleTextColor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTextColor as StyleTextColor;
    /// `StyleTextColorValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTextColorValue as StyleTextColorValue;
    /// `StyleTransform` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransform as StyleTransform;
    /// `StyleTransformMatrix2D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformMatrix2D as StyleTransformMatrix2D;
    /// `StyleTransformMatrix3D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformMatrix3D as StyleTransformMatrix3D;
    /// `StyleTransformOrigin` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformOrigin as StyleTransformOrigin;
    /// `StyleTransformOriginValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformOriginValue as StyleTransformOriginValue;
    /// `StyleTransformRotate3D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformRotate3D as StyleTransformRotate3D;
    /// `StyleTransformScale2D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformScale2D as StyleTransformScale2D;
    /// `StyleTransformScale3D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformScale3D as StyleTransformScale3D;
    /// `StyleTransformSkew2D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformSkew2D as StyleTransformSkew2D;
    /// `StyleTransformTranslate2D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformTranslate2D as StyleTransformTranslate2D;
    /// `StyleTransformTranslate3D` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformTranslate3D as StyleTransformTranslate3D;
    /// `StyleTransformVecValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformVecValue as StyleTransformVecValue;
    /// `StyleWordSpacing` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleWordSpacing as StyleWordSpacing;
    /// `StyleWordSpacingValue` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleWordSpacingValue as StyleWordSpacingValue;
    impl CssProperty {
        /// Returns the key of the CSS property as a string, i.e. `background`
        pub fn get_key_string(&self) -> crate::str::String {
            unsafe { crate::dll::AzCssProperty_getKeyString(self) }
        }
        /// Returns the value of the CSS property as a string, i.e. `linear-gradient(red, blue)`
        pub fn get_value_string(&self) -> crate::str::String {
            unsafe { crate::dll::AzCssProperty_getValueString(self) }
        }
        /// Returns the CSS key-value pair as a string, i.e. `background: linear-gradient(red,
        /// blue)`
        pub fn get_key_value_string(&self) -> crate::str::String {
            unsafe { crate::dll::AzCssProperty_getKeyValueString(self) }
        }
        /// Interpolates two CSS properties given a value `t` ranging from 0.0 to 1.0. The
        /// interpolation function can be set on the `context` (`Ease`, `Linear`, etc.).
        pub fn interpolate<_1: Into<CssProperty>, _3: Into<InterpolateContext>>(
            &self,
            other: _1,
            t: f32,
            context: _3,
        ) -> crate::css::CssProperty {
            unsafe { crate::dll::AzCssProperty_interpolate(self, other.into(), t, context.into()) }
        }
    }
}

pub mod widgets {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Default, built-in widgets (button, label, textinput, etc.)
    use core::ffi::c_void;

    /// `Ribbon` struct

    #[doc(inline)]
    pub use crate::dll::AzRibbon as Ribbon;
    use crate::{
        callbacks::{CallbackType, RefAny},
        css::{ColorU, PixelValue},
        dll::*,
        dom::Dom,
        option::OptionString,
        str::String,
        vec::{ListViewRowVec, NodeDataInlineCssPropertyVec, StringVec, StyleBackgroundContentVec},
    };
    impl Ribbon {
        /// Calls the `Ribbon::dom` function.
        pub fn dom<_1: Into<RibbonOnTabClickedCallback>, _2: Into<RefAny>>(
            &mut self,
            callback: _1,
            data: _2,
        ) -> crate::dom::Dom {
            unsafe { crate::dll::AzRibbon_dom(self, callback.into(), data.into()) }
        }
    }

    /// `Button` struct

    #[doc(inline)]
    pub use crate::dll::AzButton as Button;
    /// `RibbonOnTabClickedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzRibbonOnTabClickedCallback as RibbonOnTabClickedCallback;
    /// `RibbonOnTabClickedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzRibbonOnTabClickedCallbackType as RibbonOnTabClickedCallbackType;
    impl Button {
        /// Creates a new labeled button
        pub fn new<_1: Into<String>>(label: _1) -> Self {
            unsafe { crate::dll::AzButton_new(label.into()) }
        }
        /// Calls the `Button::set_on_click` function.
        pub fn set_on_click<_1: Into<RefAny>>(&mut self, data: _1, callback: CallbackType) {
            unsafe { crate::dll::AzButton_setOnClick(self, data.into(), callback) }
        }
        /// Calls the `Button::with_on_click` function.
        pub fn with_on_click<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: CallbackType,
        ) -> crate::widgets::Button {
            unsafe { crate::dll::AzButton_withOnClick(self, data.into(), callback) }
        }
        /// Calls the `Button::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzButton_dom(self) }
        }
    }

    /// `ButtonOnClick` struct

    #[doc(inline)]
    pub use crate::dll::AzButtonOnClick as ButtonOnClick;
    /// `FileInput` struct

    #[doc(inline)]
    pub use crate::dll::AzFileInput as FileInput;
    impl FileInput {
        /// Creates a new file input button
        pub fn new<_1: Into<OptionString>>(path: _1) -> Self {
            unsafe { crate::dll::AzFileInput_new(path.into()) }
        }
        /// Calls the `FileInput::set_default_text` function.
        pub fn set_default_text<_1: Into<String>>(&mut self, default_text: _1) {
            unsafe { crate::dll::AzFileInput_setDefaultText(self, default_text.into()) }
        }
        /// Calls the `FileInput::with_default_text` function.
        pub fn with_default_text<_1: Into<String>>(
            &mut self,
            default_text: _1,
        ) -> crate::widgets::FileInput {
            unsafe { crate::dll::AzFileInput_withDefaultText(self, default_text.into()) }
        }
        /// Calls the `FileInput::set_on_path_change` function.
        pub fn set_on_path_change<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: FileInputOnPathChangeCallbackType,
        ) {
            unsafe { crate::dll::AzFileInput_setOnPathChange(self, data.into(), callback) }
        }
        /// Calls the `FileInput::with_on_path_change` function.
        pub fn with_on_path_change<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: FileInputOnPathChangeCallbackType,
        ) -> crate::widgets::FileInput {
            unsafe { crate::dll::AzFileInput_withOnPathChange(self, data.into(), callback) }
        }
        /// Calls the `FileInput::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzFileInput_dom(self) }
        }
    }

    /// `CheckBox` struct

    #[doc(inline)]
    pub use crate::dll::AzCheckBox as CheckBox;
    /// `FileInputOnPathChange` struct

    #[doc(inline)]
    pub use crate::dll::AzFileInputOnPathChange as FileInputOnPathChange;
    /// `FileInputOnPathChangeCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzFileInputOnPathChangeCallback as FileInputOnPathChangeCallback;
    /// `FileInputOnPathChangeCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzFileInputOnPathChangeCallbackType as FileInputOnPathChangeCallbackType;
    /// `FileInputState` struct

    #[doc(inline)]
    pub use crate::dll::AzFileInputState as FileInputState;
    /// `FileInputStateWrapper` struct

    #[doc(inline)]
    pub use crate::dll::AzFileInputStateWrapper as FileInputStateWrapper;
    impl CheckBox {
        /// Creates a new checkbox, disabled or enabled
        pub fn new(checked: bool) -> Self {
            unsafe { crate::dll::AzCheckBox_new(checked) }
        }
        /// Calls the `CheckBox::set_on_toggle` function.
        pub fn set_on_toggle<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: CheckBoxOnToggleCallbackType,
        ) {
            unsafe { crate::dll::AzCheckBox_setOnToggle(self, data.into(), callback) }
        }
        /// Calls the `CheckBox::with_on_toggle` function.
        pub fn with_on_toggle<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: CheckBoxOnToggleCallbackType,
        ) -> crate::widgets::CheckBox {
            unsafe { crate::dll::AzCheckBox_withOnToggle(self, data.into(), callback) }
        }
        /// Calls the `CheckBox::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzCheckBox_dom(self) }
        }
    }

    /// `CheckBoxOnToggle` struct

    #[doc(inline)]
    pub use crate::dll::AzCheckBoxOnToggle as CheckBoxOnToggle;
    /// `CheckBoxOnToggleCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzCheckBoxOnToggleCallback as CheckBoxOnToggleCallback;
    /// `CheckBoxOnToggleCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzCheckBoxOnToggleCallbackType as CheckBoxOnToggleCallbackType;
    /// `CheckBoxState` struct

    #[doc(inline)]
    pub use crate::dll::AzCheckBoxState as CheckBoxState;
    /// `CheckBoxStateWrapper` struct

    #[doc(inline)]
    pub use crate::dll::AzCheckBoxStateWrapper as CheckBoxStateWrapper;
    /// `Label` struct

    #[doc(inline)]
    pub use crate::dll::AzLabel as Label;
    impl Label {
        /// Creates a new `Label` instance.
        pub fn new<_1: Into<String>>(text: _1) -> Self {
            unsafe { crate::dll::AzLabel_new(text.into()) }
        }
        /// Calls the `Label::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzLabel_dom(self) }
        }
    }

    /// `ColorInput` struct

    #[doc(inline)]
    pub use crate::dll::AzColorInput as ColorInput;
    impl ColorInput {
        /// Creates a new `ColorInput` instance.
        pub fn new<_1: Into<ColorU>>(color: _1) -> Self {
            unsafe { crate::dll::AzColorInput_new(color.into()) }
        }
        /// Calls the `ColorInput::set_on_value_change` function.
        pub fn set_on_value_change<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: ColorInputOnValueChangeCallbackType,
        ) {
            unsafe { crate::dll::AzColorInput_setOnValueChange(self, data.into(), callback) }
        }
        /// Calls the `ColorInput::with_on_value_change` function.
        pub fn with_on_value_change<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: ColorInputOnValueChangeCallbackType,
        ) -> crate::widgets::ColorInput {
            unsafe { crate::dll::AzColorInput_withOnValueChange(self, data.into(), callback) }
        }
        /// Calls the `ColorInput::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzColorInput_dom(self) }
        }
    }

    /// `ColorInputOnValueChange` struct

    #[doc(inline)]
    pub use crate::dll::AzColorInputOnValueChange as ColorInputOnValueChange;
    /// `ColorInputOnValueChangeCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzColorInputOnValueChangeCallback as ColorInputOnValueChangeCallback;
    /// `ColorInputOnValueChangeCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzColorInputOnValueChangeCallbackType as ColorInputOnValueChangeCallbackType;
    /// `ColorInputState` struct

    #[doc(inline)]
    pub use crate::dll::AzColorInputState as ColorInputState;
    /// `ColorInputStateWrapper` struct

    #[doc(inline)]
    pub use crate::dll::AzColorInputStateWrapper as ColorInputStateWrapper;
    /// `TextInput` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInput as TextInput;
    impl TextInput {
        /// Creates a new `TextInput` instance.
        pub fn new() -> Self {
            unsafe { crate::dll::AzTextInput_new() }
        }
        /// Calls the `TextInput::set_text` function.
        pub fn set_text<_1: Into<String>>(&mut self, text: _1) {
            unsafe { crate::dll::AzTextInput_setText(self, text.into()) }
        }
        /// Calls the `TextInput::with_text` function.
        pub fn with_text<_1: Into<String>>(&mut self, text: _1) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withText(self, text.into()) }
        }
        /// Calls the `TextInput::set_placeholder` function.
        pub fn set_placeholder<_1: Into<String>>(&mut self, text: _1) {
            unsafe { crate::dll::AzTextInput_setPlaceholder(self, text.into()) }
        }
        /// Calls the `TextInput::with_placeholder` function.
        pub fn with_placeholder<_1: Into<String>>(
            &mut self,
            text: _1,
        ) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withPlaceholder(self, text.into()) }
        }
        /// Calls the `TextInput::set_on_text_input` function.
        pub fn set_on_text_input<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnTextInputCallbackType,
        ) {
            unsafe { crate::dll::AzTextInput_setOnTextInput(self, data.into(), callback) }
        }
        /// Calls the `TextInput::with_on_text_input` function.
        pub fn with_on_text_input<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnTextInputCallbackType,
        ) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withOnTextInput(self, data.into(), callback) }
        }
        /// Calls the `TextInput::set_on_virtual_key_down` function.
        pub fn set_on_virtual_key_down<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnVirtualKeyDownCallbackType,
        ) {
            unsafe { crate::dll::AzTextInput_setOnVirtualKeyDown(self, data.into(), callback) }
        }
        /// Calls the `TextInput::with_on_virtual_key_down` function.
        pub fn with_on_virtual_key_down<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnVirtualKeyDownCallbackType,
        ) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withOnVirtualKeyDown(self, data.into(), callback) }
        }
        /// Calls the `TextInput::set_on_focus_lost` function.
        pub fn set_on_focus_lost<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnFocusLostCallbackType,
        ) {
            unsafe { crate::dll::AzTextInput_setOnFocusLost(self, data.into(), callback) }
        }
        /// Calls the `TextInput::with_on_focus_lost` function.
        pub fn with_on_focus_lost<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnFocusLostCallbackType,
        ) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withOnFocusLost(self, data.into(), callback) }
        }
        /// Calls the `TextInput::set_placeholder_style` function.
        pub fn set_placeholder_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            placeholder_style: _1,
        ) {
            unsafe { crate::dll::AzTextInput_setPlaceholderStyle(self, placeholder_style.into()) }
        }
        /// Calls the `TextInput::with_placeholder_style` function.
        pub fn with_placeholder_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            placeholder_style: _1,
        ) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withPlaceholderStyle(self, placeholder_style.into()) }
        }
        /// Calls the `TextInput::set_container_style` function.
        pub fn set_container_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            container_style: _1,
        ) {
            unsafe { crate::dll::AzTextInput_setContainerStyle(self, container_style.into()) }
        }
        /// Calls the `TextInput::with_container_style` function.
        pub fn with_container_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            container_style: _1,
        ) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withContainerStyle(self, container_style.into()) }
        }
        /// Calls the `TextInput::set_label_style` function.
        pub fn set_label_style<_1: Into<NodeDataInlineCssPropertyVec>>(&mut self, label_style: _1) {
            unsafe { crate::dll::AzTextInput_setLabelStyle(self, label_style.into()) }
        }
        /// Calls the `TextInput::with_label_style` function.
        pub fn with_label_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            label_style: _1,
        ) -> crate::widgets::TextInput {
            unsafe { crate::dll::AzTextInput_withLabelStyle(self, label_style.into()) }
        }
        /// Calls the `TextInput::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzTextInput_dom(self) }
        }
    }

    /// `TextInputState` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputState as TextInputState;
    /// `TextInputStateWrapper` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputStateWrapper as TextInputStateWrapper;
    impl TextInputState {
        /// Calls the `TextInputState::get_text` function.
        pub fn get_text(&self) -> crate::str::String {
            unsafe { crate::dll::AzTextInputState_getText(self) }
        }
    }

    /// `NumberInput` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInput as NumberInput;
    /// `OnTextInputReturn` struct

    #[doc(inline)]
    pub use crate::dll::AzOnTextInputReturn as OnTextInputReturn;
    /// `TextInputOnFocusLost` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnFocusLost as TextInputOnFocusLost;
    /// `TextInputOnFocusLostCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnFocusLostCallback as TextInputOnFocusLostCallback;
    /// `TextInputOnFocusLostCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnFocusLostCallbackType as TextInputOnFocusLostCallbackType;
    /// `TextInputOnTextInput` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnTextInput as TextInputOnTextInput;
    /// `TextInputOnTextInputCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnTextInputCallback as TextInputOnTextInputCallback;
    /// `TextInputOnTextInputCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnTextInputCallbackType as TextInputOnTextInputCallbackType;
    /// `TextInputOnVirtualKeyDown` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnVirtualKeyDown as TextInputOnVirtualKeyDown;
    /// `TextInputOnVirtualKeyDownCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnVirtualKeyDownCallback as TextInputOnVirtualKeyDownCallback;
    /// `TextInputOnVirtualKeyDownCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputOnVirtualKeyDownCallbackType as TextInputOnVirtualKeyDownCallbackType;
    /// `TextInputSelection` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputSelection as TextInputSelection;
    /// `TextInputSelectionRange` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputSelectionRange as TextInputSelectionRange;
    /// `TextInputValid` struct

    #[doc(inline)]
    pub use crate::dll::AzTextInputValid as TextInputValid;
    impl NumberInput {
        /// Creates a new `NumberInput` instance.
        pub fn new(number: f32) -> Self {
            unsafe { crate::dll::AzNumberInput_new(number) }
        }
        /// Calls the `NumberInput::set_on_text_input` function.
        pub fn set_on_text_input<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnTextInputCallbackType,
        ) {
            unsafe { crate::dll::AzNumberInput_setOnTextInput(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::with_on_text_input` function.
        pub fn with_on_text_input<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnTextInputCallbackType,
        ) -> crate::widgets::NumberInput {
            unsafe { crate::dll::AzNumberInput_withOnTextInput(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::set_on_virtual_key_down` function.
        pub fn set_on_virtual_key_down<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnVirtualKeyDownCallbackType,
        ) {
            unsafe { crate::dll::AzNumberInput_setOnVirtualKeyDown(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::with_on_virtual_key_down` function.
        pub fn with_on_virtual_key_down<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TextInputOnVirtualKeyDownCallbackType,
        ) -> crate::widgets::NumberInput {
            unsafe { crate::dll::AzNumberInput_withOnVirtualKeyDown(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::set_on_focus_lost` function.
        pub fn set_on_focus_lost<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: NumberInputOnFocusLostCallbackType,
        ) {
            unsafe { crate::dll::AzNumberInput_setOnFocusLost(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::with_on_focus_lost` function.
        pub fn with_on_focus_lost<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: NumberInputOnFocusLostCallbackType,
        ) -> crate::widgets::NumberInput {
            unsafe { crate::dll::AzNumberInput_withOnFocusLost(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::set_placeholder_style` function.
        pub fn set_placeholder_style<_1: Into<NodeDataInlineCssPropertyVec>>(&mut self, style: _1) {
            unsafe { crate::dll::AzNumberInput_setPlaceholderStyle(self, style.into()) }
        }
        /// Calls the `NumberInput::with_placeholder_style` function.
        pub fn with_placeholder_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            style: _1,
        ) -> crate::widgets::NumberInput {
            unsafe { crate::dll::AzNumberInput_withPlaceholderStyle(self, style.into()) }
        }
        /// Calls the `NumberInput::set_container_style` function.
        pub fn set_container_style<_1: Into<NodeDataInlineCssPropertyVec>>(&mut self, style: _1) {
            unsafe { crate::dll::AzNumberInput_setContainerStyle(self, style.into()) }
        }
        /// Calls the `NumberInput::with_container_style` function.
        pub fn with_container_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            style: _1,
        ) -> crate::widgets::NumberInput {
            unsafe { crate::dll::AzNumberInput_withContainerStyle(self, style.into()) }
        }
        /// Calls the `NumberInput::set_label_style` function.
        pub fn set_label_style<_1: Into<NodeDataInlineCssPropertyVec>>(&mut self, style: _1) {
            unsafe { crate::dll::AzNumberInput_setLabelStyle(self, style.into()) }
        }
        /// Calls the `NumberInput::with_label_style` function.
        pub fn with_label_style<_1: Into<NodeDataInlineCssPropertyVec>>(
            &mut self,
            style: _1,
        ) -> crate::widgets::NumberInput {
            unsafe { crate::dll::AzNumberInput_withLabelStyle(self, style.into()) }
        }
        /// Calls the `NumberInput::set_on_value_change` function.
        pub fn set_on_value_change<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: NumberInputOnValueChangeCallbackType,
        ) {
            unsafe { crate::dll::AzNumberInput_setOnValueChange(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::with_on_value_change` function.
        pub fn with_on_value_change<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: NumberInputOnValueChangeCallbackType,
        ) -> crate::widgets::NumberInput {
            unsafe { crate::dll::AzNumberInput_withOnValueChange(self, data.into(), callback) }
        }
        /// Calls the `NumberInput::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzNumberInput_dom(self) }
        }
    }

    /// `NumberInputOnFocusLost` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputOnFocusLost as NumberInputOnFocusLost;
    /// `NumberInputOnFocusLostCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputOnFocusLostCallback as NumberInputOnFocusLostCallback;
    /// `NumberInputOnFocusLostCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputOnFocusLostCallbackType as NumberInputOnFocusLostCallbackType;
    /// `NumberInputOnValueChange` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputOnValueChange as NumberInputOnValueChange;
    /// `NumberInputOnValueChangeCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputOnValueChangeCallback as NumberInputOnValueChangeCallback;
    /// `NumberInputOnValueChangeCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputOnValueChangeCallbackType as NumberInputOnValueChangeCallbackType;
    /// `NumberInputState` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputState as NumberInputState;
    /// `NumberInputStateWrapper` struct

    #[doc(inline)]
    pub use crate::dll::AzNumberInputStateWrapper as NumberInputStateWrapper;
    /// `ProgressBar` struct

    #[doc(inline)]
    pub use crate::dll::AzProgressBar as ProgressBar;
    impl ProgressBar {
        /// Creates a new `ProgressBar` instance.
        pub fn new(percent_done: f32) -> Self {
            unsafe { crate::dll::AzProgressBar_new(percent_done) }
        }
        /// Calls the `ProgressBar::set_height` function.
        pub fn set_height<_1: Into<PixelValue>>(&mut self, height: _1) {
            unsafe { crate::dll::AzProgressBar_setHeight(self, height.into()) }
        }
        /// Calls the `ProgressBar::with_height` function.
        pub fn with_height<_1: Into<PixelValue>>(
            &mut self,
            height: _1,
        ) -> crate::widgets::ProgressBar {
            unsafe { crate::dll::AzProgressBar_withHeight(self, height.into()) }
        }
        /// Calls the `ProgressBar::set_container_background` function.
        pub fn set_container_background<_1: Into<StyleBackgroundContentVec>>(
            &mut self,
            background: _1,
        ) {
            unsafe { crate::dll::AzProgressBar_setContainerBackground(self, background.into()) }
        }
        /// Calls the `ProgressBar::with_container_style` function.
        pub fn with_container_style<_1: Into<StyleBackgroundContentVec>>(
            &mut self,
            background: _1,
        ) -> crate::widgets::ProgressBar {
            unsafe { crate::dll::AzProgressBar_withContainerStyle(self, background.into()) }
        }
        /// Calls the `ProgressBar::set_bar_background` function.
        pub fn set_bar_background<_1: Into<StyleBackgroundContentVec>>(&mut self, background: _1) {
            unsafe { crate::dll::AzProgressBar_setBarBackground(self, background.into()) }
        }
        /// Calls the `ProgressBar::with_bar_background` function.
        pub fn with_bar_background<_1: Into<StyleBackgroundContentVec>>(
            &mut self,
            background: _1,
        ) -> crate::widgets::ProgressBar {
            unsafe { crate::dll::AzProgressBar_withBarBackground(self, background.into()) }
        }
        /// Calls the `ProgressBar::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzProgressBar_dom(self) }
        }
    }

    /// `ProgressBarState` struct

    #[doc(inline)]
    pub use crate::dll::AzProgressBarState as ProgressBarState;
    /// `TabHeader` struct

    #[doc(inline)]
    pub use crate::dll::AzTabHeader as TabHeader;
    impl TabHeader {
        /// Creates a new `TabHeader` instance.
        pub fn new<_1: Into<StringVec>>(tabs: _1) -> Self {
            unsafe { crate::dll::AzTabHeader_new(tabs.into()) }
        }
        /// Calls the `TabHeader::set_active_tab` function.
        pub fn set_active_tab(&mut self, active_tab: usize) {
            unsafe { crate::dll::AzTabHeader_setActiveTab(self, active_tab) }
        }
        /// Calls the `TabHeader::with_active_tab` function.
        pub fn with_active_tab(&mut self, active_tab: usize) -> crate::widgets::TabHeader {
            unsafe { crate::dll::AzTabHeader_withActiveTab(self, active_tab) }
        }
        /// Calls the `TabHeader::set_on_click` function.
        pub fn set_on_click<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TabOnClickCallbackType,
        ) {
            unsafe { crate::dll::AzTabHeader_setOnClick(self, data.into(), callback) }
        }
        /// Calls the `TabHeader::with_on_click` function.
        pub fn with_on_click<_1: Into<RefAny>>(
            &mut self,
            data: _1,
            callback: TabOnClickCallbackType,
        ) -> crate::widgets::TabHeader {
            unsafe { crate::dll::AzTabHeader_withOnClick(self, data.into(), callback) }
        }
        /// Calls the `TabHeader::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzTabHeader_dom(self) }
        }
    }

    /// `TabContent` struct

    #[doc(inline)]
    pub use crate::dll::AzTabContent as TabContent;
    /// `TabHeaderState` struct

    #[doc(inline)]
    pub use crate::dll::AzTabHeaderState as TabHeaderState;
    impl TabContent {
        /// Creates a new `TabContent` instance.
        pub fn new<_1: Into<Dom>>(content: _1) -> Self {
            unsafe { crate::dll::AzTabContent_new(content.into()) }
        }
        /// Calls the `TabContent::set_padding` function.
        pub fn set_padding(&mut self, has_padding: bool) {
            unsafe { crate::dll::AzTabContent_setPadding(self, has_padding) }
        }
        /// Calls the `TabContent::with_padding` function.
        pub fn with_padding(&mut self, has_padding: bool) -> crate::widgets::TabContent {
            unsafe { crate::dll::AzTabContent_withPadding(self, has_padding) }
        }
        /// Calls the `TabContent::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzTabContent_dom(self) }
        }
    }

    /// `Frame` struct

    #[doc(inline)]
    pub use crate::dll::AzFrame as Frame;
    /// `TabOnClick` struct

    #[doc(inline)]
    pub use crate::dll::AzTabOnClick as TabOnClick;
    /// `TabOnClickCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzTabOnClickCallback as TabOnClickCallback;
    /// `TabOnClickCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzTabOnClickCallbackType as TabOnClickCallbackType;
    impl Frame {
        /// Creates a new `Frame` instance.
        pub fn new<_1: Into<String>, _2: Into<Dom>>(title: _1, dom: _2) -> Self {
            unsafe { crate::dll::AzFrame_new(title.into(), dom.into()) }
        }
        /// Calls the `Frame::set_flex_grow` function.
        pub fn set_flex_grow(&mut self, flex_grow: f32) {
            unsafe { crate::dll::AzFrame_setFlexGrow(self, flex_grow) }
        }
        /// Calls the `Frame::with_flex_grow` function.
        pub fn with_flex_grow(&mut self, flex_grow: f32) -> crate::widgets::Frame {
            unsafe { crate::dll::AzFrame_withFlexGrow(self, flex_grow) }
        }
        /// Calls the `Frame::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzFrame_dom(self) }
        }
    }

    /// `NodeGraph` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraph as NodeGraph;
    impl NodeGraph {
        /// Calls the `NodeGraph::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzNodeGraph_dom(self) }
        }
    }

    /// `GraphDragAmount` struct

    #[doc(inline)]
    pub use crate::dll::AzGraphDragAmount as GraphDragAmount;
    /// `InputConnection` struct

    #[doc(inline)]
    pub use crate::dll::AzInputConnection as InputConnection;
    /// `InputNodeAndIndex` struct

    #[doc(inline)]
    pub use crate::dll::AzInputNodeAndIndex as InputNodeAndIndex;
    /// `InputOutputInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzInputOutputInfo as InputOutputInfo;
    /// `InputOutputTypeId` struct

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeId as InputOutputTypeId;
    /// `InputOutputTypeIdInfoMap` struct

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeIdInfoMap as InputOutputTypeIdInfoMap;
    /// `ListView` struct

    #[doc(inline)]
    pub use crate::dll::AzListView as ListView;
    /// `Node` struct

    #[doc(inline)]
    pub use crate::dll::AzNode as Node;
    /// `NodeDragAmount` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeDragAmount as NodeDragAmount;
    /// `NodeGraphCallbacks` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphCallbacks as NodeGraphCallbacks;
    /// `NodeGraphNodeId` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphNodeId as NodeGraphNodeId;
    /// `NodeGraphOnNodeAdded` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeAdded as NodeGraphOnNodeAdded;
    /// `NodeGraphOnNodeAddedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeAddedCallback as NodeGraphOnNodeAddedCallback;
    /// `NodeGraphOnNodeAddedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeAddedCallbackType as NodeGraphOnNodeAddedCallbackType;
    /// `NodeGraphOnNodeConnected` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeConnected as NodeGraphOnNodeConnected;
    /// `NodeGraphOnNodeConnectedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeConnectedCallback as NodeGraphOnNodeConnectedCallback;
    /// `NodeGraphOnNodeConnectedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeConnectedCallbackType as NodeGraphOnNodeConnectedCallbackType;
    /// `NodeGraphOnNodeDragged` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeDragged as NodeGraphOnNodeDragged;
    /// `NodeGraphOnNodeDraggedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeDraggedCallback as NodeGraphOnNodeDraggedCallback;
    /// `NodeGraphOnNodeDraggedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeDraggedCallbackType as NodeGraphOnNodeDraggedCallbackType;
    /// `NodeGraphOnNodeFieldEdited` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeFieldEdited as NodeGraphOnNodeFieldEdited;
    /// `NodeGraphOnNodeFieldEditedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeFieldEditedCallback as NodeGraphOnNodeFieldEditedCallback;
    /// `NodeGraphOnNodeFieldEditedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeFieldEditedCallbackType as NodeGraphOnNodeFieldEditedCallbackType;
    /// `NodeGraphOnNodeGraphDragged` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeGraphDragged as NodeGraphOnNodeGraphDragged;
    /// `NodeGraphOnNodeGraphDraggedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeGraphDraggedCallback as NodeGraphOnNodeGraphDraggedCallback;
    /// `NodeGraphOnNodeGraphDraggedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeGraphDraggedCallbackType as NodeGraphOnNodeGraphDraggedCallbackType;
    /// `NodeGraphOnNodeInputDisconnected` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeInputDisconnected as NodeGraphOnNodeInputDisconnected;
    /// `NodeGraphOnNodeInputDisconnectedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeInputDisconnectedCallback as NodeGraphOnNodeInputDisconnectedCallback;
    /// `NodeGraphOnNodeInputDisconnectedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeInputDisconnectedCallbackType as NodeGraphOnNodeInputDisconnectedCallbackType;
    /// `NodeGraphOnNodeOutputDisconnected` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeOutputDisconnected as NodeGraphOnNodeOutputDisconnected;
    /// `NodeGraphOnNodeOutputDisconnectedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeOutputDisconnectedCallback as NodeGraphOnNodeOutputDisconnectedCallback;
    /// `NodeGraphOnNodeOutputDisconnectedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeOutputDisconnectedCallbackType as NodeGraphOnNodeOutputDisconnectedCallbackType;
    /// `NodeGraphOnNodeRemoved` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeRemoved as NodeGraphOnNodeRemoved;
    /// `NodeGraphOnNodeRemovedCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeRemovedCallback as NodeGraphOnNodeRemovedCallback;
    /// `NodeGraphOnNodeRemovedCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphOnNodeRemovedCallbackType as NodeGraphOnNodeRemovedCallbackType;
    /// `NodeGraphStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeGraphStyle as NodeGraphStyle;
    /// `NodeIdNodeMap` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeIdNodeMap as NodeIdNodeMap;
    /// `NodePosition` struct

    #[doc(inline)]
    pub use crate::dll::AzNodePosition as NodePosition;
    /// `NodeTypeField` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeField as NodeTypeField;
    /// `NodeTypeFieldValue` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeFieldValue as NodeTypeFieldValue;
    /// `NodeTypeId` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeId as NodeTypeId;
    /// `NodeTypeIdInfoMap` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeIdInfoMap as NodeTypeIdInfoMap;
    /// `NodeTypeInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeInfo as NodeTypeInfo;
    /// `OutputConnection` struct

    #[doc(inline)]
    pub use crate::dll::AzOutputConnection as OutputConnection;
    /// `OutputNodeAndIndex` struct

    #[doc(inline)]
    pub use crate::dll::AzOutputNodeAndIndex as OutputNodeAndIndex;
    impl ListView {
        /// Creates a new `ListView` instance.
        pub fn new<_1: Into<StringVec>>(columns: _1) -> Self {
            unsafe { crate::dll::AzListView_new(columns.into()) }
        }
        /// Calls the `ListView::with_rows` function.
        pub fn with_rows<_1: Into<ListViewRowVec>>(
            &mut self,
            rows: _1,
        ) -> crate::widgets::ListView {
            unsafe { crate::dll::AzListView_withRows(self, rows.into()) }
        }
        /// Calls the `ListView::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzListView_dom(self) }
        }
    }

    /// `ListViewOnColumnClick` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnColumnClick as ListViewOnColumnClick;
    /// `ListViewOnColumnClickCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnColumnClickCallback as ListViewOnColumnClickCallback;
    /// `ListViewOnColumnClickCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnColumnClickCallbackType as ListViewOnColumnClickCallbackType;
    /// `ListViewOnLazyLoadScroll` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnLazyLoadScroll as ListViewOnLazyLoadScroll;
    /// `ListViewOnLazyLoadScrollCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnLazyLoadScrollCallback as ListViewOnLazyLoadScrollCallback;
    /// `ListViewOnLazyLoadScrollCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnLazyLoadScrollCallbackType as ListViewOnLazyLoadScrollCallbackType;
    /// `ListViewOnRowClick` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnRowClick as ListViewOnRowClick;
    /// `ListViewOnRowClickCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnRowClickCallback as ListViewOnRowClickCallback;
    /// `ListViewOnRowClickCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewOnRowClickCallbackType as ListViewOnRowClickCallbackType;
    /// `ListViewRow` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewRow as ListViewRow;
    /// `ListViewState` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewState as ListViewState;
    /// `TreeView` struct

    #[doc(inline)]
    pub use crate::dll::AzTreeView as TreeView;
    impl TreeView {
        /// Creates a new `TreeView` instance.
        pub fn new<_1: Into<String>>(root: _1) -> Self {
            unsafe { crate::dll::AzTreeView_new(root.into()) }
        }
        /// Calls the `TreeView::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzTreeView_dom(self) }
        }
    }

    /// `DropDown` struct

    #[doc(inline)]
    pub use crate::dll::AzDropDown as DropDown;
    impl DropDown {
        /// Creates a new `DropDown` instance.
        pub fn new<_1: Into<StringVec>>(choices: _1) -> Self {
            unsafe { crate::dll::AzDropDown_new(choices.into()) }
        }
        /// Calls the `DropDown::dom` function.
        pub fn dom(&mut self) -> crate::dom::Dom {
            unsafe { crate::dll::AzDropDown_dom(self) }
        }
    }

    /// `DropDownOnChoiceChange` struct

    #[doc(inline)]
    pub use crate::dll::AzDropDownOnChoiceChange as DropDownOnChoiceChange;
    /// `DropDownOnChoiceChangeCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzDropDownOnChoiceChangeCallback as DropDownOnChoiceChangeCallback;
    /// `DropDownOnChoiceChangeCallbackType` struct

    #[doc(inline)]
    pub use crate::dll::AzDropDownOnChoiceChangeCallbackType as DropDownOnChoiceChangeCallbackType;
}

pub mod style {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! DOM to CSS cascading and styling module
    use core::ffi::c_void;

    /// `CascadeInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzCascadeInfo as CascadeInfo;
    /// `CssPropertyCache` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPropertyCache as CssPropertyCache;
    /// `CssPropertySource` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPropertySource as CssPropertySource;
    /// `NodeHierarchyItem` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeHierarchyItem as NodeHierarchyItem;
    /// `ParentWithNodeDepth` struct

    #[doc(inline)]
    pub use crate::dll::AzParentWithNodeDepth as ParentWithNodeDepth;
    /// `StyledNode` struct

    #[doc(inline)]
    pub use crate::dll::AzStyledNode as StyledNode;
    /// `StyledNodeState` struct

    #[doc(inline)]
    pub use crate::dll::AzStyledNodeState as StyledNodeState;
    /// `TagId` struct

    #[doc(inline)]
    pub use crate::dll::AzTagId as TagId;
    /// `TagIdToNodeIdMapping` struct

    #[doc(inline)]
    pub use crate::dll::AzTagIdToNodeIdMapping as TagIdToNodeIdMapping;
    use crate::{css::Css, dll::*, dom::Dom, menu::Menu, str::String};
    impl Clone for CssPropertyCache {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzCssPropertyCache_deepCopy(self) }
        }
    }
    impl Drop for CssPropertyCache {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzCssPropertyCache_delete(self) }
            }
        }
    }
    /// `StyledDom` struct

    #[doc(inline)]
    pub use crate::dll::AzStyledDom as StyledDom;
    impl StyledDom {
        /// Styles a `Dom` with the given `Css`, returning the `StyledDom` - complexity
        /// `O(count(dom_nodes) * count(css_blocks))`: make sure that the `Dom` and the `Css` are as
        /// small as possible, use inline CSS if the performance isn't good enough
        pub fn new<_1: Into<Dom>, _2: Into<Css>>(dom: _1, css: _2) -> Self {
            unsafe { crate::dll::AzStyledDom_new(dom.into(), css.into()) }
        }
        /// Returns a default, empty `Dom`, usually returned if you don't want to crash in an error
        /// case.
        pub fn default() -> Self {
            unsafe { crate::dll::AzStyledDom_default() }
        }
        /// Returns a DOM loaded from an XML file
        pub fn from_xml<_1: Into<String>>(xml_string: _1) -> Self {
            unsafe { crate::dll::AzStyledDom_fromXml(xml_string.into()) }
        }
        /// Same as `from_xml`, but loads the file relative to the current directory
        pub fn from_file<_1: Into<String>>(xml_file_path: _1) -> Self {
            unsafe { crate::dll::AzStyledDom_fromFile(xml_file_path.into()) }
        }
        /// Appends an already styled list of DOM nodes to the current `dom.root` - complexity
        /// `O(count(dom.dom_nodes))`
        pub fn append_child<_1: Into<StyledDom>>(&mut self, dom: _1) {
            unsafe { crate::dll::AzStyledDom_appendChild(self, dom.into()) }
        }
        /// Same as `append_child()`, but as a builder method
        pub fn with_child<_1: Into<StyledDom>>(&mut self, dom: _1) -> crate::style::StyledDom {
            unsafe { crate::dll::AzStyledDom_withChild(self, dom.into()) }
        }
        /// Restyles an already styled DOM with a new CSS - overwrites old styles, but does not
        /// replace them, useful for implementing user styles that are applied on top of the
        /// existing application style
        pub fn restyle<_1: Into<Css>>(&mut self, css: _1) {
            unsafe { crate::dll::AzStyledDom_restyle(self, css.into()) }
        }
        /// Returns the number of nodes in the styled DOM
        pub fn node_count(&self) -> usize {
            unsafe { crate::dll::AzStyledDom_nodeCount(self) }
        }
        /// Returns a HTML string that you can write to a file in order to debug the UI structure
        /// and debug potential cascading issues
        pub fn get_html_string(&self) -> crate::str::String {
            unsafe { crate::dll::AzStyledDom_getHtmlString(self) }
        }
        /// Returns a HTML for unit testing
        pub fn get_html_string_test(&self) -> crate::str::String {
            unsafe { crate::dll::AzStyledDom_getHtmlStringTest(self) }
        }
        /// Adds a menu to the root node
        pub fn set_menu_bar<_1: Into<Menu>>(&mut self, menu: _1) {
            unsafe { crate::dll::AzStyledDom_setMenuBar(self, menu.into()) }
        }
        /// Adds a menu to the root node (builder method)
        pub fn with_menu_bar<_1: Into<Menu>>(&mut self, menu: _1) -> crate::style::StyledDom {
            unsafe { crate::dll::AzStyledDom_withMenuBar(self, menu.into()) }
        }
        /// Adds a context menu to the root node
        pub fn set_context_menu<_1: Into<Menu>>(&mut self, menu: _1) {
            unsafe { crate::dll::AzStyledDom_setContextMenu(self, menu.into()) }
        }
        /// Adds a context menu to the root node (builder method)
        pub fn with_context_menu<_1: Into<Menu>>(&mut self, menu: _1) -> crate::style::StyledDom {
            unsafe { crate::dll::AzStyledDom_withContextMenu(self, menu.into()) }
        }
    }
}

pub mod gl {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! OpenGl helper types (`Texture`, `Gl`, etc.)
    use core::ffi::c_void;

    use crate::dll::*;

    impl Refstr {
        fn as_str(&self) -> &str {
            unsafe {
                core::str::from_utf8_unchecked(core::slice::from_raw_parts(self.ptr, self.len))
            }
        }
    }

    impl From<&str> for Refstr {
        fn from(s: &str) -> Self {
            Self {
                ptr: s.as_ptr(),
                len: s.len(),
            }
        }
    }

    impl RefstrVecRef {
        fn as_slice(&self) -> &[Refstr] {
            unsafe { core::slice::from_raw_parts(self.ptr, self.len) }
        }
    }

    impl From<&[Refstr]> for RefstrVecRef {
        fn from(s: &[Refstr]) -> Self {
            Self {
                ptr: s.as_ptr(),
                len: s.len(),
            }
        }
    }

    impl From<&mut [GLint64]> for GLint64VecRefMut {
        fn from(s: &mut [GLint64]) -> Self {
            Self {
                ptr: s.as_mut_ptr(),
                len: s.len(),
            }
        }
    }

    impl GLint64VecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLint64] {
            unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) }
        }
    }

    impl From<&mut [GLfloat]> for GLfloatVecRefMut {
        fn from(s: &mut [GLfloat]) -> Self {
            Self {
                ptr: s.as_mut_ptr(),
                len: s.len(),
            }
        }
    }

    impl GLfloatVecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLfloat] {
            unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) }
        }
    }

    impl From<&mut [GLint]> for GLintVecRefMut {
        fn from(s: &mut [GLint]) -> Self {
            Self {
                ptr: s.as_mut_ptr(),
                len: s.len(),
            }
        }
    }

    impl GLintVecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLint] {
            unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) }
        }
    }

    impl From<&[GLuint]> for GLuintVecRef {
        fn from(s: &[GLuint]) -> Self {
            Self {
                ptr: s.as_ptr(),
                len: s.len(),
            }
        }
    }

    impl GLuintVecRef {
        fn as_slice(&self) -> &[GLuint] {
            unsafe { core::slice::from_raw_parts(self.ptr, self.len) }
        }
    }

    impl From<&[GLenum]> for GLenumVecRef {
        fn from(s: &[GLenum]) -> Self {
            Self {
                ptr: s.as_ptr(),
                len: s.len(),
            }
        }
    }

    impl GLenumVecRef {
        fn as_slice(&self) -> &[GLenum] {
            unsafe { core::slice::from_raw_parts(self.ptr, self.len) }
        }
    }

    impl From<&[u8]> for U8VecRef {
        fn from(s: &[u8]) -> Self {
            Self {
                ptr: s.as_ptr(),
                len: s.len(),
            }
        }
    }

    impl U8VecRef {
        fn as_slice(&self) -> &[u8] {
            unsafe { core::slice::from_raw_parts(self.ptr, self.len) }
        }
    }

    impl ::core::fmt::Debug for U8VecRef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            self.as_slice().fmt(f)
        }
    }

    impl Clone for U8VecRef {
        fn clone(&self) -> Self {
            U8VecRef::from(self.as_slice())
        }
    }

    impl PartialOrd for U8VecRef {
        fn partial_cmp(&self, rhs: &Self) -> Option<core::cmp::Ordering> {
            self.as_slice().partial_cmp(rhs.as_slice())
        }
    }

    impl Ord for U8VecRef {
        fn cmp(&self, rhs: &Self) -> core::cmp::Ordering {
            self.as_slice().cmp(rhs.as_slice())
        }
    }

    impl PartialEq for U8VecRef {
        fn eq(&self, rhs: &Self) -> bool {
            self.as_slice().eq(rhs.as_slice())
        }
    }

    impl Eq for U8VecRef {}

    impl core::hash::Hash for U8VecRef {
        fn hash<H>(&self, state: &mut H)
        where
            H: core::hash::Hasher,
        {
            self.as_slice().hash(state)
        }
    }

    impl From<&[f32]> for F32VecRef {
        fn from(s: &[f32]) -> Self {
            Self {
                ptr: s.as_ptr(),
                len: s.len(),
            }
        }
    }

    impl F32VecRef {
        fn as_slice(&self) -> &[f32] {
            unsafe { core::slice::from_raw_parts(self.ptr, self.len) }
        }
    }

    impl From<&[i32]> for I32VecRef {
        fn from(s: &[i32]) -> Self {
            Self {
                ptr: s.as_ptr(),
                len: s.len(),
            }
        }
    }

    impl I32VecRef {
        fn as_slice(&self) -> &[i32] {
            unsafe { core::slice::from_raw_parts(self.ptr, self.len) }
        }
    }

    impl From<&mut [GLboolean]> for GLbooleanVecRefMut {
        fn from(s: &mut [GLboolean]) -> Self {
            Self {
                ptr: s.as_mut_ptr(),
                len: s.len(),
            }
        }
    }

    impl GLbooleanVecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLboolean] {
            unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) }
        }
    }

    impl From<&mut [u8]> for U8VecRefMut {
        fn from(s: &mut [u8]) -> Self {
            Self {
                ptr: s.as_mut_ptr(),
                len: s.len(),
            }
        }
    }

    impl U8VecRefMut {
        fn as_mut_slice(&mut self) -> &mut [u8] {
            unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) }
        }
    }

    /// Built in primitive types provided by the C language
    #[allow(non_camel_case_types)]
    pub mod ctypes {
        pub enum c_void {}
        pub type c_char = i8;
        pub type c_schar = i8;
        pub type c_uchar = u8;
        pub type c_short = i16;
        pub type c_ushort = u16;
        pub type c_int = i32;
        pub type c_uint = u32;
        pub type c_long = i64;
        pub type c_ulong = u64;
        pub type c_longlong = i64;
        pub type c_ulonglong = u64;
        pub type c_float = f32;
        pub type c_double = f64;
        pub type __int8 = i8;
        pub type __uint8 = u8;
        pub type __int16 = i16;
        pub type __uint16 = u16;
        pub type __int32 = i32;
        pub type __uint32 = u32;
        pub type __int64 = i64;
        pub type __uint64 = u64;
        pub type wchar_t = u16;
    }

    pub use self::ctypes::*;

    pub type GLenum = c_uint;
    pub type GLboolean = c_uchar;
    pub type GLbitfield = c_uint;
    pub type GLvoid = c_void;
    pub type GLbyte = c_char;
    pub type GLshort = c_short;
    pub type GLint = c_int;
    pub type GLclampx = c_int;
    pub type GLubyte = c_uchar;
    pub type GLushort = c_ushort;
    pub type GLuint = c_uint;
    pub type GLsizei = c_int;
    pub type GLfloat = c_float;
    pub type GLclampf = c_float;
    pub type GLdouble = c_double;
    pub type GLclampd = c_double;
    pub type GLeglImageOES = *const c_void;
    pub type GLchar = c_char;
    pub type GLcharARB = c_char;

    #[cfg(target_os = "macos")]
    pub type GLhandleARB = *const c_void;
    #[cfg(not(target_os = "macos"))]
    pub type GLhandleARB = c_uint;

    pub type GLhalfARB = c_ushort;
    pub type GLhalf = c_ushort;

    // Must be 32 bits
    pub type GLfixed = GLint;
    pub type GLintptr = isize;
    pub type GLsizeiptr = isize;
    pub type GLint64 = i64;
    pub type GLuint64 = u64;
    pub type GLintptrARB = isize;
    pub type GLsizeiptrARB = isize;
    pub type GLint64EXT = i64;
    pub type GLuint64EXT = u64;

    pub type GLDEBUGPROC = Option<
        extern "system" fn(
            source: GLenum,
            gltype: GLenum,
            id: GLuint,
            severity: GLenum,
            length: GLsizei,
            message: *const GLchar,
            userParam: *mut c_void,
        ),
    >;
    pub type GLDEBUGPROCARB = Option<
        extern "system" fn(
            source: GLenum,
            gltype: GLenum,
            id: GLuint,
            severity: GLenum,
            length: GLsizei,
            message: *const GLchar,
            userParam: *mut c_void,
        ),
    >;
    pub type GLDEBUGPROCKHR = Option<
        extern "system" fn(
            source: GLenum,
            gltype: GLenum,
            id: GLuint,
            severity: GLenum,
            length: GLsizei,
            message: *const GLchar,
            userParam: *mut c_void,
        ),
    >;

    // Vendor extension types
    pub type GLDEBUGPROCAMD = Option<
        extern "system" fn(
            id: GLuint,
            category: GLenum,
            severity: GLenum,
            length: GLsizei,
            message: *const GLchar,
            userParam: *mut c_void,
        ),
    >;
    pub type GLhalfNV = c_ushort;
    pub type GLvdpauSurfaceNV = GLintptr;

    /// `Texture` struct

    #[doc(inline)]
    pub use crate::dll::AzTexture as Texture;
    use crate::{
        css::ColorU,
        image::RawImageFormat,
        option::OptionU8VecRef,
        svg::{TessellatedColoredGPUSvgNode, TessellatedGPUSvgNode, TessellatedSvgNode},
        vec::{GLuintVec, StringVec, StyleTransformVec},
        window::PhysicalSizeU32,
    };
    impl Texture {
        /// Creates a new `Texture` instance.
        pub fn new<
            _2: Into<TextureFlags>,
            _3: Into<PhysicalSizeU32>,
            _4: Into<ColorU>,
            _5: Into<Gl>,
            _6: Into<RawImageFormat>,
        >(
            texture_id: u32,
            flags: _2,
            size: _3,
            background_color: _4,
            gl_context: _5,
            format: _6,
        ) -> Self {
            unsafe {
                crate::dll::AzTexture_new(
                    texture_id,
                    flags.into(),
                    size.into(),
                    background_color.into(),
                    gl_context.into(),
                    format.into(),
                )
            }
        }
        /// Allocates an OpenGL texture of a given size with a single red channel (used for image
        /// masks)
        pub fn allocate_rgba8<_1: Into<Gl>, _2: Into<PhysicalSizeU32>, _3: Into<ColorU>>(
            gl: _1,
            size: _2,
            background: _3,
        ) -> Self {
            unsafe {
                crate::dll::AzTexture_allocateRgba8(gl.into(), size.into(), background.into())
            }
        }
        /// Allocates an OpenGL texture of a given size with a single red channel (used for image
        /// masks)
        pub fn allocate_clip_mask<_1: Into<Gl>, _2: Into<PhysicalSizeU32>, _3: Into<ColorU>>(
            gl: _1,
            size: _2,
            background: _3,
        ) -> Self {
            unsafe {
                crate::dll::AzTexture_allocateClipMask(gl.into(), size.into(), background.into())
            }
        }
        /// Clears the texture with the currently set background color
        pub fn clear(&mut self) {
            unsafe { crate::dll::AzTexture_clear(self) }
        }
        /// Draws a vertex / index buffer (aka. `&TessellatedSvgNode`) to the texture
        pub fn draw_clip_mask<_1: Into<TessellatedSvgNode>>(&mut self, node: _1) -> bool {
            unsafe { crate::dll::AzTexture_drawClipMask(self, node.into()) }
        }
        /// Draws a `&TessellatedGPUSvgNode` with the given color to the texture
        pub fn draw_tesselated_svg_gpu_node<
            _1: Into<*const AzTessellatedGPUSvgNode>,
            _2: Into<PhysicalSizeU32>,
            _3: Into<ColorU>,
            _4: Into<StyleTransformVec>,
        >(
            &mut self,
            node: _1,
            size: _2,
            color: _3,
            transforms: _4,
        ) -> bool {
            unsafe {
                crate::dll::AzTexture_drawTesselatedSvgGpuNode(
                    self,
                    node.into(),
                    size.into(),
                    color.into(),
                    transforms.into(),
                )
            }
        }
        /// Draws a `&TessellatedColoredGPUSvgNode` with the given color to the texture
        pub fn draw_tesselated_colored_svg_gpu_node<
            _1: Into<*const AzTessellatedColoredGPUSvgNode>,
            _2: Into<PhysicalSizeU32>,
            _3: Into<StyleTransformVec>,
        >(
            &mut self,
            node: _1,
            size: _2,
            transforms: _3,
        ) -> bool {
            unsafe {
                crate::dll::AzTexture_drawTesselatedColoredSvgGpuNode(
                    self,
                    node.into(),
                    size.into(),
                    transforms.into(),
                )
            }
        }
        /// Applies an FXAA filter to the texture
        pub fn apply_fxaa(&mut self) -> bool {
            unsafe { crate::dll::AzTexture_applyFxaa(self) }
        }
    }

    impl Clone for Texture {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzTexture_deepCopy(self) }
        }
    }
    impl Drop for Texture {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzTexture_delete(self) }
            }
        }
    }
    /// `GlVoidPtrConst` struct

    #[doc(inline)]
    pub use crate::dll::AzGlVoidPtrConst as GlVoidPtrConst;
    impl Clone for GlVoidPtrConst {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzGlVoidPtrConst_deepCopy(self) }
        }
    }
    impl Drop for GlVoidPtrConst {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzGlVoidPtrConst_delete(self) }
            }
        }
    }
    /// `Gl` struct

    #[doc(inline)]
    pub use crate::dll::AzGl as Gl;
    /// `GlVoidPtrMut` struct

    #[doc(inline)]
    pub use crate::dll::AzGlVoidPtrMut as GlVoidPtrMut;
    impl Gl {
        pub const ACCUM: u32 = 0x0100;
        pub const ACCUM_ALPHA_BITS: u32 = 0x0D5B;
        pub const ACCUM_BLUE_BITS: u32 = 0x0D5A;
        pub const ACCUM_BUFFER_BIT: u32 = 0x00000200;
        pub const ACCUM_CLEAR_VALUE: u32 = 0x0B80;
        pub const ACCUM_GREEN_BITS: u32 = 0x0D59;
        pub const ACCUM_RED_BITS: u32 = 0x0D58;
        pub const ACTIVE_ATTRIBUTES: u32 = 0x8B89;
        pub const ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
        pub const ACTIVE_TEXTURE: u32 = 0x84E0;
        pub const ACTIVE_UNIFORMS: u32 = 0x8B86;
        pub const ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
        pub const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
        pub const ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
        pub const ADD: u32 = 0x0104;
        pub const ADD_SIGNED: u32 = 0x8574;
        pub const ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
        pub const ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
        pub const ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
        pub const ALPHA: u32 = 0x1906;
        pub const ALPHA12: u32 = 0x803D;
        pub const ALPHA16: u32 = 0x803E;
        pub const ALPHA16F_EXT: u32 = 0x881C;
        pub const ALPHA32F_EXT: u32 = 0x8816;
        pub const ALPHA4: u32 = 0x803B;
        pub const ALPHA8: u32 = 0x803C;
        pub const ALPHA8_EXT: u32 = 0x803C;
        pub const ALPHA_BIAS: u32 = 0x0D1D;
        pub const ALPHA_BITS: u32 = 0x0D55;
        pub const ALPHA_INTEGER: u32 = 0x8D97;
        pub const ALPHA_SCALE: u32 = 0x0D1C;
        pub const ALPHA_TEST: u32 = 0x0BC0;
        pub const ALPHA_TEST_FUNC: u32 = 0x0BC1;
        pub const ALPHA_TEST_REF: u32 = 0x0BC2;
        pub const ALREADY_SIGNALED: u32 = 0x911A;
        pub const ALWAYS: u32 = 0x0207;
        pub const AMBIENT: u32 = 0x1200;
        pub const AMBIENT_AND_DIFFUSE: u32 = 0x1602;
        pub const AND: u32 = 0x1501;
        pub const AND_INVERTED: u32 = 0x1504;
        pub const AND_REVERSE: u32 = 0x1502;
        pub const ANY_SAMPLES_PASSED: u32 = 0x8C2F;
        pub const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
        pub const ARRAY_BUFFER: u32 = 0x8892;
        pub const ARRAY_BUFFER_BINDING: u32 = 0x8894;
        pub const ATTACHED_SHADERS: u32 = 0x8B85;
        pub const ATTRIB_STACK_DEPTH: u32 = 0x0BB0;
        pub const AUTO_NORMAL: u32 = 0x0D80;
        pub const AUX0: u32 = 0x0409;
        pub const AUX1: u32 = 0x040A;
        pub const AUX2: u32 = 0x040B;
        pub const AUX3: u32 = 0x040C;
        pub const AUX_BUFFERS: u32 = 0x0C00;
        pub const BACK: u32 = 0x0405;
        pub const BACK_LEFT: u32 = 0x0402;
        pub const BACK_RIGHT: u32 = 0x0403;
        pub const BGR: u32 = 0x80E0;
        pub const BGRA: u32 = 0x80E1;
        pub const BGRA8_EXT: u32 = 0x93A1;
        pub const BGRA_EXT: u32 = 0x80E1;
        pub const BGRA_INTEGER: u32 = 0x8D9B;
        pub const BGR_INTEGER: u32 = 0x8D9A;
        pub const BITMAP: u32 = 0x1A00;
        pub const BITMAP_TOKEN: u32 = 0x0704;
        pub const BLEND: u32 = 0x0BE2;
        pub const BLEND_ADVANCED_COHERENT_KHR: u32 = 0x9285;
        pub const BLEND_COLOR: u32 = 0x8005;
        pub const BLEND_DST: u32 = 0x0BE0;
        pub const BLEND_DST_ALPHA: u32 = 0x80CA;
        pub const BLEND_DST_RGB: u32 = 0x80C8;
        pub const BLEND_EQUATION: u32 = 0x8009;
        pub const BLEND_EQUATION_ALPHA: u32 = 0x883D;
        pub const BLEND_EQUATION_RGB: u32 = 0x8009;
        pub const BLEND_SRC: u32 = 0x0BE1;
        pub const BLEND_SRC_ALPHA: u32 = 0x80CB;
        pub const BLEND_SRC_RGB: u32 = 0x80C9;
        pub const BLUE: u32 = 0x1905;
        pub const BLUE_BIAS: u32 = 0x0D1B;
        pub const BLUE_BITS: u32 = 0x0D54;
        pub const BLUE_INTEGER: u32 = 0x8D96;
        pub const BLUE_SCALE: u32 = 0x0D1A;
        pub const BOOL: u32 = 0x8B56;
        pub const BOOL_VEC2: u32 = 0x8B57;
        pub const BOOL_VEC3: u32 = 0x8B58;
        pub const BOOL_VEC4: u32 = 0x8B59;
        pub const BUFFER: u32 = 0x82E0;
        pub const BUFFER_ACCESS: u32 = 0x88BB;
        pub const BUFFER_ACCESS_FLAGS: u32 = 0x911F;
        pub const BUFFER_KHR: u32 = 0x82E0;
        pub const BUFFER_MAPPED: u32 = 0x88BC;
        pub const BUFFER_MAP_LENGTH: u32 = 0x9120;
        pub const BUFFER_MAP_OFFSET: u32 = 0x9121;
        pub const BUFFER_MAP_POINTER: u32 = 0x88BD;
        pub const BUFFER_SIZE: u32 = 0x8764;
        pub const BUFFER_USAGE: u32 = 0x8765;
        pub const BYTE: u32 = 0x1400;
        pub const C3F_V3F: u32 = 0x2A24;
        pub const C4F_N3F_V3F: u32 = 0x2A26;
        pub const C4UB_V2F: u32 = 0x2A22;
        pub const C4UB_V3F: u32 = 0x2A23;
        pub const CCW: u32 = 0x0901;
        pub const CLAMP: u32 = 0x2900;
        pub const CLAMP_FRAGMENT_COLOR: u32 = 0x891B;
        pub const CLAMP_READ_COLOR: u32 = 0x891C;
        pub const CLAMP_TO_BORDER: u32 = 0x812D;
        pub const CLAMP_TO_EDGE: u32 = 0x812F;
        pub const CLAMP_VERTEX_COLOR: u32 = 0x891A;
        pub const CLEAR: u32 = 0x1500;
        pub const CLIENT_ACTIVE_TEXTURE: u32 = 0x84E1;
        pub const CLIENT_ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
        pub const CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0BB1;
        pub const CLIENT_PIXEL_STORE_BIT: u32 = 0x00000001;
        pub const CLIENT_VERTEX_ARRAY_BIT: u32 = 0x00000002;
        pub const CLIP_DISTANCE0: u32 = 0x3000;
        pub const CLIP_DISTANCE1: u32 = 0x3001;
        pub const CLIP_DISTANCE2: u32 = 0x3002;
        pub const CLIP_DISTANCE3: u32 = 0x3003;
        pub const CLIP_DISTANCE4: u32 = 0x3004;
        pub const CLIP_DISTANCE5: u32 = 0x3005;
        pub const CLIP_DISTANCE6: u32 = 0x3006;
        pub const CLIP_DISTANCE7: u32 = 0x3007;
        pub const CLIP_PLANE0: u32 = 0x3000;
        pub const CLIP_PLANE1: u32 = 0x3001;
        pub const CLIP_PLANE2: u32 = 0x3002;
        pub const CLIP_PLANE3: u32 = 0x3003;
        pub const CLIP_PLANE4: u32 = 0x3004;
        pub const CLIP_PLANE5: u32 = 0x3005;
        pub const COEFF: u32 = 0x0A00;
        pub const COLOR: u32 = 0x1800;
        pub const COLORBURN_KHR: u32 = 0x929A;
        pub const COLORDODGE_KHR: u32 = 0x9299;
        pub const COLOR_ARRAY: u32 = 0x8076;
        pub const COLOR_ARRAY_BUFFER_BINDING: u32 = 0x8898;
        pub const COLOR_ARRAY_POINTER: u32 = 0x8090;
        pub const COLOR_ARRAY_SIZE: u32 = 0x8081;
        pub const COLOR_ARRAY_STRIDE: u32 = 0x8083;
        pub const COLOR_ARRAY_TYPE: u32 = 0x8082;
        pub const COLOR_ATTACHMENT0: u32 = 0x8CE0;
        pub const COLOR_ATTACHMENT1: u32 = 0x8CE1;
        pub const COLOR_ATTACHMENT10: u32 = 0x8CEA;
        pub const COLOR_ATTACHMENT11: u32 = 0x8CEB;
        pub const COLOR_ATTACHMENT12: u32 = 0x8CEC;
        pub const COLOR_ATTACHMENT13: u32 = 0x8CED;
        pub const COLOR_ATTACHMENT14: u32 = 0x8CEE;
        pub const COLOR_ATTACHMENT15: u32 = 0x8CEF;
        pub const COLOR_ATTACHMENT16: u32 = 0x8CF0;
        pub const COLOR_ATTACHMENT17: u32 = 0x8CF1;
        pub const COLOR_ATTACHMENT18: u32 = 0x8CF2;
        pub const COLOR_ATTACHMENT19: u32 = 0x8CF3;
        pub const COLOR_ATTACHMENT2: u32 = 0x8CE2;
        pub const COLOR_ATTACHMENT20: u32 = 0x8CF4;
        pub const COLOR_ATTACHMENT21: u32 = 0x8CF5;
        pub const COLOR_ATTACHMENT22: u32 = 0x8CF6;
        pub const COLOR_ATTACHMENT23: u32 = 0x8CF7;
        pub const COLOR_ATTACHMENT24: u32 = 0x8CF8;
        pub const COLOR_ATTACHMENT25: u32 = 0x8CF9;
        pub const COLOR_ATTACHMENT26: u32 = 0x8CFA;
        pub const COLOR_ATTACHMENT27: u32 = 0x8CFB;
        pub const COLOR_ATTACHMENT28: u32 = 0x8CFC;
        pub const COLOR_ATTACHMENT29: u32 = 0x8CFD;
        pub const COLOR_ATTACHMENT3: u32 = 0x8CE3;
        pub const COLOR_ATTACHMENT30: u32 = 0x8CFE;
        pub const COLOR_ATTACHMENT31: u32 = 0x8CFF;
        pub const COLOR_ATTACHMENT4: u32 = 0x8CE4;
        pub const COLOR_ATTACHMENT5: u32 = 0x8CE5;
        pub const COLOR_ATTACHMENT6: u32 = 0x8CE6;
        pub const COLOR_ATTACHMENT7: u32 = 0x8CE7;
        pub const COLOR_ATTACHMENT8: u32 = 0x8CE8;
        pub const COLOR_ATTACHMENT9: u32 = 0x8CE9;
        pub const COLOR_BUFFER_BIT: u32 = 0x00004000;
        pub const COLOR_CLEAR_VALUE: u32 = 0x0C22;
        pub const COLOR_INDEX: u32 = 0x1900;
        pub const COLOR_INDEXES: u32 = 0x1603;
        pub const COLOR_LOGIC_OP: u32 = 0x0BF2;
        pub const COLOR_MATERIAL: u32 = 0x0B57;
        pub const COLOR_MATERIAL_FACE: u32 = 0x0B55;
        pub const COLOR_MATERIAL_PARAMETER: u32 = 0x0B56;
        pub const COLOR_SUM: u32 = 0x8458;
        pub const COLOR_WRITEMASK: u32 = 0x0C23;
        pub const COMBINE: u32 = 0x8570;
        pub const COMBINE_ALPHA: u32 = 0x8572;
        pub const COMBINE_RGB: u32 = 0x8571;
        pub const COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
        pub const COMPARE_R_TO_TEXTURE: u32 = 0x884E;
        pub const COMPILE: u32 = 0x1300;
        pub const COMPILE_AND_EXECUTE: u32 = 0x1301;
        pub const COMPILE_STATUS: u32 = 0x8B81;
        pub const COMPRESSED_ALPHA: u32 = 0x84E9;
        pub const COMPRESSED_INTENSITY: u32 = 0x84EC;
        pub const COMPRESSED_LUMINANCE: u32 = 0x84EA;
        pub const COMPRESSED_LUMINANCE_ALPHA: u32 = 0x84EB;
        pub const COMPRESSED_R11_EAC: u32 = 0x9270;
        pub const COMPRESSED_RED: u32 = 0x8225;
        pub const COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
        pub const COMPRESSED_RG: u32 = 0x8226;
        pub const COMPRESSED_RG11_EAC: u32 = 0x9272;
        pub const COMPRESSED_RGB: u32 = 0x84ED;
        pub const COMPRESSED_RGB8_ETC2: u32 = 0x9274;
        pub const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
        pub const COMPRESSED_RGBA: u32 = 0x84EE;
        pub const COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
        pub const COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
        pub const COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
        pub const COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
        pub const COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
        pub const COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
        pub const COMPRESSED_SLUMINANCE: u32 = 0x8C4A;
        pub const COMPRESSED_SLUMINANCE_ALPHA: u32 = 0x8C4B;
        pub const COMPRESSED_SRGB: u32 = 0x8C48;
        pub const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
        pub const COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
        pub const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
        pub const COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
        pub const COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
        pub const CONDITION_SATISFIED: u32 = 0x911C;
        pub const CONSTANT: u32 = 0x8576;
        pub const CONSTANT_ALPHA: u32 = 0x8003;
        pub const CONSTANT_ATTENUATION: u32 = 0x1207;
        pub const CONSTANT_COLOR: u32 = 0x8001;
        pub const CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
        pub const CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
        pub const CONTEXT_FLAGS: u32 = 0x821E;
        pub const CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
        pub const CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
        pub const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
        pub const CONTEXT_PROFILE_MASK: u32 = 0x9126;
        pub const COORD_REPLACE: u32 = 0x8862;
        pub const COPY: u32 = 0x1503;
        pub const COPY_INVERTED: u32 = 0x150C;
        pub const COPY_PIXEL_TOKEN: u32 = 0x0706;
        pub const COPY_READ_BUFFER: u32 = 0x8F36;
        pub const COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
        pub const COPY_WRITE_BUFFER: u32 = 0x8F37;
        pub const COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
        pub const CULL_FACE: u32 = 0x0B44;
        pub const CULL_FACE_MODE: u32 = 0x0B45;
        pub const CURRENT_BIT: u32 = 0x00000001;
        pub const CURRENT_COLOR: u32 = 0x0B00;
        pub const CURRENT_FOG_COORD: u32 = 0x8453;
        pub const CURRENT_FOG_COORDINATE: u32 = 0x8453;
        pub const CURRENT_INDEX: u32 = 0x0B01;
        pub const CURRENT_NORMAL: u32 = 0x0B02;
        pub const CURRENT_PROGRAM: u32 = 0x8B8D;
        pub const CURRENT_QUERY: u32 = 0x8865;
        pub const CURRENT_QUERY_EXT: u32 = 0x8865;
        pub const CURRENT_RASTER_COLOR: u32 = 0x0B04;
        pub const CURRENT_RASTER_DISTANCE: u32 = 0x0B09;
        pub const CURRENT_RASTER_INDEX: u32 = 0x0B05;
        pub const CURRENT_RASTER_POSITION: u32 = 0x0B07;
        pub const CURRENT_RASTER_POSITION_VALID: u32 = 0x0B08;
        pub const CURRENT_RASTER_SECONDARY_COLOR: u32 = 0x845F;
        pub const CURRENT_RASTER_TEXTURE_COORDS: u32 = 0x0B06;
        pub const CURRENT_SECONDARY_COLOR: u32 = 0x8459;
        pub const CURRENT_TEXTURE_COORDS: u32 = 0x0B03;
        pub const CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
        pub const CW: u32 = 0x0900;
        pub const DARKEN_KHR: u32 = 0x9297;
        pub const DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
        pub const DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
        pub const DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
        pub const DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
        pub const DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
        pub const DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
        pub const DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
        pub const DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
        pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
        pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
        pub const DEBUG_OUTPUT: u32 = 0x92E0;
        pub const DEBUG_OUTPUT_KHR: u32 = 0x92E0;
        pub const DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
        pub const DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
        pub const DEBUG_SEVERITY_HIGH: u32 = 0x9146;
        pub const DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
        pub const DEBUG_SEVERITY_LOW: u32 = 0x9148;
        pub const DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
        pub const DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
        pub const DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
        pub const DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
        pub const DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
        pub const DEBUG_SOURCE_API: u32 = 0x8246;
        pub const DEBUG_SOURCE_API_KHR: u32 = 0x8246;
        pub const DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
        pub const DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
        pub const DEBUG_SOURCE_OTHER: u32 = 0x824B;
        pub const DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
        pub const DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
        pub const DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
        pub const DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
        pub const DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
        pub const DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
        pub const DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
        pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
        pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
        pub const DEBUG_TYPE_ERROR: u32 = 0x824C;
        pub const DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
        pub const DEBUG_TYPE_MARKER: u32 = 0x8268;
        pub const DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
        pub const DEBUG_TYPE_OTHER: u32 = 0x8251;
        pub const DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
        pub const DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
        pub const DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
        pub const DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
        pub const DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
        pub const DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
        pub const DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
        pub const DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
        pub const DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
        pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
        pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
        pub const DECAL: u32 = 0x2101;
        pub const DECR: u32 = 0x1E03;
        pub const DECR_WRAP: u32 = 0x8508;
        pub const DELETE_STATUS: u32 = 0x8B80;
        pub const DEPTH: u32 = 0x1801;
        pub const DEPTH24_STENCIL8: u32 = 0x88F0;
        pub const DEPTH32F_STENCIL8: u32 = 0x8CAD;
        pub const DEPTH_ATTACHMENT: u32 = 0x8D00;
        pub const DEPTH_BIAS: u32 = 0x0D1F;
        pub const DEPTH_BITS: u32 = 0x0D56;
        pub const DEPTH_BUFFER_BIT: u32 = 0x00000100;
        pub const DEPTH_CLAMP: u32 = 0x864F;
        pub const DEPTH_CLEAR_VALUE: u32 = 0x0B73;
        pub const DEPTH_COMPONENT: u32 = 0x1902;
        pub const DEPTH_COMPONENT16: u32 = 0x81A5;
        pub const DEPTH_COMPONENT24: u32 = 0x81A6;
        pub const DEPTH_COMPONENT32: u32 = 0x81A7;
        pub const DEPTH_COMPONENT32F: u32 = 0x8CAC;
        pub const DEPTH_FUNC: u32 = 0x0B74;
        pub const DEPTH_RANGE: u32 = 0x0B70;
        pub const DEPTH_SCALE: u32 = 0x0D1E;
        pub const DEPTH_STENCIL: u32 = 0x84F9;
        pub const DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
        pub const DEPTH_TEST: u32 = 0x0B71;
        pub const DEPTH_TEXTURE_MODE: u32 = 0x884B;
        pub const DEPTH_WRITEMASK: u32 = 0x0B72;
        pub const DIFFERENCE_KHR: u32 = 0x929E;
        pub const DIFFUSE: u32 = 0x1201;
        pub const DISPLAY_LIST: u32 = 0x82E7;
        pub const DITHER: u32 = 0x0BD0;
        pub const DOMAIN: u32 = 0x0A02;
        pub const DONT_CARE: u32 = 0x1100;
        pub const DOT3_RGB: u32 = 0x86AE;
        pub const DOT3_RGBA: u32 = 0x86AF;
        pub const DOUBLE: u32 = 0x140A;
        pub const DOUBLEBUFFER: u32 = 0x0C32;
        pub const DRAW_BUFFER: u32 = 0x0C01;
        pub const DRAW_BUFFER0: u32 = 0x8825;
        pub const DRAW_BUFFER1: u32 = 0x8826;
        pub const DRAW_BUFFER10: u32 = 0x882F;
        pub const DRAW_BUFFER11: u32 = 0x8830;
        pub const DRAW_BUFFER12: u32 = 0x8831;
        pub const DRAW_BUFFER13: u32 = 0x8832;
        pub const DRAW_BUFFER14: u32 = 0x8833;
        pub const DRAW_BUFFER15: u32 = 0x8834;
        pub const DRAW_BUFFER2: u32 = 0x8827;
        pub const DRAW_BUFFER3: u32 = 0x8828;
        pub const DRAW_BUFFER4: u32 = 0x8829;
        pub const DRAW_BUFFER5: u32 = 0x882A;
        pub const DRAW_BUFFER6: u32 = 0x882B;
        pub const DRAW_BUFFER7: u32 = 0x882C;
        pub const DRAW_BUFFER8: u32 = 0x882D;
        pub const DRAW_BUFFER9: u32 = 0x882E;
        pub const DRAW_FRAMEBUFFER: u32 = 0x8CA9;
        pub const DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
        pub const DRAW_PIXELS_APPLE: u32 = 0x8A0A;
        pub const DRAW_PIXEL_TOKEN: u32 = 0x0705;
        pub const DST_ALPHA: u32 = 0x0304;
        pub const DST_COLOR: u32 = 0x0306;
        pub const DYNAMIC_COPY: u32 = 0x88EA;
        pub const DYNAMIC_DRAW: u32 = 0x88E8;
        pub const DYNAMIC_READ: u32 = 0x88E9;
        pub const EDGE_FLAG: u32 = 0x0B43;
        pub const EDGE_FLAG_ARRAY: u32 = 0x8079;
        pub const EDGE_FLAG_ARRAY_BUFFER_BINDING: u32 = 0x889B;
        pub const EDGE_FLAG_ARRAY_POINTER: u32 = 0x8093;
        pub const EDGE_FLAG_ARRAY_STRIDE: u32 = 0x808C;
        pub const ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
        pub const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
        pub const EMISSION: u32 = 0x1600;
        pub const ENABLE_BIT: u32 = 0x00002000;
        pub const EQUAL: u32 = 0x0202;
        pub const EQUIV: u32 = 0x1509;
        pub const EVAL_BIT: u32 = 0x00010000;
        pub const EXCLUSION_KHR: u32 = 0x92A0;
        pub const EXP: u32 = 0x0800;
        pub const EXP2: u32 = 0x0801;
        pub const EXTENSIONS: u32 = 0x1F03;
        pub const EYE_LINEAR: u32 = 0x2400;
        pub const EYE_PLANE: u32 = 0x2502;
        pub const FALSE: u8 = 0;
        pub const FASTEST: u32 = 0x1101;
        pub const FEEDBACK: u32 = 0x1C01;
        pub const FEEDBACK_BUFFER_POINTER: u32 = 0x0DF0;
        pub const FEEDBACK_BUFFER_SIZE: u32 = 0x0DF1;
        pub const FEEDBACK_BUFFER_TYPE: u32 = 0x0DF2;
        pub const FENCE_APPLE: u32 = 0x8A0B;
        pub const FILL: u32 = 0x1B02;
        pub const FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
        pub const FIXED: u32 = 0x140C;
        pub const FIXED_ONLY: u32 = 0x891D;
        pub const FLAT: u32 = 0x1D00;
        pub const FLOAT: u32 = 0x1406;
        pub const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
        pub const FLOAT_MAT2: u32 = 0x8B5A;
        pub const FLOAT_MAT2x3: u32 = 0x8B65;
        pub const FLOAT_MAT2x4: u32 = 0x8B66;
        pub const FLOAT_MAT3: u32 = 0x8B5B;
        pub const FLOAT_MAT3x2: u32 = 0x8B67;
        pub const FLOAT_MAT3x4: u32 = 0x8B68;
        pub const FLOAT_MAT4: u32 = 0x8B5C;
        pub const FLOAT_MAT4x2: u32 = 0x8B69;
        pub const FLOAT_MAT4x3: u32 = 0x8B6A;
        pub const FLOAT_VEC2: u32 = 0x8B50;
        pub const FLOAT_VEC3: u32 = 0x8B51;
        pub const FLOAT_VEC4: u32 = 0x8B52;
        pub const FOG: u32 = 0x0B60;
        pub const FOG_BIT: u32 = 0x00000080;
        pub const FOG_COLOR: u32 = 0x0B66;
        pub const FOG_COORD: u32 = 0x8451;
        pub const FOG_COORDINATE: u32 = 0x8451;
        pub const FOG_COORDINATE_ARRAY: u32 = 0x8457;
        pub const FOG_COORDINATE_ARRAY_BUFFER_BINDING: u32 = 0x889D;
        pub const FOG_COORDINATE_ARRAY_POINTER: u32 = 0x8456;
        pub const FOG_COORDINATE_ARRAY_STRIDE: u32 = 0x8455;
        pub const FOG_COORDINATE_ARRAY_TYPE: u32 = 0x8454;
        pub const FOG_COORDINATE_SOURCE: u32 = 0x8450;
        pub const FOG_COORD_ARRAY: u32 = 0x8457;
        pub const FOG_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889D;
        pub const FOG_COORD_ARRAY_POINTER: u32 = 0x8456;
        pub const FOG_COORD_ARRAY_STRIDE: u32 = 0x8455;
        pub const FOG_COORD_ARRAY_TYPE: u32 = 0x8454;
        pub const FOG_COORD_SRC: u32 = 0x8450;
        pub const FOG_DENSITY: u32 = 0x0B62;
        pub const FOG_END: u32 = 0x0B64;
        pub const FOG_HINT: u32 = 0x0C54;
        pub const FOG_INDEX: u32 = 0x0B61;
        pub const FOG_MODE: u32 = 0x0B65;
        pub const FOG_START: u32 = 0x0B63;
        pub const FRAGMENT_DEPTH: u32 = 0x8452;
        pub const FRAGMENT_SHADER: u32 = 0x8B30;
        pub const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
        pub const FRAMEBUFFER: u32 = 0x8D40;
        pub const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
        pub const FRAMEBUFFER_ATTACHMENT_ANGLE: u32 = 0x93A3;
        pub const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
        pub const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
        pub const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
        pub const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
        pub const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
        pub const FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
        pub const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
        pub const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
        pub const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
        pub const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
        pub const FRAMEBUFFER_BINDING: u32 = 0x8CA6;
        pub const FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
        pub const FRAMEBUFFER_DEFAULT: u32 = 0x8218;
        pub const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
        pub const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
        pub const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
        pub const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
        pub const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
        pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
        pub const FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
        pub const FRAMEBUFFER_SRGB: u32 = 0x8DB9;
        pub const FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
        pub const FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
        pub const FRONT: u32 = 0x0404;
        pub const FRONT_AND_BACK: u32 = 0x0408;
        pub const FRONT_FACE: u32 = 0x0B46;
        pub const FRONT_LEFT: u32 = 0x0400;
        pub const FRONT_RIGHT: u32 = 0x0401;
        pub const FUNC_ADD: u32 = 0x8006;
        pub const FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
        pub const FUNC_SUBTRACT: u32 = 0x800A;
        pub const GENERATE_MIPMAP: u32 = 0x8191;
        pub const GENERATE_MIPMAP_HINT: u32 = 0x8192;
        pub const GEOMETRY_INPUT_TYPE: u32 = 0x8917;
        pub const GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
        pub const GEOMETRY_SHADER: u32 = 0x8DD9;
        pub const GEOMETRY_VERTICES_OUT: u32 = 0x8916;
        pub const GEQUAL: u32 = 0x0206;
        pub const GPU_DISJOINT_EXT: u32 = 0x8FBB;
        pub const GREATER: u32 = 0x0204;
        pub const GREEN: u32 = 0x1904;
        pub const GREEN_BIAS: u32 = 0x0D19;
        pub const GREEN_BITS: u32 = 0x0D53;
        pub const GREEN_INTEGER: u32 = 0x8D95;
        pub const GREEN_SCALE: u32 = 0x0D18;
        pub const HALF_FLOAT: u32 = 0x140B;
        pub const HALF_FLOAT_OES: u32 = 0x8D61;
        pub const HARDLIGHT_KHR: u32 = 0x929B;
        pub const HIGH_FLOAT: u32 = 0x8DF2;
        pub const HIGH_INT: u32 = 0x8DF5;
        pub const HINT_BIT: u32 = 0x00008000;
        pub const HSL_COLOR_KHR: u32 = 0x92AF;
        pub const HSL_HUE_KHR: u32 = 0x92AD;
        pub const HSL_LUMINOSITY_KHR: u32 = 0x92B0;
        pub const HSL_SATURATION_KHR: u32 = 0x92AE;
        pub const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
        pub const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
        pub const INCR: u32 = 0x1E02;
        pub const INCR_WRAP: u32 = 0x8507;
        pub const INDEX: u32 = 0x8222;
        pub const INDEX_ARRAY: u32 = 0x8077;
        pub const INDEX_ARRAY_BUFFER_BINDING: u32 = 0x8899;
        pub const INDEX_ARRAY_POINTER: u32 = 0x8091;
        pub const INDEX_ARRAY_STRIDE: u32 = 0x8086;
        pub const INDEX_ARRAY_TYPE: u32 = 0x8085;
        pub const INDEX_BITS: u32 = 0x0D51;
        pub const INDEX_CLEAR_VALUE: u32 = 0x0C20;
        pub const INDEX_LOGIC_OP: u32 = 0x0BF1;
        pub const INDEX_MODE: u32 = 0x0C30;
        pub const INDEX_OFFSET: u32 = 0x0D13;
        pub const INDEX_SHIFT: u32 = 0x0D12;
        pub const INDEX_WRITEMASK: u32 = 0x0C21;
        pub const INFO_LOG_LENGTH: u32 = 0x8B84;
        pub const INT: u32 = 0x1404;
        pub const INTENSITY: u32 = 0x8049;
        pub const INTENSITY12: u32 = 0x804C;
        pub const INTENSITY16: u32 = 0x804D;
        pub const INTENSITY4: u32 = 0x804A;
        pub const INTENSITY8: u32 = 0x804B;
        pub const INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
        pub const INTERPOLATE: u32 = 0x8575;
        pub const INT_2_10_10_10_REV: u32 = 0x8D9F;
        pub const INT_SAMPLER_1D: u32 = 0x8DC9;
        pub const INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
        pub const INT_SAMPLER_2D: u32 = 0x8DCA;
        pub const INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
        pub const INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
        pub const INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
        pub const INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
        pub const INT_SAMPLER_3D: u32 = 0x8DCB;
        pub const INT_SAMPLER_BUFFER: u32 = 0x8DD0;
        pub const INT_SAMPLER_CUBE: u32 = 0x8DCC;
        pub const INT_VEC2: u32 = 0x8B53;
        pub const INT_VEC3: u32 = 0x8B54;
        pub const INT_VEC4: u32 = 0x8B55;
        pub const INVALID_ENUM: u32 = 0x0500;
        pub const INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
        pub const INVALID_INDEX: u32 = 0xFFFFFFFF;
        pub const INVALID_OPERATION: u32 = 0x0502;
        pub const INVALID_VALUE: u32 = 0x0501;
        pub const INVERT: u32 = 0x150A;
        pub const KEEP: u32 = 0x1E00;
        pub const LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
        pub const LEFT: u32 = 0x0406;
        pub const LEQUAL: u32 = 0x0203;
        pub const LESS: u32 = 0x0201;
        pub const LIGHT0: u32 = 0x4000;
        pub const LIGHT1: u32 = 0x4001;
        pub const LIGHT2: u32 = 0x4002;
        pub const LIGHT3: u32 = 0x4003;
        pub const LIGHT4: u32 = 0x4004;
        pub const LIGHT5: u32 = 0x4005;
        pub const LIGHT6: u32 = 0x4006;
        pub const LIGHT7: u32 = 0x4007;
        pub const LIGHTEN_KHR: u32 = 0x9298;
        pub const LIGHTING: u32 = 0x0B50;
        pub const LIGHTING_BIT: u32 = 0x00000040;
        pub const LIGHT_MODEL_AMBIENT: u32 = 0x0B53;
        pub const LIGHT_MODEL_COLOR_CONTROL: u32 = 0x81F8;
        pub const LIGHT_MODEL_LOCAL_VIEWER: u32 = 0x0B51;
        pub const LIGHT_MODEL_TWO_SIDE: u32 = 0x0B52;
        pub const LINE: u32 = 0x1B01;
        pub const LINEAR: u32 = 0x2601;
        pub const LINEAR_ATTENUATION: u32 = 0x1208;
        pub const LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
        pub const LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
        pub const LINES: u32 = 0x0001;
        pub const LINES_ADJACENCY: u32 = 0x000A;
        pub const LINE_BIT: u32 = 0x00000004;
        pub const LINE_LOOP: u32 = 0x0002;
        pub const LINE_RESET_TOKEN: u32 = 0x0707;
        pub const LINE_SMOOTH: u32 = 0x0B20;
        pub const LINE_SMOOTH_HINT: u32 = 0x0C52;
        pub const LINE_STIPPLE: u32 = 0x0B24;
        pub const LINE_STIPPLE_PATTERN: u32 = 0x0B25;
        pub const LINE_STIPPLE_REPEAT: u32 = 0x0B26;
        pub const LINE_STRIP: u32 = 0x0003;
        pub const LINE_STRIP_ADJACENCY: u32 = 0x000B;
        pub const LINE_TOKEN: u32 = 0x0702;
        pub const LINE_WIDTH: u32 = 0x0B21;
        pub const LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
        pub const LINE_WIDTH_RANGE: u32 = 0x0B22;
        pub const LINK_STATUS: u32 = 0x8B82;
        pub const LIST_BASE: u32 = 0x0B32;
        pub const LIST_BIT: u32 = 0x00020000;
        pub const LIST_INDEX: u32 = 0x0B33;
        pub const LIST_MODE: u32 = 0x0B30;
        pub const LOAD: u32 = 0x0101;
        pub const LOGIC_OP: u32 = 0x0BF1;
        pub const LOGIC_OP_MODE: u32 = 0x0BF0;
        pub const LOWER_LEFT: u32 = 0x8CA1;
        pub const LOW_FLOAT: u32 = 0x8DF0;
        pub const LOW_INT: u32 = 0x8DF3;
        pub const LUMINANCE: u32 = 0x1909;
        pub const LUMINANCE12: u32 = 0x8041;
        pub const LUMINANCE12_ALPHA12: u32 = 0x8047;
        pub const LUMINANCE12_ALPHA4: u32 = 0x8046;
        pub const LUMINANCE16: u32 = 0x8042;
        pub const LUMINANCE16F_EXT: u32 = 0x881E;
        pub const LUMINANCE16_ALPHA16: u32 = 0x8048;
        pub const LUMINANCE32F_EXT: u32 = 0x8818;
        pub const LUMINANCE4: u32 = 0x803F;
        pub const LUMINANCE4_ALPHA4: u32 = 0x8043;
        pub const LUMINANCE6_ALPHA2: u32 = 0x8044;
        pub const LUMINANCE8: u32 = 0x8040;
        pub const LUMINANCE8_ALPHA8: u32 = 0x8045;
        pub const LUMINANCE8_ALPHA8_EXT: u32 = 0x8045;
        pub const LUMINANCE8_EXT: u32 = 0x8040;
        pub const LUMINANCE_ALPHA: u32 = 0x190A;
        pub const LUMINANCE_ALPHA16F_EXT: u32 = 0x881F;
        pub const LUMINANCE_ALPHA32F_EXT: u32 = 0x8819;
        pub const MAJOR_VERSION: u32 = 0x821B;
        pub const MAP1_COLOR_4: u32 = 0x0D90;
        pub const MAP1_GRID_DOMAIN: u32 = 0x0DD0;
        pub const MAP1_GRID_SEGMENTS: u32 = 0x0DD1;
        pub const MAP1_INDEX: u32 = 0x0D91;
        pub const MAP1_NORMAL: u32 = 0x0D92;
        pub const MAP1_TEXTURE_COORD_1: u32 = 0x0D93;
        pub const MAP1_TEXTURE_COORD_2: u32 = 0x0D94;
        pub const MAP1_TEXTURE_COORD_3: u32 = 0x0D95;
        pub const MAP1_TEXTURE_COORD_4: u32 = 0x0D96;
        pub const MAP1_VERTEX_3: u32 = 0x0D97;
        pub const MAP1_VERTEX_4: u32 = 0x0D98;
        pub const MAP2_COLOR_4: u32 = 0x0DB0;
        pub const MAP2_GRID_DOMAIN: u32 = 0x0DD2;
        pub const MAP2_GRID_SEGMENTS: u32 = 0x0DD3;
        pub const MAP2_INDEX: u32 = 0x0DB1;
        pub const MAP2_NORMAL: u32 = 0x0DB2;
        pub const MAP2_TEXTURE_COORD_1: u32 = 0x0DB3;
        pub const MAP2_TEXTURE_COORD_2: u32 = 0x0DB4;
        pub const MAP2_TEXTURE_COORD_3: u32 = 0x0DB5;
        pub const MAP2_TEXTURE_COORD_4: u32 = 0x0DB6;
        pub const MAP2_VERTEX_3: u32 = 0x0DB7;
        pub const MAP2_VERTEX_4: u32 = 0x0DB8;
        pub const MAP_COLOR: u32 = 0x0D10;
        pub const MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
        pub const MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
        pub const MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
        pub const MAP_READ_BIT: u32 = 0x0001;
        pub const MAP_STENCIL: u32 = 0x0D11;
        pub const MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
        pub const MAP_WRITE_BIT: u32 = 0x0002;
        pub const MATRIX_MODE: u32 = 0x0BA0;
        pub const MAX: u32 = 0x8008;
        pub const MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
        pub const MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
        pub const MAX_ATTRIB_STACK_DEPTH: u32 = 0x0D35;
        pub const MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0D3B;
        pub const MAX_CLIP_DISTANCES: u32 = 0x0D32;
        pub const MAX_CLIP_PLANES: u32 = 0x0D32;
        pub const MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
        pub const MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
        pub const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
        pub const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
        pub const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
        pub const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
        pub const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
        pub const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
        pub const MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
        pub const MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
        pub const MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
        pub const MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
        pub const MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
        pub const MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
        pub const MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
        pub const MAX_DRAW_BUFFERS: u32 = 0x8824;
        pub const MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
        pub const MAX_ELEMENTS_INDICES: u32 = 0x80E9;
        pub const MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
        pub const MAX_ELEMENT_INDEX: u32 = 0x8D6B;
        pub const MAX_EVAL_ORDER: u32 = 0x0D30;
        pub const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
        pub const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
        pub const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
        pub const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
        pub const MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
        pub const MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
        pub const MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
        pub const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
        pub const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
        pub const MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
        pub const MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
        pub const MAX_INTEGER_SAMPLES: u32 = 0x9110;
        pub const MAX_LABEL_LENGTH: u32 = 0x82E8;
        pub const MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
        pub const MAX_LIGHTS: u32 = 0x0D31;
        pub const MAX_LIST_NESTING: u32 = 0x0B31;
        pub const MAX_MODELVIEW_STACK_DEPTH: u32 = 0x0D36;
        pub const MAX_NAME_STACK_DEPTH: u32 = 0x0D37;
        pub const MAX_PIXEL_MAP_TABLE: u32 = 0x0D34;
        pub const MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
        pub const MAX_PROJECTION_STACK_DEPTH: u32 = 0x0D38;
        pub const MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
        pub const MAX_RECTANGLE_TEXTURE_SIZE_ARB: u32 = 0x84F8;
        pub const MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
        pub const MAX_SAMPLES: u32 = 0x8D57;
        pub const MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
        pub const MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
        pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT: u32 = 0x8F63;
        pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT: u32 = 0x8F67;
        pub const MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
        pub const MAX_TEXTURE_COORDS: u32 = 0x8871;
        pub const MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
        pub const MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
        pub const MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
        pub const MAX_TEXTURE_SIZE: u32 = 0x0D33;
        pub const MAX_TEXTURE_STACK_DEPTH: u32 = 0x0D39;
        pub const MAX_TEXTURE_UNITS: u32 = 0x84E2;
        pub const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
        pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
        pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
        pub const MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
        pub const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
        pub const MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
        pub const MAX_VARYING_FLOATS: u32 = 0x8B4B;
        pub const MAX_VARYING_VECTORS: u32 = 0x8DFC;
        pub const MAX_VERTEX_ATTRIBS: u32 = 0x8869;
        pub const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
        pub const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
        pub const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
        pub const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
        pub const MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
        pub const MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
        pub const MEDIUM_FLOAT: u32 = 0x8DF1;
        pub const MEDIUM_INT: u32 = 0x8DF4;
        pub const MIN: u32 = 0x8007;
        pub const MINOR_VERSION: u32 = 0x821C;
        pub const MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
        pub const MIRRORED_REPEAT: u32 = 0x8370;
        pub const MODELVIEW: u32 = 0x1700;
        pub const MODELVIEW_MATRIX: u32 = 0x0BA6;
        pub const MODELVIEW_STACK_DEPTH: u32 = 0x0BA3;
        pub const MODULATE: u32 = 0x2100;
        pub const MULT: u32 = 0x0103;
        pub const MULTIPLY_KHR: u32 = 0x9294;
        pub const MULTISAMPLE: u32 = 0x809D;
        pub const MULTISAMPLE_BIT: u32 = 0x20000000;
        pub const N3F_V3F: u32 = 0x2A25;
        pub const NAME_STACK_DEPTH: u32 = 0x0D70;
        pub const NAND: u32 = 0x150E;
        pub const NEAREST: u32 = 0x2600;
        pub const NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
        pub const NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
        pub const NEVER: u32 = 0x0200;
        pub const NICEST: u32 = 0x1102;
        pub const NONE: u32 = 0;
        pub const NOOP: u32 = 0x1505;
        pub const NOR: u32 = 0x1508;
        pub const NORMALIZE: u32 = 0x0BA1;
        pub const NORMAL_ARRAY: u32 = 0x8075;
        pub const NORMAL_ARRAY_BUFFER_BINDING: u32 = 0x8897;
        pub const NORMAL_ARRAY_POINTER: u32 = 0x808F;
        pub const NORMAL_ARRAY_STRIDE: u32 = 0x807F;
        pub const NORMAL_ARRAY_TYPE: u32 = 0x807E;
        pub const NORMAL_MAP: u32 = 0x8511;
        pub const NOTEQUAL: u32 = 0x0205;
        pub const NO_ERROR: u32 = 0;
        pub const NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
        pub const NUM_EXTENSIONS: u32 = 0x821D;
        pub const NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
        pub const NUM_SAMPLE_COUNTS: u32 = 0x9380;
        pub const NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
        pub const OBJECT_LINEAR: u32 = 0x2401;
        pub const OBJECT_PLANE: u32 = 0x2501;
        pub const OBJECT_TYPE: u32 = 0x9112;
        pub const ONE: u32 = 1;
        pub const ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
        pub const ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
        pub const ONE_MINUS_DST_ALPHA: u32 = 0x0305;
        pub const ONE_MINUS_DST_COLOR: u32 = 0x0307;
        pub const ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
        pub const ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
        pub const ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
        pub const ONE_MINUS_SRC_COLOR: u32 = 0x0301;
        pub const OPERAND0_ALPHA: u32 = 0x8598;
        pub const OPERAND0_RGB: u32 = 0x8590;
        pub const OPERAND1_ALPHA: u32 = 0x8599;
        pub const OPERAND1_RGB: u32 = 0x8591;
        pub const OPERAND2_ALPHA: u32 = 0x859A;
        pub const OPERAND2_RGB: u32 = 0x8592;
        pub const OR: u32 = 0x1507;
        pub const ORDER: u32 = 0x0A01;
        pub const OR_INVERTED: u32 = 0x150D;
        pub const OR_REVERSE: u32 = 0x150B;
        pub const OUT_OF_MEMORY: u32 = 0x0505;
        pub const OVERLAY_KHR: u32 = 0x9296;
        pub const PACK_ALIGNMENT: u32 = 0x0D05;
        pub const PACK_IMAGE_HEIGHT: u32 = 0x806C;
        pub const PACK_LSB_FIRST: u32 = 0x0D01;
        pub const PACK_ROW_LENGTH: u32 = 0x0D02;
        pub const PACK_SKIP_IMAGES: u32 = 0x806B;
        pub const PACK_SKIP_PIXELS: u32 = 0x0D04;
        pub const PACK_SKIP_ROWS: u32 = 0x0D03;
        pub const PACK_SWAP_BYTES: u32 = 0x0D00;
        pub const PASS_THROUGH_TOKEN: u32 = 0x0700;
        pub const PERSPECTIVE_CORRECTION_HINT: u32 = 0x0C50;
        pub const PIXEL_MAP_A_TO_A: u32 = 0x0C79;
        pub const PIXEL_MAP_A_TO_A_SIZE: u32 = 0x0CB9;
        pub const PIXEL_MAP_B_TO_B: u32 = 0x0C78;
        pub const PIXEL_MAP_B_TO_B_SIZE: u32 = 0x0CB8;
        pub const PIXEL_MAP_G_TO_G: u32 = 0x0C77;
        pub const PIXEL_MAP_G_TO_G_SIZE: u32 = 0x0CB7;
        pub const PIXEL_MAP_I_TO_A: u32 = 0x0C75;
        pub const PIXEL_MAP_I_TO_A_SIZE: u32 = 0x0CB5;
        pub const PIXEL_MAP_I_TO_B: u32 = 0x0C74;
        pub const PIXEL_MAP_I_TO_B_SIZE: u32 = 0x0CB4;
        pub const PIXEL_MAP_I_TO_G: u32 = 0x0C73;
        pub const PIXEL_MAP_I_TO_G_SIZE: u32 = 0x0CB3;
        pub const PIXEL_MAP_I_TO_I: u32 = 0x0C70;
        pub const PIXEL_MAP_I_TO_I_SIZE: u32 = 0x0CB0;
        pub const PIXEL_MAP_I_TO_R: u32 = 0x0C72;
        pub const PIXEL_MAP_I_TO_R_SIZE: u32 = 0x0CB2;
        pub const PIXEL_MAP_R_TO_R: u32 = 0x0C76;
        pub const PIXEL_MAP_R_TO_R_SIZE: u32 = 0x0CB6;
        pub const PIXEL_MAP_S_TO_S: u32 = 0x0C71;
        pub const PIXEL_MAP_S_TO_S_SIZE: u32 = 0x0CB1;
        pub const PIXEL_MODE_BIT: u32 = 0x00000020;
        pub const PIXEL_PACK_BUFFER: u32 = 0x88EB;
        pub const PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
        pub const PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
        pub const PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
        pub const POINT: u32 = 0x1B00;
        pub const POINTS: u32 = 0x0000;
        pub const POINT_BIT: u32 = 0x00000002;
        pub const POINT_DISTANCE_ATTENUATION: u32 = 0x8129;
        pub const POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
        pub const POINT_SIZE: u32 = 0x0B11;
        pub const POINT_SIZE_GRANULARITY: u32 = 0x0B13;
        pub const POINT_SIZE_MAX: u32 = 0x8127;
        pub const POINT_SIZE_MIN: u32 = 0x8126;
        pub const POINT_SIZE_RANGE: u32 = 0x0B12;
        pub const POINT_SMOOTH: u32 = 0x0B10;
        pub const POINT_SMOOTH_HINT: u32 = 0x0C51;
        pub const POINT_SPRITE: u32 = 0x8861;
        pub const POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
        pub const POINT_TOKEN: u32 = 0x0701;
        pub const POLYGON: u32 = 0x0009;
        pub const POLYGON_BIT: u32 = 0x00000008;
        pub const POLYGON_MODE: u32 = 0x0B40;
        pub const POLYGON_OFFSET_FACTOR: u32 = 0x8038;
        pub const POLYGON_OFFSET_FILL: u32 = 0x8037;
        pub const POLYGON_OFFSET_LINE: u32 = 0x2A02;
        pub const POLYGON_OFFSET_POINT: u32 = 0x2A01;
        pub const POLYGON_OFFSET_UNITS: u32 = 0x2A00;
        pub const POLYGON_SMOOTH: u32 = 0x0B41;
        pub const POLYGON_SMOOTH_HINT: u32 = 0x0C53;
        pub const POLYGON_STIPPLE: u32 = 0x0B42;
        pub const POLYGON_STIPPLE_BIT: u32 = 0x00000010;
        pub const POLYGON_TOKEN: u32 = 0x0703;
        pub const POSITION: u32 = 0x1203;
        pub const PREVIOUS: u32 = 0x8578;
        pub const PRIMARY_COLOR: u32 = 0x8577;
        pub const PRIMITIVES_GENERATED: u32 = 0x8C87;
        pub const PRIMITIVE_RESTART: u32 = 0x8F9D;
        pub const PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
        pub const PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
        pub const PROGRAM: u32 = 0x82E2;
        pub const PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
        pub const PROGRAM_BINARY_LENGTH: u32 = 0x8741;
        pub const PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
        pub const PROGRAM_KHR: u32 = 0x82E2;
        pub const PROGRAM_PIPELINE: u32 = 0x82E4;
        pub const PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
        pub const PROGRAM_POINT_SIZE: u32 = 0x8642;
        pub const PROJECTION: u32 = 0x1701;
        pub const PROJECTION_MATRIX: u32 = 0x0BA7;
        pub const PROJECTION_STACK_DEPTH: u32 = 0x0BA4;
        pub const PROVOKING_VERTEX: u32 = 0x8E4F;
        pub const PROXY_TEXTURE_1D: u32 = 0x8063;
        pub const PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
        pub const PROXY_TEXTURE_2D: u32 = 0x8064;
        pub const PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
        pub const PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
        pub const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
        pub const PROXY_TEXTURE_3D: u32 = 0x8070;
        pub const PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
        pub const PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
        pub const PROXY_TEXTURE_RECTANGLE_ARB: u32 = 0x84F7;
        pub const Q: u32 = 0x2003;
        pub const QUADRATIC_ATTENUATION: u32 = 0x1209;
        pub const QUADS: u32 = 0x0007;
        pub const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
        pub const QUAD_STRIP: u32 = 0x0008;
        pub const QUERY: u32 = 0x82E3;
        pub const QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
        pub const QUERY_BY_REGION_WAIT: u32 = 0x8E15;
        pub const QUERY_COUNTER_BITS: u32 = 0x8864;
        pub const QUERY_COUNTER_BITS_EXT: u32 = 0x8864;
        pub const QUERY_KHR: u32 = 0x82E3;
        pub const QUERY_NO_WAIT: u32 = 0x8E14;
        pub const QUERY_RESULT: u32 = 0x8866;
        pub const QUERY_RESULT_AVAILABLE: u32 = 0x8867;
        pub const QUERY_RESULT_AVAILABLE_EXT: u32 = 0x8867;
        pub const QUERY_RESULT_EXT: u32 = 0x8866;
        pub const QUERY_WAIT: u32 = 0x8E13;
        pub const R: u32 = 0x2002;
        pub const R11F_G11F_B10F: u32 = 0x8C3A;
        pub const R16: u32 = 0x822A;
        pub const R16F: u32 = 0x822D;
        pub const R16F_EXT: u32 = 0x822D;
        pub const R16I: u32 = 0x8233;
        pub const R16UI: u32 = 0x8234;
        pub const R16_SNORM: u32 = 0x8F98;
        pub const R32F: u32 = 0x822E;
        pub const R32F_EXT: u32 = 0x822E;
        pub const R32I: u32 = 0x8235;
        pub const R32UI: u32 = 0x8236;
        pub const R3_G3_B2: u32 = 0x2A10;
        pub const R8: u32 = 0x8229;
        pub const R8I: u32 = 0x8231;
        pub const R8UI: u32 = 0x8232;
        pub const R8_EXT: u32 = 0x8229;
        pub const R8_SNORM: u32 = 0x8F94;
        pub const RASTERIZER_DISCARD: u32 = 0x8C89;
        pub const READ_BUFFER: u32 = 0x0C02;
        pub const READ_FRAMEBUFFER: u32 = 0x8CA8;
        pub const READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
        pub const READ_ONLY: u32 = 0x88B8;
        pub const READ_WRITE: u32 = 0x88BA;
        pub const RED: u32 = 0x1903;
        pub const RED_BIAS: u32 = 0x0D15;
        pub const RED_BITS: u32 = 0x0D52;
        pub const RED_INTEGER: u32 = 0x8D94;
        pub const RED_SCALE: u32 = 0x0D14;
        pub const REFLECTION_MAP: u32 = 0x8512;
        pub const RENDER: u32 = 0x1C00;
        pub const RENDERBUFFER: u32 = 0x8D41;
        pub const RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
        pub const RENDERBUFFER_BINDING: u32 = 0x8CA7;
        pub const RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
        pub const RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
        pub const RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
        pub const RENDERBUFFER_HEIGHT: u32 = 0x8D43;
        pub const RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
        pub const RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
        pub const RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
        pub const RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
        pub const RENDERBUFFER_WIDTH: u32 = 0x8D42;
        pub const RENDERER: u32 = 0x1F01;
        pub const RENDER_MODE: u32 = 0x0C40;
        pub const REPEAT: u32 = 0x2901;
        pub const REPLACE: u32 = 0x1E01;
        pub const REQUIRED_TEXTURE_IMAGE_UNITS_OES: u32 = 0x8D68;
        pub const RESCALE_NORMAL: u32 = 0x803A;
        pub const RETURN: u32 = 0x0102;
        pub const RG: u32 = 0x8227;
        pub const RG16: u32 = 0x822C;
        pub const RG16F: u32 = 0x822F;
        pub const RG16F_EXT: u32 = 0x822F;
        pub const RG16I: u32 = 0x8239;
        pub const RG16UI: u32 = 0x823A;
        pub const RG16_SNORM: u32 = 0x8F99;
        pub const RG32F: u32 = 0x8230;
        pub const RG32F_EXT: u32 = 0x8230;
        pub const RG32I: u32 = 0x823B;
        pub const RG32UI: u32 = 0x823C;
        pub const RG8: u32 = 0x822B;
        pub const RG8I: u32 = 0x8237;
        pub const RG8UI: u32 = 0x8238;
        pub const RG8_EXT: u32 = 0x822B;
        pub const RG8_SNORM: u32 = 0x8F95;
        pub const RGB: u32 = 0x1907;
        pub const RGB10: u32 = 0x8052;
        pub const RGB10_A2: u32 = 0x8059;
        pub const RGB10_A2UI: u32 = 0x906F;
        pub const RGB10_A2_EXT: u32 = 0x8059;
        pub const RGB10_EXT: u32 = 0x8052;
        pub const RGB12: u32 = 0x8053;
        pub const RGB16: u32 = 0x8054;
        pub const RGB16F: u32 = 0x881B;
        pub const RGB16F_EXT: u32 = 0x881B;
        pub const RGB16I: u32 = 0x8D89;
        pub const RGB16UI: u32 = 0x8D77;
        pub const RGB16_SNORM: u32 = 0x8F9A;
        pub const RGB32F: u32 = 0x8815;
        pub const RGB32F_EXT: u32 = 0x8815;
        pub const RGB32I: u32 = 0x8D83;
        pub const RGB32UI: u32 = 0x8D71;
        pub const RGB4: u32 = 0x804F;
        pub const RGB5: u32 = 0x8050;
        pub const RGB565: u32 = 0x8D62;
        pub const RGB5_A1: u32 = 0x8057;
        pub const RGB8: u32 = 0x8051;
        pub const RGB8I: u32 = 0x8D8F;
        pub const RGB8UI: u32 = 0x8D7D;
        pub const RGB8_SNORM: u32 = 0x8F96;
        pub const RGB9_E5: u32 = 0x8C3D;
        pub const RGBA: u32 = 0x1908;
        pub const RGBA12: u32 = 0x805A;
        pub const RGBA16: u32 = 0x805B;
        pub const RGBA16F: u32 = 0x881A;
        pub const RGBA16F_EXT: u32 = 0x881A;
        pub const RGBA16I: u32 = 0x8D88;
        pub const RGBA16UI: u32 = 0x8D76;
        pub const RGBA16_SNORM: u32 = 0x8F9B;
        pub const RGBA2: u32 = 0x8055;
        pub const RGBA32F: u32 = 0x8814;
        pub const RGBA32F_EXT: u32 = 0x8814;
        pub const RGBA32I: u32 = 0x8D82;
        pub const RGBA32UI: u32 = 0x8D70;
        pub const RGBA4: u32 = 0x8056;
        pub const RGBA8: u32 = 0x8058;
        pub const RGBA8I: u32 = 0x8D8E;
        pub const RGBA8UI: u32 = 0x8D7C;
        pub const RGBA8_SNORM: u32 = 0x8F97;
        pub const RGBA_INTEGER: u32 = 0x8D99;
        pub const RGBA_MODE: u32 = 0x0C31;
        pub const RGB_INTEGER: u32 = 0x8D98;
        pub const RGB_SCALE: u32 = 0x8573;
        pub const RG_INTEGER: u32 = 0x8228;
        pub const RIGHT: u32 = 0x0407;
        pub const S: u32 = 0x2000;
        pub const SAMPLER: u32 = 0x82E6;
        pub const SAMPLER_1D: u32 = 0x8B5D;
        pub const SAMPLER_1D_ARRAY: u32 = 0x8DC0;
        pub const SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
        pub const SAMPLER_1D_SHADOW: u32 = 0x8B61;
        pub const SAMPLER_2D: u32 = 0x8B5E;
        pub const SAMPLER_2D_ARRAY: u32 = 0x8DC1;
        pub const SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
        pub const SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
        pub const SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
        pub const SAMPLER_2D_RECT: u32 = 0x8B63;
        pub const SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
        pub const SAMPLER_2D_SHADOW: u32 = 0x8B62;
        pub const SAMPLER_3D: u32 = 0x8B5F;
        pub const SAMPLER_BINDING: u32 = 0x8919;
        pub const SAMPLER_BUFFER: u32 = 0x8DC2;
        pub const SAMPLER_CUBE: u32 = 0x8B60;
        pub const SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
        pub const SAMPLER_EXTERNAL_OES: u32 = 0x8D66;
        pub const SAMPLER_KHR: u32 = 0x82E6;
        pub const SAMPLES: u32 = 0x80A9;
        pub const SAMPLES_PASSED: u32 = 0x8914;
        pub const SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
        pub const SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
        pub const SAMPLE_BUFFERS: u32 = 0x80A8;
        pub const SAMPLE_COVERAGE: u32 = 0x80A0;
        pub const SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
        pub const SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
        pub const SAMPLE_MASK: u32 = 0x8E51;
        pub const SAMPLE_MASK_VALUE: u32 = 0x8E52;
        pub const SAMPLE_POSITION: u32 = 0x8E50;
        pub const SCISSOR_BIT: u32 = 0x00080000;
        pub const SCISSOR_BOX: u32 = 0x0C10;
        pub const SCISSOR_TEST: u32 = 0x0C11;
        pub const SCREEN_KHR: u32 = 0x9295;
        pub const SECONDARY_COLOR_ARRAY: u32 = 0x845E;
        pub const SECONDARY_COLOR_ARRAY_BUFFER_BINDING: u32 = 0x889C;
        pub const SECONDARY_COLOR_ARRAY_POINTER: u32 = 0x845D;
        pub const SECONDARY_COLOR_ARRAY_SIZE: u32 = 0x845A;
        pub const SECONDARY_COLOR_ARRAY_STRIDE: u32 = 0x845C;
        pub const SECONDARY_COLOR_ARRAY_TYPE: u32 = 0x845B;
        pub const SELECT: u32 = 0x1C02;
        pub const SELECTION_BUFFER_POINTER: u32 = 0x0DF3;
        pub const SELECTION_BUFFER_SIZE: u32 = 0x0DF4;
        pub const SEPARATE_ATTRIBS: u32 = 0x8C8D;
        pub const SEPARATE_SPECULAR_COLOR: u32 = 0x81FA;
        pub const SET: u32 = 0x150F;
        pub const SHADER: u32 = 0x82E1;
        pub const SHADER_BINARY_FORMATS: u32 = 0x8DF8;
        pub const SHADER_COMPILER: u32 = 0x8DFA;
        pub const SHADER_KHR: u32 = 0x82E1;
        pub const SHADER_PIXEL_LOCAL_STORAGE_EXT: u32 = 0x8F64;
        pub const SHADER_SOURCE_LENGTH: u32 = 0x8B88;
        pub const SHADER_TYPE: u32 = 0x8B4F;
        pub const SHADE_MODEL: u32 = 0x0B54;
        pub const SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
        pub const SHININESS: u32 = 0x1601;
        pub const SHORT: u32 = 0x1402;
        pub const SIGNALED: u32 = 0x9119;
        pub const SIGNED_NORMALIZED: u32 = 0x8F9C;
        pub const SINGLE_COLOR: u32 = 0x81F9;
        pub const SLUMINANCE: u32 = 0x8C46;
        pub const SLUMINANCE8: u32 = 0x8C47;
        pub const SLUMINANCE8_ALPHA8: u32 = 0x8C45;
        pub const SLUMINANCE_ALPHA: u32 = 0x8C44;
        pub const SMOOTH: u32 = 0x1D01;
        pub const SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
        pub const SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
        pub const SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
        pub const SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
        pub const SOFTLIGHT_KHR: u32 = 0x929C;
        pub const SOURCE0_ALPHA: u32 = 0x8588;
        pub const SOURCE0_RGB: u32 = 0x8580;
        pub const SOURCE1_ALPHA: u32 = 0x8589;
        pub const SOURCE1_RGB: u32 = 0x8581;
        pub const SOURCE2_ALPHA: u32 = 0x858A;
        pub const SOURCE2_RGB: u32 = 0x8582;
        pub const SPECULAR: u32 = 0x1202;
        pub const SPHERE_MAP: u32 = 0x2402;
        pub const SPOT_CUTOFF: u32 = 0x1206;
        pub const SPOT_DIRECTION: u32 = 0x1204;
        pub const SPOT_EXPONENT: u32 = 0x1205;
        pub const SRC0_ALPHA: u32 = 0x8588;
        pub const SRC0_RGB: u32 = 0x8580;
        pub const SRC1_ALPHA: u32 = 0x8589;
        pub const SRC1_COLOR: u32 = 0x88F9;
        pub const SRC1_RGB: u32 = 0x8581;
        pub const SRC2_ALPHA: u32 = 0x858A;
        pub const SRC2_RGB: u32 = 0x8582;
        pub const SRC_ALPHA: u32 = 0x0302;
        pub const SRC_ALPHA_SATURATE: u32 = 0x0308;
        pub const SRC_COLOR: u32 = 0x0300;
        pub const SRGB: u32 = 0x8C40;
        pub const SRGB8: u32 = 0x8C41;
        pub const SRGB8_ALPHA8: u32 = 0x8C43;
        pub const SRGB_ALPHA: u32 = 0x8C42;
        pub const STACK_OVERFLOW: u32 = 0x0503;
        pub const STACK_OVERFLOW_KHR: u32 = 0x0503;
        pub const STACK_UNDERFLOW: u32 = 0x0504;
        pub const STACK_UNDERFLOW_KHR: u32 = 0x0504;
        pub const STATIC_COPY: u32 = 0x88E6;
        pub const STATIC_DRAW: u32 = 0x88E4;
        pub const STATIC_READ: u32 = 0x88E5;
        pub const STENCIL: u32 = 0x1802;
        pub const STENCIL_ATTACHMENT: u32 = 0x8D20;
        pub const STENCIL_BACK_FAIL: u32 = 0x8801;
        pub const STENCIL_BACK_FUNC: u32 = 0x8800;
        pub const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
        pub const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
        pub const STENCIL_BACK_REF: u32 = 0x8CA3;
        pub const STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
        pub const STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
        pub const STENCIL_BITS: u32 = 0x0D57;
        pub const STENCIL_BUFFER_BIT: u32 = 0x00000400;
        pub const STENCIL_CLEAR_VALUE: u32 = 0x0B91;
        pub const STENCIL_FAIL: u32 = 0x0B94;
        pub const STENCIL_FUNC: u32 = 0x0B92;
        pub const STENCIL_INDEX: u32 = 0x1901;
        pub const STENCIL_INDEX1: u32 = 0x8D46;
        pub const STENCIL_INDEX16: u32 = 0x8D49;
        pub const STENCIL_INDEX4: u32 = 0x8D47;
        pub const STENCIL_INDEX8: u32 = 0x8D48;
        pub const STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
        pub const STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
        pub const STENCIL_REF: u32 = 0x0B97;
        pub const STENCIL_TEST: u32 = 0x0B90;
        pub const STENCIL_VALUE_MASK: u32 = 0x0B93;
        pub const STENCIL_WRITEMASK: u32 = 0x0B98;
        pub const STEREO: u32 = 0x0C33;
        pub const STORAGE_CACHED_APPLE: u32 = 0x85BE;
        pub const STORAGE_PRIVATE_APPLE: u32 = 0x85BD;
        pub const STORAGE_SHARED_APPLE: u32 = 0x85BF;
        pub const STREAM_COPY: u32 = 0x88E2;
        pub const STREAM_DRAW: u32 = 0x88E0;
        pub const STREAM_READ: u32 = 0x88E1;
        pub const SUBPIXEL_BITS: u32 = 0x0D50;
        pub const SUBTRACT: u32 = 0x84E7;
        pub const SYNC_CONDITION: u32 = 0x9113;
        pub const SYNC_FENCE: u32 = 0x9116;
        pub const SYNC_FLAGS: u32 = 0x9115;
        pub const SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
        pub const SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
        pub const SYNC_STATUS: u32 = 0x9114;
        pub const T: u32 = 0x2001;
        pub const T2F_C3F_V3F: u32 = 0x2A2A;
        pub const T2F_C4F_N3F_V3F: u32 = 0x2A2C;
        pub const T2F_C4UB_V3F: u32 = 0x2A29;
        pub const T2F_N3F_V3F: u32 = 0x2A2B;
        pub const T2F_V3F: u32 = 0x2A27;
        pub const T4F_C4F_N3F_V4F: u32 = 0x2A2D;
        pub const T4F_V4F: u32 = 0x2A28;
        pub const TEXTURE: u32 = 0x1702;
        pub const TEXTURE0: u32 = 0x84C0;
        pub const TEXTURE1: u32 = 0x84C1;
        pub const TEXTURE10: u32 = 0x84CA;
        pub const TEXTURE11: u32 = 0x84CB;
        pub const TEXTURE12: u32 = 0x84CC;
        pub const TEXTURE13: u32 = 0x84CD;
        pub const TEXTURE14: u32 = 0x84CE;
        pub const TEXTURE15: u32 = 0x84CF;
        pub const TEXTURE16: u32 = 0x84D0;
        pub const TEXTURE17: u32 = 0x84D1;
        pub const TEXTURE18: u32 = 0x84D2;
        pub const TEXTURE19: u32 = 0x84D3;
        pub const TEXTURE2: u32 = 0x84C2;
        pub const TEXTURE20: u32 = 0x84D4;
        pub const TEXTURE21: u32 = 0x84D5;
        pub const TEXTURE22: u32 = 0x84D6;
        pub const TEXTURE23: u32 = 0x84D7;
        pub const TEXTURE24: u32 = 0x84D8;
        pub const TEXTURE25: u32 = 0x84D9;
        pub const TEXTURE26: u32 = 0x84DA;
        pub const TEXTURE27: u32 = 0x84DB;
        pub const TEXTURE28: u32 = 0x84DC;
        pub const TEXTURE29: u32 = 0x84DD;
        pub const TEXTURE3: u32 = 0x84C3;
        pub const TEXTURE30: u32 = 0x84DE;
        pub const TEXTURE31: u32 = 0x84DF;
        pub const TEXTURE4: u32 = 0x84C4;
        pub const TEXTURE5: u32 = 0x84C5;
        pub const TEXTURE6: u32 = 0x84C6;
        pub const TEXTURE7: u32 = 0x84C7;
        pub const TEXTURE8: u32 = 0x84C8;
        pub const TEXTURE9: u32 = 0x84C9;
        pub const TEXTURE_1D: u32 = 0x0DE0;
        pub const TEXTURE_1D_ARRAY: u32 = 0x8C18;
        pub const TEXTURE_2D: u32 = 0x0DE1;
        pub const TEXTURE_2D_ARRAY: u32 = 0x8C1A;
        pub const TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
        pub const TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
        pub const TEXTURE_3D: u32 = 0x806F;
        pub const TEXTURE_ALPHA_SIZE: u32 = 0x805F;
        pub const TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
        pub const TEXTURE_BASE_LEVEL: u32 = 0x813C;
        pub const TEXTURE_BINDING_1D: u32 = 0x8068;
        pub const TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
        pub const TEXTURE_BINDING_2D: u32 = 0x8069;
        pub const TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
        pub const TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
        pub const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
        pub const TEXTURE_BINDING_3D: u32 = 0x806A;
        pub const TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
        pub const TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
        pub const TEXTURE_BINDING_EXTERNAL_OES: u32 = 0x8D67;
        pub const TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
        pub const TEXTURE_BINDING_RECTANGLE_ARB: u32 = 0x84F6;
        pub const TEXTURE_BIT: u32 = 0x00040000;
        pub const TEXTURE_BLUE_SIZE: u32 = 0x805E;
        pub const TEXTURE_BLUE_TYPE: u32 = 0x8C12;
        pub const TEXTURE_BORDER: u32 = 0x1005;
        pub const TEXTURE_BORDER_COLOR: u32 = 0x1004;
        pub const TEXTURE_BUFFER: u32 = 0x8C2A;
        pub const TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
        pub const TEXTURE_COMPARE_FUNC: u32 = 0x884D;
        pub const TEXTURE_COMPARE_MODE: u32 = 0x884C;
        pub const TEXTURE_COMPONENTS: u32 = 0x1003;
        pub const TEXTURE_COMPRESSED: u32 = 0x86A1;
        pub const TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
        pub const TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
        pub const TEXTURE_COORD_ARRAY: u32 = 0x8078;
        pub const TEXTURE_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889A;
        pub const TEXTURE_COORD_ARRAY_POINTER: u32 = 0x8092;
        pub const TEXTURE_COORD_ARRAY_SIZE: u32 = 0x8088;
        pub const TEXTURE_COORD_ARRAY_STRIDE: u32 = 0x808A;
        pub const TEXTURE_COORD_ARRAY_TYPE: u32 = 0x8089;
        pub const TEXTURE_CUBE_MAP: u32 = 0x8513;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
        pub const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
        pub const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
        pub const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
        pub const TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
        pub const TEXTURE_DEPTH: u32 = 0x8071;
        pub const TEXTURE_DEPTH_SIZE: u32 = 0x884A;
        pub const TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
        pub const TEXTURE_ENV: u32 = 0x2300;
        pub const TEXTURE_ENV_COLOR: u32 = 0x2201;
        pub const TEXTURE_ENV_MODE: u32 = 0x2200;
        pub const TEXTURE_EXTERNAL_OES: u32 = 0x8D65;
        pub const TEXTURE_FILTER_CONTROL: u32 = 0x8500;
        pub const TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
        pub const TEXTURE_GEN_MODE: u32 = 0x2500;
        pub const TEXTURE_GEN_Q: u32 = 0x0C63;
        pub const TEXTURE_GEN_R: u32 = 0x0C62;
        pub const TEXTURE_GEN_S: u32 = 0x0C60;
        pub const TEXTURE_GEN_T: u32 = 0x0C61;
        pub const TEXTURE_GREEN_SIZE: u32 = 0x805D;
        pub const TEXTURE_GREEN_TYPE: u32 = 0x8C11;
        pub const TEXTURE_HEIGHT: u32 = 0x1001;
        pub const TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
        pub const TEXTURE_IMMUTABLE_FORMAT_EXT: u32 = 0x912F;
        pub const TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
        pub const TEXTURE_INTENSITY_SIZE: u32 = 0x8061;
        pub const TEXTURE_INTENSITY_TYPE: u32 = 0x8C15;
        pub const TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
        pub const TEXTURE_LOD_BIAS: u32 = 0x8501;
        pub const TEXTURE_LUMINANCE_SIZE: u32 = 0x8060;
        pub const TEXTURE_LUMINANCE_TYPE: u32 = 0x8C14;
        pub const TEXTURE_MAG_FILTER: u32 = 0x2800;
        pub const TEXTURE_MATRIX: u32 = 0x0BA8;
        pub const TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
        pub const TEXTURE_MAX_LEVEL: u32 = 0x813D;
        pub const TEXTURE_MAX_LOD: u32 = 0x813B;
        pub const TEXTURE_MIN_FILTER: u32 = 0x2801;
        pub const TEXTURE_MIN_LOD: u32 = 0x813A;
        pub const TEXTURE_PRIORITY: u32 = 0x8066;
        pub const TEXTURE_RANGE_LENGTH_APPLE: u32 = 0x85B7;
        pub const TEXTURE_RANGE_POINTER_APPLE: u32 = 0x85B8;
        pub const TEXTURE_RECTANGLE: u32 = 0x84F5;
        pub const TEXTURE_RECTANGLE_ARB: u32 = 0x84F5;
        pub const TEXTURE_RED_SIZE: u32 = 0x805C;
        pub const TEXTURE_RED_TYPE: u32 = 0x8C10;
        pub const TEXTURE_RESIDENT: u32 = 0x8067;
        pub const TEXTURE_SAMPLES: u32 = 0x9106;
        pub const TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
        pub const TEXTURE_STACK_DEPTH: u32 = 0x0BA5;
        pub const TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
        pub const TEXTURE_STORAGE_HINT_APPLE: u32 = 0x85BC;
        pub const TEXTURE_SWIZZLE_A: u32 = 0x8E45;
        pub const TEXTURE_SWIZZLE_B: u32 = 0x8E44;
        pub const TEXTURE_SWIZZLE_G: u32 = 0x8E43;
        pub const TEXTURE_SWIZZLE_R: u32 = 0x8E42;
        pub const TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
        pub const TEXTURE_USAGE_ANGLE: u32 = 0x93A2;
        pub const TEXTURE_WIDTH: u32 = 0x1000;
        pub const TEXTURE_WRAP_R: u32 = 0x8072;
        pub const TEXTURE_WRAP_S: u32 = 0x2802;
        pub const TEXTURE_WRAP_T: u32 = 0x2803;
        pub const TIMEOUT_EXPIRED: u32 = 0x911B;
        pub const TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
        pub const TIMESTAMP: u32 = 0x8E28;
        pub const TIMESTAMP_EXT: u32 = 0x8E28;
        pub const TIME_ELAPSED: u32 = 0x88BF;
        pub const TIME_ELAPSED_EXT: u32 = 0x88BF;
        pub const TRANSFORM_BIT: u32 = 0x00001000;
        pub const TRANSFORM_FEEDBACK: u32 = 0x8E22;
        pub const TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
        pub const TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
        pub const TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
        pub const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
        pub const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
        pub const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
        pub const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
        pub const TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
        pub const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
        pub const TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
        pub const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
        pub const TRANSPOSE_COLOR_MATRIX: u32 = 0x84E6;
        pub const TRANSPOSE_MODELVIEW_MATRIX: u32 = 0x84E3;
        pub const TRANSPOSE_PROJECTION_MATRIX: u32 = 0x84E4;
        pub const TRANSPOSE_TEXTURE_MATRIX: u32 = 0x84E5;
        pub const TRIANGLES: u32 = 0x0004;
        pub const TRIANGLES_ADJACENCY: u32 = 0x000C;
        pub const TRIANGLE_FAN: u32 = 0x0006;
        pub const TRIANGLE_STRIP: u32 = 0x0005;
        pub const TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
        pub const TRUE: u8 = 1;
        pub const UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
        pub const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
        pub const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
        pub const UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
        pub const UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
        pub const UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
        pub const UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
        pub const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
        pub const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
        pub const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
        pub const UNIFORM_BUFFER: u32 = 0x8A11;
        pub const UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
        pub const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
        pub const UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
        pub const UNIFORM_BUFFER_START: u32 = 0x8A29;
        pub const UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
        pub const UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
        pub const UNIFORM_NAME_LENGTH: u32 = 0x8A39;
        pub const UNIFORM_OFFSET: u32 = 0x8A3B;
        pub const UNIFORM_SIZE: u32 = 0x8A38;
        pub const UNIFORM_TYPE: u32 = 0x8A37;
        pub const UNPACK_ALIGNMENT: u32 = 0x0CF5;
        pub const UNPACK_CLIENT_STORAGE_APPLE: u32 = 0x85B2;
        pub const UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
        pub const UNPACK_LSB_FIRST: u32 = 0x0CF1;
        pub const UNPACK_ROW_LENGTH: u32 = 0x0CF2;
        pub const UNPACK_SKIP_IMAGES: u32 = 0x806D;
        pub const UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
        pub const UNPACK_SKIP_ROWS: u32 = 0x0CF3;
        pub const UNPACK_SWAP_BYTES: u32 = 0x0CF0;
        pub const UNSIGNALED: u32 = 0x9118;
        pub const UNSIGNED_BYTE: u32 = 0x1401;
        pub const UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
        pub const UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
        pub const UNSIGNED_INT: u32 = 0x1405;
        pub const UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
        pub const UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
        pub const UNSIGNED_INT_24_8: u32 = 0x84FA;
        pub const UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
        pub const UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
        pub const UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
        pub const UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
        pub const UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
        pub const UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
        pub const UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
        pub const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
        pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
        pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
        pub const UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
        pub const UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
        pub const UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
        pub const UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
        pub const UNSIGNED_INT_VEC2: u32 = 0x8DC6;
        pub const UNSIGNED_INT_VEC3: u32 = 0x8DC7;
        pub const UNSIGNED_INT_VEC4: u32 = 0x8DC8;
        pub const UNSIGNED_NORMALIZED: u32 = 0x8C17;
        pub const UNSIGNED_SHORT: u32 = 0x1403;
        pub const UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
        pub const UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
        pub const UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
        pub const UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
        pub const UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
        pub const UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
        pub const UPPER_LEFT: u32 = 0x8CA2;
        pub const V2F: u32 = 0x2A20;
        pub const V3F: u32 = 0x2A21;
        pub const VALIDATE_STATUS: u32 = 0x8B83;
        pub const VENDOR: u32 = 0x1F00;
        pub const VERSION: u32 = 0x1F02;
        pub const VERTEX_ARRAY: u32 = 0x8074;
        pub const VERTEX_ARRAY_BINDING: u32 = 0x85B5;
        pub const VERTEX_ARRAY_BINDING_APPLE: u32 = 0x85B5;
        pub const VERTEX_ARRAY_BUFFER_BINDING: u32 = 0x8896;
        pub const VERTEX_ARRAY_KHR: u32 = 0x8074;
        pub const VERTEX_ARRAY_POINTER: u32 = 0x808E;
        pub const VERTEX_ARRAY_SIZE: u32 = 0x807A;
        pub const VERTEX_ARRAY_STRIDE: u32 = 0x807C;
        pub const VERTEX_ARRAY_TYPE: u32 = 0x807B;
        pub const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
        pub const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
        pub const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
        pub const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
        pub const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
        pub const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
        pub const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
        pub const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
        pub const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
        pub const VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
        pub const VERTEX_PROGRAM_TWO_SIDE: u32 = 0x8643;
        pub const VERTEX_SHADER: u32 = 0x8B31;
        pub const VIEWPORT: u32 = 0x0BA2;
        pub const VIEWPORT_BIT: u32 = 0x00000800;
        pub const WAIT_FAILED: u32 = 0x911D;
        pub const WEIGHT_ARRAY_BUFFER_BINDING: u32 = 0x889E;
        pub const WRITE_ONLY: u32 = 0x88B9;
        pub const XOR: u32 = 0x1506;
        pub const ZERO: u32 = 0;
        pub const ZOOM_X: u32 = 0x0D16;
        pub const ZOOM_Y: u32 = 0x0D17;

        /// Calls the `Gl::get_type` function.
        pub fn get_type(&self) -> crate::gl::GlType {
            unsafe { crate::dll::AzGl_getType(self) }
        }
        /// Calls the `Gl::buffer_data_untyped` function.
        pub fn buffer_data_untyped<_3: Into<GlVoidPtrConst>>(
            &self,
            target: u32,
            size: isize,
            data: _3,
            usage: u32,
        ) {
            unsafe { crate::dll::AzGl_bufferDataUntyped(self, target, size, data.into(), usage) }
        }
        /// Calls the `Gl::buffer_sub_data_untyped` function.
        pub fn buffer_sub_data_untyped<_4: Into<GlVoidPtrConst>>(
            &self,
            target: u32,
            offset: isize,
            size: isize,
            data: _4,
        ) {
            unsafe {
                crate::dll::AzGl_bufferSubDataUntyped(self, target, offset, size, data.into())
            }
        }
        /// Calls the `Gl::map_buffer` function.
        pub fn map_buffer(&self, target: u32, access: u32) -> crate::gl::GlVoidPtrMut {
            unsafe { crate::dll::AzGl_mapBuffer(self, target, access) }
        }
        /// Calls the `Gl::map_buffer_range` function.
        pub fn map_buffer_range(
            &self,
            target: u32,
            offset: isize,
            length: isize,
            access: u32,
        ) -> crate::gl::GlVoidPtrMut {
            unsafe { crate::dll::AzGl_mapBufferRange(self, target, offset, length, access) }
        }
        /// Calls the `Gl::unmap_buffer` function.
        pub fn unmap_buffer(&self, target: u32) -> u8 {
            unsafe { crate::dll::AzGl_unmapBuffer(self, target) }
        }
        /// Calls the `Gl::tex_buffer` function.
        pub fn tex_buffer(&self, target: u32, internal_format: u32, buffer: u32) {
            unsafe { crate::dll::AzGl_texBuffer(self, target, internal_format, buffer) }
        }
        /// Calls the `Gl::shader_source` function.
        pub fn shader_source<_2: Into<StringVec>>(&self, shader: u32, strings: _2) {
            unsafe { crate::dll::AzGl_shaderSource(self, shader, strings.into()) }
        }
        /// Calls the `Gl::read_buffer` function.
        pub fn read_buffer(&self, mode: u32) {
            unsafe { crate::dll::AzGl_readBuffer(self, mode) }
        }
        /// Calls the `Gl::read_pixels_into_buffer` function.
        pub fn read_pixels_into_buffer<_7: Into<U8VecRefMut>>(
            &self,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            format: u32,
            pixel_type: u32,
            dst_buffer: _7,
        ) {
            unsafe {
                crate::dll::AzGl_readPixelsIntoBuffer(
                    self,
                    x,
                    y,
                    width,
                    height,
                    format,
                    pixel_type,
                    dst_buffer.into(),
                )
            }
        }
        /// Calls the `Gl::read_pixels` function.
        pub fn read_pixels(
            &self,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            format: u32,
            pixel_type: u32,
        ) -> crate::vec::U8Vec {
            unsafe { crate::dll::AzGl_readPixels(self, x, y, width, height, format, pixel_type) }
        }
        /// Calls the `Gl::read_pixels_into_pbo` function.
        pub fn read_pixels_into_pbo(
            &self,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            format: u32,
            pixel_type: u32,
        ) {
            unsafe {
                crate::dll::AzGl_readPixelsIntoPbo(self, x, y, width, height, format, pixel_type)
            }
        }
        /// Calls the `Gl::sample_coverage` function.
        pub fn sample_coverage(&self, value: f32, invert: bool) {
            unsafe { crate::dll::AzGl_sampleCoverage(self, value, invert) }
        }
        /// Calls the `Gl::polygon_offset` function.
        pub fn polygon_offset(&self, factor: f32, units: f32) {
            unsafe { crate::dll::AzGl_polygonOffset(self, factor, units) }
        }
        /// Calls the `Gl::pixel_store_i` function.
        pub fn pixel_store_i(&self, name: u32, param: i32) {
            unsafe { crate::dll::AzGl_pixelStoreI(self, name, param) }
        }
        /// Calls the `Gl::gen_buffers` function.
        pub fn gen_buffers(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genBuffers(self, n) }
        }
        /// Calls the `Gl::gen_renderbuffers` function.
        pub fn gen_renderbuffers(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genRenderbuffers(self, n) }
        }
        /// Calls the `Gl::gen_framebuffers` function.
        pub fn gen_framebuffers(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genFramebuffers(self, n) }
        }
        /// Calls the `Gl::gen_textures` function.
        pub fn gen_textures(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genTextures(self, n) }
        }
        /// Calls the `Gl::gen_vertex_arrays` function.
        pub fn gen_vertex_arrays(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genVertexArrays(self, n) }
        }
        /// Calls the `Gl::gen_queries` function.
        pub fn gen_queries(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genQueries(self, n) }
        }
        /// Calls the `Gl::begin_query` function.
        pub fn begin_query(&self, target: u32, id: u32) {
            unsafe { crate::dll::AzGl_beginQuery(self, target, id) }
        }
        /// Calls the `Gl::end_query` function.
        pub fn end_query(&self, target: u32) {
            unsafe { crate::dll::AzGl_endQuery(self, target) }
        }
        /// Calls the `Gl::query_counter` function.
        pub fn query_counter(&self, id: u32, target: u32) {
            unsafe { crate::dll::AzGl_queryCounter(self, id, target) }
        }
        /// Calls the `Gl::get_query_object_iv` function.
        pub fn get_query_object_iv(&self, id: u32, pname: u32) -> i32 {
            unsafe { crate::dll::AzGl_getQueryObjectIv(self, id, pname) }
        }
        /// Calls the `Gl::get_query_object_uiv` function.
        pub fn get_query_object_uiv(&self, id: u32, pname: u32) -> u32 {
            unsafe { crate::dll::AzGl_getQueryObjectUiv(self, id, pname) }
        }
        /// Calls the `Gl::get_query_object_i64v` function.
        pub fn get_query_object_i64v(&self, id: u32, pname: u32) -> i64 {
            unsafe { crate::dll::AzGl_getQueryObjectI64V(self, id, pname) }
        }
        /// Calls the `Gl::get_query_object_ui64v` function.
        pub fn get_query_object_ui64v(&self, id: u32, pname: u32) -> u64 {
            unsafe { crate::dll::AzGl_getQueryObjectUi64V(self, id, pname) }
        }
        /// Calls the `Gl::delete_queries` function.
        pub fn delete_queries<_1: Into<GLuintVecRef>>(&self, queries: _1) {
            unsafe { crate::dll::AzGl_deleteQueries(self, queries.into()) }
        }
        /// Calls the `Gl::delete_vertex_arrays` function.
        pub fn delete_vertex_arrays<_1: Into<GLuintVecRef>>(&self, vertex_arrays: _1) {
            unsafe { crate::dll::AzGl_deleteVertexArrays(self, vertex_arrays.into()) }
        }
        /// Calls the `Gl::delete_buffers` function.
        pub fn delete_buffers<_1: Into<GLuintVecRef>>(&self, buffers: _1) {
            unsafe { crate::dll::AzGl_deleteBuffers(self, buffers.into()) }
        }
        /// Calls the `Gl::delete_renderbuffers` function.
        pub fn delete_renderbuffers<_1: Into<GLuintVecRef>>(&self, renderbuffers: _1) {
            unsafe { crate::dll::AzGl_deleteRenderbuffers(self, renderbuffers.into()) }
        }
        /// Calls the `Gl::delete_framebuffers` function.
        pub fn delete_framebuffers<_1: Into<GLuintVecRef>>(&self, framebuffers: _1) {
            unsafe { crate::dll::AzGl_deleteFramebuffers(self, framebuffers.into()) }
        }
        /// Calls the `Gl::delete_textures` function.
        pub fn delete_textures<_1: Into<GLuintVecRef>>(&self, textures: _1) {
            unsafe { crate::dll::AzGl_deleteTextures(self, textures.into()) }
        }
        /// Calls the `Gl::framebuffer_renderbuffer` function.
        pub fn framebuffer_renderbuffer(
            &self,
            target: u32,
            attachment: u32,
            renderbuffertarget: u32,
            renderbuffer: u32,
        ) {
            unsafe {
                crate::dll::AzGl_framebufferRenderbuffer(
                    self,
                    target,
                    attachment,
                    renderbuffertarget,
                    renderbuffer,
                )
            }
        }
        /// Calls the `Gl::renderbuffer_storage` function.
        pub fn renderbuffer_storage(
            &self,
            target: u32,
            internalformat: u32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                crate::dll::AzGl_renderbufferStorage(self, target, internalformat, width, height)
            }
        }
        /// Calls the `Gl::depth_func` function.
        pub fn depth_func(&self, func: u32) {
            unsafe { crate::dll::AzGl_depthFunc(self, func) }
        }
        /// Calls the `Gl::active_texture` function.
        pub fn active_texture(&self, texture: u32) {
            unsafe { crate::dll::AzGl_activeTexture(self, texture) }
        }
        /// Calls the `Gl::attach_shader` function.
        pub fn attach_shader(&self, program: u32, shader: u32) {
            unsafe { crate::dll::AzGl_attachShader(self, program, shader) }
        }
        /// Calls the `Gl::bind_attrib_location` function.
        pub fn bind_attrib_location<_3: Into<Refstr>>(&self, program: u32, index: u32, name: _3) {
            unsafe { crate::dll::AzGl_bindAttribLocation(self, program, index, name.into()) }
        }
        /// Calls the `Gl::get_uniform_iv` function.
        pub fn get_uniform_iv<_3: Into<GLintVecRefMut>>(
            &self,
            program: u32,
            location: i32,
            result: _3,
        ) {
            unsafe { crate::dll::AzGl_getUniformIv(self, program, location, result.into()) }
        }
        /// Calls the `Gl::get_uniform_fv` function.
        pub fn get_uniform_fv<_3: Into<GLfloatVecRefMut>>(
            &self,
            program: u32,
            location: i32,
            result: _3,
        ) {
            unsafe { crate::dll::AzGl_getUniformFv(self, program, location, result.into()) }
        }
        /// Calls the `Gl::get_uniform_block_index` function.
        pub fn get_uniform_block_index<_2: Into<Refstr>>(&self, program: u32, name: _2) -> u32 {
            unsafe { crate::dll::AzGl_getUniformBlockIndex(self, program, name.into()) }
        }
        /// Calls the `Gl::get_uniform_indices` function.
        pub fn get_uniform_indices<_2: Into<RefstrVecRef>>(
            &self,
            program: u32,
            names: _2,
        ) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_getUniformIndices(self, program, names.into()) }
        }
        /// Calls the `Gl::bind_buffer_base` function.
        pub fn bind_buffer_base(&self, target: u32, index: u32, buffer: u32) {
            unsafe { crate::dll::AzGl_bindBufferBase(self, target, index, buffer) }
        }
        /// Calls the `Gl::bind_buffer_range` function.
        pub fn bind_buffer_range(
            &self,
            target: u32,
            index: u32,
            buffer: u32,
            offset: isize,
            size: isize,
        ) {
            unsafe { crate::dll::AzGl_bindBufferRange(self, target, index, buffer, offset, size) }
        }
        /// Calls the `Gl::uniform_block_binding` function.
        pub fn uniform_block_binding(
            &self,
            program: u32,
            uniform_block_index: u32,
            uniform_block_binding: u32,
        ) {
            unsafe {
                crate::dll::AzGl_uniformBlockBinding(
                    self,
                    program,
                    uniform_block_index,
                    uniform_block_binding,
                )
            }
        }
        /// Calls the `Gl::bind_buffer` function.
        pub fn bind_buffer(&self, target: u32, buffer: u32) {
            unsafe { crate::dll::AzGl_bindBuffer(self, target, buffer) }
        }
        /// Calls the `Gl::bind_vertex_array` function.
        pub fn bind_vertex_array(&self, vao: u32) {
            unsafe { crate::dll::AzGl_bindVertexArray(self, vao) }
        }
        /// Calls the `Gl::bind_renderbuffer` function.
        pub fn bind_renderbuffer(&self, target: u32, renderbuffer: u32) {
            unsafe { crate::dll::AzGl_bindRenderbuffer(self, target, renderbuffer) }
        }
        /// Calls the `Gl::bind_framebuffer` function.
        pub fn bind_framebuffer(&self, target: u32, framebuffer: u32) {
            unsafe { crate::dll::AzGl_bindFramebuffer(self, target, framebuffer) }
        }
        /// Calls the `Gl::bind_texture` function.
        pub fn bind_texture(&self, target: u32, texture: u32) {
            unsafe { crate::dll::AzGl_bindTexture(self, target, texture) }
        }
        /// Calls the `Gl::draw_buffers` function.
        pub fn draw_buffers<_1: Into<GLenumVecRef>>(&self, bufs: _1) {
            unsafe { crate::dll::AzGl_drawBuffers(self, bufs.into()) }
        }
        /// Calls the `Gl::tex_image_2d` function.
        pub fn tex_image_2d<_9: Into<OptionU8VecRef>>(
            &self,
            target: u32,
            level: i32,
            internal_format: i32,
            width: i32,
            height: i32,
            border: i32,
            format: u32,
            ty: u32,
            opt_data: _9,
        ) {
            unsafe {
                crate::dll::AzGl_texImage2D(
                    self,
                    target,
                    level,
                    internal_format,
                    width,
                    height,
                    border,
                    format,
                    ty,
                    opt_data.into(),
                )
            }
        }
        /// Calls the `Gl::compressed_tex_image_2d` function.
        pub fn compressed_tex_image_2d<_7: Into<U8VecRef>>(
            &self,
            target: u32,
            level: i32,
            internal_format: u32,
            width: i32,
            height: i32,
            border: i32,
            data: _7,
        ) {
            unsafe {
                crate::dll::AzGl_compressedTexImage2D(
                    self,
                    target,
                    level,
                    internal_format,
                    width,
                    height,
                    border,
                    data.into(),
                )
            }
        }
        /// Calls the `Gl::compressed_tex_sub_image_2d` function.
        pub fn compressed_tex_sub_image_2d<_8: Into<U8VecRef>>(
            &self,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
            format: u32,
            data: _8,
        ) {
            unsafe {
                crate::dll::AzGl_compressedTexSubImage2D(
                    self,
                    target,
                    level,
                    xoffset,
                    yoffset,
                    width,
                    height,
                    format,
                    data.into(),
                )
            }
        }
        /// Calls the `Gl::tex_image_3d` function.
        pub fn tex_image_3d<_10: Into<OptionU8VecRef>>(
            &self,
            target: u32,
            level: i32,
            internal_format: i32,
            width: i32,
            height: i32,
            depth: i32,
            border: i32,
            format: u32,
            ty: u32,
            opt_data: _10,
        ) {
            unsafe {
                crate::dll::AzGl_texImage3D(
                    self,
                    target,
                    level,
                    internal_format,
                    width,
                    height,
                    depth,
                    border,
                    format,
                    ty,
                    opt_data.into(),
                )
            }
        }
        /// Calls the `Gl::copy_tex_image_2d` function.
        pub fn copy_tex_image_2d(
            &self,
            target: u32,
            level: i32,
            internal_format: u32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            border: i32,
        ) {
            unsafe {
                crate::dll::AzGl_copyTexImage2D(
                    self,
                    target,
                    level,
                    internal_format,
                    x,
                    y,
                    width,
                    height,
                    border,
                )
            }
        }
        /// Calls the `Gl::copy_tex_sub_image_2d` function.
        pub fn copy_tex_sub_image_2d(
            &self,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                crate::dll::AzGl_copyTexSubImage2D(
                    self, target, level, xoffset, yoffset, x, y, width, height,
                )
            }
        }
        /// Calls the `Gl::copy_tex_sub_image_3d` function.
        pub fn copy_tex_sub_image_3d(
            &self,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            zoffset: i32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                crate::dll::AzGl_copyTexSubImage3D(
                    self, target, level, xoffset, yoffset, zoffset, x, y, width, height,
                )
            }
        }
        /// Calls the `Gl::tex_sub_image_2d` function.
        pub fn tex_sub_image_2d<_9: Into<U8VecRef>>(
            &self,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
            format: u32,
            ty: u32,
            data: _9,
        ) {
            unsafe {
                crate::dll::AzGl_texSubImage2D(
                    self,
                    target,
                    level,
                    xoffset,
                    yoffset,
                    width,
                    height,
                    format,
                    ty,
                    data.into(),
                )
            }
        }
        /// Calls the `Gl::tex_sub_image_2d_pbo` function.
        pub fn tex_sub_image_2d_pbo(
            &self,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
            format: u32,
            ty: u32,
            offset: usize,
        ) {
            unsafe {
                crate::dll::AzGl_texSubImage2DPbo(
                    self, target, level, xoffset, yoffset, width, height, format, ty, offset,
                )
            }
        }
        /// Calls the `Gl::tex_sub_image_3d` function.
        pub fn tex_sub_image_3d<_11: Into<U8VecRef>>(
            &self,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            zoffset: i32,
            width: i32,
            height: i32,
            depth: i32,
            format: u32,
            ty: u32,
            data: _11,
        ) {
            unsafe {
                crate::dll::AzGl_texSubImage3D(
                    self,
                    target,
                    level,
                    xoffset,
                    yoffset,
                    zoffset,
                    width,
                    height,
                    depth,
                    format,
                    ty,
                    data.into(),
                )
            }
        }
        /// Calls the `Gl::tex_sub_image_3d_pbo` function.
        pub fn tex_sub_image_3d_pbo(
            &self,
            target: u32,
            level: i32,
            xoffset: i32,
            yoffset: i32,
            zoffset: i32,
            width: i32,
            height: i32,
            depth: i32,
            format: u32,
            ty: u32,
            offset: usize,
        ) {
            unsafe {
                crate::dll::AzGl_texSubImage3DPbo(
                    self, target, level, xoffset, yoffset, zoffset, width, height, depth, format,
                    ty, offset,
                )
            }
        }
        /// Calls the `Gl::tex_storage_2d` function.
        pub fn tex_storage_2d(
            &self,
            target: u32,
            levels: i32,
            internal_format: u32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                crate::dll::AzGl_texStorage2D(self, target, levels, internal_format, width, height)
            }
        }
        /// Calls the `Gl::tex_storage_3d` function.
        pub fn tex_storage_3d(
            &self,
            target: u32,
            levels: i32,
            internal_format: u32,
            width: i32,
            height: i32,
            depth: i32,
        ) {
            unsafe {
                crate::dll::AzGl_texStorage3D(
                    self,
                    target,
                    levels,
                    internal_format,
                    width,
                    height,
                    depth,
                )
            }
        }
        /// Calls the `Gl::get_tex_image_into_buffer` function.
        pub fn get_tex_image_into_buffer<_5: Into<U8VecRefMut>>(
            &self,
            target: u32,
            level: i32,
            format: u32,
            ty: u32,
            output: _5,
        ) {
            unsafe {
                crate::dll::AzGl_getTexImageIntoBuffer(
                    self,
                    target,
                    level,
                    format,
                    ty,
                    output.into(),
                )
            }
        }
        /// Calls the `Gl::copy_image_sub_data` function.
        pub fn copy_image_sub_data(
            &self,
            src_name: u32,
            src_target: u32,
            src_level: i32,
            src_x: i32,
            src_y: i32,
            src_z: i32,
            dst_name: u32,
            dst_target: u32,
            dst_level: i32,
            dst_x: i32,
            dst_y: i32,
            dst_z: i32,
            src_width: i32,
            src_height: i32,
            src_depth: i32,
        ) {
            unsafe {
                crate::dll::AzGl_copyImageSubData(
                    self, src_name, src_target, src_level, src_x, src_y, src_z, dst_name,
                    dst_target, dst_level, dst_x, dst_y, dst_z, src_width, src_height, src_depth,
                )
            }
        }
        /// Calls the `Gl::invalidate_framebuffer` function.
        pub fn invalidate_framebuffer<_2: Into<GLenumVecRef>>(&self, target: u32, attachments: _2) {
            unsafe { crate::dll::AzGl_invalidateFramebuffer(self, target, attachments.into()) }
        }
        /// Calls the `Gl::invalidate_sub_framebuffer` function.
        pub fn invalidate_sub_framebuffer<_2: Into<GLenumVecRef>>(
            &self,
            target: u32,
            attachments: _2,
            xoffset: i32,
            yoffset: i32,
            width: i32,
            height: i32,
        ) {
            unsafe {
                crate::dll::AzGl_invalidateSubFramebuffer(
                    self,
                    target,
                    attachments.into(),
                    xoffset,
                    yoffset,
                    width,
                    height,
                )
            }
        }
        /// Calls the `Gl::get_integer_v` function.
        pub fn get_integer_v<_2: Into<GLintVecRefMut>>(&self, name: u32, result: _2) {
            unsafe { crate::dll::AzGl_getIntegerV(self, name, result.into()) }
        }
        /// Calls the `Gl::get_integer_64v` function.
        pub fn get_integer_64v<_2: Into<GLint64VecRefMut>>(&self, name: u32, result: _2) {
            unsafe { crate::dll::AzGl_getInteger64V(self, name, result.into()) }
        }
        /// Calls the `Gl::get_integer_iv` function.
        pub fn get_integer_iv<_3: Into<GLintVecRefMut>>(&self, name: u32, index: u32, result: _3) {
            unsafe { crate::dll::AzGl_getIntegerIv(self, name, index, result.into()) }
        }
        /// Calls the `Gl::get_integer_64iv` function.
        pub fn get_integer_64iv<_3: Into<GLint64VecRefMut>>(
            &self,
            name: u32,
            index: u32,
            result: _3,
        ) {
            unsafe { crate::dll::AzGl_getInteger64Iv(self, name, index, result.into()) }
        }
        /// Calls the `Gl::get_boolean_v` function.
        pub fn get_boolean_v<_2: Into<GLbooleanVecRefMut>>(&self, name: u32, result: _2) {
            unsafe { crate::dll::AzGl_getBooleanV(self, name, result.into()) }
        }
        /// Calls the `Gl::get_float_v` function.
        pub fn get_float_v<_2: Into<GLfloatVecRefMut>>(&self, name: u32, result: _2) {
            unsafe { crate::dll::AzGl_getFloatV(self, name, result.into()) }
        }
        /// Calls the `Gl::get_framebuffer_attachment_parameter_iv` function.
        pub fn get_framebuffer_attachment_parameter_iv(
            &self,
            target: u32,
            attachment: u32,
            pname: u32,
        ) -> i32 {
            unsafe {
                crate::dll::AzGl_getFramebufferAttachmentParameterIv(
                    self, target, attachment, pname,
                )
            }
        }
        /// Calls the `Gl::get_renderbuffer_parameter_iv` function.
        pub fn get_renderbuffer_parameter_iv(&self, target: u32, pname: u32) -> i32 {
            unsafe { crate::dll::AzGl_getRenderbufferParameterIv(self, target, pname) }
        }
        /// Calls the `Gl::get_tex_parameter_iv` function.
        pub fn get_tex_parameter_iv(&self, target: u32, name: u32) -> i32 {
            unsafe { crate::dll::AzGl_getTexParameterIv(self, target, name) }
        }
        /// Calls the `Gl::get_tex_parameter_fv` function.
        pub fn get_tex_parameter_fv(&self, target: u32, name: u32) -> f32 {
            unsafe { crate::dll::AzGl_getTexParameterFv(self, target, name) }
        }
        /// Calls the `Gl::tex_parameter_i` function.
        pub fn tex_parameter_i(&self, target: u32, pname: u32, param: i32) {
            unsafe { crate::dll::AzGl_texParameterI(self, target, pname, param) }
        }
        /// Calls the `Gl::tex_parameter_f` function.
        pub fn tex_parameter_f(&self, target: u32, pname: u32, param: f32) {
            unsafe { crate::dll::AzGl_texParameterF(self, target, pname, param) }
        }
        /// Calls the `Gl::framebuffer_texture_2d` function.
        pub fn framebuffer_texture_2d(
            &self,
            target: u32,
            attachment: u32,
            textarget: u32,
            texture: u32,
            level: i32,
        ) {
            unsafe {
                crate::dll::AzGl_framebufferTexture2D(
                    self, target, attachment, textarget, texture, level,
                )
            }
        }
        /// Calls the `Gl::framebuffer_texture_layer` function.
        pub fn framebuffer_texture_layer(
            &self,
            target: u32,
            attachment: u32,
            texture: u32,
            level: i32,
            layer: i32,
        ) {
            unsafe {
                crate::dll::AzGl_framebufferTextureLayer(
                    self, target, attachment, texture, level, layer,
                )
            }
        }
        /// Calls the `Gl::blit_framebuffer` function.
        pub fn blit_framebuffer(
            &self,
            src_x0: i32,
            src_y0: i32,
            src_x1: i32,
            src_y1: i32,
            dst_x0: i32,
            dst_y0: i32,
            dst_x1: i32,
            dst_y1: i32,
            mask: u32,
            filter: u32,
        ) {
            unsafe {
                crate::dll::AzGl_blitFramebuffer(
                    self, src_x0, src_y0, src_x1, src_y1, dst_x0, dst_y0, dst_x1, dst_y1, mask,
                    filter,
                )
            }
        }
        /// Calls the `Gl::vertex_attrib_4f` function.
        pub fn vertex_attrib_4f(&self, index: u32, x: f32, y: f32, z: f32, w: f32) {
            unsafe { crate::dll::AzGl_vertexAttrib4F(self, index, x, y, z, w) }
        }
        /// Calls the `Gl::vertex_attrib_pointer_f32` function.
        pub fn vertex_attrib_pointer_f32(
            &self,
            index: u32,
            size: i32,
            normalized: bool,
            stride: i32,
            offset: u32,
        ) {
            unsafe {
                crate::dll::AzGl_vertexAttribPointerF32(
                    self, index, size, normalized, stride, offset,
                )
            }
        }
        /// Calls the `Gl::vertex_attrib_pointer` function.
        pub fn vertex_attrib_pointer(
            &self,
            index: u32,
            size: i32,
            type_: u32,
            normalized: bool,
            stride: i32,
            offset: u32,
        ) {
            unsafe {
                crate::dll::AzGl_vertexAttribPointer(
                    self, index, size, type_, normalized, stride, offset,
                )
            }
        }
        /// Calls the `Gl::vertex_attrib_i_pointer` function.
        pub fn vertex_attrib_i_pointer(
            &self,
            index: u32,
            size: i32,
            type_: u32,
            stride: i32,
            offset: u32,
        ) {
            unsafe {
                crate::dll::AzGl_vertexAttribIPointer(self, index, size, type_, stride, offset)
            }
        }
        /// Calls the `Gl::vertex_attrib_divisor` function.
        pub fn vertex_attrib_divisor(&self, index: u32, divisor: u32) {
            unsafe { crate::dll::AzGl_vertexAttribDivisor(self, index, divisor) }
        }
        /// Calls the `Gl::viewport` function.
        pub fn viewport(&self, x: i32, y: i32, width: i32, height: i32) {
            unsafe { crate::dll::AzGl_viewport(self, x, y, width, height) }
        }
        /// Calls the `Gl::scissor` function.
        pub fn scissor(&self, x: i32, y: i32, width: i32, height: i32) {
            unsafe { crate::dll::AzGl_scissor(self, x, y, width, height) }
        }
        /// Calls the `Gl::line_width` function.
        pub fn line_width(&self, width: f32) {
            unsafe { crate::dll::AzGl_lineWidth(self, width) }
        }
        /// Calls the `Gl::use_program` function.
        pub fn use_program(&self, program: u32) {
            unsafe { crate::dll::AzGl_useProgram(self, program) }
        }
        /// Calls the `Gl::validate_program` function.
        pub fn validate_program(&self, program: u32) {
            unsafe { crate::dll::AzGl_validateProgram(self, program) }
        }
        /// Calls the `Gl::draw_arrays` function.
        pub fn draw_arrays(&self, mode: u32, first: i32, count: i32) {
            unsafe { crate::dll::AzGl_drawArrays(self, mode, first, count) }
        }
        /// Calls the `Gl::draw_arrays_instanced` function.
        pub fn draw_arrays_instanced(&self, mode: u32, first: i32, count: i32, primcount: i32) {
            unsafe { crate::dll::AzGl_drawArraysInstanced(self, mode, first, count, primcount) }
        }
        /// Calls the `Gl::draw_elements` function.
        pub fn draw_elements(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32) {
            unsafe {
                crate::dll::AzGl_drawElements(self, mode, count, element_type, indices_offset)
            }
        }
        /// Calls the `Gl::draw_elements_instanced` function.
        pub fn draw_elements_instanced(
            &self,
            mode: u32,
            count: i32,
            element_type: u32,
            indices_offset: u32,
            primcount: i32,
        ) {
            unsafe {
                crate::dll::AzGl_drawElementsInstanced(
                    self,
                    mode,
                    count,
                    element_type,
                    indices_offset,
                    primcount,
                )
            }
        }
        /// Calls the `Gl::blend_color` function.
        pub fn blend_color(&self, r: f32, g: f32, b: f32, a: f32) {
            unsafe { crate::dll::AzGl_blendColor(self, r, g, b, a) }
        }
        /// Calls the `Gl::blend_func` function.
        pub fn blend_func(&self, sfactor: u32, dfactor: u32) {
            unsafe { crate::dll::AzGl_blendFunc(self, sfactor, dfactor) }
        }
        /// Calls the `Gl::blend_func_separate` function.
        pub fn blend_func_separate(
            &self,
            src_rgb: u32,
            dest_rgb: u32,
            src_alpha: u32,
            dest_alpha: u32,
        ) {
            unsafe {
                crate::dll::AzGl_blendFuncSeparate(self, src_rgb, dest_rgb, src_alpha, dest_alpha)
            }
        }
        /// Calls the `Gl::blend_equation` function.
        pub fn blend_equation(&self, mode: u32) {
            unsafe { crate::dll::AzGl_blendEquation(self, mode) }
        }
        /// Calls the `Gl::blend_equation_separate` function.
        pub fn blend_equation_separate(&self, mode_rgb: u32, mode_alpha: u32) {
            unsafe { crate::dll::AzGl_blendEquationSeparate(self, mode_rgb, mode_alpha) }
        }
        /// Calls the `Gl::color_mask` function.
        pub fn color_mask(&self, r: bool, g: bool, b: bool, a: bool) {
            unsafe { crate::dll::AzGl_colorMask(self, r, g, b, a) }
        }
        /// Calls the `Gl::cull_face` function.
        pub fn cull_face(&self, mode: u32) {
            unsafe { crate::dll::AzGl_cullFace(self, mode) }
        }
        /// Calls the `Gl::front_face` function.
        pub fn front_face(&self, mode: u32) {
            unsafe { crate::dll::AzGl_frontFace(self, mode) }
        }
        /// Calls the `Gl::enable` function.
        pub fn enable(&self, cap: u32) {
            unsafe { crate::dll::AzGl_enable(self, cap) }
        }
        /// Calls the `Gl::disable` function.
        pub fn disable(&self, cap: u32) {
            unsafe { crate::dll::AzGl_disable(self, cap) }
        }
        /// Calls the `Gl::hint` function.
        pub fn hint(&self, param_name: u32, param_val: u32) {
            unsafe { crate::dll::AzGl_hint(self, param_name, param_val) }
        }
        /// Calls the `Gl::is_enabled` function.
        pub fn is_enabled(&self, cap: u32) -> u8 {
            unsafe { crate::dll::AzGl_isEnabled(self, cap) }
        }
        /// Calls the `Gl::is_shader` function.
        pub fn is_shader(&self, shader: u32) -> u8 {
            unsafe { crate::dll::AzGl_isShader(self, shader) }
        }
        /// Calls the `Gl::is_texture` function.
        pub fn is_texture(&self, texture: u32) -> u8 {
            unsafe { crate::dll::AzGl_isTexture(self, texture) }
        }
        /// Calls the `Gl::is_framebuffer` function.
        pub fn is_framebuffer(&self, framebuffer: u32) -> u8 {
            unsafe { crate::dll::AzGl_isFramebuffer(self, framebuffer) }
        }
        /// Calls the `Gl::is_renderbuffer` function.
        pub fn is_renderbuffer(&self, renderbuffer: u32) -> u8 {
            unsafe { crate::dll::AzGl_isRenderbuffer(self, renderbuffer) }
        }
        /// Calls the `Gl::check_frame_buffer_status` function.
        pub fn check_frame_buffer_status(&self, target: u32) -> u32 {
            unsafe { crate::dll::AzGl_checkFrameBufferStatus(self, target) }
        }
        /// Calls the `Gl::enable_vertex_attrib_array` function.
        pub fn enable_vertex_attrib_array(&self, index: u32) {
            unsafe { crate::dll::AzGl_enableVertexAttribArray(self, index) }
        }
        /// Calls the `Gl::disable_vertex_attrib_array` function.
        pub fn disable_vertex_attrib_array(&self, index: u32) {
            unsafe { crate::dll::AzGl_disableVertexAttribArray(self, index) }
        }
        /// Calls the `Gl::uniform_1f` function.
        pub fn uniform_1f(&self, location: i32, v0: f32) {
            unsafe { crate::dll::AzGl_uniform1F(self, location, v0) }
        }
        /// Calls the `Gl::uniform_1fv` function.
        pub fn uniform_1fv<_2: Into<F32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform1Fv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_1i` function.
        pub fn uniform_1i(&self, location: i32, v0: i32) {
            unsafe { crate::dll::AzGl_uniform1I(self, location, v0) }
        }
        /// Calls the `Gl::uniform_1iv` function.
        pub fn uniform_1iv<_2: Into<I32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform1Iv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_1ui` function.
        pub fn uniform_1ui(&self, location: i32, v0: u32) {
            unsafe { crate::dll::AzGl_uniform1Ui(self, location, v0) }
        }
        /// Calls the `Gl::uniform_2f` function.
        pub fn uniform_2f(&self, location: i32, v0: f32, v1: f32) {
            unsafe { crate::dll::AzGl_uniform2F(self, location, v0, v1) }
        }
        /// Calls the `Gl::uniform_2fv` function.
        pub fn uniform_2fv<_2: Into<F32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform2Fv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_2i` function.
        pub fn uniform_2i(&self, location: i32, v0: i32, v1: i32) {
            unsafe { crate::dll::AzGl_uniform2I(self, location, v0, v1) }
        }
        /// Calls the `Gl::uniform_2iv` function.
        pub fn uniform_2iv<_2: Into<I32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform2Iv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_2ui` function.
        pub fn uniform_2ui(&self, location: i32, v0: u32, v1: u32) {
            unsafe { crate::dll::AzGl_uniform2Ui(self, location, v0, v1) }
        }
        /// Calls the `Gl::uniform_3f` function.
        pub fn uniform_3f(&self, location: i32, v0: f32, v1: f32, v2: f32) {
            unsafe { crate::dll::AzGl_uniform3F(self, location, v0, v1, v2) }
        }
        /// Calls the `Gl::uniform_3fv` function.
        pub fn uniform_3fv<_2: Into<F32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform3Fv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_3i` function.
        pub fn uniform_3i(&self, location: i32, v0: i32, v1: i32, v2: i32) {
            unsafe { crate::dll::AzGl_uniform3I(self, location, v0, v1, v2) }
        }
        /// Calls the `Gl::uniform_3iv` function.
        pub fn uniform_3iv<_2: Into<I32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform3Iv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_3ui` function.
        pub fn uniform_3ui(&self, location: i32, v0: u32, v1: u32, v2: u32) {
            unsafe { crate::dll::AzGl_uniform3Ui(self, location, v0, v1, v2) }
        }
        /// Calls the `Gl::uniform_4f` function.
        pub fn uniform_4f(&self, location: i32, x: f32, y: f32, z: f32, w: f32) {
            unsafe { crate::dll::AzGl_uniform4F(self, location, x, y, z, w) }
        }
        /// Calls the `Gl::uniform_4i` function.
        pub fn uniform_4i(&self, location: i32, x: i32, y: i32, z: i32, w: i32) {
            unsafe { crate::dll::AzGl_uniform4I(self, location, x, y, z, w) }
        }
        /// Calls the `Gl::uniform_4iv` function.
        pub fn uniform_4iv<_2: Into<I32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform4Iv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_4ui` function.
        pub fn uniform_4ui(&self, location: i32, x: u32, y: u32, z: u32, w: u32) {
            unsafe { crate::dll::AzGl_uniform4Ui(self, location, x, y, z, w) }
        }
        /// Calls the `Gl::uniform_4fv` function.
        pub fn uniform_4fv<_2: Into<F32VecRef>>(&self, location: i32, values: _2) {
            unsafe { crate::dll::AzGl_uniform4Fv(self, location, values.into()) }
        }
        /// Calls the `Gl::uniform_matrix_2fv` function.
        pub fn uniform_matrix_2fv<_3: Into<F32VecRef>>(
            &self,
            location: i32,
            transpose: bool,
            value: _3,
        ) {
            unsafe { crate::dll::AzGl_uniformMatrix2Fv(self, location, transpose, value.into()) }
        }
        /// Calls the `Gl::uniform_matrix_3fv` function.
        pub fn uniform_matrix_3fv<_3: Into<F32VecRef>>(
            &self,
            location: i32,
            transpose: bool,
            value: _3,
        ) {
            unsafe { crate::dll::AzGl_uniformMatrix3Fv(self, location, transpose, value.into()) }
        }
        /// Calls the `Gl::uniform_matrix_4fv` function.
        pub fn uniform_matrix_4fv<_3: Into<F32VecRef>>(
            &self,
            location: i32,
            transpose: bool,
            value: _3,
        ) {
            unsafe { crate::dll::AzGl_uniformMatrix4Fv(self, location, transpose, value.into()) }
        }
        /// Calls the `Gl::depth_mask` function.
        pub fn depth_mask(&self, flag: bool) {
            unsafe { crate::dll::AzGl_depthMask(self, flag) }
        }
        /// Calls the `Gl::depth_range` function.
        pub fn depth_range(&self, near: f64, far: f64) {
            unsafe { crate::dll::AzGl_depthRange(self, near, far) }
        }
        /// Calls the `Gl::get_active_attrib` function.
        pub fn get_active_attrib(
            &self,
            program: u32,
            index: u32,
        ) -> crate::gl::GetActiveAttribReturn {
            unsafe { crate::dll::AzGl_getActiveAttrib(self, program, index) }
        }
        /// Calls the `Gl::get_active_uniform` function.
        pub fn get_active_uniform(
            &self,
            program: u32,
            index: u32,
        ) -> crate::gl::GetActiveUniformReturn {
            unsafe { crate::dll::AzGl_getActiveUniform(self, program, index) }
        }
        /// Calls the `Gl::get_active_uniforms_iv` function.
        pub fn get_active_uniforms_iv<_2: Into<GLuintVec>>(
            &self,
            program: u32,
            indices: _2,
            pname: u32,
        ) -> crate::vec::GLintVec {
            unsafe { crate::dll::AzGl_getActiveUniformsIv(self, program, indices.into(), pname) }
        }
        /// Calls the `Gl::get_active_uniform_block_i` function.
        pub fn get_active_uniform_block_i(&self, program: u32, index: u32, pname: u32) -> i32 {
            unsafe { crate::dll::AzGl_getActiveUniformBlockI(self, program, index, pname) }
        }
        /// Calls the `Gl::get_active_uniform_block_iv` function.
        pub fn get_active_uniform_block_iv(
            &self,
            program: u32,
            index: u32,
            pname: u32,
        ) -> crate::vec::GLintVec {
            unsafe { crate::dll::AzGl_getActiveUniformBlockIv(self, program, index, pname) }
        }
        /// Calls the `Gl::get_active_uniform_block_name` function.
        pub fn get_active_uniform_block_name(
            &self,
            program: u32,
            index: u32,
        ) -> crate::str::String {
            unsafe { crate::dll::AzGl_getActiveUniformBlockName(self, program, index) }
        }
        /// Calls the `Gl::get_attrib_location` function.
        pub fn get_attrib_location<_2: Into<Refstr>>(&self, program: u32, name: _2) -> i32 {
            unsafe { crate::dll::AzGl_getAttribLocation(self, program, name.into()) }
        }
        /// Calls the `Gl::get_frag_data_location` function.
        pub fn get_frag_data_location<_2: Into<Refstr>>(&self, program: u32, name: _2) -> i32 {
            unsafe { crate::dll::AzGl_getFragDataLocation(self, program, name.into()) }
        }
        /// Calls the `Gl::get_uniform_location` function.
        pub fn get_uniform_location<_2: Into<Refstr>>(&self, program: u32, name: _2) -> i32 {
            unsafe { crate::dll::AzGl_getUniformLocation(self, program, name.into()) }
        }
        /// Calls the `Gl::get_program_info_log` function.
        pub fn get_program_info_log(&self, program: u32) -> crate::str::String {
            unsafe { crate::dll::AzGl_getProgramInfoLog(self, program) }
        }
        /// Calls the `Gl::get_program_iv` function.
        pub fn get_program_iv<_3: Into<GLintVecRefMut>>(
            &self,
            program: u32,
            pname: u32,
            result: _3,
        ) {
            unsafe { crate::dll::AzGl_getProgramIv(self, program, pname, result.into()) }
        }
        /// Calls the `Gl::get_program_binary` function.
        pub fn get_program_binary(&self, program: u32) -> crate::gl::GetProgramBinaryReturn {
            unsafe { crate::dll::AzGl_getProgramBinary(self, program) }
        }
        /// Calls the `Gl::program_binary` function.
        pub fn program_binary<_3: Into<U8VecRef>>(&self, program: u32, format: u32, binary: _3) {
            unsafe { crate::dll::AzGl_programBinary(self, program, format, binary.into()) }
        }
        /// Calls the `Gl::program_parameter_i` function.
        pub fn program_parameter_i(&self, program: u32, pname: u32, value: i32) {
            unsafe { crate::dll::AzGl_programParameterI(self, program, pname, value) }
        }
        /// Calls the `Gl::get_vertex_attrib_iv` function.
        pub fn get_vertex_attrib_iv<_3: Into<GLintVecRefMut>>(
            &self,
            index: u32,
            pname: u32,
            result: _3,
        ) {
            unsafe { crate::dll::AzGl_getVertexAttribIv(self, index, pname, result.into()) }
        }
        /// Calls the `Gl::get_vertex_attrib_fv` function.
        pub fn get_vertex_attrib_fv<_3: Into<GLfloatVecRefMut>>(
            &self,
            index: u32,
            pname: u32,
            result: _3,
        ) {
            unsafe { crate::dll::AzGl_getVertexAttribFv(self, index, pname, result.into()) }
        }
        /// Calls the `Gl::get_vertex_attrib_pointer_v` function.
        pub fn get_vertex_attrib_pointer_v(&self, index: u32, pname: u32) -> isize {
            unsafe { crate::dll::AzGl_getVertexAttribPointerV(self, index, pname) }
        }
        /// Calls the `Gl::get_buffer_parameter_iv` function.
        pub fn get_buffer_parameter_iv(&self, target: u32, pname: u32) -> i32 {
            unsafe { crate::dll::AzGl_getBufferParameterIv(self, target, pname) }
        }
        /// Calls the `Gl::get_shader_info_log` function.
        pub fn get_shader_info_log(&self, shader: u32) -> crate::str::String {
            unsafe { crate::dll::AzGl_getShaderInfoLog(self, shader) }
        }
        /// Calls the `Gl::get_string` function.
        pub fn get_string(&self, which: u32) -> crate::str::String {
            unsafe { crate::dll::AzGl_getString(self, which) }
        }
        /// Calls the `Gl::get_string_i` function.
        pub fn get_string_i(&self, which: u32, index: u32) -> crate::str::String {
            unsafe { crate::dll::AzGl_getStringI(self, which, index) }
        }
        /// Calls the `Gl::get_shader_iv` function.
        pub fn get_shader_iv<_3: Into<GLintVecRefMut>>(&self, shader: u32, pname: u32, result: _3) {
            unsafe { crate::dll::AzGl_getShaderIv(self, shader, pname, result.into()) }
        }
        /// Calls the `Gl::get_shader_precision_format` function.
        pub fn get_shader_precision_format(
            &self,
            shader_type: u32,
            precision_type: u32,
        ) -> crate::gl::GlShaderPrecisionFormatReturn {
            unsafe { crate::dll::AzGl_getShaderPrecisionFormat(self, shader_type, precision_type) }
        }
        /// Calls the `Gl::compile_shader` function.
        pub fn compile_shader(&self, shader: u32) {
            unsafe { crate::dll::AzGl_compileShader(self, shader) }
        }
        /// Calls the `Gl::create_program` function.
        pub fn create_program(&self) -> u32 {
            unsafe { crate::dll::AzGl_createProgram(self) }
        }
        /// Calls the `Gl::delete_program` function.
        pub fn delete_program(&self, program: u32) {
            unsafe { crate::dll::AzGl_deleteProgram(self, program) }
        }
        /// Calls the `Gl::create_shader` function.
        pub fn create_shader(&self, shader_type: u32) -> u32 {
            unsafe { crate::dll::AzGl_createShader(self, shader_type) }
        }
        /// Calls the `Gl::delete_shader` function.
        pub fn delete_shader(&self, shader: u32) {
            unsafe { crate::dll::AzGl_deleteShader(self, shader) }
        }
        /// Calls the `Gl::detach_shader` function.
        pub fn detach_shader(&self, program: u32, shader: u32) {
            unsafe { crate::dll::AzGl_detachShader(self, program, shader) }
        }
        /// Calls the `Gl::link_program` function.
        pub fn link_program(&self, program: u32) {
            unsafe { crate::dll::AzGl_linkProgram(self, program) }
        }
        /// Calls the `Gl::clear_color` function.
        pub fn clear_color(&self, r: f32, g: f32, b: f32, a: f32) {
            unsafe { crate::dll::AzGl_clearColor(self, r, g, b, a) }
        }
        /// Calls the `Gl::clear` function.
        pub fn clear(&self, buffer_mask: u32) {
            unsafe { crate::dll::AzGl_clear(self, buffer_mask) }
        }
        /// Calls the `Gl::clear_depth` function.
        pub fn clear_depth(&self, depth: f64) {
            unsafe { crate::dll::AzGl_clearDepth(self, depth) }
        }
        /// Calls the `Gl::clear_stencil` function.
        pub fn clear_stencil(&self, s: i32) {
            unsafe { crate::dll::AzGl_clearStencil(self, s) }
        }
        /// Calls the `Gl::flush` function.
        pub fn flush(&self) {
            unsafe { crate::dll::AzGl_flush(self) }
        }
        /// Calls the `Gl::finish` function.
        pub fn finish(&self) {
            unsafe { crate::dll::AzGl_finish(self) }
        }
        /// Calls the `Gl::get_error` function.
        pub fn get_error(&self) -> u32 {
            unsafe { crate::dll::AzGl_getError(self) }
        }
        /// Calls the `Gl::stencil_mask` function.
        pub fn stencil_mask(&self, mask: u32) {
            unsafe { crate::dll::AzGl_stencilMask(self, mask) }
        }
        /// Calls the `Gl::stencil_mask_separate` function.
        pub fn stencil_mask_separate(&self, face: u32, mask: u32) {
            unsafe { crate::dll::AzGl_stencilMaskSeparate(self, face, mask) }
        }
        /// Calls the `Gl::stencil_func` function.
        pub fn stencil_func(&self, func: u32, ref_: i32, mask: u32) {
            unsafe { crate::dll::AzGl_stencilFunc(self, func, ref_, mask) }
        }
        /// Calls the `Gl::stencil_func_separate` function.
        pub fn stencil_func_separate(&self, face: u32, func: u32, ref_: i32, mask: u32) {
            unsafe { crate::dll::AzGl_stencilFuncSeparate(self, face, func, ref_, mask) }
        }
        /// Calls the `Gl::stencil_op` function.
        pub fn stencil_op(&self, sfail: u32, dpfail: u32, dppass: u32) {
            unsafe { crate::dll::AzGl_stencilOp(self, sfail, dpfail, dppass) }
        }
        /// Calls the `Gl::stencil_op_separate` function.
        pub fn stencil_op_separate(&self, face: u32, sfail: u32, dpfail: u32, dppass: u32) {
            unsafe { crate::dll::AzGl_stencilOpSeparate(self, face, sfail, dpfail, dppass) }
        }
        /// Calls the `Gl::egl_image_target_texture2d_oes` function.
        pub fn egl_image_target_texture2d_oes<_2: Into<GlVoidPtrConst>>(
            &self,
            target: u32,
            image: _2,
        ) {
            unsafe { crate::dll::AzGl_eglImageTargetTexture2DOes(self, target, image.into()) }
        }
        /// Calls the `Gl::generate_mipmap` function.
        pub fn generate_mipmap(&self, target: u32) {
            unsafe { crate::dll::AzGl_generateMipmap(self, target) }
        }
        /// Calls the `Gl::insert_event_marker_ext` function.
        pub fn insert_event_marker_ext<_1: Into<Refstr>>(&self, message: _1) {
            unsafe { crate::dll::AzGl_insertEventMarkerExt(self, message.into()) }
        }
        /// Calls the `Gl::push_group_marker_ext` function.
        pub fn push_group_marker_ext<_1: Into<Refstr>>(&self, message: _1) {
            unsafe { crate::dll::AzGl_pushGroupMarkerExt(self, message.into()) }
        }
        /// Calls the `Gl::pop_group_marker_ext` function.
        pub fn pop_group_marker_ext(&self) {
            unsafe { crate::dll::AzGl_popGroupMarkerExt(self) }
        }
        /// Calls the `Gl::debug_message_insert_khr` function.
        pub fn debug_message_insert_khr<_5: Into<Refstr>>(
            &self,
            source: u32,
            type_: u32,
            id: u32,
            severity: u32,
            message: _5,
        ) {
            unsafe {
                crate::dll::AzGl_debugMessageInsertKhr(
                    self,
                    source,
                    type_,
                    id,
                    severity,
                    message.into(),
                )
            }
        }
        /// Calls the `Gl::push_debug_group_khr` function.
        pub fn push_debug_group_khr<_3: Into<Refstr>>(&self, source: u32, id: u32, message: _3) {
            unsafe { crate::dll::AzGl_pushDebugGroupKhr(self, source, id, message.into()) }
        }
        /// Calls the `Gl::pop_debug_group_khr` function.
        pub fn pop_debug_group_khr(&self) {
            unsafe { crate::dll::AzGl_popDebugGroupKhr(self) }
        }
        /// Calls the `Gl::fence_sync` function.
        pub fn fence_sync(&self, condition: u32, flags: u32) -> crate::gl::GLsyncPtr {
            unsafe { crate::dll::AzGl_fenceSync(self, condition, flags) }
        }
        /// Calls the `Gl::client_wait_sync` function.
        pub fn client_wait_sync<_1: Into<GLsyncPtr>>(
            &self,
            sync: _1,
            flags: u32,
            timeout: u64,
        ) -> u32 {
            unsafe { crate::dll::AzGl_clientWaitSync(self, sync.into(), flags, timeout) }
        }
        /// Calls the `Gl::wait_sync` function.
        pub fn wait_sync<_1: Into<GLsyncPtr>>(&self, sync: _1, flags: u32, timeout: u64) {
            unsafe { crate::dll::AzGl_waitSync(self, sync.into(), flags, timeout) }
        }
        /// Calls the `Gl::delete_sync` function.
        pub fn delete_sync<_1: Into<GLsyncPtr>>(&self, sync: _1) {
            unsafe { crate::dll::AzGl_deleteSync(self, sync.into()) }
        }
        /// Calls the `Gl::texture_range_apple` function.
        pub fn texture_range_apple<_2: Into<U8VecRef>>(&self, target: u32, data: _2) {
            unsafe { crate::dll::AzGl_textureRangeApple(self, target, data.into()) }
        }
        /// Calls the `Gl::gen_fences_apple` function.
        pub fn gen_fences_apple(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genFencesApple(self, n) }
        }
        /// Calls the `Gl::delete_fences_apple` function.
        pub fn delete_fences_apple<_1: Into<GLuintVecRef>>(&self, fences: _1) {
            unsafe { crate::dll::AzGl_deleteFencesApple(self, fences.into()) }
        }
        /// Calls the `Gl::set_fence_apple` function.
        pub fn set_fence_apple(&self, fence: u32) {
            unsafe { crate::dll::AzGl_setFenceApple(self, fence) }
        }
        /// Calls the `Gl::finish_fence_apple` function.
        pub fn finish_fence_apple(&self, fence: u32) {
            unsafe { crate::dll::AzGl_finishFenceApple(self, fence) }
        }
        /// Calls the `Gl::test_fence_apple` function.
        pub fn test_fence_apple(&self, fence: u32) {
            unsafe { crate::dll::AzGl_testFenceApple(self, fence) }
        }
        /// Calls the `Gl::test_object_apple` function.
        pub fn test_object_apple(&self, object: u32, name: u32) -> u8 {
            unsafe { crate::dll::AzGl_testObjectApple(self, object, name) }
        }
        /// Calls the `Gl::finish_object_apple` function.
        pub fn finish_object_apple(&self, object: u32, name: u32) {
            unsafe { crate::dll::AzGl_finishObjectApple(self, object, name) }
        }
        /// Calls the `Gl::get_frag_data_index` function.
        pub fn get_frag_data_index<_2: Into<Refstr>>(&self, program: u32, name: _2) -> i32 {
            unsafe { crate::dll::AzGl_getFragDataIndex(self, program, name.into()) }
        }
        /// Calls the `Gl::blend_barrier_khr` function.
        pub fn blend_barrier_khr(&self) {
            unsafe { crate::dll::AzGl_blendBarrierKhr(self) }
        }
        /// Calls the `Gl::bind_frag_data_location_indexed` function.
        pub fn bind_frag_data_location_indexed<_4: Into<Refstr>>(
            &self,
            program: u32,
            color_number: u32,
            index: u32,
            name: _4,
        ) {
            unsafe {
                crate::dll::AzGl_bindFragDataLocationIndexed(
                    self,
                    program,
                    color_number,
                    index,
                    name.into(),
                )
            }
        }
        /// Calls the `Gl::get_debug_messages` function.
        pub fn get_debug_messages(&self) -> crate::vec::DebugMessageVec {
            unsafe { crate::dll::AzGl_getDebugMessages(self) }
        }
        /// Calls the `Gl::provoking_vertex_angle` function.
        pub fn provoking_vertex_angle(&self, mode: u32) {
            unsafe { crate::dll::AzGl_provokingVertexAngle(self, mode) }
        }
        /// Calls the `Gl::gen_vertex_arrays_apple` function.
        pub fn gen_vertex_arrays_apple(&self, n: i32) -> crate::vec::GLuintVec {
            unsafe { crate::dll::AzGl_genVertexArraysApple(self, n) }
        }
        /// Calls the `Gl::bind_vertex_array_apple` function.
        pub fn bind_vertex_array_apple(&self, vao: u32) {
            unsafe { crate::dll::AzGl_bindVertexArrayApple(self, vao) }
        }
        /// Calls the `Gl::delete_vertex_arrays_apple` function.
        pub fn delete_vertex_arrays_apple<_1: Into<GLuintVecRef>>(&self, vertex_arrays: _1) {
            unsafe { crate::dll::AzGl_deleteVertexArraysApple(self, vertex_arrays.into()) }
        }
        /// Calls the `Gl::copy_texture_chromium` function.
        pub fn copy_texture_chromium(
            &self,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            internal_format: i32,
            dest_type: u32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                crate::dll::AzGl_copyTextureChromium(
                    self,
                    source_id,
                    source_level,
                    dest_target,
                    dest_id,
                    dest_level,
                    internal_format,
                    dest_type,
                    unpack_flip_y,
                    unpack_premultiply_alpha,
                    unpack_unmultiply_alpha,
                )
            }
        }
        /// Calls the `Gl::copy_sub_texture_chromium` function.
        pub fn copy_sub_texture_chromium(
            &self,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            x_offset: i32,
            y_offset: i32,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                crate::dll::AzGl_copySubTextureChromium(
                    self,
                    source_id,
                    source_level,
                    dest_target,
                    dest_id,
                    dest_level,
                    x_offset,
                    y_offset,
                    x,
                    y,
                    width,
                    height,
                    unpack_flip_y,
                    unpack_premultiply_alpha,
                    unpack_unmultiply_alpha,
                )
            }
        }
        /// Calls the `Gl::egl_image_target_renderbuffer_storage_oes` function.
        pub fn egl_image_target_renderbuffer_storage_oes<_2: Into<GlVoidPtrConst>>(
            &self,
            target: u32,
            image: _2,
        ) {
            unsafe {
                crate::dll::AzGl_eglImageTargetRenderbufferStorageOes(self, target, image.into())
            }
        }
        /// Calls the `Gl::copy_texture_3d_angle` function.
        pub fn copy_texture_3d_angle(
            &self,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            internal_format: i32,
            dest_type: u32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                crate::dll::AzGl_copyTexture3DAngle(
                    self,
                    source_id,
                    source_level,
                    dest_target,
                    dest_id,
                    dest_level,
                    internal_format,
                    dest_type,
                    unpack_flip_y,
                    unpack_premultiply_alpha,
                    unpack_unmultiply_alpha,
                )
            }
        }
        /// Calls the `Gl::copy_sub_texture_3d_angle` function.
        pub fn copy_sub_texture_3d_angle(
            &self,
            source_id: u32,
            source_level: i32,
            dest_target: u32,
            dest_id: u32,
            dest_level: i32,
            x_offset: i32,
            y_offset: i32,
            z_offset: i32,
            x: i32,
            y: i32,
            z: i32,
            width: i32,
            height: i32,
            depth: i32,
            unpack_flip_y: u8,
            unpack_premultiply_alpha: u8,
            unpack_unmultiply_alpha: u8,
        ) {
            unsafe {
                crate::dll::AzGl_copySubTexture3DAngle(
                    self,
                    source_id,
                    source_level,
                    dest_target,
                    dest_id,
                    dest_level,
                    x_offset,
                    y_offset,
                    z_offset,
                    x,
                    y,
                    z,
                    width,
                    height,
                    depth,
                    unpack_flip_y,
                    unpack_premultiply_alpha,
                    unpack_unmultiply_alpha,
                )
            }
        }
        /// Calls the `Gl::buffer_storage` function.
        pub fn buffer_storage<_3: Into<GlVoidPtrConst>>(
            &self,
            target: u32,
            size: isize,
            data: _3,
            flags: u32,
        ) {
            unsafe { crate::dll::AzGl_bufferStorage(self, target, size, data.into(), flags) }
        }
        /// Calls the `Gl::flush_mapped_buffer_range` function.
        pub fn flush_mapped_buffer_range(&self, target: u32, offset: isize, length: isize) {
            unsafe { crate::dll::AzGl_flushMappedBufferRange(self, target, offset, length) }
        }
    }

    impl Clone for Gl {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzGl_deepCopy(self) }
        }
    }
    impl Drop for Gl {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzGl_delete(self) }
            }
        }
    }
    /// `GlShaderPrecisionFormatReturn` struct

    #[doc(inline)]
    pub use crate::dll::AzGlShaderPrecisionFormatReturn as GlShaderPrecisionFormatReturn;
    /// `VertexArrayObject` struct

    #[doc(inline)]
    pub use crate::dll::AzVertexArrayObject as VertexArrayObject;
    /// `VertexAttribute` struct

    #[doc(inline)]
    pub use crate::dll::AzVertexAttribute as VertexAttribute;
    /// `VertexAttributeType` struct

    #[doc(inline)]
    pub use crate::dll::AzVertexAttributeType as VertexAttributeType;
    /// `VertexLayout` struct

    #[doc(inline)]
    pub use crate::dll::AzVertexLayout as VertexLayout;
    impl VertexArrayObject {
        /// Creates a new `VertexArrayObject` instance.
        pub fn new<_1: Into<VertexLayout>, _3: Into<Gl>>(
            vertex_layout: _1,
            vao_id: u32,
            gl_context: _3,
        ) -> Self {
            unsafe {
                crate::dll::AzVertexArrayObject_new(vertex_layout.into(), vao_id, gl_context.into())
            }
        }
    }

    impl Clone for VertexArrayObject {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzVertexArrayObject_deepCopy(self) }
        }
    }
    impl Drop for VertexArrayObject {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzVertexArrayObject_delete(self) }
            }
        }
    }
    /// `IndexBufferFormat` struct

    #[doc(inline)]
    pub use crate::dll::AzIndexBufferFormat as IndexBufferFormat;
    /// `VertexBuffer` struct

    #[doc(inline)]
    pub use crate::dll::AzVertexBuffer as VertexBuffer;
    impl VertexBuffer {
        /// Creates a new `VertexBuffer` instance.
        pub fn new<_3: Into<VertexArrayObject>, _6: Into<IndexBufferFormat>>(
            vertex_buffer_id: u32,
            vertex_buffer_len: usize,
            vao: _3,
            index_buffer_id: u32,
            index_buffer_len: usize,
            index_buffer_format: _6,
        ) -> Self {
            unsafe {
                crate::dll::AzVertexBuffer_new(
                    vertex_buffer_id,
                    vertex_buffer_len,
                    vao.into(),
                    index_buffer_id,
                    index_buffer_len,
                    index_buffer_format.into(),
                )
            }
        }
    }

    impl Clone for VertexBuffer {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzVertexBuffer_deepCopy(self) }
        }
    }
    impl Drop for VertexBuffer {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzVertexBuffer_delete(self) }
            }
        }
    }
    /// `DebugMessage` struct

    #[doc(inline)]
    pub use crate::dll::AzDebugMessage as DebugMessage;
    /// C-ABI stable reexport of `&[f32]`

    #[doc(inline)]
    pub use crate::dll::AzF32VecRef as F32VecRef;
    /// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`

    #[doc(inline)]
    pub use crate::dll::AzGLbooleanVecRefMut as GLbooleanVecRefMut;
    /// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`

    #[doc(inline)]
    pub use crate::dll::AzGLenumVecRef as GLenumVecRef;
    /// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`

    #[doc(inline)]
    pub use crate::dll::AzGLfloatVecRefMut as GLfloatVecRefMut;
    /// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`

    #[doc(inline)]
    pub use crate::dll::AzGLint64VecRefMut as GLint64VecRefMut;
    /// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`

    #[doc(inline)]
    pub use crate::dll::AzGLintVecRefMut as GLintVecRefMut;
    /// C-ABI stable reexport of `*const gleam::gl::GLsync`

    #[doc(inline)]
    pub use crate::dll::AzGLsyncPtr as GLsyncPtr;
    /// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`

    #[doc(inline)]
    pub use crate::dll::AzGLuintVecRef as GLuintVecRef;
    /// C-ABI stable reexport of `(i32, u32, AzString)`

    #[doc(inline)]
    pub use crate::dll::AzGetActiveAttribReturn as GetActiveAttribReturn;
    /// C-ABI stable reexport of `(U8Vec, u32)`

    #[doc(inline)]
    pub use crate::dll::AzGetProgramBinaryReturn as GetProgramBinaryReturn;
    /// `GlType` struct

    #[doc(inline)]
    pub use crate::dll::AzGlType as GlType;
    /// C-ABI stable reexport of `&[i32]`

    #[doc(inline)]
    pub use crate::dll::AzI32VecRef as I32VecRef;
    /// C-ABI stable reexport of `&str`

    #[doc(inline)]
    pub use crate::dll::AzRefstr as Refstr;
    /// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`

    #[doc(inline)]
    pub use crate::dll::AzRefstrVecRef as RefstrVecRef;
    /// C-ABI stable reexport of `&[u8]`

    #[doc(inline)]
    pub use crate::dll::AzU8VecRef as U8VecRef;
    /// C-ABI stable reexport of `&mut [u8]`

    #[doc(inline)]
    pub use crate::dll::AzU8VecRefMut as U8VecRefMut;
    impl Clone for GLsyncPtr {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzGLsyncPtr_deepCopy(self) }
        }
    }
    impl Drop for GLsyncPtr {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzGLsyncPtr_delete(self) }
            }
        }
    }
    /// C-ABI stable reexport of `(i32, u32, AzString)`

    #[doc(inline)]
    pub use crate::dll::AzGetActiveUniformReturn as GetActiveUniformReturn;
    /// `TextureFlags` struct

    #[doc(inline)]
    pub use crate::dll::AzTextureFlags as TextureFlags;
    impl TextureFlags {
        /// Default texture flags (not opaque, not a video texture)
        pub fn default() -> Self {
            unsafe { crate::dll::AzTextureFlags_default() }
        }
    }
}

pub mod image {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Struct definitions for image loading
    use core::ffi::c_void;

    /// `ImageRef` struct

    #[doc(inline)]
    pub use crate::dll::AzImageRef as ImageRef;
    use crate::{
        callbacks::{RefAny, RenderImageCallbackType},
        dll::*,
        gl::{Texture, U8VecRef},
        svg::{SvgNode, SvgStyle},
        vec::U8Vec,
        window::LayoutSize,
    };
    impl ImageRef {
        /// Creates an "invalid" image with a width and height that reserves an image key, but does
        /// not render anything
        pub fn null_image<_3: Into<RawImageFormat>, _4: Into<U8Vec>>(
            width: usize,
            height: usize,
            format: _3,
            tag: _4,
        ) -> Self {
            unsafe { crate::dll::AzImageRef_nullImage(width, height, format.into(), tag.into()) }
        }
        /// Creates an image reference from a CPU-backed buffer
        pub fn raw_image<_1: Into<RawImage>>(data: _1) -> crate::option::OptionImageRef {
            unsafe { crate::dll::AzImageRef_rawImage(data.into()) }
        }
        /// Creates an image reference from an OpenGL texture
        pub fn gl_texture<_1: Into<Texture>>(texture: _1) -> Self {
            unsafe { crate::dll::AzImageRef_glTexture(texture.into()) }
        }
        /// Creates an image reference from a callback that is going to be rendered with the given
        /// nodes computed size
        pub fn callback<_1: Into<RefAny>>(data: _1, callback: RenderImageCallbackType) -> Self {
            unsafe { crate::dll::AzImageRef_callback(data.into(), callback) }
        }
        /// Creates a new copy of the image bytes instead of shallow-copying the reference
        pub fn clone_bytes(&self) -> crate::image::ImageRef {
            unsafe { crate::dll::AzImageRef_cloneBytes(self) }
        }
        /// Returns whether the image is a null (invalid) image
        pub fn is_invalid(&self) -> bool {
            unsafe { crate::dll::AzImageRef_isInvalid(self) }
        }
        /// Returns whether the image is a GL texture
        pub fn is_gl_texture(&self) -> bool {
            unsafe { crate::dll::AzImageRef_isGlTexture(self) }
        }
        /// Returns whether the image is a raw (CPU-decoded) image
        pub fn is_raw_image(&self) -> bool {
            unsafe { crate::dll::AzImageRef_isRawImage(self) }
        }
        /// Returns whether the image is a `RenderImageCallback`
        pub fn is_callback(&self) -> bool {
            unsafe { crate::dll::AzImageRef_isCallback(self) }
        }
        /// If the image is a RawImage, returns a COPY of the internal image bytes (useful for
        /// encoding the RawImage / exporting the ImageRef to a file)
        pub fn get_raw_image(&self) -> crate::option::OptionRawImage {
            unsafe { crate::dll::AzImageRef_getRawImage(self) }
        }
        /// Returns the hash of the ImageRef (fast)
        pub fn get_hash(&self) -> u64 {
            unsafe { crate::dll::AzImageRef_getHash(self) }
        }
    }

    impl Clone for ImageRef {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzImageRef_deepCopy(self) }
        }
    }
    impl Drop for ImageRef {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzImageRef_delete(self) }
            }
        }
    }
    /// `RawImage` struct

    #[doc(inline)]
    pub use crate::dll::AzRawImage as RawImage;
    impl RawImage {
        /// Returns a zero-sized image
        pub fn empty() -> Self {
            unsafe { crate::dll::AzRawImage_empty() }
        }
        /// Allocates a width * height, single-channel image with zeroed bytes
        pub fn allocate_clip_mask<_1: Into<LayoutSize>>(size: _1) -> Self {
            unsafe { crate::dll::AzRawImage_allocateClipMask(size.into()) }
        }
        /// Decodes a RawImage from any supported image format - automatically guesses the format
        /// based on magic header
        pub fn decode_image_bytes_any<_1: Into<U8VecRef>>(
            bytes: _1,
        ) -> crate::error::ResultRawImageDecodeImageError {
            unsafe { crate::dll::AzRawImage_decodeImageBytesAny(bytes.into()) }
        }
        /// Calls the `RawImage::draw_clip_mask` function.
        pub fn draw_clip_mask<_1: Into<SvgNode>, _2: Into<SvgStyle>>(
            &mut self,
            node: _1,
            style: _2,
        ) -> bool {
            unsafe { crate::dll::AzRawImage_drawClipMask(self, node.into(), style.into()) }
        }
        /// Encodes the RawImage in the BMP image format
        pub fn encode_bmp(&self) -> crate::error::ResultU8VecEncodeImageError {
            unsafe { crate::dll::AzRawImage_encodeBmp(self) }
        }
        /// Encodes the RawImage in the PNG image format
        pub fn encode_png(&self) -> crate::error::ResultU8VecEncodeImageError {
            unsafe { crate::dll::AzRawImage_encodePng(self) }
        }
        /// Encodes the RawImage in the JPG image format
        pub fn encode_jpeg(&self, quality: u8) -> crate::error::ResultU8VecEncodeImageError {
            unsafe { crate::dll::AzRawImage_encodeJpeg(self, quality) }
        }
        /// Encodes the RawImage in the TGA image format
        pub fn encode_tga(&self) -> crate::error::ResultU8VecEncodeImageError {
            unsafe { crate::dll::AzRawImage_encodeTga(self) }
        }
        /// Encodes the RawImage in the PNM image format
        pub fn encode_pnm(&self) -> crate::error::ResultU8VecEncodeImageError {
            unsafe { crate::dll::AzRawImage_encodePnm(self) }
        }
        /// Encodes the RawImage in the GIF image format
        pub fn encode_gif(&self) -> crate::error::ResultU8VecEncodeImageError {
            unsafe { crate::dll::AzRawImage_encodeGif(self) }
        }
        /// Encodes the RawImage in the TIFF image format
        pub fn encode_tiff(&self) -> crate::error::ResultU8VecEncodeImageError {
            unsafe { crate::dll::AzRawImage_encodeTiff(self) }
        }
    }

    /// `DecodeImageError` struct

    #[doc(inline)]
    pub use crate::dll::AzDecodeImageError as DecodeImageError;
    /// `EncodeImageError` struct

    #[doc(inline)]
    pub use crate::dll::AzEncodeImageError as EncodeImageError;
    /// `ImageMask` struct

    #[doc(inline)]
    pub use crate::dll::AzImageMask as ImageMask;
    /// `RawImageData` struct

    #[doc(inline)]
    pub use crate::dll::AzRawImageData as RawImageData;
    /// `RawImageFormat` struct

    #[doc(inline)]
    pub use crate::dll::AzRawImageFormat as RawImageFormat;
}

pub mod font {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Font decoding / parsing module
    use core::ffi::c_void;

    /// `FontMetrics` struct

    #[doc(inline)]
    pub use crate::dll::AzFontMetrics as FontMetrics;
    /// `ParsedFontDestructorFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzParsedFontDestructorFnType as ParsedFontDestructorFnType;
    use crate::{callbacks::ResolvedTextLayoutOptions, dll::*, gl::Refstr};
    impl FontMetrics {
        /// Returns a FontMetrics struct with all fields set to 0
        pub fn zero() -> Self {
            unsafe { crate::dll::AzFontMetrics_zero() }
        }
        /// If set, use `OS/2.sTypoAscender - OS/2.sTypoDescender + OS/2.sTypoLineGap` to calculate
        /// the height.
        pub fn use_typo_metrics(&self) -> bool {
            unsafe { crate::dll::AzFontMetrics_useTypoMetrics(self) }
        }
        /// Calls the `FontMetrics::get_ascender` function.
        pub fn get_ascender(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getAscender(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_descender` function.
        pub fn get_descender(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getDescender(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_line_gap` function.
        pub fn get_line_gap(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getLineGap(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_x_min` function.
        pub fn get_x_min(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getXMin(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_min` function.
        pub fn get_y_min(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYMin(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_x_max` function.
        pub fn get_x_max(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getXMax(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_max` function.
        pub fn get_y_max(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYMax(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_advance_width_max` function.
        pub fn get_advance_width_max(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getAdvanceWidthMax(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_min_left_side_bearing` function.
        pub fn get_min_left_side_bearing(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getMinLeftSideBearing(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_min_right_side_bearing` function.
        pub fn get_min_right_side_bearing(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getMinRightSideBearing(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_x_max_extent` function.
        pub fn get_x_max_extent(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getXMaxExtent(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_x_avg_char_width` function.
        pub fn get_x_avg_char_width(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getXAvgCharWidth(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_subscript_x_size` function.
        pub fn get_y_subscript_x_size(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSubscriptXSize(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_subscript_y_size` function.
        pub fn get_y_subscript_y_size(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSubscriptYSize(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_subscript_x_offset` function.
        pub fn get_y_subscript_x_offset(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSubscriptXOffset(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_subscript_y_offset` function.
        pub fn get_y_subscript_y_offset(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSubscriptYOffset(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_superscript_x_size` function.
        pub fn get_y_superscript_x_size(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSuperscriptXSize(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_superscript_y_size` function.
        pub fn get_y_superscript_y_size(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSuperscriptYSize(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_superscript_x_offset` function.
        pub fn get_y_superscript_x_offset(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSuperscriptXOffset(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_superscript_y_offset` function.
        pub fn get_y_superscript_y_offset(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYSuperscriptYOffset(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_strikeout_size` function.
        pub fn get_y_strikeout_size(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYStrikeoutSize(self, target_font_size) }
        }
        /// Calls the `FontMetrics::get_y_strikeout_position` function.
        pub fn get_y_strikeout_position(&self, target_font_size: f32) -> f32 {
            unsafe { crate::dll::AzFontMetrics_getYStrikeoutPosition(self, target_font_size) }
        }
    }

    /// Atomically reference-counted parsed font data

    #[doc(inline)]
    pub use crate::dll::AzFontRef as FontRef;
    /// Source data of a font file (bytes)

    #[doc(inline)]
    pub use crate::dll::AzFontSource as FontSource;
    impl FontRef {
        /// Parses a new font from bytes. Returns `None` if the font could not be parsed correctly.
        pub fn parse<_1: Into<FontSource>>(source: _1) -> crate::option::OptionFontRef {
            unsafe { crate::dll::AzFontRef_parse(source.into()) }
        }
        /// Returns the font bytes of the underlying font source
        pub fn get_bytes(&self) -> crate::vec::U8Vec {
            unsafe { crate::dll::AzFontRef_getBytes(self) }
        }
        /// Returns the font metrics of the parsed font
        pub fn get_font_metrics(&self) -> crate::font::FontMetrics {
            unsafe { crate::dll::AzFontRef_getFontMetrics(self) }
        }
        /// Returns the text layout of the shaped text
        pub fn shape_text<_1: Into<Refstr>, _2: Into<ResolvedTextLayoutOptions>>(
            &self,
            text: _1,
            options: _2,
        ) -> crate::callbacks::InlineText {
            unsafe { crate::dll::AzFontRef_shapeText(self, text.into(), options.into()) }
        }
        /// Returns the hash of the FontRef (fast)
        pub fn get_hash(&self) -> u64 {
            unsafe { crate::dll::AzFontRef_getHash(self) }
        }
    }

    impl Clone for FontRef {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzFontRef_deepCopy(self) }
        }
    }
    impl Drop for FontRef {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzFontRef_delete(self) }
            }
        }
    }
}

pub mod svg {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! SVG parsing and rendering functions
    use core::ffi::c_void;

    /// `Svg` struct

    #[doc(inline)]
    pub use crate::dll::AzSvg as Svg;
    use crate::{
        dll::*,
        gl::{Gl, U8VecRef},
        str::String,
    };
    impl Svg {
        /// Creates a new `Svg` instance.
        pub fn from_string<_1: Into<String>, _2: Into<SvgParseOptions>>(
            svg_string: _1,
            parse_options: _2,
        ) -> crate::error::ResultSvgSvgParseError {
            unsafe { crate::dll::AzSvg_fromString(svg_string.into(), parse_options.into()) }
        }
        /// Creates a new `Svg` instance.
        pub fn from_bytes<_1: Into<U8VecRef>, _2: Into<SvgParseOptions>>(
            svg_bytes: _1,
            parse_options: _2,
        ) -> crate::error::ResultSvgSvgParseError {
            unsafe { crate::dll::AzSvg_fromBytes(svg_bytes.into(), parse_options.into()) }
        }
        /// Calls the `Svg::get_root` function.
        pub fn get_root(&self) -> crate::svg::SvgXmlNode {
            unsafe { crate::dll::AzSvg_getRoot(self) }
        }
        /// Calls the `Svg::render` function.
        pub fn render<_1: Into<SvgRenderOptions>>(
            &self,
            options: _1,
        ) -> crate::option::OptionRawImage {
            unsafe { crate::dll::AzSvg_render(self, options.into()) }
        }
        /// Calls the `Svg::to_string` function.
        pub fn to_string<_1: Into<SvgStringFormatOptions>>(
            &self,
            options: _1,
        ) -> crate::str::String {
            unsafe { crate::dll::AzSvg_toString(self, options.into()) }
        }
    }

    impl Clone for Svg {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzSvg_deepCopy(self) }
        }
    }
    impl Drop for Svg {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzSvg_delete(self) }
            }
        }
    }
    /// `SvgXmlNode` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgXmlNode as SvgXmlNode;
    impl SvgXmlNode {
        /// Creates a new `SvgXmlNode` instance.
        pub fn parse_from<_1: Into<U8VecRef>, _2: Into<SvgParseOptions>>(
            svg_bytes: _1,
            parse_options: _2,
        ) -> crate::error::ResultSvgXmlNodeSvgParseError {
            unsafe { crate::dll::AzSvgXmlNode_parseFrom(svg_bytes.into(), parse_options.into()) }
        }
    }

    impl Clone for SvgXmlNode {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzSvgXmlNode_deepCopy(self) }
        }
    }
    impl Drop for SvgXmlNode {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzSvgXmlNode_delete(self) }
            }
        }
    }
    /// `SvgMultiPolygon` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgMultiPolygon as SvgMultiPolygon;
    impl SvgMultiPolygon {
        /// Returns the bounds of the polygon
        pub fn get_bounds(&self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgMultiPolygon_getBounds(self) }
        }
        /// Returns whether the polygon contains a point
        pub fn contains_point<_1: Into<SvgPoint>, _2: Into<SvgFillRule>>(
            &self,
            point: _1,
            fill_rule: _2,
            tolerance: f32,
        ) -> bool {
            unsafe {
                crate::dll::AzSvgMultiPolygon_containsPoint(
                    self,
                    point.into(),
                    fill_rule.into(),
                    tolerance,
                )
            }
        }
        /// Unions two MultiPolygons, returns the unioned MultiPolygon
        pub fn union<_1: Into<SvgMultiPolygon>>(&self, other: _1) -> crate::svg::SvgMultiPolygon {
            unsafe { crate::dll::AzSvgMultiPolygon_union(self, other.into()) }
        }
        /// Intersects two MultiPolygons, returns the intersected MultiPolygon
        pub fn intersection<_1: Into<SvgMultiPolygon>>(
            &self,
            other: _1,
        ) -> crate::svg::SvgMultiPolygon {
            unsafe { crate::dll::AzSvgMultiPolygon_intersection(self, other.into()) }
        }
        /// Calculates the difference two MultiPolygons, returns a MultiPolygon
        pub fn difference<_1: Into<SvgMultiPolygon>>(
            &self,
            other: _1,
        ) -> crate::svg::SvgMultiPolygon {
            unsafe { crate::dll::AzSvgMultiPolygon_difference(self, other.into()) }
        }
        /// Xors two MultiPolygons, returns a MultiPolygon
        pub fn xor<_1: Into<SvgMultiPolygon>>(&self, other: _1) -> crate::svg::SvgMultiPolygon {
            unsafe { crate::dll::AzSvgMultiPolygon_xor(self, other.into()) }
        }
        /// Calls the `SvgMultiPolygon::tessellate_fill` function.
        pub fn tessellate_fill<_1: Into<SvgFillStyle>>(
            &self,
            fill_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgMultiPolygon_tessellateFill(self, fill_style.into()) }
        }
        /// Calls the `SvgMultiPolygon::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgMultiPolygon_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgNode` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgNode as SvgNode;
    impl SvgNode {
        /// Calls the `SvgNode::tessellate_fill` function.
        pub fn tessellate_fill<_1: Into<SvgFillStyle>>(
            &self,
            fill_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgNode_tessellateFill(self, fill_style.into()) }
        }
        /// Calls the `SvgNode::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgNode_tessellateStroke(self, stroke_style.into()) }
        }
        /// Returns whether the shape is closed
        pub fn is_closed(&self) -> bool {
            unsafe { crate::dll::AzSvgNode_isClosed(self) }
        }
        /// Returns the bounds of the polygon
        pub fn contains_point<_1: Into<SvgPoint>, _2: Into<SvgFillRule>>(
            &self,
            point: _1,
            fill_rule: _2,
            tolerance: f32,
        ) -> bool {
            unsafe {
                crate::dll::AzSvgNode_containsPoint(self, point.into(), fill_rule.into(), tolerance)
            }
        }
        /// Calls the `SvgNode::get_bounds` function.
        pub fn get_bounds(&self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgNode_getBounds(self) }
        }
    }

    /// `SvgSimpleNode` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgSimpleNode as SvgSimpleNode;
    impl SvgSimpleNode {
        /// Calls the `SvgSimpleNode::get_bounds` function.
        pub fn get_bounds(&self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgSimpleNode_getBounds(self) }
        }
    }

    /// `SvgStyledNode` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgStyledNode as SvgStyledNode;
    impl SvgStyledNode {
        /// Calls the `SvgStyledNode::tessellate` function.
        pub fn tessellate(&self) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgStyledNode_tessellate(self) }
        }
    }

    /// `SvgCircle` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgCircle as SvgCircle;
    impl SvgCircle {
        /// Calls the `SvgCircle::tessellate_fill` function.
        pub fn tessellate_fill<_1: Into<SvgFillStyle>>(
            &self,
            fill_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgCircle_tessellateFill(self, fill_style.into()) }
        }
        /// Calls the `SvgCircle::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgCircle_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgPath` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgPath as SvgPath;
    impl SvgPath {
        /// Returns whether the path is closed
        pub fn is_closed(&self) -> bool {
            unsafe { crate::dll::AzSvgPath_isClosed(self) }
        }
        /// Reverses the order of points in the path so that the path runs in the opposite direction
        /// afterwards
        pub fn reverse(&mut self) {
            unsafe { crate::dll::AzSvgPath_reverse(self) }
        }
        /// Returns the first point of the path (or None if path has no items)
        pub fn get_start(&self) -> crate::option::OptionSvgPoint {
            unsafe { crate::dll::AzSvgPath_getStart(self) }
        }
        /// Returns the first point of the path (or None if path has no items)
        pub fn get_end(&self) -> crate::option::OptionSvgPoint {
            unsafe { crate::dll::AzSvgPath_getEnd(self) }
        }
        /// Returns the axis-aligned bounding rect of this path
        pub fn get_bounds(&mut self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgPath_getBounds(self) }
        }
        /// Adds a path to the end of the current path
        pub fn join_with<_1: Into<SvgPath>>(&mut self, path: _1) {
            unsafe { crate::dll::AzSvgPath_joinWith(self, path.into()) }
        }
        /// Offset the path by a certain distance. Will create bezier curves around the edges when
        /// the path is closed
        pub fn offset<_2: Into<SvgLineJoin>, _3: Into<SvgLineCap>>(
            &mut self,
            distance: f32,
            join: _2,
            cap: _3,
        ) -> crate::svg::SvgPath {
            unsafe { crate::dll::AzSvgPath_offset(self, distance, join.into(), cap.into()) }
        }
        /// Round the edges with a cubic curve
        pub fn bevel(&mut self, distance: f32) -> crate::svg::SvgPath {
            unsafe { crate::dll::AzSvgPath_bevel(self, distance) }
        }
        /// Calls the `SvgPath::tessellate_fill` function.
        pub fn tessellate_fill<_1: Into<SvgFillStyle>>(
            &self,
            fill_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgPath_tessellateFill(self, fill_style.into()) }
        }
        /// Calls the `SvgPath::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgPath_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgPathElement` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgPathElement as SvgPathElement;
    impl SvgPathElement {
        /// Reverses the order of points in the path so that the path runs in the opposite direction
        /// afterwards
        pub fn reverse(&mut self) {
            unsafe { crate::dll::AzSvgPathElement_reverse(self) }
        }
        /// Returns the starting point of this item
        pub fn get_start(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgPathElement_getStart(self) }
        }
        /// Returns the ending point of this item
        pub fn get_end(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgPathElement_getEnd(self) }
        }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgPathElement_getBounds(self) }
        }
        /// Returns the length of the line or curve
        pub fn get_length(&self) -> f64 {
            unsafe { crate::dll::AzSvgPathElement_getLength(self) }
        }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or
        /// curve start
        pub fn get_t_at_offset(&self, offset: f64) -> f64 {
            unsafe { crate::dll::AzSvgPathElement_getTAtOffset(self, offset) }
        }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgPathElement_getXAtT(self, t) }
        }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgPathElement_getYAtT(self, t) }
        }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between
        /// 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64) -> crate::svg::SvgVector {
            unsafe { crate::dll::AzSvgPathElement_getTangentVectorAtT(self, t) }
        }
        /// Calls the `SvgPathElement::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgPathElement_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgPoint` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgPoint as SvgPoint;
    impl SvgPoint {
        /// Returns the euclidean distance to some other point
        pub fn distance<_1: Into<SvgPoint>>(&self, other: _1) -> f64 {
            unsafe { crate::dll::AzSvgPoint_distance(self, other.into()) }
        }
    }

    /// `SvgVector` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgVector as SvgVector;
    impl SvgVector {
        /// Returns the angle of this vector in degrees
        pub fn angle_degrees(&self) -> f64 {
            unsafe { crate::dll::AzSvgVector_angleDegrees(self) }
        }
        /// Normalizes the vector, returning the normalized vector
        pub fn normalize(&self) -> crate::svg::SvgVector {
            unsafe { crate::dll::AzSvgVector_normalize(self) }
        }
        /// Rotates the vector 90 degrees counter clockwise, returning the rotated vector
        pub fn rotate_90deg_ccw(&self) -> crate::svg::SvgVector {
            unsafe { crate::dll::AzSvgVector_rotate90DegCcw(self) }
        }
    }

    /// `SvgLine` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgLine as SvgLine;
    impl SvgLine {
        /// Reverses the order of points in the path so that the path runs in the opposite direction
        /// afterwards
        pub fn reverse(&mut self) {
            unsafe { crate::dll::AzSvgLine_reverse(self) }
        }
        /// Returns the starting point of this item
        pub fn get_start(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgLine_getStart(self) }
        }
        /// Returns the ending point of this item
        pub fn get_end(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgLine_getEnd(self) }
        }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgLine_getBounds(self) }
        }
        /// Returns the length of the line or curve
        pub fn get_length(&self) -> f64 {
            unsafe { crate::dll::AzSvgLine_getLength(self) }
        }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or
        /// curve start
        pub fn get_t_at_offset(&self, offset: f64) -> f64 {
            unsafe { crate::dll::AzSvgLine_getTAtOffset(self, offset) }
        }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgLine_getXAtT(self, t) }
        }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgLine_getYAtT(self, t) }
        }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between
        /// 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64) -> crate::svg::SvgVector {
            unsafe { crate::dll::AzSvgLine_getTangentVectorAtT(self, t) }
        }
        /// Intersect two lines EVEN IF THEY ARE DISTINCT. Only returns None on parallel lines
        /// (never intersect)
        pub fn intersect<_1: Into<SvgLine>>(&self, other: _1) -> crate::option::OptionSvgPoint {
            unsafe { crate::dll::AzSvgLine_intersect(self, other.into()) }
        }
        /// Calls the `SvgLine::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgLine_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgQuadraticCurve` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgQuadraticCurve as SvgQuadraticCurve;
    impl SvgQuadraticCurve {
        /// Reverses the order of points in the curve so that the curve runs in the opposite
        /// direction afterwards
        pub fn reverse(&mut self) {
            unsafe { crate::dll::AzSvgQuadraticCurve_reverse(self) }
        }
        /// Returns the starting point of this item
        pub fn get_start(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgQuadraticCurve_getStart(self) }
        }
        /// Returns the ending point of this item
        pub fn get_end(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgQuadraticCurve_getEnd(self) }
        }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgQuadraticCurve_getBounds(self) }
        }
        /// Returns the length of the line or curve
        pub fn get_length(&self) -> f64 {
            unsafe { crate::dll::AzSvgQuadraticCurve_getLength(self) }
        }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or
        /// curve start
        pub fn get_t_at_offset(&self, offset: f64) -> f64 {
            unsafe { crate::dll::AzSvgQuadraticCurve_getTAtOffset(self, offset) }
        }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgQuadraticCurve_getXAtT(self, t) }
        }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgQuadraticCurve_getYAtT(self, t) }
        }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between
        /// 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64) -> crate::svg::SvgVector {
            unsafe { crate::dll::AzSvgQuadraticCurve_getTangentVectorAtT(self, t) }
        }
        /// Calls the `SvgQuadraticCurve::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgQuadraticCurve_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgCubicCurve` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgCubicCurve as SvgCubicCurve;
    impl SvgCubicCurve {
        /// Reverses the order of points in the curve so that the curve runs in the opposite
        /// direction afterwards
        pub fn reverse(&mut self) {
            unsafe { crate::dll::AzSvgCubicCurve_reverse(self) }
        }
        /// Returns the starting point of this item
        pub fn get_start(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgCubicCurve_getStart(self) }
        }
        /// Returns the ending point of this item
        pub fn get_end(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgCubicCurve_getEnd(self) }
        }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self) -> crate::svg::SvgRect {
            unsafe { crate::dll::AzSvgCubicCurve_getBounds(self) }
        }
        /// Returns the length of the line or curve
        pub fn get_length(&self) -> f64 {
            unsafe { crate::dll::AzSvgCubicCurve_getLength(self) }
        }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or
        /// curve start
        pub fn get_t_at_offset(&self, offset: f64) -> f64 {
            unsafe { crate::dll::AzSvgCubicCurve_getTAtOffset(self, offset) }
        }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgCubicCurve_getXAtT(self, t) }
        }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64) -> f64 {
            unsafe { crate::dll::AzSvgCubicCurve_getYAtT(self, t) }
        }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between
        /// 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64) -> crate::svg::SvgVector {
            unsafe { crate::dll::AzSvgCubicCurve_getTangentVectorAtT(self, t) }
        }
        /// Calls the `SvgCubicCurve::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgCubicCurve_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgRect` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgRect as SvgRect;
    impl SvgRect {
        /// Calls the `SvgRect::get_center` function.
        pub fn get_center(&self) -> crate::svg::SvgPoint {
            unsafe { crate::dll::AzSvgRect_getCenter(self) }
        }
        /// Calls the `SvgRect::contains_point` function.
        pub fn contains_point<_1: Into<SvgPoint>>(&self, point: _1) -> bool {
            unsafe { crate::dll::AzSvgRect_containsPoint(self, point.into()) }
        }
        /// Calls the `SvgRect::expand` function.
        pub fn expand(
            &self,
            padding_top: f32,
            padding_bottom: f32,
            padding_left: f32,
            padding_right: f32,
        ) -> crate::svg::SvgRect {
            unsafe {
                crate::dll::AzSvgRect_expand(
                    self,
                    padding_top,
                    padding_bottom,
                    padding_left,
                    padding_right,
                )
            }
        }
        /// Calls the `SvgRect::tessellate_fill` function.
        pub fn tessellate_fill<_1: Into<SvgFillStyle>>(
            &self,
            fill_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgRect_tessellateFill(self, fill_style.into()) }
        }
        /// Calls the `SvgRect::tessellate_stroke` function.
        pub fn tessellate_stroke<_1: Into<SvgStrokeStyle>>(
            &self,
            stroke_style: _1,
        ) -> crate::svg::TessellatedSvgNode {
            unsafe { crate::dll::AzSvgRect_tessellateStroke(self, stroke_style.into()) }
        }
    }

    /// `SvgColoredVertex` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgColoredVertex as SvgColoredVertex;
    /// `TessellatedColoredSvgNode` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedColoredSvgNode as TessellatedColoredSvgNode;
    impl TessellatedColoredSvgNode {
        /// Returns an empty buffer vertices / indices
        pub fn empty() -> Self {
            unsafe { crate::dll::AzTessellatedColoredSvgNode_empty() }
        }
        /// Creates a new TessellatedColoredSvgNode by joining all the given nodes together into one
        /// array and inserting a `GL_RESTART_INDEX` (`u32::MAX`) into the indices (so that the
        /// resulting buffer can be drawn in one draw call).
        pub fn from_nodes<_1: Into<TessellatedColoredSvgNodeVecRef>>(nodes: _1) -> Self {
            unsafe { crate::dll::AzTessellatedColoredSvgNode_fromNodes(nodes.into()) }
        }
    }

    /// `TessellatedColoredGPUSvgNode` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedColoredGPUSvgNode as TessellatedColoredGPUSvgNode;
    /// Rust wrapper over a `&[TessellatedColoredSvgNode]` or `&Vec<TessellatedColoredSvgNode>`

    #[doc(inline)]
    pub use crate::dll::AzTessellatedColoredSvgNodeVecRef as TessellatedColoredSvgNodeVecRef;
    impl TessellatedColoredGPUSvgNode {
        /// Creates a new `TessellatedColoredGPUSvgNode` instance.
        pub fn new<_1: Into<*const AzTessellatedColoredSvgNode>, _2: Into<Gl>>(
            tessellated_node: _1,
            gl: _2,
        ) -> Self {
            unsafe {
                crate::dll::AzTessellatedColoredGPUSvgNode_new(tessellated_node.into(), gl.into())
            }
        }
    }

    /// `SvgVertex` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgVertex as SvgVertex;
    /// `TessellatedSvgNode` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedSvgNode as TessellatedSvgNode;
    impl TessellatedSvgNode {
        /// Returns an empty buffer vertices / indices
        pub fn empty() -> Self {
            unsafe { crate::dll::AzTessellatedSvgNode_empty() }
        }
        /// Creates a new TessellatedSvgNode by joining all the given nodes together into one array
        /// and inserting a `GL_RESTART_INDEX` (`u32::MAX`) into the indices (so that the resulting
        /// buffer can be drawn in one draw call).
        pub fn from_nodes<_1: Into<TessellatedSvgNodeVecRef>>(nodes: _1) -> Self {
            unsafe { crate::dll::AzTessellatedSvgNode_fromNodes(nodes.into()) }
        }
    }

    /// `TessellatedGPUSvgNode` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedGPUSvgNode as TessellatedGPUSvgNode;
    /// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`

    #[doc(inline)]
    pub use crate::dll::AzTessellatedSvgNodeVecRef as TessellatedSvgNodeVecRef;
    impl TessellatedGPUSvgNode {
        /// Creates a new `TessellatedGPUSvgNode` instance.
        pub fn new<_1: Into<*const AzTessellatedSvgNode>, _2: Into<Gl>>(
            tessellated_node: _1,
            gl: _2,
        ) -> Self {
            unsafe { crate::dll::AzTessellatedGPUSvgNode_new(tessellated_node.into(), gl.into()) }
        }
    }

    /// `SvgParseOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgParseOptions as SvgParseOptions;
    impl SvgParseOptions {
        /// Creates a new `SvgParseOptions` instance.
        pub fn default() -> Self {
            unsafe { crate::dll::AzSvgParseOptions_default() }
        }
    }

    /// `FontDatabase` struct

    #[doc(inline)]
    pub use crate::dll::AzFontDatabase as FontDatabase;
    /// `ImageRendering` struct

    #[doc(inline)]
    pub use crate::dll::AzImageRendering as ImageRendering;
    /// `ShapeRendering` struct

    #[doc(inline)]
    pub use crate::dll::AzShapeRendering as ShapeRendering;
    /// `SvgRenderOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgRenderOptions as SvgRenderOptions;
    /// `TextRendering` struct

    #[doc(inline)]
    pub use crate::dll::AzTextRendering as TextRendering;
    impl SvgRenderOptions {
        /// Creates a new `SvgRenderOptions` instance.
        pub fn default() -> Self {
            unsafe { crate::dll::AzSvgRenderOptions_default() }
        }
    }

    /// `Indent` struct

    #[doc(inline)]
    pub use crate::dll::AzIndent as Indent;
    /// `SvgFillRule` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgFillRule as SvgFillRule;
    /// `SvgFillStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgFillStyle as SvgFillStyle;
    /// `SvgFitTo` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgFitTo as SvgFitTo;
    /// `SvgRenderTransform` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgRenderTransform as SvgRenderTransform;
    /// `SvgStringFormatOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgStringFormatOptions as SvgStringFormatOptions;
    /// `SvgStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgStyle as SvgStyle;
    /// `SvgTransform` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgTransform as SvgTransform;
    impl SvgFillStyle {
        /// Creates a new `SvgFillStyle` instance.
        pub fn default() -> Self {
            unsafe { crate::dll::AzSvgFillStyle_default() }
        }
    }

    /// `SvgStrokeStyle` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgStrokeStyle as SvgStrokeStyle;
    impl SvgStrokeStyle {
        /// Creates a new `SvgStrokeStyle` instance.
        pub fn default() -> Self {
            unsafe { crate::dll::AzSvgStrokeStyle_default() }
        }
    }

    /// `SvgDashPattern` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgDashPattern as SvgDashPattern;
    /// `SvgLineCap` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgLineCap as SvgLineCap;
    /// `SvgLineJoin` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgLineJoin as SvgLineJoin;
}

pub mod xml {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! XML parsing / decoding module
    use core::ffi::c_void;

    /// `Xml` struct

    #[doc(inline)]
    pub use crate::dll::AzXml as Xml;
    use crate::{dll::*, gl::Refstr};
    impl Xml {
        /// Parses an XML document with one or more root nodes
        pub fn from_str<_1: Into<Refstr>>(xml_string: _1) -> crate::error::ResultXmlXmlError {
            unsafe { crate::dll::AzXml_fromStr(xml_string.into()) }
        }
    }

    /// `XmlNode` struct

    #[doc(inline)]
    pub use crate::dll::AzXmlNode as XmlNode;
}

pub mod fs {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Filesystem / file input and output module
    use core::ffi::c_void;

    /// **Reference-counted** file handle

    #[doc(inline)]
    pub use crate::dll::AzFile as File;
    use crate::{
        dll::*,
        gl::{Refstr, U8VecRef},
        str::String,
    };
    impl File {
        /// Opens a file at the given path. If the file exists, replaces it with a new file
        pub fn open<_1: Into<String>>(path: _1) -> crate::option::OptionFile {
            unsafe { crate::dll::AzFile_open(path.into()) }
        }
        /// Creates a file at the given path. If the file exists, replaces it with a new file
        pub fn create<_1: Into<String>>(path: _1) -> crate::option::OptionFile {
            unsafe { crate::dll::AzFile_create(path.into()) }
        }
        /// Reads the file to a UTF8-encoded String, returns None if the file can't be decoded
        /// correctly
        pub fn read_to_string(&mut self) -> crate::option::OptionString {
            unsafe { crate::dll::AzFile_readToString(self) }
        }
        /// Reads the file as bytes, returns None if the file can't be decoded correctly
        pub fn read_to_bytes(&mut self) -> crate::option::OptionU8Vec {
            unsafe { crate::dll::AzFile_readToBytes(self) }
        }
        /// Writes a string to the file, synchronizes the results before returning
        pub fn write_string<_1: Into<Refstr>>(&mut self, bytes: _1) -> bool {
            unsafe { crate::dll::AzFile_writeString(self, bytes.into()) }
        }
        /// Writes some bytes to the file, synchronizes the results before returning
        pub fn write_bytes<_1: Into<U8VecRef>>(&mut self, bytes: _1) -> bool {
            unsafe { crate::dll::AzFile_writeBytes(self, bytes.into()) }
        }
        /// Destructor, closes the file handle
        pub fn close(&mut self) {
            unsafe { crate::dll::AzFile_close(self) }
        }
    }

    impl Clone for File {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzFile_deepCopy(self) }
        }
    }
    impl Drop for File {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzFile_delete(self) }
            }
        }
    }
}

pub mod dialog {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Interface for system file selection dialogs / popup message boxes, etc.
    use core::ffi::c_void;

    /// `MsgBox` struct

    #[doc(inline)]
    pub use crate::dll::AzMsgBox as MsgBox;
    use crate::{
        dll::*,
        option::{OptionColorU, OptionFileTypeList, OptionString},
        str::String,
    };
    impl MsgBox {
        /// Opens an informational message box with only an "OK" button
        pub fn ok<_1: Into<MsgBoxIcon>, _2: Into<String>, _3: Into<String>>(
            icon: _1,
            title: _2,
            message: _3,
        ) -> bool {
            unsafe { crate::dll::AzMsgBox_ok(icon.into(), title.into(), message.into()) }
        }
        /// Shorthand for `MsgBox::ok("Info", $message, Icon::Info)`
        pub fn info<_1: Into<String>>(message: _1) -> bool {
            unsafe { crate::dll::AzMsgBox_info(message.into()) }
        }
        /// Shorthand for `MsgBox::ok("Warning", $message, Icon::Warning)`
        pub fn warning<_1: Into<String>>(message: _1) -> bool {
            unsafe { crate::dll::AzMsgBox_warning(message.into()) }
        }
        /// Shorthand for `MsgBox::ok("Error", $message, Icon::Error)`
        pub fn error<_1: Into<String>>(message: _1) -> bool {
            unsafe { crate::dll::AzMsgBox_error(message.into()) }
        }
        /// Shorthand for `MsgBox::ok("Question", $message, Icon::Question)`
        pub fn question<_1: Into<String>>(message: _1) -> bool {
            unsafe { crate::dll::AzMsgBox_question(message.into()) }
        }
        /// Opens a ok / cancel message box. Blocks the current thread.
        pub fn ok_cancel<
            _1: Into<MsgBoxIcon>,
            _2: Into<String>,
            _3: Into<String>,
            _4: Into<MsgBoxOkCancel>,
        >(
            icon: _1,
            title: _2,
            message: _3,
            default_value: _4,
        ) -> crate::dialog::MsgBoxOkCancel {
            unsafe {
                crate::dll::AzMsgBox_okCancel(
                    icon.into(),
                    title.into(),
                    message.into(),
                    default_value.into(),
                )
            }
        }
        /// Opens a yes / no message box. Blocks the current thread.
        pub fn yes_no<
            _1: Into<MsgBoxIcon>,
            _2: Into<String>,
            _3: Into<String>,
            _4: Into<MsgBoxYesNo>,
        >(
            icon: _1,
            title: _2,
            message: _3,
            default_value: _4,
        ) -> crate::dialog::MsgBoxYesNo {
            unsafe {
                crate::dll::AzMsgBox_yesNo(
                    icon.into(),
                    title.into(),
                    message.into(),
                    default_value.into(),
                )
            }
        }
    }

    /// File picker dialog

    #[doc(inline)]
    pub use crate::dll::AzFileDialog as FileDialog;
    /// Type of message box icon

    #[doc(inline)]
    pub use crate::dll::AzMsgBoxIcon as MsgBoxIcon;
    /// Value returned from an ok / cancel message box

    #[doc(inline)]
    pub use crate::dll::AzMsgBoxOkCancel as MsgBoxOkCancel;
    /// Value returned from a yes / no message box

    #[doc(inline)]
    pub use crate::dll::AzMsgBoxYesNo as MsgBoxYesNo;
    impl FileDialog {
        /// Select a single file using the system-native file picker. Blocks the current thread.
        pub fn select_file<
            _1: Into<String>,
            _2: Into<OptionString>,
            _3: Into<OptionFileTypeList>,
        >(
            title: _1,
            default_path: _2,
            filter_list: _3,
        ) -> crate::option::OptionString {
            unsafe {
                crate::dll::AzFileDialog_selectFile(
                    title.into(),
                    default_path.into(),
                    filter_list.into(),
                )
            }
        }
        /// Select multiple files using the system-native file picker. Blocks the current thread.
        pub fn select_multiple_files<
            _1: Into<String>,
            _2: Into<OptionString>,
            _3: Into<OptionFileTypeList>,
        >(
            title: _1,
            default_path: _2,
            filter_list: _3,
        ) -> crate::option::OptionStringVec {
            unsafe {
                crate::dll::AzFileDialog_selectMultipleFiles(
                    title.into(),
                    default_path.into(),
                    filter_list.into(),
                )
            }
        }
        /// Open a dialog prompting the user to select a directory to open. Blocks the current
        /// thread.
        pub fn select_folder<_1: Into<String>, _2: Into<OptionString>>(
            title: _1,
            default_path: _2,
        ) -> crate::option::OptionString {
            unsafe { crate::dll::AzFileDialog_selectFolder(title.into(), default_path.into()) }
        }
        /// Open a dialog prompting the user to save a file. Blocks the current thread.
        pub fn save_file<_1: Into<String>, _2: Into<OptionString>>(
            title: _1,
            default_path: _2,
        ) -> crate::option::OptionString {
            unsafe { crate::dll::AzFileDialog_saveFile(title.into(), default_path.into()) }
        }
    }

    /// `ColorPickerDialog` struct

    #[doc(inline)]
    pub use crate::dll::AzColorPickerDialog as ColorPickerDialog;
    /// `FileTypeList` struct

    #[doc(inline)]
    pub use crate::dll::AzFileTypeList as FileTypeList;
    impl ColorPickerDialog {
        /// Opens a system-native color picker dialog
        pub fn open<_1: Into<String>, _2: Into<OptionColorU>>(
            title: _1,
            default_color: _2,
        ) -> crate::option::OptionColorU {
            unsafe { crate::dll::AzColorPickerDialog_open(title.into(), default_color.into()) }
        }
    }
}

pub mod clipboard {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Classes to talk to the system clipboard manager
    use core::ffi::c_void;

    /// Connection to the system clipboard, on some systems this connection can be cached

    #[doc(inline)]
    pub use crate::dll::AzSystemClipboard as SystemClipboard;
    use crate::{dll::*, str::String};
    impl SystemClipboard {
        /// Creates a new connection to the system clipboard manager
        pub fn new() -> crate::option::OptionSystemClipboard {
            unsafe { crate::dll::AzSystemClipboard_new() }
        }
        /// Returns the system clipboard contents or `None` if the clipboard is empty or there was
        /// an error
        pub fn get_string_contents(&self) -> crate::option::OptionString {
            unsafe { crate::dll::AzSystemClipboard_getStringContents(self) }
        }
        /// Sets the system clipboard contents to the new string, returns true if the system
        /// clipboard was updated
        pub fn set_string_contents<_1: Into<String>>(&mut self, contents: _1) -> bool {
            unsafe { crate::dll::AzSystemClipboard_setStringContents(self, contents.into()) }
        }
    }

    impl Clone for SystemClipboard {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzSystemClipboard_deepCopy(self) }
        }
    }
    impl Drop for SystemClipboard {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzSystemClipboard_delete(self) }
            }
        }
    }
}

pub mod time {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Rust wrappers for `Instant` / `Duration` classes
    use core::ffi::c_void;

    /// `Instant` struct

    #[doc(inline)]
    pub use crate::dll::AzInstant as Instant;
    use crate::dll::*;
    impl Instant {
        /// Returns the duration since and earlier instant or None if the earlier instant is later
        /// than self
        pub fn duration_since<_1: Into<Instant>>(
            &self,
            earlier: _1,
        ) -> crate::option::OptionDuration {
            unsafe { crate::dll::AzInstant_durationSince(self, earlier.into()) }
        }
        /// Adds a duration to the current time instant, returning the new `Instant`
        pub fn add_duration<_1: Into<Duration>>(&mut self, duration: _1) -> crate::time::Instant {
            unsafe { crate::dll::AzInstant_addDuration(self, duration.into()) }
        }
        /// Linearly interpolates between [start, end] if the `self` Instant lies between start and
        /// end. Returns values between 0.0 and 1.0
        pub fn linear_interpolate<_1: Into<Instant>, _2: Into<Instant>>(
            &self,
            start: _1,
            end: _2,
        ) -> f32 {
            unsafe { crate::dll::AzInstant_linearInterpolate(self, start.into(), end.into()) }
        }
    }

    /// `InstantPtr` struct

    #[doc(inline)]
    pub use crate::dll::AzInstantPtr as InstantPtr;
    impl Clone for InstantPtr {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzInstantPtr_deepCopy(self) }
        }
    }
    impl Drop for InstantPtr {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzInstantPtr_delete(self) }
            }
        }
    }
    /// `Duration` struct

    #[doc(inline)]
    pub use crate::dll::AzDuration as Duration;
    /// `InstantPtrCloneFn` struct

    #[doc(inline)]
    pub use crate::dll::AzInstantPtrCloneFn as InstantPtrCloneFn;
    /// `InstantPtrCloneFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzInstantPtrCloneFnType as InstantPtrCloneFnType;
    /// `InstantPtrDestructorFn` struct

    #[doc(inline)]
    pub use crate::dll::AzInstantPtrDestructorFn as InstantPtrDestructorFn;
    /// `InstantPtrDestructorFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzInstantPtrDestructorFnType as InstantPtrDestructorFnType;
    /// `SystemTick` struct

    #[doc(inline)]
    pub use crate::dll::AzSystemTick as SystemTick;
    /// `SystemTickDiff` struct

    #[doc(inline)]
    pub use crate::dll::AzSystemTickDiff as SystemTickDiff;
    /// `SystemTimeDiff` struct

    #[doc(inline)]
    pub use crate::dll::AzSystemTimeDiff as SystemTimeDiff;
}

pub mod task {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Asyncronous timers / task / thread handlers for easy async loading
    use core::ffi::c_void;

    /// `Timer` struct

    #[doc(inline)]
    pub use crate::dll::AzTimer as Timer;
    /// `TimerId` struct

    #[doc(inline)]
    pub use crate::dll::AzTimerId as TimerId;
    use crate::{
        callbacks::{RefAny, TimerCallbackType},
        dll::*,
        time::Duration,
    };
    impl Timer {
        /// Creates a new `Timer` instance.
        pub fn new<_1: Into<RefAny>, _3: Into<GetSystemTimeFn>>(
            timer_data: _1,
            callback: TimerCallbackType,
            get_system_time_fn: _3,
        ) -> Self {
            unsafe {
                crate::dll::AzTimer_new(timer_data.into(), callback, get_system_time_fn.into())
            }
        }
        /// Calls the `Timer::with_delay` function.
        pub fn with_delay<_1: Into<Duration>>(&self, delay: _1) -> crate::task::Timer {
            unsafe { crate::dll::AzTimer_withDelay(self, delay.into()) }
        }
        /// Calls the `Timer::with_interval` function.
        pub fn with_interval<_1: Into<Duration>>(&self, interval: _1) -> crate::task::Timer {
            unsafe { crate::dll::AzTimer_withInterval(self, interval.into()) }
        }
        /// Calls the `Timer::with_timeout` function.
        pub fn with_timeout<_1: Into<Duration>>(&self, timeout: _1) -> crate::task::Timer {
            unsafe { crate::dll::AzTimer_withTimeout(self, timeout.into()) }
        }
    }

    /// Should a timer terminate or not - used to remove active timers

    #[doc(inline)]
    pub use crate::dll::AzTerminateTimer as TerminateTimer;
    /// `Thread` struct

    #[doc(inline)]
    pub use crate::dll::AzThread as Thread;
    /// `ThreadId` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadId as ThreadId;
    impl Clone for Thread {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzThread_deepCopy(self) }
        }
    }
    impl Drop for Thread {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzThread_delete(self) }
            }
        }
    }
    /// `ThreadSender` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadSender as ThreadSender;
    impl ThreadSender {
        /// Calls the `ThreadSender::send` function.
        pub fn send<_1: Into<ThreadReceiveMsg>>(&mut self, msg: _1) -> bool {
            unsafe { crate::dll::AzThreadSender_send(self, msg.into()) }
        }
    }

    impl Clone for ThreadSender {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzThreadSender_deepCopy(self) }
        }
    }
    impl Drop for ThreadSender {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzThreadSender_delete(self) }
            }
        }
    }
    /// `ThreadReceiver` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadReceiver as ThreadReceiver;
    impl ThreadReceiver {
        /// Calls the `ThreadReceiver::receive` function.
        pub fn receive(&mut self) -> crate::option::OptionThreadSendMsg {
            unsafe { crate::dll::AzThreadReceiver_receive(self) }
        }
    }

    impl Clone for ThreadReceiver {
        fn clone(&self) -> Self {
            unsafe { crate::dll::AzThreadReceiver_deepCopy(self) }
        }
    }
    impl Drop for ThreadReceiver {
        fn drop(&mut self) {
            if self.run_destructor {
                unsafe { crate::dll::AzThreadReceiver_delete(self) }
            }
        }
    }
    /// Function called to check if the thread has finished

    #[doc(inline)]
    pub use crate::dll::AzCheckThreadFinishedFn as CheckThreadFinishedFn;
    /// Callback that checks whether the thread has finished - the input argument is the
    /// `dropcheck` field on the Thread.

    #[doc(inline)]
    pub use crate::dll::AzCheckThreadFinishedFnType as CheckThreadFinishedFnType;
    /// `CreateThreadFn` struct

    #[doc(inline)]
    pub use crate::dll::AzCreateThreadFn as CreateThreadFn;
    /// `CreateThreadFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzCreateThreadFnType as CreateThreadFnType;
    /// Get the current system time, equivalent to `std::time::Instant::now()`, except it also
    /// works on systems that work with "ticks" instead of timers

    #[doc(inline)]
    pub use crate::dll::AzGetSystemTimeFn as GetSystemTimeFn;
    /// `GetSystemTimeFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzGetSystemTimeFnType as GetSystemTimeFnType;
    /// Function to receive a message from the thread

    #[doc(inline)]
    pub use crate::dll::AzLibraryReceiveThreadMsgFn as LibraryReceiveThreadMsgFn;
    /// `LibraryReceiveThreadMsgFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzLibraryReceiveThreadMsgFnType as LibraryReceiveThreadMsgFnType;
    /// Function to send a message to the thread

    #[doc(inline)]
    pub use crate::dll::AzLibrarySendThreadMsgFn as LibrarySendThreadMsgFn;
    /// `LibrarySendThreadMsgFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzLibrarySendThreadMsgFnType as LibrarySendThreadMsgFnType;
    /// Destructor of the `Thread`

    #[doc(inline)]
    pub use crate::dll::AzThreadDestructorFn as ThreadDestructorFn;
    /// `ThreadDestructorFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadDestructorFnType as ThreadDestructorFnType;
    /// `ThreadReceiveMsg` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadReceiveMsg as ThreadReceiveMsg;
    /// Destructor of the `ThreadReceiver`

    #[doc(inline)]
    pub use crate::dll::AzThreadReceiverDestructorFn as ThreadReceiverDestructorFn;
    /// `ThreadReceiverDestructorFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadReceiverDestructorFnType as ThreadReceiverDestructorFnType;
    /// Function that the running `Thread` can call to receive messages from the main UI thread

    #[doc(inline)]
    pub use crate::dll::AzThreadRecvFn as ThreadRecvFn;
    /// `ThreadRecvFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadRecvFnType as ThreadRecvFnType;
    /// Function that the running `Thread` can call to receive messages from the main UI thread

    #[doc(inline)]
    pub use crate::dll::AzThreadSendFn as ThreadSendFn;
    /// `ThreadSendFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadSendFnType as ThreadSendFnType;
    /// `ThreadSendMsg` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadSendMsg as ThreadSendMsg;
    /// Destructor of the `ThreadSender`

    #[doc(inline)]
    pub use crate::dll::AzThreadSenderDestructorFn as ThreadSenderDestructorFn;
    /// `ThreadSenderDestructorFnType` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadSenderDestructorFnType as ThreadSenderDestructorFnType;
    /// `ThreadWriteBackMsg` struct

    #[doc(inline)]
    pub use crate::dll::AzThreadWriteBackMsg as ThreadWriteBackMsg;
}

pub mod str {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Definition of azuls internal `String` wrappers
    use alloc::string;
    use core::ffi::c_void;

    #[cfg(all(feature = "serde-support"))]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};

    use crate::dll::*;

    #[cfg(feature = "serde-support")]
    impl Serialize for crate::str::String {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }

    #[cfg(feature = "serde-support")]
    impl<'de> Deserialize<'de> for crate::str::String {
        fn deserialize<D>(deserializer: D) -> Result<crate::str::String, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = string::String::deserialize(deserializer)?;
            Ok(s.into())
        }
    }

    impl From<&'static str> for crate::str::String {
        fn from(v: &'static str) -> crate::str::String {
            crate::str::String::from_const_str(v)
        }
    }

    impl From<string::String> for crate::str::String {
        fn from(s: string::String) -> crate::str::String {
            crate::str::String::from_string(s)
        }
    }

    impl AsRef<str> for crate::str::String {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }

    impl core::fmt::Debug for crate::str::String {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            self.as_str().fmt(f)
        }
    }

    impl core::fmt::Display for crate::str::String {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            self.as_str().fmt(f)
        }
    }

    impl crate::str::String {
        #[inline(always)]
        pub fn from_string(s: string::String) -> crate::str::String {
            crate::str::String {
                vec: crate::vec::U8Vec::from_vec(s.into_bytes()),
            }
        }

        #[inline(always)]
        pub const fn from_const_str(s: &'static str) -> crate::str::String {
            crate::str::String {
                vec: crate::vec::U8Vec::from_const_slice(s.as_bytes()),
            }
        }
    }
    /// `FmtArg` struct

    #[doc(inline)]
    pub use crate::dll::AzFmtArg as FmtArg;
    /// `FmtValue` struct

    #[doc(inline)]
    pub use crate::dll::AzFmtValue as FmtValue;
    /// `String` struct

    #[doc(inline)]
    pub use crate::dll::AzString as String;
    use crate::vec::FmtArgVec;
    impl String {
        /// Creates a dynamically formatted String from a fomat string + named arguments
        pub fn format<_1: Into<String>, _2: Into<FmtArgVec>>(format: _1, args: _2) -> Self {
            unsafe { crate::dll::AzString_format(format.into(), args.into()) }
        }
        /// Creates a new String from an arbitary pointer, a start offset (bytes from the start
        /// pointer, usually 0) and a length (in bytes). The bytes are expected to point to a UTF-8
        /// encoded string, no error checking is performed.
        pub fn copy_from_bytes(ptr: *const u8, start: usize, len: usize) -> Self {
            unsafe { crate::dll::AzString_copyFromBytes(ptr, start, len) }
        }
        /// Trims whitespace from the start / end of the string
        pub fn trim(&self) -> crate::str::String {
            unsafe { crate::dll::AzString_trim(self) }
        }
        /// Returns a reference to the string - NOTE: the returned value is a reference to `self`,
        /// you MUST NOT drop the `String` object that the `Refstr` references
        pub fn as_refstr(&self) -> crate::gl::Refstr {
            unsafe { crate::dll::AzString_asRefstr(self) }
        }
    }
}

pub mod vec {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Definition of azuls internal `Vec<*>` wrappers
    use alloc::{
        slice, string,
        vec::{self, Vec},
    };
    use core::{cmp, ffi::c_void, fmt, iter};

    use crate::{
        dll::*,
        gl::{GLint as AzGLint, GLuint as AzGLuint},
    };

    macro_rules! impl_vec {
        (
            $struct_type:ident,
            $struct_name:ident,
            $destructor_name:ident,
            $c_destructor_fn_name:ident,
            $crate_dll_delete_fn:ident
        ) => {
            unsafe impl Send for $struct_name {}

            unsafe impl Sync for $struct_name {}

            impl fmt::Debug for $destructor_name {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                    match self {
                        $destructor_name::DefaultRust => write!(f, "DefaultRust"),
                        $destructor_name::NoDestructor => write!(f, "NoDestructor"),
                        $destructor_name::External(_) => write!(f, "External"),
                    }
                }
            }

            impl PartialEq for $destructor_name {
                fn eq(&self, rhs: &Self) -> bool {
                    match (self, rhs) {
                        ($destructor_name::DefaultRust, $destructor_name::DefaultRust) => true,
                        ($destructor_name::NoDestructor, $destructor_name::NoDestructor) => true,
                        ($destructor_name::External(a), $destructor_name::External(b)) => {
                            (a as *const _ as usize).eq(&(b as *const _ as usize))
                        }
                        _ => false,
                    }
                }
            }

            impl PartialOrd for $destructor_name {
                fn partial_cmp(&self, _rhs: &Self) -> Option<cmp::Ordering> {
                    None
                }
            }

            impl $struct_name {
                #[inline]
                pub fn iter(&self) -> slice::Iter<$struct_type> {
                    self.as_ref().iter()
                }

                #[inline]
                pub fn ptr_as_usize(&self) -> usize {
                    self.ptr as usize
                }

                #[inline]
                pub fn len(&self) -> usize {
                    self.len
                }

                #[inline]
                pub fn capacity(&self) -> usize {
                    self.cap
                }

                #[inline]
                pub fn is_empty(&self) -> bool {
                    self.len == 0
                }

                pub fn get(&self, index: usize) -> Option<&$struct_type> {
                    let v1: &[$struct_type] = self.as_ref();
                    let res = v1.get(index);
                    res
                }

                #[inline]
                unsafe fn get_unchecked(&self, index: usize) -> &$struct_type {
                    let v1: &[$struct_type] = self.as_ref();
                    let res = v1.get_unchecked(index);
                    res
                }

                pub fn as_slice(&self) -> &[$struct_type] {
                    self.as_ref()
                }

                #[inline(always)]
                pub const fn from_const_slice(input: &'static [$struct_type]) -> Self {
                    Self {
                        ptr: input.as_ptr(),
                        len: input.len(),
                        cap: input.len(),
                        destructor: $destructor_name::NoDestructor, // because of &'static
                    }
                }

                #[inline(always)]
                pub fn from_vec(input: Vec<$struct_type>) -> Self {
                    extern "C" fn $c_destructor_fn_name(s: &mut $struct_name) {
                        let _ = unsafe {
                            Vec::from_raw_parts(s.ptr as *mut $struct_type, s.len, s.cap)
                        };
                    }

                    let ptr = input.as_ptr();
                    let len = input.len();
                    let cap = input.capacity();

                    let _ = ::core::mem::ManuallyDrop::new(input);

                    Self {
                        ptr,
                        len,
                        cap,
                        destructor: $destructor_name::External($c_destructor_fn_name),
                    }
                }
            }

            impl AsRef<[$struct_type]> for $struct_name {
                fn as_ref(&self) -> &[$struct_type] {
                    unsafe { slice::from_raw_parts(self.ptr, self.len) }
                }
            }

            impl iter::FromIterator<$struct_type> for $struct_name {
                fn from_iter<T>(iter: T) -> Self
                where
                    T: IntoIterator<Item = $struct_type>,
                {
                    Self::from_vec(Vec::from_iter(iter))
                }
            }

            impl From<Vec<$struct_type>> for $struct_name {
                fn from(input: Vec<$struct_type>) -> $struct_name {
                    Self::from_vec(input)
                }
            }

            impl From<&'static [$struct_type]> for $struct_name {
                fn from(input: &'static [$struct_type]) -> $struct_name {
                    Self::from_const_slice(input)
                }
            }

            impl Drop for $struct_name {
                fn drop(&mut self) {
                    match self.destructor {
                        $destructor_name::DefaultRust => unsafe {
                            crate::dll::$crate_dll_delete_fn(self);
                        },
                        $destructor_name::NoDestructor => {}
                        $destructor_name::External(f) => {
                            f(self);
                        }
                    }
                    // necessary so that double-frees are avoided
                    self.destructor = $destructor_name::NoDestructor;
                }
            }

            impl fmt::Debug for $struct_name {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                    self.as_ref().fmt(f)
                }
            }

            impl PartialOrd for $struct_name {
                fn partial_cmp(&self, rhs: &Self) -> Option<cmp::Ordering> {
                    self.as_ref().partial_cmp(rhs.as_ref())
                }
            }

            impl PartialEq for $struct_name {
                fn eq(&self, rhs: &Self) -> bool {
                    self.as_ref().eq(rhs.as_ref())
                }
            }
        };
    }

    macro_rules! impl_vec_clone {
        ($struct_type:ident, $struct_name:ident, $destructor_name:ident) => {
            impl $struct_name {
                /// NOTE: CLONES the memory if the memory is external or &'static
                /// Moves the memory out if the memory is library-allocated
                #[inline(always)]
                pub fn clone_self(&self) -> Self {
                    match self.destructor {
                        $destructor_name::NoDestructor => Self {
                            ptr: self.ptr,
                            len: self.len,
                            cap: self.cap,
                            destructor: $destructor_name::NoDestructor,
                        },
                        $destructor_name::External(_) | $destructor_name::DefaultRust => {
                            Self::from_vec(self.as_ref().to_vec())
                        }
                    }
                }
            }

            impl Clone for $struct_name {
                fn clone(&self) -> Self {
                    self.clone_self()
                }
            }
        };
    }

    macro_rules! impl_vec_serde {
        ($struct_type:ident, $struct_name:ident) => {
            #[cfg(all(feature = "serde-support"))]
            use serde::{Deserialize, Deserializer, Serialize, Serializer};

            #[cfg(all(feature = "serde-support"))]
            impl Serialize for $struct_name {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: Serializer,
                {
                    self.as_ref().serialize(serializer)
                }
            }

            #[cfg(all(feature = "serde-support"))]
            impl<'de> Deserialize<'de> for $struct_name {
                fn deserialize<D>(deserializer: D) -> Result<$struct_name, D::Error>
                where
                    D: Deserializer<'de>,
                {
                    let s = Vec::<$struct_type>::deserialize(deserializer)?;
                    Ok(s.into())
                }
            }
        };
    }

    impl_vec!(
        u8,
        AzU8Vec,
        AzU8VecDestructor,
        az_u8_vec_destructor,
        AzU8Vec_delete
    );
    impl_vec_clone!(u8, AzU8Vec, AzU8VecDestructor);
    impl_vec!(
        u16,
        AzU16Vec,
        AzU16VecDestructor,
        az_u16_vec_destructor,
        AzU16Vec_delete
    );
    impl_vec_clone!(u16, AzU16Vec, AzU16VecDestructor);
    impl_vec!(
        u32,
        AzU32Vec,
        AzU32VecDestructor,
        az_u32_vec_destructor,
        AzU32Vec_delete
    );
    impl_vec_clone!(u32, AzU32Vec, AzU32VecDestructor);
    impl_vec!(
        u32,
        AzScanCodeVec,
        AzScanCodeVecDestructor,
        az_scan_code_vec_destructor,
        AzScanCodeVec_delete
    );
    impl_vec_clone!(u32, AzScanCodeVec, AzScanCodeVecDestructor);
    impl_vec!(
        u32,
        AzGLuintVec,
        AzGLuintVecDestructor,
        az_g_luint_vec_destructor,
        AzGLuintVec_delete
    );
    impl_vec_clone!(u32, AzGLuintVec, AzGLuintVecDestructor);
    impl_vec!(
        i32,
        AzGLintVec,
        AzGLintVecDestructor,
        az_g_lint_vec_destructor,
        AzGLintVec_delete
    );
    impl_vec_clone!(i32, AzGLintVec, AzGLintVecDestructor);
    impl_vec!(
        f32,
        AzF32Vec,
        AzF32VecDestructor,
        az_f32_vec_destructor,
        AzF32Vec_delete
    );
    impl_vec_clone!(f32, AzF32Vec, AzF32VecDestructor);
    impl_vec!(
        AzXmlNode,
        AzXmlNodeVec,
        AzXmlNodeVecDestructor,
        az_xml_node_vec_destructor,
        AzXmlNodeVec_delete
    );
    impl_vec_clone!(AzXmlNode, AzXmlNodeVec, AzXmlNodeVecDestructor);
    impl_vec!(
        AzInlineWord,
        AzInlineWordVec,
        AzInlineWordVecDestructor,
        az_inline_word_vec_destructor,
        AzInlineWordVec_delete
    );
    impl_vec_clone!(AzInlineWord, AzInlineWordVec, AzInlineWordVecDestructor);
    impl_vec!(
        AzInlineGlyph,
        AzInlineGlyphVec,
        AzInlineGlyphVecDestructor,
        az_inline_glyph_vec_destructor,
        AzInlineGlyphVec_delete
    );
    impl_vec_clone!(AzInlineGlyph, AzInlineGlyphVec, AzInlineGlyphVecDestructor);
    impl_vec!(
        AzInlineLine,
        AzInlineLineVec,
        AzInlineLineVecDestructor,
        az_inline_line_vec_destructor,
        AzInlineLineVec_delete
    );
    impl_vec_clone!(AzInlineLine, AzInlineLineVec, AzInlineLineVecDestructor);
    impl_vec!(
        AzFmtArg,
        AzFmtArgVec,
        AzFmtArgVecDestructor,
        az_fmt_arg_vec_destructor,
        AzFmtArgVec_delete
    );
    impl_vec_clone!(AzFmtArg, AzFmtArgVec, AzFmtArgVecDestructor);
    impl_vec!(
        AzInlineTextHit,
        AzInlineTextHitVec,
        AzInlineTextHitVecDestructor,
        az_inline_text_hit_vec_destructor,
        AzInlineTextHitVec_delete
    );
    impl_vec_clone!(
        AzInlineTextHit,
        AzInlineTextHitVec,
        AzInlineTextHitVecDestructor
    );
    impl_vec!(
        AzTessellatedSvgNode,
        AzTessellatedSvgNodeVec,
        AzTessellatedSvgNodeVecDestructor,
        az_tesselated_svg_node_vec_destructor,
        AzTessellatedSvgNodeVec_delete
    );
    impl_vec_clone!(
        AzTessellatedSvgNode,
        AzTessellatedSvgNodeVec,
        AzTessellatedSvgNodeVecDestructor
    );
    impl_vec!(
        AzNodeDataInlineCssProperty,
        AzNodeDataInlineCssPropertyVec,
        NodeDataInlineCssPropertyVecDestructor,
        az_node_data_inline_css_property_vec_destructor,
        AzNodeDataInlineCssPropertyVec_delete
    );
    impl_vec_clone!(
        AzNodeDataInlineCssProperty,
        AzNodeDataInlineCssPropertyVec,
        NodeDataInlineCssPropertyVecDestructor
    );
    impl_vec!(
        AzIdOrClass,
        AzIdOrClassVec,
        IdOrClassVecDestructor,
        az_id_or_class_vec_destructor,
        AzIdOrClassVec_delete
    );
    impl_vec_clone!(AzIdOrClass, AzIdOrClassVec, IdOrClassVecDestructor);
    impl_vec!(
        AzStyleTransform,
        AzStyleTransformVec,
        AzStyleTransformVecDestructor,
        az_style_transform_vec_destructor,
        AzStyleTransformVec_delete
    );
    impl_vec_clone!(
        AzStyleTransform,
        AzStyleTransformVec,
        AzStyleTransformVecDestructor
    );
    impl_vec!(
        AzCssProperty,
        AzCssPropertyVec,
        AzCssPropertyVecDestructor,
        az_css_property_vec_destructor,
        AzCssPropertyVec_delete
    );
    impl_vec_clone!(AzCssProperty, AzCssPropertyVec, AzCssPropertyVecDestructor);
    impl_vec!(
        AzSvgMultiPolygon,
        AzSvgMultiPolygonVec,
        AzSvgMultiPolygonVecDestructor,
        az_svg_multi_polygon_vec_destructor,
        AzSvgMultiPolygonVec_delete
    );
    impl_vec_clone!(
        AzSvgMultiPolygon,
        AzSvgMultiPolygonVec,
        AzSvgMultiPolygonVecDestructor
    );
    impl_vec!(
        AzSvgPath,
        AzSvgPathVec,
        AzSvgPathVecDestructor,
        az_svg_path_vec_destructor,
        AzSvgPathVec_delete
    );
    impl_vec_clone!(AzSvgPath, AzSvgPathVec, AzSvgPathVecDestructor);
    impl_vec!(
        AzVertexAttribute,
        AzVertexAttributeVec,
        AzVertexAttributeVecDestructor,
        az_vertex_attribute_vec_destructor,
        AzVertexAttributeVec_delete
    );
    impl_vec_clone!(
        AzVertexAttribute,
        AzVertexAttributeVec,
        AzVertexAttributeVecDestructor
    );
    impl_vec!(
        AzSvgPathElement,
        AzSvgPathElementVec,
        AzSvgPathElementVecDestructor,
        az_svg_path_element_vec_destructor,
        AzSvgPathElementVec_delete
    );
    impl_vec_clone!(
        AzSvgPathElement,
        AzSvgPathElementVec,
        AzSvgPathElementVecDestructor
    );
    impl_vec!(
        AzSvgVertex,
        AzSvgVertexVec,
        AzSvgVertexVecDestructor,
        az_svg_vertex_vec_destructor,
        AzSvgVertexVec_delete
    );
    impl_vec_clone!(AzSvgVertex, AzSvgVertexVec, AzSvgVertexVecDestructor);
    impl_vec!(
        AzXWindowType,
        AzXWindowTypeVec,
        AzXWindowTypeVecDestructor,
        az_x_window_type_vec_destructor,
        AzXWindowTypeVec_delete
    );
    impl_vec_clone!(AzXWindowType, AzXWindowTypeVec, AzXWindowTypeVecDestructor);
    impl_vec!(
        AzVirtualKeyCode,
        AzVirtualKeyCodeVec,
        AzVirtualKeyCodeVecDestructor,
        az_virtual_key_code_vec_destructor,
        AzVirtualKeyCodeVec_delete
    );
    impl_vec_clone!(
        AzVirtualKeyCode,
        AzVirtualKeyCodeVec,
        AzVirtualKeyCodeVecDestructor
    );
    impl_vec!(
        AzCascadeInfo,
        AzCascadeInfoVec,
        AzCascadeInfoVecDestructor,
        az_cascade_info_vec_destructor,
        AzCascadeInfoVec_delete
    );
    impl_vec_clone!(AzCascadeInfo, AzCascadeInfoVec, AzCascadeInfoVecDestructor);
    impl_vec!(
        AzCssDeclaration,
        AzCssDeclarationVec,
        AzCssDeclarationVecDestructor,
        az_css_declaration_vec_destructor,
        AzCssDeclarationVec_delete
    );
    impl_vec_clone!(
        AzCssDeclaration,
        AzCssDeclarationVec,
        AzCssDeclarationVecDestructor
    );
    impl_vec!(
        AzCssPathSelector,
        AzCssPathSelectorVec,
        AzCssPathSelectorVecDestructor,
        az_css_path_selector_vec_destructor,
        AzCssPathSelectorVec_delete
    );
    impl_vec_clone!(
        AzCssPathSelector,
        AzCssPathSelectorVec,
        AzCssPathSelectorVecDestructor
    );
    impl_vec!(
        AzStylesheet,
        AzStylesheetVec,
        AzStylesheetVecDestructor,
        az_stylesheet_vec_destructor,
        AzStylesheetVec_delete
    );
    impl_vec_clone!(AzStylesheet, AzStylesheetVec, AzStylesheetVecDestructor);
    impl_vec!(
        AzCssRuleBlock,
        AzCssRuleBlockVec,
        AzCssRuleBlockVecDestructor,
        az_css_rule_block_vec_destructor,
        AzCssRuleBlockVec_delete
    );
    impl_vec_clone!(
        AzCssRuleBlock,
        AzCssRuleBlockVec,
        AzCssRuleBlockVecDestructor
    );
    impl_vec!(
        AzCallbackData,
        AzCallbackDataVec,
        AzCallbackDataVecDestructor,
        az_callback_data_vec_destructor,
        AzCallbackDataVec_delete
    );
    impl_vec_clone!(
        AzCallbackData,
        AzCallbackDataVec,
        AzCallbackDataVecDestructor
    );
    impl_vec!(
        AzDebugMessage,
        AzDebugMessageVec,
        AzDebugMessageVecDestructor,
        az_debug_message_vec_destructor,
        AzDebugMessageVec_delete
    );
    impl_vec_clone!(
        AzDebugMessage,
        AzDebugMessageVec,
        AzDebugMessageVecDestructor
    );
    impl_vec!(
        AzDom,
        AzDomVec,
        AzDomVecDestructor,
        az_dom_vec_destructor,
        AzDomVec_delete
    );
    impl_vec_clone!(AzDom, AzDomVec, AzDomVecDestructor);
    impl_vec!(
        AzString,
        AzStringVec,
        AzStringVecDestructor,
        az_string_vec_destructor,
        AzStringVec_delete
    );
    impl_vec_clone!(AzString, AzStringVec, AzStringVecDestructor);
    impl_vec!(
        AzStringPair,
        AzStringPairVec,
        AzStringPairVecDestructor,
        az_string_pair_vec_destructor,
        AzStringPairVec_delete
    );
    impl_vec_clone!(AzStringPair, AzStringPairVec, AzStringPairVecDestructor);
    impl_vec!(
        AzNormalizedLinearColorStop,
        AzNormalizedLinearColorStopVec,
        AzNormalizedLinearColorStopVecDestructor,
        az_normalized_linear_color_stop_vec_destructor,
        AzNormalizedLinearColorStopVec_delete
    );
    impl_vec_clone!(
        AzNormalizedLinearColorStop,
        AzNormalizedLinearColorStopVec,
        AzNormalizedLinearColorStopVecDestructor
    );
    impl_vec!(
        AzNormalizedRadialColorStop,
        AzNormalizedRadialColorStopVec,
        AzNormalizedRadialColorStopVecDestructor,
        az_normalized_radial_color_stop_vec_destructor,
        AzNormalizedRadialColorStopVec_delete
    );
    impl_vec_clone!(
        AzNormalizedRadialColorStop,
        AzNormalizedRadialColorStopVec,
        AzNormalizedRadialColorStopVecDestructor
    );
    impl_vec!(
        AzNodeId,
        AzNodeIdVec,
        AzNodeIdVecDestructor,
        az_node_id_vec_destructor,
        AzNodeIdVec_delete
    );
    impl_vec_clone!(AzNodeId, AzNodeIdVec, AzNodeIdVecDestructor);
    impl_vec!(
        AzNodeHierarchyItem,
        AzNodeHierarchyItemVec,
        AzNodeHierarchyItemVecDestructor,
        az_node_hierarchy_item_vec_destructor,
        AzNodeHierarchyItemVec_delete
    );
    impl_vec_clone!(
        AzNodeHierarchyItem,
        AzNodeHierarchyItemVec,
        AzNodeHierarchyItemVecDestructor
    );
    impl_vec!(
        AzStyledNode,
        AzStyledNodeVec,
        AzStyledNodeVecDestructor,
        az_styled_node_vec_destructor,
        AzStyledNodeVec_delete
    );
    impl_vec_clone!(AzStyledNode, AzStyledNodeVec, AzStyledNodeVecDestructor);
    impl_vec!(
        AzTagIdToNodeIdMapping,
        AzTagIdToNodeIdMappingVec,
        AzTagIdToNodeIdMappingVecDestructor,
        az_tag_id_to_node_id_mapping_vec_destructor,
        AzTagIdToNodeIdMappingVec_delete
    );
    impl_vec_clone!(
        AzTagIdToNodeIdMapping,
        AzTagIdToNodeIdMappingVec,
        AzTagIdToNodeIdMappingVecDestructor
    );
    impl_vec!(
        AzParentWithNodeDepth,
        AzParentWithNodeDepthVec,
        AzParentWithNodeDepthVecDestructor,
        az_parent_with_node_depth_vec_destructor,
        AzParentWithNodeDepthVec_delete
    );
    impl_vec_clone!(
        AzParentWithNodeDepth,
        AzParentWithNodeDepthVec,
        AzParentWithNodeDepthVecDestructor
    );
    impl_vec!(
        AzNodeData,
        AzNodeDataVec,
        AzNodeDataVecDestructor,
        az_node_data_vec_destructor,
        AzNodeDataVec_delete
    );
    impl_vec_clone!(AzNodeData, AzNodeDataVec, AzNodeDataVecDestructor);
    impl_vec!(
        AzStyleBackgroundRepeat,
        AzStyleBackgroundRepeatVec,
        AzStyleBackgroundRepeatVecDestructor,
        az_style_background_repeat_vec_destructor,
        AzStyleBackgroundRepeatVec_delete
    );
    impl_vec_clone!(
        AzStyleBackgroundRepeat,
        AzStyleBackgroundRepeatVec,
        AzStyleBackgroundRepeatVecDestructor
    );
    impl_vec!(
        AzStyleBackgroundPosition,
        AzStyleBackgroundPositionVec,
        AzStyleBackgroundPositionVecDestructor,
        az_style_background_position_vec_destructor,
        AzStyleBackgroundPositionVec_delete
    );
    impl_vec_clone!(
        AzStyleBackgroundPosition,
        AzStyleBackgroundPositionVec,
        AzStyleBackgroundPositionVecDestructor
    );
    impl_vec!(
        AzStyleBackgroundSize,
        AzStyleBackgroundSizeVec,
        AzStyleBackgroundSizeVecDestructor,
        az_style_background_size_vec_destructor,
        AzStyleBackgroundSizeVec_delete
    );
    impl_vec_clone!(
        AzStyleBackgroundSize,
        AzStyleBackgroundSizeVec,
        AzStyleBackgroundSizeVecDestructor
    );
    impl_vec!(
        AzStyleBackgroundContent,
        AzStyleBackgroundContentVec,
        AzStyleBackgroundContentVecDestructor,
        az_style_background_content_vec_destructor,
        AzStyleBackgroundContentVec_delete
    );
    impl_vec_clone!(
        AzStyleBackgroundContent,
        AzStyleBackgroundContentVec,
        AzStyleBackgroundContentVecDestructor
    );
    impl_vec!(
        AzVideoMode,
        AzVideoModeVec,
        AzVideoModeVecDestructor,
        az_video_mode_vec_destructor,
        AzVideoModeVec_delete
    );
    impl_vec_clone!(AzVideoMode, AzVideoModeVec, AzVideoModeVecDestructor);
    impl_vec!(
        AzMonitor,
        AzMonitorVec,
        AzMonitorVecDestructor,
        az_monitor_vec_destructor,
        AzMonitorVec_delete
    );
    impl_vec_clone!(AzMonitor, AzMonitorVec, AzMonitorVecDestructor);
    impl_vec!(
        AzStyleFontFamily,
        AzStyleFontFamilyVec,
        AzStyleFontFamilyVecDestructor,
        az_style_font_family_vec_destructor,
        AzStyleFontFamilyVec_delete
    );
    impl_vec_clone!(
        AzStyleFontFamily,
        AzStyleFontFamilyVec,
        AzStyleFontFamilyVecDestructor
    );
    impl_vec!(
        AzNodeTypeIdInfoMap,
        AzNodeTypeIdInfoMapVec,
        AzNodeTypeIdInfoMapVecDestructor,
        az_node_type_id_info_map_vec_destructor,
        AzNodeTypeIdInfoMapVec_delete
    );
    impl_vec_clone!(
        AzNodeTypeIdInfoMap,
        AzNodeTypeIdInfoMapVec,
        AzNodeTypeIdInfoMapVecDestructor
    );
    impl_vec!(
        AzInputOutputTypeIdInfoMap,
        AzInputOutputTypeIdInfoMapVec,
        AzInputOutputTypeIdInfoMapVecDestructor,
        az_input_output_type_id_info_map_vec_destructor,
        AzInputOutputTypeIdInfoMapVec_delete
    );
    impl_vec_clone!(
        AzInputOutputTypeIdInfoMap,
        AzInputOutputTypeIdInfoMapVec,
        AzInputOutputTypeIdInfoMapVecDestructor
    );
    impl_vec!(
        AzNodeIdNodeMap,
        AzNodeIdNodeMapVec,
        AzNodeIdNodeMapVecDestructor,
        az_node_id_node_map_vec_destructor,
        AzNodeIdNodeMapVec_delete
    );
    impl_vec_clone!(
        AzNodeIdNodeMap,
        AzNodeIdNodeMapVec,
        AzNodeIdNodeMapVecDestructor
    );
    impl_vec!(
        AzInputOutputTypeId,
        AzInputOutputTypeIdVec,
        AzInputOutputTypeIdVecDestructor,
        az_input_output_type_id_vec_destructor,
        AzInputOutputTypeIdVec_delete
    );
    impl_vec_clone!(
        AzInputOutputTypeId,
        AzInputOutputTypeIdVec,
        AzInputOutputTypeIdVecDestructor
    );
    impl_vec_serde!(AzInputOutputTypeId, AzInputOutputTypeIdVec);
    impl_vec!(
        AzNodeTypeField,
        AzNodeTypeFieldVec,
        AzNodeTypeFieldVecDestructor,
        az_node_type_field_vec_destructor,
        AzNodeTypeFieldVec_delete
    );
    impl_vec_clone!(
        AzNodeTypeField,
        AzNodeTypeFieldVec,
        AzNodeTypeFieldVecDestructor
    );
    impl_vec!(
        AzInputConnection,
        AzInputConnectionVec,
        AzInputConnectionVecDestructor,
        az_input_connection_vec_destructor,
        AzInputConnectionVec_delete
    );
    impl_vec_clone!(
        AzInputConnection,
        AzInputConnectionVec,
        AzInputConnectionVecDestructor
    );
    impl_vec!(
        AzOutputNodeAndIndex,
        AzOutputNodeAndIndexVec,
        AzOutputNodeAndIndexVecDestructor,
        az_output_node_and_index_vec_destructor,
        AzOutputNodeAndIndexVec_delete
    );
    impl_vec_clone!(
        AzOutputNodeAndIndex,
        AzOutputNodeAndIndexVec,
        AzOutputNodeAndIndexVecDestructor
    );
    impl_vec!(
        AzOutputConnection,
        AzOutputConnectionVec,
        AzOutputConnectionVecDestructor,
        az_output_connection_vec_destructor,
        AzOutputConnectionVec_delete
    );
    impl_vec_clone!(
        AzOutputConnection,
        AzOutputConnectionVec,
        AzOutputConnectionVecDestructor
    );
    impl_vec!(
        AzInputNodeAndIndex,
        AzInputNodeAndIndexVec,
        AzInputNodeAndIndexVecDestructor,
        az_input_node_and_index_vec_destructor,
        AzInputNodeAndIndexVec_delete
    );
    impl_vec_clone!(
        AzInputNodeAndIndex,
        AzInputNodeAndIndexVec,
        AzInputNodeAndIndexVecDestructor
    );
    impl_vec!(
        AzLogicalRect,
        AzLogicalRectVec,
        AzLogicalRectVecDestructor,
        az_logical_rect_vec_destructor,
        AzLogicalRectVec_delete
    );
    impl_vec_clone!(AzLogicalRect, AzLogicalRectVec, AzLogicalRectVecDestructor);
    impl_vec!(
        AzStyleFilter,
        AzStyleFilterVec,
        AzStyleFilterVecDestructor,
        az_style_filter_vec_destructor,
        AzStyleFilterVec_delete
    );
    impl_vec_clone!(AzStyleFilter, AzStyleFilterVec, AzStyleFilterVecDestructor);
    impl_vec!(
        AzListViewRow,
        AzListViewRowVec,
        AzListViewRowVecDestructor,
        az_list_view_vec_destructor,
        AzListViewRowVec_delete
    );
    impl_vec_clone!(AzListViewRow, AzListViewRowVec, AzListViewRowVecDestructor);
    impl_vec!(
        AzAccessibilityState,
        AzAccessibilityStateVec,
        AzAccessibilityStateVecDestructor,
        az_accessibility_state_vec_destructor,
        AzAccessibilityStateVec_delete
    );
    impl_vec_clone!(
        AzAccessibilityState,
        AzAccessibilityStateVec,
        AzAccessibilityStateVecDestructor
    );
    impl_vec!(
        AzMenuItem,
        AzMenuItemVec,
        AzMenuItemVecDestructor,
        az_menu_item_vec_destructor,
        AzMenuItemVec_delete
    );
    impl_vec_clone!(AzMenuItem, AzMenuItemVec, AzMenuItemVecDestructor);
    impl_vec!(
        AzSvgSimpleNode,
        AzSvgSimpleNodeVec,
        AzSvgSimpleNodeVecDestructor,
        az_svg_simple_node_vec_destructor,
        AzSvgSimpleNodeVec_delete
    );
    impl_vec_clone!(
        AzSvgSimpleNode,
        AzSvgSimpleNodeVec,
        AzSvgSimpleNodeVecDestructor
    );
    impl_vec!(
        AzSvgColoredVertex,
        AzSvgColoredVertexVec,
        AzSvgColoredVertexVecDestructor,
        az_svg_colored_vertex_vec_destructor,
        AzSvgColoredVertexVec_delete
    );
    impl_vec_clone!(
        AzSvgColoredVertex,
        AzSvgColoredVertexVec,
        AzSvgColoredVertexVecDestructor
    );
    impl_vec!(
        AzTessellatedColoredSvgNode,
        AzTessellatedColoredSvgNodeVec,
        AzTessellatedColoredSvgNodeVecDestructor,
        az_tesselated_colored_svg_node_vec_destructor,
        AzTessellatedColoredSvgNodeVec_delete
    );
    impl_vec_clone!(
        AzTessellatedColoredSvgNode,
        AzTessellatedColoredSvgNodeVec,
        AzTessellatedColoredSvgNodeVecDestructor
    );

    impl From<vec::Vec<string::String>> for crate::vec::StringVec {
        fn from(v: vec::Vec<string::String>) -> crate::vec::StringVec {
            let vec: Vec<AzString> = v.into_iter().map(Into::into).collect();
            vec.into()
            // v dropped here
        }
    }

    #[cfg(all(feature = "serde-support"))]
    impl Serialize for crate::prelude::SvgPathElementVec {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            self.as_ref().serialize(serializer)
        }
    }

    #[cfg(all(feature = "serde-support"))]
    impl<'de> Deserialize<'de> for crate::prelude::SvgPathElementVec {
        fn deserialize<D>(deserializer: D) -> Result<crate::prelude::SvgPathElementVec, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = Vec::<crate::prelude::SvgPathElement>::deserialize(deserializer)?;
            Ok(s.into())
        }
    }
    /// Wrapper over a Rust-allocated `Vec<AccessibilityState>`

    #[doc(inline)]
    pub use crate::dll::AzAccessibilityStateVec as AccessibilityStateVec;
    /// Wrapper over a Rust-allocated `Vec<InputConnection>`

    #[doc(inline)]
    pub use crate::dll::AzInputConnectionVec as InputConnectionVec;
    /// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`

    #[doc(inline)]
    pub use crate::dll::AzInputNodeAndIndexVec as InputNodeAndIndexVec;
    /// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeIdInfoMapVec as InputOutputTypeIdInfoMapVec;
    /// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeIdVec as InputOutputTypeIdVec;
    /// Wrapper over a Rust-allocated `Vec<ListViewRow>`

    #[doc(inline)]
    pub use crate::dll::AzListViewRowVec as ListViewRowVec;
    /// Wrapper over a Rust-allocated `Vec<LogicalRect>`

    #[doc(inline)]
    pub use crate::dll::AzLogicalRectVec as LogicalRectVec;
    /// Wrapper over a Rust-allocated `Vec<MenuItem>`

    #[doc(inline)]
    pub use crate::dll::AzMenuItemVec as MenuItemVec;
    /// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`

    #[doc(inline)]
    pub use crate::dll::AzNodeIdNodeMapVec as NodeIdNodeMapVec;
    /// Wrapper over a Rust-allocated `Vec<NodeTypeField>`

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeFieldVec as NodeTypeFieldVec;
    /// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeIdInfoMapVec as NodeTypeIdInfoMapVec;
    /// Wrapper over a Rust-allocated `Vec<OutputConnection>`

    #[doc(inline)]
    pub use crate::dll::AzOutputConnectionVec as OutputConnectionVec;
    /// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`

    #[doc(inline)]
    pub use crate::dll::AzOutputNodeAndIndexVec as OutputNodeAndIndexVec;
    /// Wrapper over a Rust-allocated `Vec<StyleFilter>`

    #[doc(inline)]
    pub use crate::dll::AzStyleFilterVec as StyleFilterVec;
    /// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`

    #[doc(inline)]
    pub use crate::dll::AzTessellatedSvgNodeVec as TessellatedSvgNodeVec;
    impl TessellatedSvgNodeVec {
        /// Returns the `TessellatedSvgNodeVec` as a non-owning slice, NOTE: The `U8Vec` that this
        /// slice was borrowed from MUST NOT be deleted before the `U8VecRef`
        pub fn as_ref_vec(&self) -> crate::svg::TessellatedSvgNodeVecRef {
            unsafe { crate::dll::AzTessellatedSvgNodeVec_asRefVec(self) }
        }
    }

    /// Wrapper over a Rust-allocated `Vec<TessellatedColoredSvgNode>`

    #[doc(inline)]
    pub use crate::dll::AzTessellatedColoredSvgNodeVec as TessellatedColoredSvgNodeVec;
    impl TessellatedColoredSvgNodeVec {
        /// Returns the `TessellatedColoredSvgNodeVec` as a non-owning slice, NOTE: The
        /// `TessellatedColoredSvgNodeVec` that this slice was borrowed from MUST NOT be deleted
        /// before the `U8VecRef`
        pub fn as_ref_vec(&self) -> crate::svg::TessellatedColoredSvgNodeVecRef {
            unsafe { crate::dll::AzTessellatedColoredSvgNodeVec_asRefVec(self) }
        }
    }

    /// Wrapper over a Rust-allocated `CascadeInfo`

    #[doc(inline)]
    pub use crate::dll::AzCascadeInfoVec as CascadeInfoVec;
    /// Wrapper over a Rust-allocated `CssDeclaration`

    #[doc(inline)]
    pub use crate::dll::AzCssDeclarationVec as CssDeclarationVec;
    /// Wrapper over a Rust-allocated `CssPathSelector`

    #[doc(inline)]
    pub use crate::dll::AzCssPathSelectorVec as CssPathSelectorVec;
    /// Wrapper over a Rust-allocated `Vec<CssProperty>`

    #[doc(inline)]
    pub use crate::dll::AzCssPropertyVec as CssPropertyVec;
    /// Wrapper over a Rust-allocated `CssRuleBlock`

    #[doc(inline)]
    pub use crate::dll::AzCssRuleBlockVec as CssRuleBlockVec;
    /// Wrapper over a Rust-allocated `Vec<Dom>`

    #[doc(inline)]
    pub use crate::dll::AzDomVec as DomVec;
    /// Wrapper over a Rust-allocated `Vec<f32>`

    #[doc(inline)]
    pub use crate::dll::AzF32Vec as F32Vec;
    /// Wrapper over a Rust-allocated `Vec<FmtArg>`

    #[doc(inline)]
    pub use crate::dll::AzFmtArgVec as FmtArgVec;
    /// Wrapper over a Rust-allocated `Vec<IdOrClass>`

    #[doc(inline)]
    pub use crate::dll::AzIdOrClassVec as IdOrClassVec;
    /// Wrapper over a Rust-allocated `Vec<InlineGlyph>`

    #[doc(inline)]
    pub use crate::dll::AzInlineGlyphVec as InlineGlyphVec;
    /// Wrapper over a Rust-allocated `Vec<InlineLine>`

    #[doc(inline)]
    pub use crate::dll::AzInlineLineVec as InlineLineVec;
    /// Wrapper over a Rust-allocated `Vec<InlineTextHit>`

    #[doc(inline)]
    pub use crate::dll::AzInlineTextHitVec as InlineTextHitVec;
    /// Wrapper over a Rust-allocated `Vec<InlineWord>`

    #[doc(inline)]
    pub use crate::dll::AzInlineWordVec as InlineWordVec;
    /// Wrapper over a Rust-allocated `Vec<Monitor>`

    #[doc(inline)]
    pub use crate::dll::AzMonitorVec as MonitorVec;
    /// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`

    #[doc(inline)]
    pub use crate::dll::AzNodeDataInlineCssPropertyVec as NodeDataInlineCssPropertyVec;
    /// Wrapper over a Rust-allocated `ScanCode`

    #[doc(inline)]
    pub use crate::dll::AzScanCodeVec as ScanCodeVec;
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundContentVec as StyleBackgroundContentVec;
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundPositionVec as StyleBackgroundPositionVec;
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundRepeatVec as StyleBackgroundRepeatVec;
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundSizeVec as StyleBackgroundSizeVec;
    /// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`

    #[doc(inline)]
    pub use crate::dll::AzStyleFontFamilyVec as StyleFontFamilyVec;
    /// Wrapper over a Rust-allocated `Vec<StyleTransform>`

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformVec as StyleTransformVec;
    /// Wrapper over a Rust-allocated `Stylesheet`

    #[doc(inline)]
    pub use crate::dll::AzStylesheetVec as StylesheetVec;
    /// Wrapper over a Rust-allocated `SvgColoredVertex`

    #[doc(inline)]
    pub use crate::dll::AzSvgColoredVertexVec as SvgColoredVertexVec;
    /// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`

    #[doc(inline)]
    pub use crate::dll::AzSvgMultiPolygonVec as SvgMultiPolygonVec;
    /// Wrapper over a Rust-allocated `VertexAttribute`

    #[doc(inline)]
    pub use crate::dll::AzSvgPathElementVec as SvgPathElementVec;
    /// Wrapper over a Rust-allocated `Vec<SvgPath>`

    #[doc(inline)]
    pub use crate::dll::AzSvgPathVec as SvgPathVec;
    /// Wrapper over a Rust-allocated `Vec<SvgSimpleNode>`

    #[doc(inline)]
    pub use crate::dll::AzSvgSimpleNodeVec as SvgSimpleNodeVec;
    /// Wrapper over a Rust-allocated `SvgVertex`

    #[doc(inline)]
    pub use crate::dll::AzSvgVertexVec as SvgVertexVec;
    /// Wrapper over a Rust-allocated `Vec<u16>`

    #[doc(inline)]
    pub use crate::dll::AzU16Vec as U16Vec;
    /// Wrapper over a Rust-allocated `Vec<u32>`

    #[doc(inline)]
    pub use crate::dll::AzU32Vec as U32Vec;
    /// Wrapper over a Rust-allocated `U8Vec`

    #[doc(inline)]
    pub use crate::dll::AzU8Vec as U8Vec;
    /// Wrapper over a Rust-allocated `Vec<VertexAttribute>`

    #[doc(inline)]
    pub use crate::dll::AzVertexAttributeVec as VertexAttributeVec;
    /// Wrapper over a Rust-allocated `Vec<VideoMode>`

    #[doc(inline)]
    pub use crate::dll::AzVideoModeVec as VideoModeVec;
    /// Wrapper over a Rust-allocated `VirtualKeyCode`

    #[doc(inline)]
    pub use crate::dll::AzVirtualKeyCodeVec as VirtualKeyCodeVec;
    /// Wrapper over a Rust-allocated `XWindowType`

    #[doc(inline)]
    pub use crate::dll::AzXWindowTypeVec as XWindowTypeVec;
    /// Wrapper over a Rust-allocated `Vec<XmlNode>`

    #[doc(inline)]
    pub use crate::dll::AzXmlNodeVec as XmlNodeVec;
    impl U8Vec {
        /// Creates a new, heap-allocated U8Vec by copying the memory into Rust (heap allocation)
        pub fn copy_from_bytes(ptr: *const u8, start: usize, len: usize) -> Self {
            unsafe { crate::dll::AzU8Vec_copyFromBytes(ptr, start, len) }
        }
        /// Returns the `U8Vec` as a non-owning slice, NOTE: The `U8Vec` that this slice was
        /// borrowed from MUST NOT be deleted before the `U8VecRef`
        pub fn as_ref_vec(&self) -> crate::gl::U8VecRef {
            unsafe { crate::dll::AzU8Vec_asRefVec(self) }
        }
    }

    /// `AccessibilityStateVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzAccessibilityStateVecDestructor as AccessibilityStateVecDestructor;
    /// `AccessibilityStateVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzAccessibilityStateVecDestructorType as AccessibilityStateVecDestructorType;
    /// Wrapper over a Rust-allocated `CallbackData`

    #[doc(inline)]
    pub use crate::dll::AzCallbackDataVec as CallbackDataVec;
    /// `CallbackDataVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzCallbackDataVecDestructor as CallbackDataVecDestructor;
    /// `CallbackDataVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzCallbackDataVecDestructorType as CallbackDataVecDestructorType;
    /// `CascadeInfoVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzCascadeInfoVecDestructor as CascadeInfoVecDestructor;
    /// `CascadeInfoVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzCascadeInfoVecDestructorType as CascadeInfoVecDestructorType;
    /// `CssDeclarationVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzCssDeclarationVecDestructor as CssDeclarationVecDestructor;
    /// `CssDeclarationVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzCssDeclarationVecDestructorType as CssDeclarationVecDestructorType;
    /// `CssPathSelectorVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPathSelectorVecDestructor as CssPathSelectorVecDestructor;
    /// `CssPathSelectorVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPathSelectorVecDestructorType as CssPathSelectorVecDestructorType;
    /// `CssPropertyVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPropertyVecDestructor as CssPropertyVecDestructor;
    /// `CssPropertyVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzCssPropertyVecDestructorType as CssPropertyVecDestructorType;
    /// `CssRuleBlockVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzCssRuleBlockVecDestructor as CssRuleBlockVecDestructor;
    /// `CssRuleBlockVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzCssRuleBlockVecDestructorType as CssRuleBlockVecDestructorType;
    /// Wrapper over a Rust-allocated `Vec<DebugMessage>`

    #[doc(inline)]
    pub use crate::dll::AzDebugMessageVec as DebugMessageVec;
    /// `DebugMessageVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzDebugMessageVecDestructor as DebugMessageVecDestructor;
    /// `DebugMessageVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzDebugMessageVecDestructorType as DebugMessageVecDestructorType;
    /// `DomVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzDomVecDestructor as DomVecDestructor;
    /// `DomVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzDomVecDestructorType as DomVecDestructorType;
    /// `F32VecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzF32VecDestructor as F32VecDestructor;
    /// `F32VecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzF32VecDestructorType as F32VecDestructorType;
    /// `FmtArgVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzFmtArgVecDestructor as FmtArgVecDestructor;
    /// `FmtArgVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzFmtArgVecDestructorType as FmtArgVecDestructorType;
    /// Wrapper over a Rust-allocated `GLintVec`

    #[doc(inline)]
    pub use crate::dll::AzGLintVec as GLintVec;
    /// `GLintVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzGLintVecDestructor as GLintVecDestructor;
    /// `GLintVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzGLintVecDestructorType as GLintVecDestructorType;
    /// Wrapper over a Rust-allocated `U32Vec`

    #[doc(inline)]
    pub use crate::dll::AzGLuintVec as GLuintVec;
    /// `GLuintVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzGLuintVecDestructor as GLuintVecDestructor;
    /// `GLuintVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzGLuintVecDestructorType as GLuintVecDestructorType;
    /// `IdOrClassVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzIdOrClassVecDestructor as IdOrClassVecDestructor;
    /// `IdOrClassVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzIdOrClassVecDestructorType as IdOrClassVecDestructorType;
    /// `InlineGlyphVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineGlyphVecDestructor as InlineGlyphVecDestructor;
    /// `InlineGlyphVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineGlyphVecDestructorType as InlineGlyphVecDestructorType;
    /// `InlineLineVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineLineVecDestructor as InlineLineVecDestructor;
    /// `InlineLineVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineLineVecDestructorType as InlineLineVecDestructorType;
    /// `InlineTextHitVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineTextHitVecDestructor as InlineTextHitVecDestructor;
    /// `InlineTextHitVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineTextHitVecDestructorType as InlineTextHitVecDestructorType;
    /// `InlineWordVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineWordVecDestructor as InlineWordVecDestructor;
    /// `InlineWordVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInlineWordVecDestructorType as InlineWordVecDestructorType;
    /// `InputConnectionVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInputConnectionVecDestructor as InputConnectionVecDestructor;
    /// `InputConnectionVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInputConnectionVecDestructorType as InputConnectionVecDestructorType;
    /// `InputNodeAndIndexVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInputNodeAndIndexVecDestructor as InputNodeAndIndexVecDestructor;
    /// `InputNodeAndIndexVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInputNodeAndIndexVecDestructorType as InputNodeAndIndexVecDestructorType;
    /// `InputOutputTypeIdInfoMapVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeIdInfoMapVecDestructor as InputOutputTypeIdInfoMapVecDestructor;
    /// `InputOutputTypeIdInfoMapVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeIdInfoMapVecDestructorType as InputOutputTypeIdInfoMapVecDestructorType;
    /// `InputOutputTypeIdVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeIdVecDestructor as InputOutputTypeIdVecDestructor;
    /// `InputOutputTypeIdVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzInputOutputTypeIdVecDestructorType as InputOutputTypeIdVecDestructorType;
    /// `ListViewRowVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewRowVecDestructor as ListViewRowVecDestructor;
    /// `ListViewRowVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzListViewRowVecDestructorType as ListViewRowVecDestructorType;
    /// `LogicalRectVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzLogicalRectVecDestructor as LogicalRectVecDestructor;
    /// `LogicalRectVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzLogicalRectVecDestructorType as LogicalRectVecDestructorType;
    /// `MenuItemVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzMenuItemVecDestructor as MenuItemVecDestructor;
    /// `MenuItemVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzMenuItemVecDestructorType as MenuItemVecDestructorType;
    /// `MonitorVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzMonitorVecDestructor as MonitorVecDestructor;
    /// `MonitorVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzMonitorVecDestructorType as MonitorVecDestructorType;
    /// `NodeDataInlineCssPropertyVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeDataInlineCssPropertyVecDestructor as NodeDataInlineCssPropertyVecDestructor;
    /// `NodeDataInlineCssPropertyVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeDataInlineCssPropertyVecDestructorType as NodeDataInlineCssPropertyVecDestructorType;
    /// Wrapper over a Rust-allocated `NodeDataVec`

    #[doc(inline)]
    pub use crate::dll::AzNodeDataVec as NodeDataVec;
    /// `NodeDataVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeDataVecDestructor as NodeDataVecDestructor;
    /// `NodeDataVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeDataVecDestructorType as NodeDataVecDestructorType;
    /// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`

    #[doc(inline)]
    pub use crate::dll::AzNodeHierarchyItemVec as NodeHierarchyItemVec;
    /// `NodeHierarchyItemVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeHierarchyItemVecDestructor as NodeHierarchyItemVecDestructor;
    /// `NodeHierarchyItemVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeHierarchyItemVecDestructorType as NodeHierarchyItemVecDestructorType;
    /// `NodeIdNodeMapVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeIdNodeMapVecDestructor as NodeIdNodeMapVecDestructor;
    /// `NodeIdNodeMapVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeIdNodeMapVecDestructorType as NodeIdNodeMapVecDestructorType;
    /// Wrapper over a Rust-allocated `NodeIdVec`

    #[doc(inline)]
    pub use crate::dll::AzNodeIdVec as NodeIdVec;
    /// `NodeIdVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeIdVecDestructor as NodeIdVecDestructor;
    /// `NodeIdVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeIdVecDestructorType as NodeIdVecDestructorType;
    /// `NodeTypeFieldVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeFieldVecDestructor as NodeTypeFieldVecDestructor;
    /// `NodeTypeFieldVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeFieldVecDestructorType as NodeTypeFieldVecDestructorType;
    /// `NodeTypeIdInfoMapVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeIdInfoMapVecDestructor as NodeTypeIdInfoMapVecDestructor;
    /// `NodeTypeIdInfoMapVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNodeTypeIdInfoMapVecDestructorType as NodeTypeIdInfoMapVecDestructorType;
    /// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`

    #[doc(inline)]
    pub use crate::dll::AzNormalizedLinearColorStopVec as NormalizedLinearColorStopVec;
    /// `NormalizedLinearColorStopVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNormalizedLinearColorStopVecDestructor as NormalizedLinearColorStopVecDestructor;
    /// `NormalizedLinearColorStopVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNormalizedLinearColorStopVecDestructorType as NormalizedLinearColorStopVecDestructorType;
    /// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`

    #[doc(inline)]
    pub use crate::dll::AzNormalizedRadialColorStopVec as NormalizedRadialColorStopVec;
    /// `NormalizedRadialColorStopVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzNormalizedRadialColorStopVecDestructor as NormalizedRadialColorStopVecDestructor;
    /// `NormalizedRadialColorStopVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzNormalizedRadialColorStopVecDestructorType as NormalizedRadialColorStopVecDestructorType;
    /// `OutputConnectionVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzOutputConnectionVecDestructor as OutputConnectionVecDestructor;
    /// `OutputConnectionVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzOutputConnectionVecDestructorType as OutputConnectionVecDestructorType;
    /// `OutputNodeAndIndexVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzOutputNodeAndIndexVecDestructor as OutputNodeAndIndexVecDestructor;
    /// `OutputNodeAndIndexVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzOutputNodeAndIndexVecDestructorType as OutputNodeAndIndexVecDestructorType;
    /// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`

    #[doc(inline)]
    pub use crate::dll::AzParentWithNodeDepthVec as ParentWithNodeDepthVec;
    /// `ParentWithNodeDepthVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzParentWithNodeDepthVecDestructor as ParentWithNodeDepthVecDestructor;
    /// `ParentWithNodeDepthVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzParentWithNodeDepthVecDestructorType as ParentWithNodeDepthVecDestructorType;
    /// `ScanCodeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzScanCodeVecDestructor as ScanCodeVecDestructor;
    /// `ScanCodeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzScanCodeVecDestructorType as ScanCodeVecDestructorType;
    /// Wrapper over a Rust-allocated `StringPairVec`

    #[doc(inline)]
    pub use crate::dll::AzStringPairVec as StringPairVec;
    /// `StringPairVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStringPairVecDestructor as StringPairVecDestructor;
    /// `StringPairVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStringPairVecDestructorType as StringPairVecDestructorType;
    /// Wrapper over a Rust-allocated `StringVec`

    #[doc(inline)]
    pub use crate::dll::AzStringVec as StringVec;
    /// `StringVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStringVecDestructor as StringVecDestructor;
    /// `StringVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStringVecDestructorType as StringVecDestructorType;
    /// `StyleBackgroundContentVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundContentVecDestructor as StyleBackgroundContentVecDestructor;
    /// `StyleBackgroundContentVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundContentVecDestructorType as StyleBackgroundContentVecDestructorType;
    /// `StyleBackgroundPositionVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundPositionVecDestructor as StyleBackgroundPositionVecDestructor;
    /// `StyleBackgroundPositionVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundPositionVecDestructorType as StyleBackgroundPositionVecDestructorType;
    /// `StyleBackgroundRepeatVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundRepeatVecDestructor as StyleBackgroundRepeatVecDestructor;
    /// `StyleBackgroundRepeatVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundRepeatVecDestructorType as StyleBackgroundRepeatVecDestructorType;
    /// `StyleBackgroundSizeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundSizeVecDestructor as StyleBackgroundSizeVecDestructor;
    /// `StyleBackgroundSizeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleBackgroundSizeVecDestructorType as StyleBackgroundSizeVecDestructorType;
    /// `StyleFilterVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFilterVecDestructor as StyleFilterVecDestructor;
    /// `StyleFilterVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFilterVecDestructorType as StyleFilterVecDestructorType;
    /// `StyleFontFamilyVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFontFamilyVecDestructor as StyleFontFamilyVecDestructor;
    /// `StyleFontFamilyVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleFontFamilyVecDestructorType as StyleFontFamilyVecDestructorType;
    /// `StyleTransformVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformVecDestructor as StyleTransformVecDestructor;
    /// `StyleTransformVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyleTransformVecDestructorType as StyleTransformVecDestructorType;
    /// Wrapper over a Rust-allocated `StyledNodeVec`

    #[doc(inline)]
    pub use crate::dll::AzStyledNodeVec as StyledNodeVec;
    /// `StyledNodeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStyledNodeVecDestructor as StyledNodeVecDestructor;
    /// `StyledNodeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStyledNodeVecDestructorType as StyledNodeVecDestructorType;
    /// `StylesheetVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzStylesheetVecDestructor as StylesheetVecDestructor;
    /// `StylesheetVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzStylesheetVecDestructorType as StylesheetVecDestructorType;
    /// `SvgColoredVertexVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgColoredVertexVecDestructor as SvgColoredVertexVecDestructor;
    /// `SvgColoredVertexVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgColoredVertexVecDestructorType as SvgColoredVertexVecDestructorType;
    /// `SvgMultiPolygonVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgMultiPolygonVecDestructor as SvgMultiPolygonVecDestructor;
    /// `SvgMultiPolygonVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgMultiPolygonVecDestructorType as SvgMultiPolygonVecDestructorType;
    /// `SvgPathElementVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgPathElementVecDestructor as SvgPathElementVecDestructor;
    /// `SvgPathElementVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgPathElementVecDestructorType as SvgPathElementVecDestructorType;
    /// `SvgPathVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgPathVecDestructor as SvgPathVecDestructor;
    /// `SvgPathVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgPathVecDestructorType as SvgPathVecDestructorType;
    /// `SvgSimpleNodeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgSimpleNodeVecDestructor as SvgSimpleNodeVecDestructor;
    /// `SvgSimpleNodeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgSimpleNodeVecDestructorType as SvgSimpleNodeVecDestructorType;
    /// `SvgVertexVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgVertexVecDestructor as SvgVertexVecDestructor;
    /// `SvgVertexVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgVertexVecDestructorType as SvgVertexVecDestructorType;
    /// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`

    #[doc(inline)]
    pub use crate::dll::AzTagIdToNodeIdMappingVec as TagIdToNodeIdMappingVec;
    /// `TagIdToNodeIdMappingVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzTagIdToNodeIdMappingVecDestructor as TagIdToNodeIdMappingVecDestructor;
    /// `TagIdToNodeIdMappingVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzTagIdToNodeIdMappingVecDestructorType as TagIdToNodeIdMappingVecDestructorType;
    /// `TessellatedColoredSvgNodeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedColoredSvgNodeVecDestructor as TessellatedColoredSvgNodeVecDestructor;
    /// `TessellatedColoredSvgNodeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedColoredSvgNodeVecDestructorType as TessellatedColoredSvgNodeVecDestructorType;
    /// `TessellatedSvgNodeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedSvgNodeVecDestructor as TessellatedSvgNodeVecDestructor;
    /// `TessellatedSvgNodeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzTessellatedSvgNodeVecDestructorType as TessellatedSvgNodeVecDestructorType;
    /// `U16VecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzU16VecDestructor as U16VecDestructor;
    /// `U16VecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzU16VecDestructorType as U16VecDestructorType;
    /// `U32VecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzU32VecDestructor as U32VecDestructor;
    /// `U32VecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzU32VecDestructorType as U32VecDestructorType;
    /// `U8VecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzU8VecDestructor as U8VecDestructor;
    /// `U8VecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzU8VecDestructorType as U8VecDestructorType;
    /// `VertexAttributeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzVertexAttributeVecDestructor as VertexAttributeVecDestructor;
    /// `VertexAttributeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzVertexAttributeVecDestructorType as VertexAttributeVecDestructorType;
    /// `VideoModeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzVideoModeVecDestructor as VideoModeVecDestructor;
    /// `VideoModeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzVideoModeVecDestructorType as VideoModeVecDestructorType;
    /// `VirtualKeyCodeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzVirtualKeyCodeVecDestructor as VirtualKeyCodeVecDestructor;
    /// `VirtualKeyCodeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzVirtualKeyCodeVecDestructorType as VirtualKeyCodeVecDestructorType;
    /// `XWindowTypeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzXWindowTypeVecDestructor as XWindowTypeVecDestructor;
    /// `XWindowTypeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzXWindowTypeVecDestructorType as XWindowTypeVecDestructorType;
    /// `XmlNodeVecDestructor` struct

    #[doc(inline)]
    pub use crate::dll::AzXmlNodeVecDestructor as XmlNodeVecDestructor;
    /// `XmlNodeVecDestructorType` struct

    #[doc(inline)]
    pub use crate::dll::AzXmlNodeVecDestructorType as XmlNodeVecDestructorType;
}

pub mod option {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Definition of azuls internal `Option<*>` wrappers
    use core::ffi::c_void;

    use crate::dll::*;

    macro_rules! impl_option_inner {
        ($struct_type:ident, $struct_name:ident) => {
            impl Default for $struct_name {
                fn default() -> $struct_name {
                    $struct_name::None
                }
            }

            impl $struct_name {
                pub fn as_option(&self) -> Option<&$struct_type> {
                    match self {
                        $struct_name::None => None,
                        $struct_name::Some(t) => Some(t),
                    }
                }
                pub fn replace(&mut self, value: $struct_type) -> $struct_name {
                    ::core::mem::replace(self, $struct_name::Some(value))
                }
                pub const fn is_some(&self) -> bool {
                    match self {
                        $struct_name::None => false,
                        $struct_name::Some(_) => true,
                    }
                }
                pub const fn is_none(&self) -> bool {
                    !self.is_some()
                }
                pub const fn as_ref(&self) -> Option<&$struct_type> {
                    match *self {
                        $struct_name::Some(ref x) => Some(x),
                        $struct_name::None => None,
                    }
                }
            }
        };
    }

    macro_rules! impl_option {
        ($struct_type:ident, $struct_name:ident,copy = false,clone = false,[$($derive:meta),*]) => {
            impl_option_inner!($struct_type, $struct_name);
        };
        ($struct_type:ident, $struct_name:ident,copy = false,[$($derive:meta),*]) => {
            impl_option_inner!($struct_type, $struct_name);

            impl From<$struct_name> for Option<$struct_type> {
                fn from(o: $struct_name) -> Option<$struct_type> {
                    match &o {
                        $struct_name::None => None,
                        $struct_name::Some(t) => Some(t.clone()),
                    }
                }
            }

            impl From<Option<$struct_type>> for $struct_name {
                fn from(o: Option<$struct_type>) -> $struct_name {
                    match &o {
                        None => $struct_name::None,
                        Some(t) => $struct_name::Some(t.clone()),
                    }
                }
            }

            impl $struct_name {
                pub fn into_option(self) -> Option<$struct_type> {
                    self.into()
                }
                pub fn map<U, F: FnOnce($struct_type) -> U>(self, f: F) -> Option<U> {
                    match self.into_option() {
                        None => None,
                        Some(s) => Some(f(s)),
                    }
                }

                pub fn and_then<U, F>(self, f: F) -> Option<U>
                where
                    F: FnOnce($struct_type) -> Option<U>,
                {
                    match self.into_option() {
                        None => None,
                        Some(s) => f(s),
                    }
                }
            }
        };
        ($struct_type:ident, $struct_name:ident,[$($derive:meta),*]) => {
            impl_option_inner!($struct_type, $struct_name);

            impl From<$struct_name> for Option<$struct_type> {
                fn from(o: $struct_name) -> Option<$struct_type> {
                    match o {
                        $struct_name::None => None,
                        $struct_name::Some(t) => Some(t),
                    }
                }
            }

            impl From<Option<$struct_type>> for $struct_name {
                fn from(o: Option<$struct_type>) -> $struct_name {
                    match o {
                        None => $struct_name::None,
                        Some(t) => $struct_name::Some(t),
                    }
                }
            }

            impl $struct_name {
                pub fn into_option(self) -> Option<$struct_type> {
                    self.into()
                }
                pub fn map<U, F: FnOnce($struct_type) -> U>(self, f: F) -> Option<U> {
                    match self.into_option() {
                        None => None,
                        Some(s) => Some(f(s)),
                    }
                }

                pub fn and_then<U, F>(self, f: F) -> Option<U>
                where
                    F: FnOnce($struct_type) -> Option<U>,
                {
                    match self.into_option() {
                        None => None,
                        Some(s) => f(s),
                    }
                }
            }
        };
    }

    pub type AzX11Visual = *const c_void;
    pub type AzHwndHandle = *mut c_void;

    impl_option!(i32, AzOptionI32, [Debug, Copy, Clone]);
    impl_option!(f32, AzOptionF32, [Debug, Copy, Clone]);
    impl_option!(usize, AzOptionUsize, [Debug, Copy, Clone]);
    impl_option!(u32, AzOptionChar, [Debug, Copy, Clone]);

    impl_option!(AzThreadId, AzOptionThreadId, [Debug, Copy, Clone]);
    impl_option!(AzTimerId, AzOptionTimerId, [Debug, Copy, Clone]);
    impl_option!(AzThreadSendMsg, AzOptionThreadSendMsg, [Debug, Copy, Clone]);
    impl_option!(AzLayoutRect, AzOptionLayoutRect, [Debug, Copy, Clone]);
    impl_option!(
        AzRefAny,
        AzOptionRefAny,
        copy = false,
        clone = false,
        [Debug, Clone]
    );
    impl_option!(AzLayoutPoint, AzOptionLayoutPoint, [Debug, Copy, Clone]);
    impl_option!(AzWindowTheme, AzOptionWindowTheme, [Debug, Copy, Clone]);
    impl_option!(AzNodeId, AzOptionNodeId, [Debug, Copy, Clone]);
    impl_option!(AzDomNodeId, AzOptionDomNodeId, [Debug, Copy, Clone]);
    impl_option!(AzColorU, AzOptionColorU, [Debug, Copy, Clone]);
    impl_option!(AzRawImage, AzOptionRawImage, copy = false, [Debug, Clone]);
    impl_option!(
        AzSvgDashPattern,
        AzOptionSvgDashPattern,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzWaylandTheme,
        AzOptionWaylandTheme,
        copy = false,
        [Debug, Clone]
    );
    impl_option!(
        AzTaskBarIcon,
        AzOptionTaskBarIcon,
        copy = false,
        [Debug, Clone]
    );
    impl_option!(
        AzLogicalPosition,
        AzOptionLogicalPosition,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzPhysicalPositionI32,
        AzOptionPhysicalPositionI32,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzWindowIcon,
        AzOptionWindowIcon,
        copy = false,
        [Debug, Clone]
    );
    impl_option!(AzString, AzOptionString, copy = false, [Debug, Clone]);
    impl_option!(
        AzMouseCursorType,
        AzOptionMouseCursorType,
        [Debug, Copy, Clone]
    );
    impl_option!(AzLogicalSize, AzOptionLogicalSize, [Debug, Copy, Clone]);
    impl_option!(
        AzVirtualKeyCode,
        AzOptionVirtualKeyCode,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzPercentageValue,
        AzOptionPercentageValue,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzDom,
        AzOptionDom,
        copy = false,
        clone = false,
        [Debug, Clone]
    );
    impl_option!(
        AzTexture,
        AzOptionTexture,
        copy = false,
        clone = false,
        [Debug]
    );
    impl_option!(AzImageMask, AzOptionImageMask, copy = false, [Debug, Clone]);
    impl_option!(AzTabIndex, AzOptionTabIndex, [Debug, Copy, Clone]);
    impl_option!(AzCallback, AzOptionCallback, [Debug, Copy, Clone]);
    impl_option!(AzTagId, AzOptionTagId, [Debug, Copy, Clone]);
    impl_option!(AzDuration, AzOptionDuration, [Debug, Copy, Clone]);
    impl_option!(
        AzInstant,
        AzOptionInstant,
        copy = false,
        clone = false,
        [Debug]
    ); // TODO: impl clone!
    impl_option!(
        AzU8VecRef,
        AzOptionU8VecRef,
        copy = false,
        clone = false,
        [Debug]
    );
    impl_option!(
        AzSystemClipboard,
        AzOptionSystemClipboard,
        copy = false,
        clone = false,
        [Debug]
    );
    impl_option!(
        AzFileTypeList,
        AzOptionFileTypeList,
        copy = false,
        [Debug, Clone]
    );
    impl_option!(
        AzWindowState,
        AzOptionWindowState,
        copy = false,
        [Debug, Clone]
    );
    impl_option!(
        AzKeyboardState,
        AzOptionKeyboardState,
        copy = false,
        [Debug, Clone]
    );
    impl_option!(AzMouseState, AzOptionMouseState, [Debug, Clone]);
    impl_option!(
        AzNodeGraphOnNodeAdded,
        AzOptionNodeGraphOnNodeAdded,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzNodeGraphOnNodeRemoved,
        AzOptionNodeGraphOnNodeRemoved,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzNodeGraphOnNodeDragged,
        AzOptionNodeGraphOnNodeDragged,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzNodeGraphOnNodeGraphDragged,
        AzOptionNodeGraphOnNodeGraphDragged,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzNodeGraphOnNodeConnected,
        AzOptionNodeGraphOnNodeConnected,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzNodeGraphOnNodeInputDisconnected,
        AzOptionNodeGraphOnNodeInputDisconnected,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzNodeGraphOnNodeOutputDisconnected,
        AzOptionNodeGraphOnNodeOutputDisconnected,
        [Debug, Copy, Clone]
    );
    impl_option!(
        AzNodeGraphOnNodeFieldEdited,
        AzOptionNodeGraphOnNodeFieldEdited,
        [Debug, Copy, Clone]
    );
    impl_option!(AzGl, AzOptionGl, copy = false, [Debug, Clone]);
    impl_option!(
        AzPixelValueNoPercent,
        AzOptionPixelValueNoPercent,
        copy = false,
        [Debug, Copy, Clone]
    );
    impl_option!(AzSvgPoint, AzOptionSvgPoint, [Debug, Copy, Clone]);
    impl_option!(
        AzStyleTextAlign,
        AzOptionStyleTextAlign,
        [Debug, Copy, Clone]
    );
    /// `OptionAngleValue` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionAngleValue as OptionAngleValue;
    /// `OptionButtonOnClick` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionButtonOnClick as OptionButtonOnClick;
    /// `OptionCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionCallback as OptionCallback;
    /// Option<char> but the char is a u32, for C FFI stability reasons

    #[doc(inline)]
    pub use crate::dll::AzOptionChar as OptionChar;
    /// `OptionCheckBoxOnToggle` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionCheckBoxOnToggle as OptionCheckBoxOnToggle;
    /// `OptionColorInputOnValueChange` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionColorInputOnValueChange as OptionColorInputOnValueChange;
    /// `OptionColorU` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionColorU as OptionColorU;
    /// `OptionCssProperty` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionCssProperty as OptionCssProperty;
    /// `OptionDom` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionDom as OptionDom;
    /// `OptionDomNodeId` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionDomNodeId as OptionDomNodeId;
    /// `OptionDropDownOnChoiceChange` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionDropDownOnChoiceChange as OptionDropDownOnChoiceChange;
    /// `OptionDuration` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionDuration as OptionDuration;
    /// `OptionF32` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionF32 as OptionF32;
    /// `OptionFile` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionFile as OptionFile;
    /// `OptionFileInputOnPathChange` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionFileInputOnPathChange as OptionFileInputOnPathChange;
    /// `OptionFileTypeList` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionFileTypeList as OptionFileTypeList;
    /// `OptionFontRef` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionFontRef as OptionFontRef;
    /// `OptionGl` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionGl as OptionGl;
    /// `OptionHwndHandle` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionHwndHandle as OptionHwndHandle;
    /// `OptionI16` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionI16 as OptionI16;
    /// `OptionI32` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionI32 as OptionI32;
    /// `OptionImageMask` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionImageMask as OptionImageMask;
    /// `OptionImageRef` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionImageRef as OptionImageRef;
    /// `OptionInlineText` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionInlineText as OptionInlineText;
    /// `OptionInstant` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionInstant as OptionInstant;
    /// `OptionKeyboardState` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionKeyboardState as OptionKeyboardState;
    /// `OptionLayoutPoint` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionLayoutPoint as OptionLayoutPoint;
    /// `OptionLayoutRect` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionLayoutRect as OptionLayoutRect;
    /// `OptionLayoutSize` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionLayoutSize as OptionLayoutSize;
    /// `OptionListViewOnColumnClick` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionListViewOnColumnClick as OptionListViewOnColumnClick;
    /// `OptionListViewOnLazyLoadScroll` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionListViewOnLazyLoadScroll as OptionListViewOnLazyLoadScroll;
    /// `OptionListViewOnRowClick` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionListViewOnRowClick as OptionListViewOnRowClick;
    /// `OptionLogicalPosition` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionLogicalPosition as OptionLogicalPosition;
    /// `OptionLogicalSize` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionLogicalSize as OptionLogicalSize;
    /// `OptionMenu` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionMenu as OptionMenu;
    /// `OptionMenuCallback` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionMenuCallback as OptionMenuCallback;
    /// `OptionMenuItemIcon` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionMenuItemIcon as OptionMenuItemIcon;
    /// `OptionMouseCursorType` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionMouseCursorType as OptionMouseCursorType;
    /// `OptionMouseState` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionMouseState as OptionMouseState;
    /// `OptionNodeGraphOnNodeAdded` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeAdded as OptionNodeGraphOnNodeAdded;
    /// `OptionNodeGraphOnNodeConnected` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeConnected as OptionNodeGraphOnNodeConnected;
    /// `OptionNodeGraphOnNodeDragged` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeDragged as OptionNodeGraphOnNodeDragged;
    /// `OptionNodeGraphOnNodeFieldEdited` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeFieldEdited as OptionNodeGraphOnNodeFieldEdited;
    /// `OptionNodeGraphOnNodeGraphDragged` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeGraphDragged as OptionNodeGraphOnNodeGraphDragged;
    /// `OptionNodeGraphOnNodeInputDisconnected` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeInputDisconnected as OptionNodeGraphOnNodeInputDisconnected;
    /// `OptionNodeGraphOnNodeOutputDisconnected` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeOutputDisconnected as OptionNodeGraphOnNodeOutputDisconnected;
    /// `OptionNodeGraphOnNodeRemoved` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeGraphOnNodeRemoved as OptionNodeGraphOnNodeRemoved;
    /// `OptionNodeId` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNodeId as OptionNodeId;
    /// `OptionNumberInputOnFocusLost` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNumberInputOnFocusLost as OptionNumberInputOnFocusLost;
    /// `OptionNumberInputOnValueChange` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionNumberInputOnValueChange as OptionNumberInputOnValueChange;
    /// `OptionPercentageValue` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionPercentageValue as OptionPercentageValue;
    /// `OptionPhysicalPositionI32` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionPhysicalPositionI32 as OptionPhysicalPositionI32;
    /// `OptionPixelValueNoPercent` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionPixelValueNoPercent as OptionPixelValueNoPercent;
    /// `OptionPositionInfo` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionPositionInfo as OptionPositionInfo;
    /// `OptionRawImage` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionRawImage as OptionRawImage;
    /// `OptionRefAny` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionRefAny as OptionRefAny;
    /// `OptionRendererOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionRendererOptions as OptionRendererOptions;
    /// `OptionResolvedTextLayoutOptions` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionResolvedTextLayoutOptions as OptionResolvedTextLayoutOptions;
    /// `OptionString` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionString as OptionString;
    /// `OptionStringVec` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionStringVec as OptionStringVec;
    /// `OptionStyleTextAlign` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionStyleTextAlign as OptionStyleTextAlign;
    /// `OptionSvgDashPattern` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionSvgDashPattern as OptionSvgDashPattern;
    /// `OptionSvgPoint` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionSvgPoint as OptionSvgPoint;
    /// `OptionSystemClipboard` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionSystemClipboard as OptionSystemClipboard;
    /// `OptionTabIndex` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTabIndex as OptionTabIndex;
    /// `OptionTabOnClick` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTabOnClick as OptionTabOnClick;
    /// `OptionTagId` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTagId as OptionTagId;
    /// `OptionTaskBarIcon` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTaskBarIcon as OptionTaskBarIcon;
    /// `OptionTextInputOnFocusLost` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTextInputOnFocusLost as OptionTextInputOnFocusLost;
    /// `OptionTextInputOnTextInput` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTextInputOnTextInput as OptionTextInputOnTextInput;
    /// `OptionTextInputOnVirtualKeyDown` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTextInputOnVirtualKeyDown as OptionTextInputOnVirtualKeyDown;
    /// `OptionTextInputSelection` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTextInputSelection as OptionTextInputSelection;
    /// `OptionTexture` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTexture as OptionTexture;
    /// `OptionThreadId` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionThreadId as OptionThreadId;
    /// `OptionThreadReceiveMsg` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionThreadReceiveMsg as OptionThreadReceiveMsg;
    /// `OptionThreadSendMsg` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionThreadSendMsg as OptionThreadSendMsg;
    /// `OptionTimerId` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionTimerId as OptionTimerId;
    /// `OptionU16` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionU16 as OptionU16;
    /// `OptionU32` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionU32 as OptionU32;
    /// `OptionU8Vec` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionU8Vec as OptionU8Vec;
    /// `OptionU8VecRef` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionU8VecRef as OptionU8VecRef;
    /// `OptionUsize` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionUsize as OptionUsize;
    /// `OptionVirtualKeyCode` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionVirtualKeyCode as OptionVirtualKeyCode;
    /// `OptionVirtualKeyCodeCombo` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionVirtualKeyCodeCombo as OptionVirtualKeyCodeCombo;
    /// `OptionWaylandTheme` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionWaylandTheme as OptionWaylandTheme;
    /// `OptionWindowIcon` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionWindowIcon as OptionWindowIcon;
    /// `OptionWindowState` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionWindowState as OptionWindowState;
    /// `OptionWindowTheme` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionWindowTheme as OptionWindowTheme;
    /// `OptionX11Visual` struct

    #[doc(inline)]
    pub use crate::dll::AzOptionX11Visual as OptionX11Visual;
}

pub mod error {
    #![allow(dead_code, unused_imports, unused_unsafe)]
    //! Definition of error and `Result<T, E>`  types
    use core::ffi::c_void;

    /// `DuplicatedAttributeError` struct

    #[doc(inline)]
    pub use crate::dll::AzDuplicatedAttributeError as DuplicatedAttributeError;
    /// `DuplicatedNamespaceError` struct

    #[doc(inline)]
    pub use crate::dll::AzDuplicatedNamespaceError as DuplicatedNamespaceError;
    /// `InvalidCharError` struct

    #[doc(inline)]
    pub use crate::dll::AzInvalidCharError as InvalidCharError;
    /// `InvalidCharMultipleError` struct

    #[doc(inline)]
    pub use crate::dll::AzInvalidCharMultipleError as InvalidCharMultipleError;
    /// `InvalidQuoteError` struct

    #[doc(inline)]
    pub use crate::dll::AzInvalidQuoteError as InvalidQuoteError;
    /// `InvalidSpaceError` struct

    #[doc(inline)]
    pub use crate::dll::AzInvalidSpaceError as InvalidSpaceError;
    /// `InvalidStringError` struct

    #[doc(inline)]
    pub use crate::dll::AzInvalidStringError as InvalidStringError;
    /// `NonXmlCharError` struct

    #[doc(inline)]
    pub use crate::dll::AzNonXmlCharError as NonXmlCharError;
    /// `ResultRawImageDecodeImageError` struct

    #[doc(inline)]
    pub use crate::dll::AzResultRawImageDecodeImageError as ResultRawImageDecodeImageError;
    /// `ResultSvgSvgParseError` struct

    #[doc(inline)]
    pub use crate::dll::AzResultSvgSvgParseError as ResultSvgSvgParseError;
    /// `ResultSvgXmlNodeSvgParseError` struct

    #[doc(inline)]
    pub use crate::dll::AzResultSvgXmlNodeSvgParseError as ResultSvgXmlNodeSvgParseError;
    /// `ResultU8VecEncodeImageError` struct

    #[doc(inline)]
    pub use crate::dll::AzResultU8VecEncodeImageError as ResultU8VecEncodeImageError;
    /// `ResultXmlXmlError` struct

    #[doc(inline)]
    pub use crate::dll::AzResultXmlXmlError as ResultXmlXmlError;
    /// `SvgParseError` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgParseError as SvgParseError;
    /// `SvgParseErrorPosition` struct

    #[doc(inline)]
    pub use crate::dll::AzSvgParseErrorPosition as SvgParseErrorPosition;
    /// `UnexpectedCloseTagError` struct

    #[doc(inline)]
    pub use crate::dll::AzUnexpectedCloseTagError as UnexpectedCloseTagError;
    /// `UnknownEntityReferenceError` struct

    #[doc(inline)]
    pub use crate::dll::AzUnknownEntityReferenceError as UnknownEntityReferenceError;
    /// `UnknownNamespaceError` struct

    #[doc(inline)]
    pub use crate::dll::AzUnknownNamespaceError as UnknownNamespaceError;
    /// `XmlError` struct

    #[doc(inline)]
    pub use crate::dll::AzXmlError as XmlError;
    /// `XmlParseError` struct

    #[doc(inline)]
    pub use crate::dll::AzXmlParseError as XmlParseError;
    /// `XmlStreamError` struct

    #[doc(inline)]
    pub use crate::dll::AzXmlStreamError as XmlStreamError;
    /// `XmlTextError` struct

    #[doc(inline)]
    pub use crate::dll::AzXmlTextError as XmlTextError;
    use crate::dll::*;
}
