#![allow(non_snake_case)]

#[macro_use]
extern crate alloc;
extern crate azul_core;

#[cfg(not(target_arch = "wasm32"))]
pub mod desktop;
#[cfg(target_arch = "wasm32")]
pub mod web;

pub mod extra;
pub mod str;

pub mod azul_impl {
    #[cfg(target_arch = "wasm32")]
    pub use self::web::*;
    #[cfg(not(target_arch = "wasm32"))]
    pub use super::desktop::*;
}

use core::{ffi::c_void, mem};

use pyo3::{exceptions::PyException, prelude::*, types::*, PyObjectProtocol};
type GLuint = u32;
type AzGLuint = GLuint;
type GLint = i32;
type AzGLint = GLint;
type GLint64 = i64;
type AzGLint64 = GLint64;
type GLuint64 = u64;
type AzGLuint64 = GLuint64;
type GLenum = u32;
type AzGLenum = GLenum;
type GLintptr = isize;
type AzGLintptr = GLintptr;
type GLboolean = u8;
type AzGLboolean = GLboolean;
type GLsizeiptr = isize;
type AzGLsizeiptr = GLsizeiptr;
type GLvoid = c_void;
type AzGLvoid = GLvoid;
type GLbitfield = u32;
type AzGLbitfield = GLbitfield;
type GLsizei = i32;
type AzGLsizei = GLsizei;
type GLclampf = f32;
type AzGLclampf = GLclampf;
type GLfloat = f32;
type AzGLfloat = GLfloat;
type AzF32 = f32;
type AzU16 = u16;
type AzU32 = u32;
type AzScanCode = u32;

use pyo3::{PyGCProtocol, PyTraverseError, PyVisit};

fn pystring_to_azstring(input: &String) -> AzString {
    input.clone().into()
}
fn az_string_to_py_string(input: AzString) -> String {
    input.into()
}
fn pystring_to_refstr(input: &str) -> AzRefstr {
    AzRefstr {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn az_vecu8_to_py_vecu8(input: AzU8Vec) -> Vec<u8> {
    let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
    input.into_library_owned_vec()
}
fn vec_string_to_vec_refstr(input: &Vec<&str>) -> Vec<AzRefstr> {
    input.iter().map(|i| pystring_to_refstr(i)).collect()
}
fn pybytesrefmut_to_vecu8refmut(input: &mut Vec<u8>) -> AzU8VecRefMut {
    AzU8VecRefMut {
        ptr: input.as_mut_ptr(),
        len: input.len(),
    }
}
fn pybytesref_to_vecu8_ref(input: &Vec<u8>) -> AzU8VecRef {
    AzU8VecRef {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn pylist_f32_to_rust(input: &Vec<f32>) -> AzF32VecRef {
    AzF32VecRef {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn pylist_u32_to_rust(input: &Vec<u32>) -> AzGLuintVecRef {
    AzGLuintVecRef {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn pylist_i32_to_rust(input: &mut Vec<i32>) -> AzGLintVecRefMut {
    AzGLintVecRefMut {
        ptr: input.as_mut_ptr(),
        len: input.len(),
    }
}
fn pylist_i64_to_rust(input: &mut Vec<i64>) -> AzGLint64VecRefMut {
    AzGLint64VecRefMut {
        ptr: input.as_mut_ptr(),
        len: input.len(),
    }
}
fn pylist_bool_to_rust(input: &mut Vec<u8>) -> AzGLbooleanVecRefMut {
    AzGLbooleanVecRefMut {
        ptr: input.as_mut_ptr(),
        len: input.len(),
    }
}
fn pylist_glfoat_to_rust(input: &mut Vec<f32>) -> AzGLfloatVecRefMut {
    AzGLfloatVecRefMut {
        ptr: input.as_mut_ptr(),
        len: input.len(),
    }
}
fn pylist_str_to_rust(input: &Vec<AzRefstr>) -> AzRefstrVecRef {
    AzRefstrVecRef {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}
fn pylist_tessellated_svg_node(input: &Vec<AzTessellatedSvgNode>) -> AzTessellatedSvgNodeVecRef {
    AzTessellatedSvgNodeVecRef {
        ptr: input.as_ptr(),
        len: input.len(),
    }
}

impl From<String> for AzString {
    fn from(s: String) -> AzString {
        Self {
            vec: s.into_bytes().into(),
        }
    }
}

impl From<AzString> for String {
    fn from(s: AzString) -> String {
        let s: azul_impl::css::AzString = unsafe { mem::transmute(s) };
        s.into_library_owned_string()
    }
}

// AzU8Vec
impl From<AzU8Vec> for Vec<u8> {
    fn from(input: AzU8Vec) -> Vec<u8> {
        let input: azul_impl::css::U8Vec = unsafe { mem::transmute(input) };
        input.into_library_owned_vec()
    }
}

impl From<Vec<u8>> for AzU8Vec {
    fn from(input: Vec<u8>) -> AzU8Vec {
        let ptr = input.as_ptr();
        let len = input.len();
        let cap = input.capacity();

        let _ = ::core::mem::ManuallyDrop::new(input);

        Self {
            ptr,
            len,
            cap,
            destructor: AzU8VecDestructorEnumWrapper::DefaultRust(),
        }
    }
}

// manually implement App::new, WindowState::new,
// WindowCreateOptions::new and LayoutCallback::new

#[pyproto]
impl PyGCProtocol for AzApp {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return Ok(()),
        };

        let data_ref = match app_lock.data.downcast_ref::<AppDataTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data_ref._py_app_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };

        // NOTE: should not block - this should only succeed
        // AFTER the App has finished executing
        let mut app_lock = match data.ptr.try_lock().ok() {
            Some(s) => s,
            None => return,
        };

        let mut data = match app_lock.data.downcast_mut::<AppDataTy>() {
            Some(s) => s,
            None => return,
        };

        // Clear reference, this decrements Python ref counter.
        data._py_app_data = None;
    }
}

#[repr(C)]
pub struct AppDataTy {
    _py_app_data: Option<PyObject>,
}

#[repr(C)]
pub struct LayoutCallbackTy {
    // acual callable object from python
    _py_layout_callback: Option<PyObject>,
}

extern "C" fn invoke_py_marshaled_layout_callback(
    marshal_data: &mut AzRefAny,
    app_data: &mut AzRefAny,
    info: AzLayoutCallbackInfo,
) -> AzStyledDom {
    let mut marshal_data: &mut azul_impl::callbacks::RefAny =
        unsafe { mem::transmute(marshal_data) };
    let mut app_data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(app_data) };

    let mut app_data_downcast = match app_data.downcast_mut::<AppDataTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut app_data_downcast = match app_data_downcast._py_app_data.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match marshal_data.downcast_mut::<LayoutCallbackTy>() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    let mut pyfunction = match pyfunction._py_layout_callback.as_mut() {
        Some(s) => s,
        None => return AzStyledDom::default(),
    };

    // call layout callback into python
    let s: AzStyledDom = Python::with_gil(|py| {
        match pyfunction.call1(py.clone(), (app_data_downcast.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzStyledDom>() {
                Ok(o) => o.clone(),
                Err(e) => {
                    #[cfg(feature = "logging")]
                    {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!(
                            "ERROR: LayoutCallback returned object of type {}, expected \
                             azul.dom.StyledDom",
                            type_name
                        );
                    }
                    AzStyledDom::default()
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")]
                {
                    log::error!("Exception caught when invoking LayoutCallback: {}", e);
                }
                AzStyledDom::default()
            }
        }
    });

    s
}

#[pyproto]
impl PyGCProtocol for AzMarshaledLayoutCallback {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.marshal_data.clone();

        let data = match refany.downcast_ref::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_layout_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::callbacks::MarshaledLayoutCallback =
            unsafe { mem::transmute(self) };

        let mut data = match data.marshal_data.downcast_mut::<LayoutCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_layout_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_layout_callback = None;
        }
    }
}

#[repr(C)]
pub struct IFrameCallbackTy {
    _py_iframe_data: Option<PyObject>,
    _py_iframe_callback: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzIFrameNode {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_iframe_data.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_iframe_callback.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::dom::IFrameNode = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<IFrameCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_iframe_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_data = None;
        }

        if data._py_iframe_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_iframe_callback = None;
        }
    }
}

extern "C" fn invoke_python_iframe(
    data: &mut azul_impl::callbacks::RefAny,
    info: azul_impl::callbacks::IFrameCallbackInfo,
) -> azul_impl::callbacks::IFrameCallbackReturn {
    let default = azul_impl::callbacks::IFrameCallbackReturn {
        dom: azul_impl::styled_dom::StyledDom::default(),
        scroll_size: azul_core::geom::LogicalSize::new(0.0, 0.0),
        scroll_offset: azul_core::geom::LogicalPosition::new(0.0, 0.0),
        virtual_scroll_size: azul_core::geom::LogicalSize::new(0.0, 0.0),
        virtual_scroll_offset: azul_core::geom::LogicalPosition::new(0.0, 0.0),
    };

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut iframe_cb = match data.downcast_mut::<IFrameCallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut iframe_cb = &mut *iframe_cb;

    let mut py_data = match iframe_cb._py_iframe_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match iframe_cb._py_iframe_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call iframe callback into python
    let s: azul_impl::callbacks::IFrameCallbackReturn = Python::with_gil(|py| {
        let info: AzIFrameCallbackInfo = unsafe { mem::transmute(info) };
        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzIFrameCallbackReturn>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")]
                    {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!(
                            "ERROR: LayoutCallback returned object of type {}, expected \
                             azul.callbacks.AzIFrameCallbackReturn",
                            type_name
                        );
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")]
                {
                    log::error!("Exception caught when invoking IFrameCallback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct CallbackTy {
    _py_callback: Option<PyObject>,
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzCallbackData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<CallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::dom::CallbackData = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<CallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_callback = None;
        }

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}

extern "C" fn invoke_python_callback(
    data: &mut azul_impl::callbacks::RefAny,
    info: azul_impl::callbacks::CallbackInfo,
) -> azul_impl::callbacks::Update {
    let default: azul_impl::callbacks::Update = azul_impl::callbacks::Update::DoNothing;

    let data: &mut azul_impl::callbacks::RefAny = unsafe { mem::transmute(data) };

    let mut cb = match data.downcast_mut::<CallbackTy>() {
        Some(s) => s,
        None => return default,
    };

    let mut cb = &mut *cb;

    let mut py_data = match cb._py_data.as_mut() {
        Some(s) => s,
        None => return default,
    };

    let mut py_function = match cb._py_callback.as_mut() {
        Some(s) => s,
        None => return default,
    };

    // call callback into python
    let s: azul_impl::callbacks::Update = Python::with_gil(|py| {
        let info: AzCallbackInfo = unsafe { mem::transmute(info) };

        match py_function.call1(py.clone(), (py_data.clone_ref(py.clone()), info)) {
            Ok(o) => match o.as_ref(py).extract::<AzUpdateEnumWrapper>() {
                Ok(o) => unsafe { mem::transmute(o.clone()) },
                Err(e) => {
                    #[cfg(feature = "logging")]
                    {
                        let cb_any = o.as_ref(py);
                        let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                        log::error!(
                            "ERROR: Callback returned object of type {}, expected \
                             azul.callbacks.Update",
                            type_name
                        );
                    }
                    default
                }
            },
            Err(e) => {
                #[cfg(feature = "logging")]
                {
                    log::error!("Exception caught when invoking Callback: {}", e);
                }
                default
            }
        }
    });

    s
}

#[repr(C)]
pub struct TimerCallbackTy {
    _py_timer_callback: Option<PyObject>,
    _py_timer_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzTimer {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::task::Timer = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let mut refany = data.data.clone();

        let data = match refany.downcast_ref::<TimerCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_timer_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_timer_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::task::Timer = unsafe { mem::transmute(self) };

        let mut data = match data.data.downcast_mut::<TimerCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_timer_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_callback = None;
        }

        if data._py_timer_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_timer_data = None;
        }
    }
}

#[repr(C)]
pub struct ImageCallbackTy {
    _py_image_callback: Option<PyObject>,
    _py_image_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzImageRef {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback() {
            Some(s) => s,
            None => return Ok(()),
        };

        // temporary clone since we can't borrow mutable here
        let mut refany = image_callback.data.clone();

        let data = match refany.downcast_ref::<ImageCallbackTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_image_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_image_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::resources::ImageRef = unsafe { mem::transmute(self) };

        let image_callback = match data.get_image_callback_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match image_callback.data.downcast_mut::<ImageCallbackTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_image_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_callback = None;
        }

        if data._py_image_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_image_data = None;
        }
    }
}

#[repr(C)]
pub struct ThreadWriteBackCallbackTy {
    _py_thread_callback: Option<PyObject>,
    _py_thread_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzThread {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return Ok(()),
        };

        let mut data = match thread_inner
            .writeback_data
            .downcast_mut::<ThreadWriteBackCallbackTy>()
        {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_thread_callback.as_ref() {
            visit.call(obj)?;
        }

        if let Some(obj) = data._py_thread_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::task::Thread = unsafe { mem::transmute(self) };

        let mut thread_inner = match data.ptr.try_lock().ok() {
            Some(o) => o,
            None => return,
        };

        let mut data = match thread_inner
            .writeback_data
            .downcast_mut::<ThreadWriteBackCallbackTy>()
        {
            Some(s) => s,
            None => return,
        };

        if data._py_thread_callback.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_callback = None;
        }

        if data._py_thread_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_thread_data = None;
        }
    }
}

#[repr(C)]
pub struct DatasetTy {
    _py_data: Option<PyObject>,
}

#[pyproto]
impl PyGCProtocol for AzNodeData {
    fn __traverse__(&self, visit: PyVisit) -> Result<(), PyTraverseError> {
        let data: &azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        // temporary clone since we can't borrow mutable here
        let dataset = match data.get_dataset().as_ref() {
            Some(s) => s,
            None => return Ok(()),
        };

        let mut refany = dataset.clone();

        let data = match refany.downcast_ref::<DatasetTy>() {
            Some(s) => s,
            None => return Ok(()),
        };

        if let Some(obj) = data._py_data.as_ref() {
            visit.call(obj)?;
        }

        Ok(())
    }

    fn __clear__(&mut self) {
        let mut data: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };

        let dataset = match data.get_dataset_mut().as_mut() {
            Some(s) => s,
            None => return,
        };

        let mut data = match dataset.downcast_mut::<DatasetTy>() {
            Some(s) => s,
            None => return,
        };

        if data._py_data.as_mut().is_some() {
            // Clear reference, this decrements Python ref counter.
            data._py_data = None;
        }
    }
}
/// Main application class
#[repr(C)]
pub struct AzApp {
    pub ptr: *const c_void,
    pub run_destructor: bool,
}

/// Configuration to set which messages should be logged.
#[repr(C)]
pub enum AzAppLogLevel {
    Off,
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

/// Version of the layout solver to use - future binary versions of azul may have more fields here,
/// necessary so that old compiled applications don't break with newer releases of azul. Newer
/// layout versions are opt-in only.
#[repr(C)]
pub enum AzLayoutSolver {
    Default,
}

/// Whether the renderer has VSync enabled
#[repr(C)]
pub enum AzVsync {
    Enabled,
    Disabled,
    DontCare,
}

/// Does the renderer render in SRGB color space? By default, azul tries to set it to `Enabled` and
/// falls back to `Disabled` if the OpenGL context can't be initialized properly
#[repr(C)]
pub enum AzSrgb {
    Enabled,
    Disabled,
    DontCare,
}

/// Does the renderer render using hardware acceleration? By default, azul tries to set it to
/// `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
#[repr(C)]
pub enum AzHwAcceleration {
    Enabled,
    Disabled,
    DontCare,
}

/// Offset in physical pixels (integer units)
#[repr(C)]
pub struct AzLayoutPoint {
    pub x: isize,
    pub y: isize,
}

/// Size in physical pixels (integer units)
#[repr(C)]
pub struct AzLayoutSize {
    pub width: isize,
    pub height: isize,
}

/// Re-export of rust-allocated (stack based) `IOSHandle` struct
#[repr(C)]
pub struct AzIOSHandle {
    pub ui_window: *mut c_void,
    pub ui_view: *mut c_void,
    pub ui_view_controller: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `MacOSHandle` struct
#[repr(C)]
pub struct AzMacOSHandle {
    pub ns_window: *mut c_void,
    pub ns_view: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `XlibHandle` struct
#[repr(C)]
pub struct AzXlibHandle {
    pub window: u64,
    pub display: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `XcbHandle` struct
#[repr(C)]
pub struct AzXcbHandle {
    pub window: u32,
    pub connection: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `WaylandHandle` struct
#[repr(C)]
pub struct AzWaylandHandle {
    pub surface: *mut c_void,
    pub display: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `WindowsHandle` struct
#[repr(C)]
pub struct AzWindowsHandle {
    pub hwnd: *mut c_void,
    pub hinstance: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `WebHandle` struct
#[repr(C)]
pub struct AzWebHandle {
    pub id: u32,
}

/// Re-export of rust-allocated (stack based) `AndroidHandle` struct
#[repr(C)]
pub struct AzAndroidHandle {
    pub a_native_window: *mut c_void,
}

/// X11 window hint: Type of window
#[repr(C)]
pub enum AzXWindowType {
    Desktop,
    Dock,
    Toolbar,
    Menu,
    Utility,
    Splash,
    Dialog,
    DropdownMenu,
    PopupMenu,
    Tooltip,
    Notification,
    Combo,
    Dnd,
    Normal,
}

/// Same as `LayoutPoint`, but uses `i32` instead of `isize`
#[repr(C)]
pub struct AzPhysicalPositionI32 {
    pub x: i32,
    pub y: i32,
}

/// Same as `LayoutPoint`, but uses `u32` instead of `isize`
#[repr(C)]
pub struct AzPhysicalSizeU32 {
    pub width: u32,
    pub height: u32,
}

/// Logical position (can differ based on HiDPI settings). Usually this is what you'd want for
/// hit-testing and positioning elements.
#[repr(C)]
pub struct AzLogicalPosition {
    pub x: f32,
    pub y: f32,
}

/// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units
#[repr(C)]
pub struct AzLogicalSize {
    pub width: f32,
    pub height: f32,
}

/// Unique hash of a window icon, so that azul does not have to compare the actual bytes to see
/// wether the window icon has changed.
#[repr(C)]
pub struct AzIconKey {
    pub id: usize,
}

/// Symbolic name for a keyboard key, does **not** take the keyboard locale into account
#[repr(C)]
pub enum AzVirtualKeyCode {
    Key1,
    Key2,
    Key3,
    Key4,
    Key5,
    Key6,
    Key7,
    Key8,
    Key9,
    Key0,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    Escape,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    F21,
    F22,
    F23,
    F24,
    Snapshot,
    Scroll,
    Pause,
    Insert,
    Home,
    Delete,
    End,
    PageDown,
    PageUp,
    Left,
    Up,
    Right,
    Down,
    Back,
    Return,
    Space,
    Compose,
    Caret,
    Numlock,
    Numpad0,
    Numpad1,
    Numpad2,
    Numpad3,
    Numpad4,
    Numpad5,
    Numpad6,
    Numpad7,
    Numpad8,
    Numpad9,
    NumpadAdd,
    NumpadDivide,
    NumpadDecimal,
    NumpadComma,
    NumpadEnter,
    NumpadEquals,
    NumpadMultiply,
    NumpadSubtract,
    AbntC1,
    AbntC2,
    Apostrophe,
    Apps,
    Asterisk,
    At,
    Ax,
    Backslash,
    Calculator,
    Capital,
    Colon,
    Comma,
    Convert,
    Equals,
    Grave,
    Kana,
    Kanji,
    LAlt,
    LBracket,
    LControl,
    LShift,
    LWin,
    Mail,
    MediaSelect,
    MediaStop,
    Minus,
    Mute,
    MyComputer,
    NavigateForward,
    NavigateBackward,
    NextTrack,
    NoConvert,
    OEM102,
    Period,
    PlayPause,
    Plus,
    Power,
    PrevTrack,
    RAlt,
    RBracket,
    RControl,
    RShift,
    RWin,
    Semicolon,
    Slash,
    Sleep,
    Stop,
    Sysrq,
    Tab,
    Underline,
    Unlabeled,
    VolumeDown,
    VolumeUp,
    Wake,
    WebBack,
    WebFavorites,
    WebForward,
    WebHome,
    WebRefresh,
    WebSearch,
    WebStop,
    Yen,
    Copy,
    Paste,
    Cut,
}

/// State of the window frame (minimized, maximized, fullscreen or normal window)
#[repr(C)]
pub enum AzWindowFrame {
    Normal,
    Minimized,
    Maximized,
    Fullscreen,
}

/// Debugging information, will be rendered as an overlay on top of the UI
#[repr(C)]
pub struct AzDebugState {
    pub profiler_dbg: bool,
    pub render_target_dbg: bool,
    pub texture_cache_dbg: bool,
    pub gpu_time_queries: bool,
    pub gpu_sample_queries: bool,
    pub disable_batching: bool,
    pub epochs: bool,
    pub echo_driver_messages: bool,
    pub show_overdraw: bool,
    pub gpu_cache_dbg: bool,
    pub texture_cache_dbg_clear_evicted: bool,
    pub picture_caching_dbg: bool,
    pub primitive_dbg: bool,
    pub zoom_dbg: bool,
    pub small_screen: bool,
    pub disable_opaque_pass: bool,
    pub disable_alpha_pass: bool,
    pub disable_clip_masks: bool,
    pub disable_text_prims: bool,
    pub disable_gradient_prims: bool,
    pub obscure_images: bool,
    pub glyph_flashing: bool,
    pub smart_profiler: bool,
    pub invalidation_dbg: bool,
    pub tile_cache_logging_dbg: bool,
    pub profiler_capture: bool,
    pub force_picture_invalidation: bool,
}

/// Current icon of the mouse cursor
#[repr(C)]
pub enum AzMouseCursorType {
    Default,
    Crosshair,
    Hand,
    Arrow,
    Move,
    Text,
    Wait,
    Help,
    Progress,
    NotAllowed,
    ContextMenu,
    Cell,
    VerticalText,
    Alias,
    Copy,
    NoDrop,
    Grab,
    Grabbing,
    AllScroll,
    ZoomIn,
    ZoomOut,
    EResize,
    NResize,
    NeResize,
    NwResize,
    SResize,
    SeResize,
    SwResize,
    WResize,
    EwResize,
    NsResize,
    NeswResize,
    NwseResize,
    ColResize,
    RowResize,
}

/// Renderer type of the current windows OpenGL context
#[repr(C)]
pub enum AzRendererType {
    Hardware,
    Software,
}

/// Re-export of rust-allocated (stack based) `MacWindowOptions` struct
#[repr(C)]
pub struct AzMacWindowOptions {
    pub _reserved: u8,
}

/// Re-export of rust-allocated (stack based) `WasmWindowOptions` struct
#[repr(C)]
pub struct AzWasmWindowOptions {
    pub _reserved: u8,
}

/// Re-export of rust-allocated (stack based) `FullScreenMode` struct
#[repr(C)]
pub enum AzFullScreenMode {
    SlowFullScreen,
    FastFullScreen,
    SlowWindowed,
    FastWindowed,
}

/// Window theme, set by the operating system or `WindowCreateOptions.theme` on startup
#[repr(C)]
pub enum AzWindowTheme {
    DarkMode,
    LightMode,
}

/// Current state of touch devices / touch inputs
#[repr(C)]
pub struct AzTouchState {
    pub unused: u8,
}

/// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`
#[repr(C)]
pub struct AzMarshaledLayoutCallbackInner {
    pub cb: AzMarshaledLayoutCallbackType,
}

/// `AzMarshaledLayoutCallbackType` struct
pub type AzMarshaledLayoutCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzRefAny, AzLayoutCallbackInfo) -> AzStyledDom;

/// C-ABI stable wrapper over a `LayoutCallbackType`
#[repr(C)]
pub struct AzLayoutCallbackInner {
    pub cb: AzLayoutCallbackType,
}

/// `AzLayoutCallbackType` struct
pub type AzLayoutCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzLayoutCallbackInfo) -> AzStyledDom;

/// C-ABI stable wrapper over a `CallbackType`
#[repr(C)]
pub struct AzCallback {
    pub cb: AzCallbackType,
}

/// `AzCallbackType` struct
pub type AzCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

/// Which type of image should be updated: background image (the CSS background) or content image
/// (the <img src=""> content)
#[repr(C)]
pub enum AzUpdateImageType {
    Background,
    Content,
}

/// Specifies if the screen should be updated after the callback function has returned
#[repr(C)]
pub enum AzUpdate {
    DoNothing,
    RefreshDom,
    RefreshDomAllWindows,
}

/// Index of a Node in the internal `NodeDataContainer`
#[repr(C)]
pub struct AzNodeId {
    pub inner: usize,
}

/// ID of a DOM - one window can contain multiple, nested DOMs (such as iframes)
#[repr(C)]
pub struct AzDomId {
    pub inner: usize,
}

/// Re-export of rust-allocated (stack based) `PositionInfoInner` struct
#[repr(C)]
pub struct AzPositionInfoInner {
    pub x_offset: f32,
    pub y_offset: f32,
    pub static_x_offset: f32,
    pub static_y_offset: f32,
}

/// Re-export of rust-allocated (stack based) `ScriptType` struct
#[repr(C)]
pub enum AzScriptType {
    Mixed,
    LTR,
    RTL,
}

/// How should an animation repeat (loop, ping-pong, etc.)
#[repr(C)]
pub enum AzAnimationRepeat {
    NoRepeat,
    Loop,
    PingPong,
}

/// How many times should an animation repeat
#[repr(C, u8)]
pub enum AzAnimationRepeatCount {
    Times(usize),
    Infinite,
}

/// C-ABI wrapper over an `IFrameCallbackType`
#[repr(C)]
pub struct AzIFrameCallback {
    pub cb: AzIFrameCallbackType,
}

/// `AzIFrameCallbackType` struct
pub type AzIFrameCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzIFrameCallbackInfo) -> AzIFrameCallbackReturn;

/// Re-export of rust-allocated (stack based) `RenderImageCallback` struct
#[repr(C)]
pub struct AzRenderImageCallback {
    pub cb: AzRenderImageCallbackType,
}

/// `AzRenderImageCallbackType` struct
pub type AzRenderImageCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzRenderImageCallbackInfo) -> AzImageRef;

/// Re-export of rust-allocated (stack based) `TimerCallback` struct
#[repr(C)]
pub struct AzTimerCallback {
    pub cb: AzTimerCallbackType,
}

/// `AzTimerCallbackType` struct
pub type AzTimerCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzTimerCallbackInfo) -> AzTimerCallbackReturn;

/// `AzWriteBackCallbackType` struct
pub type AzWriteBackCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `WriteBackCallback` struct
#[repr(C)]
pub struct AzWriteBackCallback {
    pub cb: AzWriteBackCallbackType,
}

/// Re-export of rust-allocated (stack based) `ThreadCallback` struct
#[repr(C)]
pub struct AzThreadCallback {
    pub cb: AzThreadCallbackType,
}

/// `AzThreadCallbackType` struct
pub type AzThreadCallbackType = extern "C" fn(AzRefAny, AzThreadSender, AzThreadReceiver);

/// `AzRefAnyDestructorType` struct
pub type AzRefAnyDestructorType = extern "C" fn(&mut c_void);

/// Re-export of rust-allocated (stack based) `RefCount` struct
#[repr(C)]
pub struct AzRefCount {
    pub ptr: *const c_void,
    pub run_destructor: bool,
}

/// When to call a callback action - `On::MouseOver`, `On::MouseOut`, etc.
#[repr(C)]
pub enum AzOn {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    MiddleMouseDown,
    RightMouseDown,
    MouseUp,
    LeftMouseUp,
    MiddleMouseUp,
    RightMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    HoveredFile,
    DroppedFile,
    HoveredFileCancelled,
    FocusReceived,
    FocusLost,
}

/// Re-export of rust-allocated (stack based) `HoverEventFilter` struct
#[repr(C)]
pub enum AzHoverEventFilter {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    RightMouseDown,
    MiddleMouseDown,
    MouseUp,
    LeftMouseUp,
    RightMouseUp,
    MiddleMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    ScrollStart,
    ScrollEnd,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    HoveredFile,
    DroppedFile,
    HoveredFileCancelled,
    TouchStart,
    TouchMove,
    TouchEnd,
    TouchCancel,
}

/// Re-export of rust-allocated (stack based) `FocusEventFilter` struct
#[repr(C)]
pub enum AzFocusEventFilter {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    RightMouseDown,
    MiddleMouseDown,
    MouseUp,
    LeftMouseUp,
    RightMouseUp,
    MiddleMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    ScrollStart,
    ScrollEnd,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    FocusReceived,
    FocusLost,
}

/// Re-export of rust-allocated (stack based) `WindowEventFilter` struct
#[repr(C)]
pub enum AzWindowEventFilter {
    MouseOver,
    MouseDown,
    LeftMouseDown,
    RightMouseDown,
    MiddleMouseDown,
    MouseUp,
    LeftMouseUp,
    RightMouseUp,
    MiddleMouseUp,
    MouseEnter,
    MouseLeave,
    Scroll,
    ScrollStart,
    ScrollEnd,
    TextInput,
    VirtualKeyDown,
    VirtualKeyUp,
    HoveredFile,
    DroppedFile,
    HoveredFileCancelled,
    Resized,
    Moved,
    TouchStart,
    TouchMove,
    TouchEnd,
    TouchCancel,
    FocusReceived,
    FocusLost,
    CloseRequested,
    ThemeChanged,
}

/// Re-export of rust-allocated (stack based) `ComponentEventFilter` struct
#[repr(C)]
pub enum AzComponentEventFilter {
    AfterMount,
    BeforeUnmount,
    NodeResized,
    DefaultAction,
    Selected,
}

/// Re-export of rust-allocated (stack based) `ApplicationEventFilter` struct
#[repr(C)]
pub enum AzApplicationEventFilter {
    DeviceConnected,
    DeviceDisconnected,
}

/// MSAA Accessibility role constants. For information on what each role does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-roles">MSDN Role Constants page</a>
#[repr(C)]
pub enum AzAccessibilityRole {
    TitleBar,
    MenuBar,
    ScrollBar,
    Grip,
    Sound,
    Cursor,
    Caret,
    Alert,
    Window,
    Client,
    MenuPopup,
    MenuItem,
    Tooltip,
    Application,
    Document,
    Pane,
    Chart,
    Dialog,
    Border,
    Grouping,
    Separator,
    Toolbar,
    StatusBar,
    Table,
    ColumnHeader,
    RowHeader,
    Column,
    Row,
    Cell,
    Link,
    HelpBalloon,
    Character,
    List,
    ListItem,
    Outline,
    OutlineItem,
    Pagetab,
    PropertyPage,
    Indicator,
    Graphic,
    StaticText,
    Text,
    PushButton,
    CheckButton,
    RadioButton,
    ComboBox,
    DropList,
    ProgressBar,
    Dial,
    HotkeyField,
    Slider,
    SpinButton,
    Diagram,
    Animation,
    Equation,
    ButtonDropdown,
    ButtonMenu,
    ButtonDropdownGrid,
    Whitespace,
    PageTabList,
    Clock,
    SplitButton,
    IpAddress,
    Nothing,
}

/// MSAA accessibility state. For information on what each state does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants">MSDN State Constants page</a>.
#[repr(C)]
pub enum AzAccessibilityState {
    Unavailable,
    Selected,
    Focused,
    Checked,
    Readonly,
    Default,
    Expanded,
    Collapsed,
    Busy,
    Offscreen,
    Focusable,
    Selectable,
    Linked,
    Traversed,
    Multiselectable,
    Protected,
}

/// Re-export of rust-allocated (stack based) `TabIndex` struct
#[repr(C, u8)]
pub enum AzTabIndex {
    Auto,
    OverrideInParent(u32),
    NoKeyboardFocus,
}

/// Determines whether this context menu should pop up on a left, right or middle click
#[repr(C)]
pub enum AzContextMenuMouseButton {
    Right,
    Middle,
    Left,
}

/// Position of where the context menu should pop up
#[repr(C)]
pub enum AzMenuPopupPosition {
    BottomLeftOfCursor,
    BottomRightOfCursor,
    TopLeftOfCursor,
    TopRightOfCursor,
    BottomOfHitRect,
    LeftOfHitRect,
    TopOfHitRect,
    RightOfHitRect,
    AutoCursor,
    AutoHitRect,
}

/// Describes the state of a menu item
#[repr(C)]
pub enum AzMenuItemState {
    Normal,
    Greyed,
    Disabled,
}

/// Re-export of rust-allocated (stack based) `NodeTypeKey` struct
#[repr(C)]
pub enum AzNodeTypeKey {
    Body,
    Div,
    Br,
    P,
    Img,
    IFrame,
}

/// Re-export of rust-allocated (stack based) `CssNthChildPattern` struct
#[repr(C)]
pub struct AzCssNthChildPattern {
    pub repeat: u32,
    pub offset: u32,
}

/// Re-export of rust-allocated (stack based) `CssPropertyType` struct
#[repr(C)]
pub enum AzCssPropertyType {
    TextColor,
    FontSize,
    FontFamily,
    TextAlign,
    LetterSpacing,
    LineHeight,
    WordSpacing,
    TabWidth,
    Cursor,
    Display,
    Float,
    BoxSizing,
    Width,
    Height,
    MinWidth,
    MinHeight,
    MaxWidth,
    MaxHeight,
    Position,
    Top,
    Right,
    Left,
    Bottom,
    FlexWrap,
    FlexDirection,
    FlexGrow,
    FlexShrink,
    JustifyContent,
    AlignItems,
    AlignContent,
    BackgroundContent,
    BackgroundPosition,
    BackgroundSize,
    BackgroundRepeat,
    OverflowX,
    OverflowY,
    PaddingTop,
    PaddingLeft,
    PaddingRight,
    PaddingBottom,
    MarginTop,
    MarginLeft,
    MarginRight,
    MarginBottom,
    BorderTopLeftRadius,
    BorderTopRightRadius,
    BorderBottomLeftRadius,
    BorderBottomRightRadius,
    BorderTopColor,
    BorderRightColor,
    BorderLeftColor,
    BorderBottomColor,
    BorderTopStyle,
    BorderRightStyle,
    BorderLeftStyle,
    BorderBottomStyle,
    BorderTopWidth,
    BorderRightWidth,
    BorderLeftWidth,
    BorderBottomWidth,
    BoxShadowLeft,
    BoxShadowRight,
    BoxShadowTop,
    BoxShadowBottom,
    ScrollbarStyle,
    Opacity,
    Transform,
    TransformOrigin,
    PerspectiveOrigin,
    BackfaceVisibility,
    MixBlendMode,
    Filter,
    BackdropFilter,
    TextShadow,
}

/// Re-export of rust-allocated (stack based) `ColorU` struct
#[repr(C)]
pub struct AzColorU {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

/// Re-export of rust-allocated (stack based) `SizeMetric` struct
#[repr(C)]
pub enum AzSizeMetric {
    Px,
    Pt,
    Em,
    Percent,
}

/// Re-export of rust-allocated (stack based) `BoxShadowClipMode` struct
#[repr(C)]
pub enum AzBoxShadowClipMode {
    Outset,
    Inset,
}

/// Re-export of rust-allocated (stack based) `StyleMixBlendMode` struct
#[repr(C)]
pub enum AzStyleMixBlendMode {
    Normal,
    Multiply,
    Screen,
    Overlay,
    Darken,
    Lighten,
    ColorDodge,
    ColorBurn,
    HardLight,
    SoftLight,
    Difference,
    Exclusion,
    Hue,
    Saturation,
    Color,
    Luminosity,
}

/// Re-export of rust-allocated (stack based) `LayoutAlignContent` struct
#[repr(C)]
pub enum AzLayoutAlignContent {
    Stretch,
    Center,
    Start,
    End,
    SpaceBetween,
    SpaceAround,
}

/// Re-export of rust-allocated (stack based) `LayoutAlignItems` struct
#[repr(C)]
pub enum AzLayoutAlignItems {
    Stretch,
    Center,
    FlexStart,
    FlexEnd,
}

/// Re-export of rust-allocated (stack based) `LayoutBoxSizing` struct
#[repr(C)]
pub enum AzLayoutBoxSizing {
    ContentBox,
    BorderBox,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexDirection` struct
#[repr(C)]
pub enum AzLayoutFlexDirection {
    Row,
    RowReverse,
    Column,
    ColumnReverse,
}

/// Re-export of rust-allocated (stack based) `LayoutDisplay` struct
#[repr(C)]
pub enum AzLayoutDisplay {
    None,
    Flex,
    Block,
    InlineBlock,
}

/// Re-export of rust-allocated (stack based) `LayoutFloat` struct
#[repr(C)]
pub enum AzLayoutFloat {
    Left,
    Right,
    None,
}

/// Re-export of rust-allocated (stack based) `LayoutJustifyContent` struct
#[repr(C)]
pub enum AzLayoutJustifyContent {
    Start,
    End,
    Center,
    SpaceBetween,
    SpaceAround,
    SpaceEvenly,
}

/// Re-export of rust-allocated (stack based) `LayoutPosition` struct
#[repr(C)]
pub enum AzLayoutPosition {
    Static,
    Relative,
    Absolute,
    Fixed,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexWrap` struct
#[repr(C)]
pub enum AzLayoutFlexWrap {
    Wrap,
    NoWrap,
}

/// Re-export of rust-allocated (stack based) `LayoutOverflow` struct
#[repr(C)]
pub enum AzLayoutOverflow {
    Scroll,
    Auto,
    Hidden,
    Visible,
}

/// Re-export of rust-allocated (stack based) `FloatValue` struct
#[repr(C)]
pub struct AzFloatValue {
    pub number: isize,
}

/// Re-export of rust-allocated (stack based) `AngleMetric` struct
#[repr(C)]
pub enum AzAngleMetric {
    Degree,
    Radians,
    Grad,
    Turn,
    Percent,
}

/// Re-export of rust-allocated (stack based) `DirectionCorner` struct
#[repr(C)]
pub enum AzDirectionCorner {
    Right,
    Left,
    Top,
    Bottom,
    TopRight,
    TopLeft,
    BottomRight,
    BottomLeft,
}

/// Re-export of rust-allocated (stack based) `ExtendMode` struct
#[repr(C)]
pub enum AzExtendMode {
    Clamp,
    Repeat,
}

/// Re-export of rust-allocated (stack based) `Shape` struct
#[repr(C)]
pub enum AzShape {
    Ellipse,
    Circle,
}

/// Re-export of rust-allocated (stack based) `RadialGradientSize` struct
#[repr(C)]
pub enum AzRadialGradientSize {
    ClosestSide,
    ClosestCorner,
    FarthestSide,
    FarthestCorner,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundRepeat` struct
#[repr(C)]
pub enum AzStyleBackgroundRepeat {
    NoRepeat,
    Repeat,
    RepeatX,
    RepeatY,
}

/// Re-export of rust-allocated (stack based) `BorderStyle` struct
#[repr(C)]
pub enum AzBorderStyle {
    None,
    Solid,
    Double,
    Dotted,
    Dashed,
    Hidden,
    Groove,
    Ridge,
    Inset,
    Outset,
}

/// Re-export of rust-allocated (stack based) `StyleCursor` struct
#[repr(C)]
pub enum AzStyleCursor {
    Alias,
    AllScroll,
    Cell,
    ColResize,
    ContextMenu,
    Copy,
    Crosshair,
    Default,
    EResize,
    EwResize,
    Grab,
    Grabbing,
    Help,
    Move,
    NResize,
    NsResize,
    NeswResize,
    NwseResize,
    Pointer,
    Progress,
    RowResize,
    SResize,
    SeResize,
    Text,
    Unset,
    VerticalText,
    WResize,
    Wait,
    ZoomIn,
    ZoomOut,
}

/// Re-export of rust-allocated (stack based) `StyleBackfaceVisibility` struct
#[repr(C)]
pub enum AzStyleBackfaceVisibility {
    Hidden,
    Visible,
}

/// Re-export of rust-allocated (stack based) `StyleTextAlign` struct
#[repr(C)]
pub enum AzStyleTextAlign {
    Left,
    Center,
    Right,
    Justify,
}

/// Re-export of rust-allocated (stack based) `Ribbon` struct
#[repr(C)]
pub struct AzRibbon {
    pub tab_active: i32,
}

/// Re-export of rust-allocated (stack based) `RibbonOnTabClickedCallback` struct
#[repr(C)]
pub struct AzRibbonOnTabClickedCallback {
    pub cb: AzRibbonOnTabClickedCallbackType,
}

/// `AzRibbonOnTabClickedCallbackType` struct
pub type AzRibbonOnTabClickedCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, i32) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `FileInputOnPathChangeCallback` struct
#[repr(C)]
pub struct AzFileInputOnPathChangeCallback {
    pub cb: AzFileInputOnPathChangeCallbackType,
}

/// `AzFileInputOnPathChangeCallbackType` struct
pub type AzFileInputOnPathChangeCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzFileInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `CheckBoxOnToggleCallback` struct
#[repr(C)]
pub struct AzCheckBoxOnToggleCallback {
    pub cb: AzCheckBoxOnToggleCallbackType,
}

/// `AzCheckBoxOnToggleCallbackType` struct
pub type AzCheckBoxOnToggleCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzCheckBoxState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `CheckBoxState` struct
#[repr(C)]
pub struct AzCheckBoxState {
    pub checked: bool,
}

/// Re-export of rust-allocated (stack based) `ColorInputOnValueChangeCallback` struct
#[repr(C)]
pub struct AzColorInputOnValueChangeCallback {
    pub cb: AzColorInputOnValueChangeCallbackType,
}

/// `AzColorInputOnValueChangeCallbackType` struct
pub type AzColorInputOnValueChangeCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzColorInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `TextInputSelectionRange` struct
#[repr(C)]
pub struct AzTextInputSelectionRange {
    pub from: usize,
    pub to: usize,
}

/// Re-export of rust-allocated (stack based) `TextInputOnTextInputCallback` struct
#[repr(C)]
pub struct AzTextInputOnTextInputCallback {
    pub cb: AzTextInputOnTextInputCallbackType,
}

/// `AzTextInputOnTextInputCallbackType` struct
pub type AzTextInputOnTextInputCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzOnTextInputReturn;

/// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDownCallback` struct
#[repr(C)]
pub struct AzTextInputOnVirtualKeyDownCallback {
    pub cb: AzTextInputOnVirtualKeyDownCallbackType,
}

/// `AzTextInputOnVirtualKeyDownCallbackType` struct
pub type AzTextInputOnVirtualKeyDownCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzOnTextInputReturn;

/// Re-export of rust-allocated (stack based) `TextInputOnFocusLostCallback` struct
#[repr(C)]
pub struct AzTextInputOnFocusLostCallback {
    pub cb: AzTextInputOnFocusLostCallbackType,
}

/// `AzTextInputOnFocusLostCallbackType` struct
pub type AzTextInputOnFocusLostCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `TextInputValid` struct
#[repr(C)]
pub enum AzTextInputValid {
    Yes,
    No,
}

/// Re-export of rust-allocated (stack based) `NumberInputState` struct
#[repr(C)]
pub struct AzNumberInputState {
    pub previous: f32,
    pub number: f32,
    pub min: f32,
    pub max: f32,
}

/// Re-export of rust-allocated (stack based) `NumberInputOnValueChangeCallback` struct
#[repr(C)]
pub struct AzNumberInputOnValueChangeCallback {
    pub cb: AzNumberInputOnValueChangeCallbackType,
}

/// `AzNumberInputOnValueChangeCallbackType` struct
pub type AzNumberInputOnValueChangeCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NumberInputOnFocusLostCallback` struct
#[repr(C)]
pub struct AzNumberInputOnFocusLostCallback {
    pub cb: AzNumberInputOnFocusLostCallbackType,
}

/// `AzNumberInputOnFocusLostCallbackType` struct
pub type AzNumberInputOnFocusLostCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `ProgressBarState` struct
#[repr(C)]
pub struct AzProgressBarState {
    pub percent_done: f32,
    pub display_percentage: bool,
}

/// Re-export of rust-allocated (stack based) `TabHeaderState` struct
#[repr(C)]
pub struct AzTabHeaderState {
    pub active_tab: usize,
}

/// Re-export of rust-allocated (stack based) `TabOnClickCallback` struct
#[repr(C)]
pub struct AzTabOnClickCallback {
    pub cb: AzTabOnClickCallbackType,
}

/// `AzTabOnClickCallbackType` struct
pub type AzTabOnClickCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTabHeaderState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphStyle` struct
#[repr(C)]
pub enum AzNodeGraphStyle {
    Default,
}

/// `AzNodeGraphOnNodeAddedCallbackType` struct
pub type AzNodeGraphOnNodeAddedCallbackType = extern "C" fn(
    &mut AzRefAny,
    &mut AzCallbackInfo,
    AzNodeTypeId,
    AzNodeGraphNodeId,
    AzNodePosition,
) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAddedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeAddedCallback {
    pub cb: AzNodeGraphOnNodeAddedCallbackType,
}

/// `AzNodeGraphOnNodeRemovedCallbackType` struct
pub type AzNodeGraphOnNodeRemovedCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemovedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeRemovedCallback {
    pub cb: AzNodeGraphOnNodeRemovedCallbackType,
}

/// `AzNodeGraphOnNodeGraphDraggedCallbackType` struct
pub type AzNodeGraphOnNodeGraphDraggedCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzGraphDragAmount) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDraggedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeGraphDraggedCallback {
    pub cb: AzNodeGraphOnNodeGraphDraggedCallbackType,
}

/// `AzNodeGraphOnNodeDraggedCallbackType` struct
pub type AzNodeGraphOnNodeDraggedCallbackType = extern "C" fn(
    &mut AzRefAny,
    &mut AzCallbackInfo,
    AzNodeGraphNodeId,
    AzNodeDragAmount,
) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDraggedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeDraggedCallback {
    pub cb: AzNodeGraphOnNodeDraggedCallbackType,
}

/// `AzNodeGraphOnNodeConnectedCallbackType` struct
pub type AzNodeGraphOnNodeConnectedCallbackType = extern "C" fn(
    &mut AzRefAny,
    &mut AzCallbackInfo,
    AzNodeGraphNodeId,
    usize,
    AzNodeGraphNodeId,
    usize,
) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnectedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeConnectedCallback {
    pub cb: AzNodeGraphOnNodeConnectedCallbackType,
}

/// `AzNodeGraphOnNodeInputDisconnectedCallbackType` struct
pub type AzNodeGraphOnNodeInputDisconnectedCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnectedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeInputDisconnectedCallback {
    pub cb: AzNodeGraphOnNodeInputDisconnectedCallbackType,
}

/// `AzNodeGraphOnNodeOutputDisconnectedCallbackType` struct
pub type AzNodeGraphOnNodeOutputDisconnectedCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnectedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeOutputDisconnectedCallback {
    pub cb: AzNodeGraphOnNodeOutputDisconnectedCallbackType,
}

/// `AzNodeGraphOnNodeFieldEditedCallbackType` struct
pub type AzNodeGraphOnNodeFieldEditedCallbackType = extern "C" fn(
    &mut AzRefAny,
    &mut AzCallbackInfo,
    AzNodeGraphNodeId,
    usize,
    AzNodeTypeId,
    AzNodeTypeFieldValue,
) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEditedCallback` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeFieldEditedCallback {
    pub cb: AzNodeGraphOnNodeFieldEditedCallbackType,
}

/// Re-export of rust-allocated (stack based) `InputOutputTypeId` struct
#[repr(C)]
pub struct AzInputOutputTypeId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `NodeTypeId` struct
#[repr(C)]
pub struct AzNodeTypeId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `NodeGraphNodeId` struct
#[repr(C)]
pub struct AzNodeGraphNodeId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `NodePosition` struct
#[repr(C)]
pub struct AzNodePosition {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `GraphDragAmount` struct
#[repr(C)]
pub struct AzGraphDragAmount {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `NodeDragAmount` struct
#[repr(C)]
pub struct AzNodeDragAmount {
    pub x: f32,
    pub y: f32,
}

/// `AzListViewOnLazyLoadScrollCallbackType` struct
pub type AzListViewOnLazyLoadScrollCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzListViewState) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `ListViewOnLazyLoadScrollCallback` struct
#[repr(C)]
pub struct AzListViewOnLazyLoadScrollCallback {
    pub cb: AzListViewOnLazyLoadScrollCallbackType,
}

/// `AzListViewOnColumnClickCallbackType` struct
pub type AzListViewOnColumnClickCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzListViewState, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `ListViewOnColumnClickCallback` struct
#[repr(C)]
pub struct AzListViewOnColumnClickCallback {
    pub cb: AzListViewOnColumnClickCallbackType,
}

/// `AzListViewOnRowClickCallbackType` struct
pub type AzListViewOnRowClickCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzListViewState, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `ListViewOnRowClickCallback` struct
#[repr(C)]
pub struct AzListViewOnRowClickCallback {
    pub cb: AzListViewOnRowClickCallbackType,
}

/// `AzDropDownOnChoiceChangeCallbackType` struct
pub type AzDropDownOnChoiceChangeCallbackType =
    extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, usize) -> AzUpdate;

/// Re-export of rust-allocated (stack based) `DropDownOnChoiceChangeCallback` struct
#[repr(C)]
pub struct AzDropDownOnChoiceChangeCallback {
    pub cb: AzDropDownOnChoiceChangeCallbackType,
}

/// Re-export of rust-allocated (stack based) `NodeHierarchyItem` struct
#[repr(C)]
pub struct AzNodeHierarchyItem {
    pub parent: usize,
    pub previous_sibling: usize,
    pub next_sibling: usize,
    pub last_child: usize,
}

/// Re-export of rust-allocated (stack based) `CascadeInfo` struct
#[repr(C)]
pub struct AzCascadeInfo {
    pub index_in_parent: u32,
    pub is_last_child: bool,
}

/// Re-export of rust-allocated (stack based) `StyledNodeState` struct
#[repr(C)]
pub struct AzStyledNodeState {
    pub normal: bool,
    pub hover: bool,
    pub active: bool,
    pub focused: bool,
}

/// Re-export of rust-allocated (stack based) `TagId` struct
#[repr(C)]
pub struct AzTagId {
    pub inner: u64,
}

/// Re-export of rust-allocated (stack based) `CssPropertyCache` struct
#[repr(C)]
pub struct AzCssPropertyCache {
    pub ptr: *mut c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `GlVoidPtrConst` struct
#[repr(C)]
pub struct AzGlVoidPtrConst {
    pub ptr: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `GlVoidPtrMut` struct
#[repr(C)]
pub struct AzGlVoidPtrMut {
    pub ptr: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `GlShaderPrecisionFormatReturn` struct
#[repr(C)]
pub struct AzGlShaderPrecisionFormatReturn {
    pub _0: i32,
    pub _1: i32,
    pub _2: i32,
}

/// Re-export of rust-allocated (stack based) `VertexAttributeType` struct
#[repr(C)]
pub enum AzVertexAttributeType {
    Float,
    Double,
    UnsignedByte,
    UnsignedShort,
    UnsignedInt,
}

/// Re-export of rust-allocated (stack based) `IndexBufferFormat` struct
#[repr(C)]
pub enum AzIndexBufferFormat {
    Points,
    Lines,
    LineStrip,
    Triangles,
    TriangleStrip,
    TriangleFan,
}

/// Re-export of rust-allocated (stack based) `GlType` struct
#[repr(C)]
pub enum AzGlType {
    Gl,
    Gles,
}

/// C-ABI stable reexport of `&[u8]`
#[repr(C)]
pub struct AzU8VecRef {
    pub ptr: *const u8,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [u8]`
#[repr(C)]
pub struct AzU8VecRefMut {
    pub ptr: *mut u8,
    pub len: usize,
}

/// C-ABI stable reexport of `&[f32]`
#[repr(C)]
pub struct AzF32VecRef {
    pub ptr: *const f32,
    pub len: usize,
}

/// C-ABI stable reexport of `&[i32]`
#[repr(C)]
pub struct AzI32VecRef {
    pub ptr: *const i32,
    pub len: usize,
}

/// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`
#[repr(C)]
pub struct AzGLuintVecRef {
    pub ptr: *const u32,
    pub len: usize,
}

/// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`
#[repr(C)]
pub struct AzGLenumVecRef {
    pub ptr: *const u32,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`
#[repr(C)]
pub struct AzGLintVecRefMut {
    pub ptr: *mut i32,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`
#[repr(C)]
pub struct AzGLint64VecRefMut {
    pub ptr: *mut i64,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`
#[repr(C)]
pub struct AzGLbooleanVecRefMut {
    pub ptr: *mut u8,
    pub len: usize,
}

/// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`
#[repr(C)]
pub struct AzGLfloatVecRefMut {
    pub ptr: *mut f32,
    pub len: usize,
}

/// C-ABI stable reexport of `&str`
#[repr(C)]
pub struct AzRefstr {
    pub ptr: *const u8,
    pub len: usize,
}

/// C-ABI stable reexport of `*const gleam::gl::GLsync`
#[repr(C)]
pub struct AzGLsyncPtr {
    pub ptr: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `TextureFlags` struct
#[repr(C)]
pub struct AzTextureFlags {
    pub is_opaque: bool,
    pub is_video_texture: bool,
}

/// Re-export of rust-allocated (stack based) `ImageRef` struct
#[repr(C)]
pub struct AzImageRef {
    pub data: *const c_void,
    pub copies: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `RawImageFormat` struct
#[repr(C)]
pub enum AzRawImageFormat {
    R8,
    RG8,
    RGB8,
    RGBA8,
    R16,
    RG16,
    RGB16,
    RGBA16,
    BGR8,
    BGRA8,
}

/// Re-export of rust-allocated (stack based) `EncodeImageError` struct
#[repr(C)]
pub enum AzEncodeImageError {
    EncoderNotAvailable,
    InsufficientMemory,
    DimensionError,
    InvalidData,
    Unknown,
}

/// Re-export of rust-allocated (stack based) `DecodeImageError` struct
#[repr(C)]
pub enum AzDecodeImageError {
    InsufficientMemory,
    DimensionError,
    UnsupportedImageFormat,
    Unknown,
}

/// `AzParsedFontDestructorFnType` struct
pub type AzParsedFontDestructorFnType = extern "C" fn(&mut c_void);

/// Atomically reference-counted parsed font data
#[repr(C)]
pub struct AzFontRef {
    pub data: *const c_void,
    pub copies: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `Svg` struct
#[repr(C)]
pub struct AzSvg {
    pub ptr: *mut c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `SvgXmlNode` struct
#[repr(C)]
pub struct AzSvgXmlNode {
    pub ptr: *mut c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `SvgCircle` struct
#[repr(C)]
pub struct AzSvgCircle {
    pub center_x: f32,
    pub center_y: f32,
    pub radius: f32,
}

/// Re-export of rust-allocated (stack based) `SvgPoint` struct
#[repr(C)]
pub struct AzSvgPoint {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `SvgVector` struct
#[repr(C)]
pub struct AzSvgVector {
    pub x: f64,
    pub y: f64,
}

/// Re-export of rust-allocated (stack based) `SvgRect` struct
#[repr(C)]
pub struct AzSvgRect {
    pub width: f32,
    pub height: f32,
    pub x: f32,
    pub y: f32,
    pub radius_top_left: f32,
    pub radius_top_right: f32,
    pub radius_bottom_left: f32,
    pub radius_bottom_right: f32,
}

/// Re-export of rust-allocated (stack based) `SvgColoredVertex` struct
#[repr(C)]
pub struct AzSvgColoredVertex {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}

/// Re-export of rust-allocated (stack based) `SvgVertex` struct
#[repr(C)]
pub struct AzSvgVertex {
    pub x: f32,
    pub y: f32,
}

/// Re-export of rust-allocated (stack based) `ShapeRendering` struct
#[repr(C)]
pub enum AzShapeRendering {
    OptimizeSpeed,
    CrispEdges,
    GeometricPrecision,
}

/// Re-export of rust-allocated (stack based) `TextRendering` struct
#[repr(C)]
pub enum AzTextRendering {
    OptimizeSpeed,
    OptimizeLegibility,
    GeometricPrecision,
}

/// Re-export of rust-allocated (stack based) `ImageRendering` struct
#[repr(C)]
pub enum AzImageRendering {
    OptimizeQuality,
    OptimizeSpeed,
}

/// Re-export of rust-allocated (stack based) `FontDatabase` struct
#[repr(C)]
pub enum AzFontDatabase {
    Empty,
    System,
}

/// Re-export of rust-allocated (stack based) `SvgRenderTransform` struct
#[repr(C)]
pub struct AzSvgRenderTransform {
    pub sx: f32,
    pub kx: f32,
    pub ky: f32,
    pub sy: f32,
    pub tx: f32,
    pub ty: f32,
}

/// Re-export of rust-allocated (stack based) `Indent` struct
#[repr(C, u8)]
pub enum AzIndent {
    None,
    Spaces(u8),
    Tabs,
}

/// Re-export of rust-allocated (stack based) `SvgFitTo` struct
#[repr(C, u8)]
pub enum AzSvgFitTo {
    Original,
    Width(u32),
    Height(u32),
    Zoom(f32),
}

/// Re-export of rust-allocated (stack based) `SvgFillRule` struct
#[repr(C)]
pub enum AzSvgFillRule {
    Winding,
    EvenOdd,
}

/// Re-export of rust-allocated (stack based) `SvgTransform` struct
#[repr(C)]
pub struct AzSvgTransform {
    pub sx: f32,
    pub kx: f32,
    pub ky: f32,
    pub sy: f32,
    pub tx: f32,
    pub ty: f32,
}

/// Re-export of rust-allocated (stack based) `SvgLineJoin` struct
#[repr(C)]
pub enum AzSvgLineJoin {
    Miter,
    MiterClip,
    Round,
    Bevel,
}

/// Re-export of rust-allocated (stack based) `SvgLineCap` struct
#[repr(C)]
pub enum AzSvgLineCap {
    Butt,
    Square,
    Round,
}

/// Re-export of rust-allocated (stack based) `SvgDashPattern` struct
#[repr(C)]
pub struct AzSvgDashPattern {
    pub offset: f32,
    pub length_1: f32,
    pub gap_1: f32,
    pub length_2: f32,
    pub gap_2: f32,
    pub length_3: f32,
    pub gap_3: f32,
}

/// Re-export of rust-allocated (stack based) `MsgBox` struct
#[repr(C)]
pub struct AzMsgBox {
    pub _reserved: usize,
}

/// Type of message box icon
#[repr(C)]
pub enum AzMsgBoxIcon {
    Info,
    Warning,
    Error,
    Question,
}

/// Value returned from a yes / no message box
#[repr(C)]
pub enum AzMsgBoxYesNo {
    Yes,
    No,
}

/// Value returned from an ok / cancel message box
#[repr(C)]
pub enum AzMsgBoxOkCancel {
    Ok,
    Cancel,
}

/// File picker dialog
#[repr(C)]
pub struct AzFileDialog {
    pub _reserved: usize,
}

/// Re-export of rust-allocated (stack based) `ColorPickerDialog` struct
#[repr(C)]
pub struct AzColorPickerDialog {
    pub _reserved: usize,
}

/// Connection to the system clipboard, on some systems this connection can be cached
#[repr(C)]
pub struct AzSystemClipboard {
    pub _native: *const c_void,
    pub run_destructor: bool,
}

/// `AzInstantPtrCloneFnType` struct
pub type AzInstantPtrCloneFnType = extern "C" fn(&AzInstantPtr) -> AzInstantPtr;

/// Re-export of rust-allocated (stack based) `InstantPtrCloneFn` struct
#[repr(C)]
pub struct AzInstantPtrCloneFn {
    pub cb: AzInstantPtrCloneFnType,
}

/// `AzInstantPtrDestructorFnType` struct
pub type AzInstantPtrDestructorFnType = extern "C" fn(&mut AzInstantPtr);

/// Re-export of rust-allocated (stack based) `InstantPtrDestructorFn` struct
#[repr(C)]
pub struct AzInstantPtrDestructorFn {
    pub cb: AzInstantPtrDestructorFnType,
}

/// Re-export of rust-allocated (stack based) `SystemTick` struct
#[repr(C)]
pub struct AzSystemTick {
    pub tick_counter: u64,
}

/// Re-export of rust-allocated (stack based) `SystemTimeDiff` struct
#[repr(C)]
pub struct AzSystemTimeDiff {
    pub secs: u64,
    pub nanos: u32,
}

/// Re-export of rust-allocated (stack based) `SystemTickDiff` struct
#[repr(C)]
pub struct AzSystemTickDiff {
    pub tick_diff: u64,
}

/// Re-export of rust-allocated (stack based) `TimerId` struct
#[repr(C)]
pub struct AzTimerId {
    pub id: usize,
}

/// Should a timer terminate or not - used to remove active timers
#[repr(C)]
pub enum AzTerminateTimer {
    Terminate,
    Continue,
}

/// Re-export of rust-allocated (stack based) `ThreadId` struct
#[repr(C)]
pub struct AzThreadId {
    pub id: usize,
}

/// Re-export of rust-allocated (stack based) `Thread` struct
#[repr(C)]
pub struct AzThread {
    pub ptr: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `ThreadSender` struct
#[repr(C)]
pub struct AzThreadSender {
    pub ptr: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `ThreadReceiver` struct
#[repr(C)]
pub struct AzThreadReceiver {
    pub ptr: *const c_void,
    pub run_destructor: bool,
}

/// `AzCreateThreadFnType` struct
pub type AzCreateThreadFnType = extern "C" fn(AzRefAny, AzRefAny, AzThreadCallback) -> AzThread;

/// Re-export of rust-allocated (stack based) `CreateThreadFn` struct
#[repr(C)]
pub struct AzCreateThreadFn {
    pub cb: AzCreateThreadFnType,
}

/// `AzGetSystemTimeFnType` struct
pub type AzGetSystemTimeFnType = extern "C" fn() -> AzInstant;

/// Get the current system time, equivalent to `std::time::Instant::now()`, except it also works on
/// systems that work with "ticks" instead of timers
#[repr(C)]
pub struct AzGetSystemTimeFn {
    pub cb: AzGetSystemTimeFnType,
}

/// `AzCheckThreadFinishedFnType` struct
pub type AzCheckThreadFinishedFnType = extern "C" fn(&c_void) -> bool;

/// Function called to check if the thread has finished
#[repr(C)]
pub struct AzCheckThreadFinishedFn {
    pub cb: AzCheckThreadFinishedFnType,
}

/// `AzLibrarySendThreadMsgFnType` struct
pub type AzLibrarySendThreadMsgFnType = extern "C" fn(&c_void, AzThreadSendMsg) -> bool;

/// Function to send a message to the thread
#[repr(C)]
pub struct AzLibrarySendThreadMsgFn {
    pub cb: AzLibrarySendThreadMsgFnType,
}

/// `AzLibraryReceiveThreadMsgFnType` struct
pub type AzLibraryReceiveThreadMsgFnType = extern "C" fn(&c_void) -> AzOptionThreadReceiveMsg;

/// Function to receive a message from the thread
#[repr(C)]
pub struct AzLibraryReceiveThreadMsgFn {
    pub cb: AzLibraryReceiveThreadMsgFnType,
}

/// `AzThreadRecvFnType` struct
pub type AzThreadRecvFnType = extern "C" fn(&c_void) -> AzOptionThreadSendMsg;

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[repr(C)]
pub struct AzThreadRecvFn {
    pub cb: AzThreadRecvFnType,
}

/// `AzThreadSendFnType` struct
pub type AzThreadSendFnType = extern "C" fn(&c_void, AzThreadReceiveMsg) -> bool;

/// Function that the running `Thread` can call to receive messages from the main UI thread
#[repr(C)]
pub struct AzThreadSendFn {
    pub cb: AzThreadSendFnType,
}

/// `AzThreadDestructorFnType` struct
pub type AzThreadDestructorFnType = extern "C" fn(&mut AzThread);

/// Destructor of the `Thread`
#[repr(C)]
pub struct AzThreadDestructorFn {
    pub cb: AzThreadDestructorFnType,
}

/// `AzThreadReceiverDestructorFnType` struct
pub type AzThreadReceiverDestructorFnType = extern "C" fn(&mut AzThreadReceiver);

/// Destructor of the `ThreadReceiver`
#[repr(C)]
pub struct AzThreadReceiverDestructorFn {
    pub cb: AzThreadReceiverDestructorFnType,
}

/// `AzThreadSenderDestructorFnType` struct
pub type AzThreadSenderDestructorFnType = extern "C" fn(&mut AzThreadSender);

/// Destructor of the `ThreadSender`
#[repr(C)]
pub struct AzThreadSenderDestructorFn {
    pub cb: AzThreadSenderDestructorFnType,
}

/// Re-export of rust-allocated (stack based) `StyleFontFamilyVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleFontFamilyVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleFontFamilyVecDestructorType),
}

/// `AzStyleFontFamilyVecDestructorType` struct
pub type AzStyleFontFamilyVecDestructorType = extern "C" fn(&mut AzStyleFontFamilyVec);

/// Re-export of rust-allocated (stack based) `ListViewRowVecDestructor` struct
#[repr(C, u8)]
pub enum AzListViewRowVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzListViewRowVecDestructorType),
}

/// `AzListViewRowVecDestructorType` struct
pub type AzListViewRowVecDestructorType = extern "C" fn(&mut AzListViewRowVec);

/// Re-export of rust-allocated (stack based) `StyleFilterVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleFilterVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleFilterVecDestructorType),
}

/// `AzStyleFilterVecDestructorType` struct
pub type AzStyleFilterVecDestructorType = extern "C" fn(&mut AzStyleFilterVec);

/// Re-export of rust-allocated (stack based) `LogicalRectVecDestructor` struct
#[repr(C, u8)]
pub enum AzLogicalRectVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzLogicalRectVecDestructorType),
}

/// `AzLogicalRectVecDestructorType` struct
pub type AzLogicalRectVecDestructorType = extern "C" fn(&mut AzLogicalRectVec);

/// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMapVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeTypeIdInfoMapVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeTypeIdInfoMapVecDestructorType),
}

/// `AzNodeTypeIdInfoMapVecDestructorType` struct
pub type AzNodeTypeIdInfoMapVecDestructorType = extern "C" fn(&mut AzNodeTypeIdInfoMapVec);

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMapVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputOutputTypeIdInfoMapVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputOutputTypeIdInfoMapVecDestructorType),
}

/// `AzInputOutputTypeIdInfoMapVecDestructorType` struct
pub type AzInputOutputTypeIdInfoMapVecDestructorType =
    extern "C" fn(&mut AzInputOutputTypeIdInfoMapVec);

/// Re-export of rust-allocated (stack based) `NodeIdNodeMapVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeIdNodeMapVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeIdNodeMapVecDestructorType),
}

/// `AzNodeIdNodeMapVecDestructorType` struct
pub type AzNodeIdNodeMapVecDestructorType = extern "C" fn(&mut AzNodeIdNodeMapVec);

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputOutputTypeIdVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputOutputTypeIdVecDestructorType),
}

/// `AzInputOutputTypeIdVecDestructorType` struct
pub type AzInputOutputTypeIdVecDestructorType = extern "C" fn(&mut AzInputOutputTypeIdVec);

/// Re-export of rust-allocated (stack based) `NodeTypeFieldVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeTypeFieldVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeTypeFieldVecDestructorType),
}

/// `AzNodeTypeFieldVecDestructorType` struct
pub type AzNodeTypeFieldVecDestructorType = extern "C" fn(&mut AzNodeTypeFieldVec);

/// Re-export of rust-allocated (stack based) `InputConnectionVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputConnectionVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputConnectionVecDestructorType),
}

/// `AzInputConnectionVecDestructorType` struct
pub type AzInputConnectionVecDestructorType = extern "C" fn(&mut AzInputConnectionVec);

/// Re-export of rust-allocated (stack based) `OutputNodeAndIndexVecDestructor` struct
#[repr(C, u8)]
pub enum AzOutputNodeAndIndexVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzOutputNodeAndIndexVecDestructorType),
}

/// `AzOutputNodeAndIndexVecDestructorType` struct
pub type AzOutputNodeAndIndexVecDestructorType = extern "C" fn(&mut AzOutputNodeAndIndexVec);

/// Re-export of rust-allocated (stack based) `OutputConnectionVecDestructor` struct
#[repr(C, u8)]
pub enum AzOutputConnectionVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzOutputConnectionVecDestructorType),
}

/// `AzOutputConnectionVecDestructorType` struct
pub type AzOutputConnectionVecDestructorType = extern "C" fn(&mut AzOutputConnectionVec);

/// Re-export of rust-allocated (stack based) `InputNodeAndIndexVecDestructor` struct
#[repr(C, u8)]
pub enum AzInputNodeAndIndexVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInputNodeAndIndexVecDestructorType),
}

/// `AzInputNodeAndIndexVecDestructorType` struct
pub type AzInputNodeAndIndexVecDestructorType = extern "C" fn(&mut AzInputNodeAndIndexVec);

/// Re-export of rust-allocated (stack based) `AccessibilityStateVecDestructor` struct
#[repr(C, u8)]
pub enum AzAccessibilityStateVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzAccessibilityStateVecDestructorType),
}

/// `AzAccessibilityStateVecDestructorType` struct
pub type AzAccessibilityStateVecDestructorType = extern "C" fn(&mut AzAccessibilityStateVec);

/// Re-export of rust-allocated (stack based) `MenuItemVecDestructor` struct
#[repr(C, u8)]
pub enum AzMenuItemVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzMenuItemVecDestructorType),
}

/// `AzMenuItemVecDestructorType` struct
pub type AzMenuItemVecDestructorType = extern "C" fn(&mut AzMenuItemVec);

/// Re-export of rust-allocated (stack based) `TessellatedSvgNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzTessellatedSvgNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzTessellatedSvgNodeVecDestructorType),
}

/// `AzTessellatedSvgNodeVecDestructorType` struct
pub type AzTessellatedSvgNodeVecDestructorType = extern "C" fn(&mut AzTessellatedSvgNodeVec);

/// Re-export of rust-allocated (stack based) `TessellatedColoredSvgNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzTessellatedColoredSvgNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzTessellatedColoredSvgNodeVecDestructorType),
}

/// `AzTessellatedColoredSvgNodeVecDestructorType` struct
pub type AzTessellatedColoredSvgNodeVecDestructorType =
    extern "C" fn(&mut AzTessellatedColoredSvgNodeVec);

/// Re-export of rust-allocated (stack based) `XmlNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzXmlNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzXmlNodeVecDestructorType),
}

/// `AzXmlNodeVecDestructorType` struct
pub type AzXmlNodeVecDestructorType = extern "C" fn(&mut AzXmlNodeVec);

/// Re-export of rust-allocated (stack based) `FmtArgVecDestructor` struct
#[repr(C, u8)]
pub enum AzFmtArgVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzFmtArgVecDestructorType),
}

/// `AzFmtArgVecDestructorType` struct
pub type AzFmtArgVecDestructorType = extern "C" fn(&mut AzFmtArgVec);

/// Re-export of rust-allocated (stack based) `InlineLineVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineLineVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineLineVecDestructorType),
}

/// `AzInlineLineVecDestructorType` struct
pub type AzInlineLineVecDestructorType = extern "C" fn(&mut AzInlineLineVec);

/// Re-export of rust-allocated (stack based) `InlineWordVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineWordVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineWordVecDestructorType),
}

/// `AzInlineWordVecDestructorType` struct
pub type AzInlineWordVecDestructorType = extern "C" fn(&mut AzInlineWordVec);

/// Re-export of rust-allocated (stack based) `InlineGlyphVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineGlyphVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineGlyphVecDestructorType),
}

/// `AzInlineGlyphVecDestructorType` struct
pub type AzInlineGlyphVecDestructorType = extern "C" fn(&mut AzInlineGlyphVec);

/// Re-export of rust-allocated (stack based) `InlineTextHitVecDestructor` struct
#[repr(C, u8)]
pub enum AzInlineTextHitVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzInlineTextHitVecDestructorType),
}

/// `AzInlineTextHitVecDestructorType` struct
pub type AzInlineTextHitVecDestructorType = extern "C" fn(&mut AzInlineTextHitVec);

/// Re-export of rust-allocated (stack based) `MonitorVecDestructor` struct
#[repr(C, u8)]
pub enum AzMonitorVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzMonitorVecDestructorType),
}

/// `AzMonitorVecDestructorType` struct
pub type AzMonitorVecDestructorType = extern "C" fn(&mut AzMonitorVec);

/// Re-export of rust-allocated (stack based) `VideoModeVecDestructor` struct
#[repr(C, u8)]
pub enum AzVideoModeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzVideoModeVecDestructorType),
}

/// `AzVideoModeVecDestructorType` struct
pub type AzVideoModeVecDestructorType = extern "C" fn(&mut AzVideoModeVec);

/// Re-export of rust-allocated (stack based) `DomVecDestructor` struct
#[repr(C, u8)]
pub enum AzDomVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzDomVecDestructorType),
}

/// `AzDomVecDestructorType` struct
pub type AzDomVecDestructorType = extern "C" fn(&mut AzDomVec);

/// Re-export of rust-allocated (stack based) `IdOrClassVecDestructor` struct
#[repr(C, u8)]
pub enum AzIdOrClassVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzIdOrClassVecDestructorType),
}

/// `AzIdOrClassVecDestructorType` struct
pub type AzIdOrClassVecDestructorType = extern "C" fn(&mut AzIdOrClassVec);

/// Re-export of rust-allocated (stack based) `NodeDataInlineCssPropertyVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeDataInlineCssPropertyVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeDataInlineCssPropertyVecDestructorType),
}

/// `AzNodeDataInlineCssPropertyVecDestructorType` struct
pub type AzNodeDataInlineCssPropertyVecDestructorType =
    extern "C" fn(&mut AzNodeDataInlineCssPropertyVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundContentVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundContentVecDestructorType),
}

/// `AzStyleBackgroundContentVecDestructorType` struct
pub type AzStyleBackgroundContentVecDestructorType =
    extern "C" fn(&mut AzStyleBackgroundContentVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundPositionVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundPositionVecDestructorType),
}

/// `AzStyleBackgroundPositionVecDestructorType` struct
pub type AzStyleBackgroundPositionVecDestructorType =
    extern "C" fn(&mut AzStyleBackgroundPositionVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundRepeatVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundRepeatVecDestructorType),
}

/// `AzStyleBackgroundRepeatVecDestructorType` struct
pub type AzStyleBackgroundRepeatVecDestructorType = extern "C" fn(&mut AzStyleBackgroundRepeatVec);

/// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundSizeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleBackgroundSizeVecDestructorType),
}

/// `AzStyleBackgroundSizeVecDestructorType` struct
pub type AzStyleBackgroundSizeVecDestructorType = extern "C" fn(&mut AzStyleBackgroundSizeVec);

/// Re-export of rust-allocated (stack based) `StyleTransformVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyleTransformVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyleTransformVecDestructorType),
}

/// `AzStyleTransformVecDestructorType` struct
pub type AzStyleTransformVecDestructorType = extern "C" fn(&mut AzStyleTransformVec);

/// Re-export of rust-allocated (stack based) `CssPropertyVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssPropertyVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssPropertyVecDestructorType),
}

/// `AzCssPropertyVecDestructorType` struct
pub type AzCssPropertyVecDestructorType = extern "C" fn(&mut AzCssPropertyVec);

/// Re-export of rust-allocated (stack based) `SvgMultiPolygonVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgMultiPolygonVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgMultiPolygonVecDestructorType),
}

/// `AzSvgMultiPolygonVecDestructorType` struct
pub type AzSvgMultiPolygonVecDestructorType = extern "C" fn(&mut AzSvgMultiPolygonVec);

/// Re-export of rust-allocated (stack based) `SvgSimpleNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgSimpleNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgSimpleNodeVecDestructorType),
}

/// `AzSvgSimpleNodeVecDestructorType` struct
pub type AzSvgSimpleNodeVecDestructorType = extern "C" fn(&mut AzSvgSimpleNodeVec);

/// Re-export of rust-allocated (stack based) `SvgPathVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgPathVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgPathVecDestructorType),
}

/// `AzSvgPathVecDestructorType` struct
pub type AzSvgPathVecDestructorType = extern "C" fn(&mut AzSvgPathVec);

/// Re-export of rust-allocated (stack based) `VertexAttributeVecDestructor` struct
#[repr(C, u8)]
pub enum AzVertexAttributeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzVertexAttributeVecDestructorType),
}

/// `AzVertexAttributeVecDestructorType` struct
pub type AzVertexAttributeVecDestructorType = extern "C" fn(&mut AzVertexAttributeVec);

/// Re-export of rust-allocated (stack based) `SvgPathElementVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgPathElementVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgPathElementVecDestructorType),
}

/// `AzSvgPathElementVecDestructorType` struct
pub type AzSvgPathElementVecDestructorType = extern "C" fn(&mut AzSvgPathElementVec);

/// Re-export of rust-allocated (stack based) `SvgVertexVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgVertexVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgVertexVecDestructorType),
}

/// `AzSvgVertexVecDestructorType` struct
pub type AzSvgVertexVecDestructorType = extern "C" fn(&mut AzSvgVertexVec);

/// Re-export of rust-allocated (stack based) `SvgColoredVertexVecDestructor` struct
#[repr(C, u8)]
pub enum AzSvgColoredVertexVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzSvgColoredVertexVecDestructorType),
}

/// `AzSvgColoredVertexVecDestructorType` struct
pub type AzSvgColoredVertexVecDestructorType = extern "C" fn(&mut AzSvgColoredVertexVec);

/// Re-export of rust-allocated (stack based) `U32VecDestructor` struct
#[repr(C, u8)]
pub enum AzU32VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzU32VecDestructorType),
}

/// `AzU32VecDestructorType` struct
pub type AzU32VecDestructorType = extern "C" fn(&mut AzU32Vec);

/// Re-export of rust-allocated (stack based) `XWindowTypeVecDestructor` struct
#[repr(C, u8)]
pub enum AzXWindowTypeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzXWindowTypeVecDestructorType),
}

/// `AzXWindowTypeVecDestructorType` struct
pub type AzXWindowTypeVecDestructorType = extern "C" fn(&mut AzXWindowTypeVec);

/// Re-export of rust-allocated (stack based) `VirtualKeyCodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzVirtualKeyCodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzVirtualKeyCodeVecDestructorType),
}

/// `AzVirtualKeyCodeVecDestructorType` struct
pub type AzVirtualKeyCodeVecDestructorType = extern "C" fn(&mut AzVirtualKeyCodeVec);

/// Re-export of rust-allocated (stack based) `CascadeInfoVecDestructor` struct
#[repr(C, u8)]
pub enum AzCascadeInfoVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCascadeInfoVecDestructorType),
}

/// `AzCascadeInfoVecDestructorType` struct
pub type AzCascadeInfoVecDestructorType = extern "C" fn(&mut AzCascadeInfoVec);

/// Re-export of rust-allocated (stack based) `ScanCodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzScanCodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzScanCodeVecDestructorType),
}

/// `AzScanCodeVecDestructorType` struct
pub type AzScanCodeVecDestructorType = extern "C" fn(&mut AzScanCodeVec);

/// Re-export of rust-allocated (stack based) `CssDeclarationVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssDeclarationVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssDeclarationVecDestructorType),
}

/// `AzCssDeclarationVecDestructorType` struct
pub type AzCssDeclarationVecDestructorType = extern "C" fn(&mut AzCssDeclarationVec);

/// Re-export of rust-allocated (stack based) `CssPathSelectorVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssPathSelectorVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssPathSelectorVecDestructorType),
}

/// `AzCssPathSelectorVecDestructorType` struct
pub type AzCssPathSelectorVecDestructorType = extern "C" fn(&mut AzCssPathSelectorVec);

/// Re-export of rust-allocated (stack based) `StylesheetVecDestructor` struct
#[repr(C, u8)]
pub enum AzStylesheetVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStylesheetVecDestructorType),
}

/// `AzStylesheetVecDestructorType` struct
pub type AzStylesheetVecDestructorType = extern "C" fn(&mut AzStylesheetVec);

/// Re-export of rust-allocated (stack based) `CssRuleBlockVecDestructor` struct
#[repr(C, u8)]
pub enum AzCssRuleBlockVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCssRuleBlockVecDestructorType),
}

/// `AzCssRuleBlockVecDestructorType` struct
pub type AzCssRuleBlockVecDestructorType = extern "C" fn(&mut AzCssRuleBlockVec);

/// Re-export of rust-allocated (stack based) `F32VecDestructor` struct
#[repr(C, u8)]
pub enum AzF32VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzF32VecDestructorType),
}

/// `AzF32VecDestructorType` struct
pub type AzF32VecDestructorType = extern "C" fn(&mut AzF32Vec);

/// Re-export of rust-allocated (stack based) `U16VecDestructor` struct
#[repr(C, u8)]
pub enum AzU16VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzU16VecDestructorType),
}

/// `AzU16VecDestructorType` struct
pub type AzU16VecDestructorType = extern "C" fn(&mut AzU16Vec);

/// Re-export of rust-allocated (stack based) `U8VecDestructor` struct
#[repr(C, u8)]
pub enum AzU8VecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzU8VecDestructorType),
}

/// `AzU8VecDestructorType` struct
pub type AzU8VecDestructorType = extern "C" fn(&mut AzU8Vec);

/// Re-export of rust-allocated (stack based) `CallbackDataVecDestructor` struct
#[repr(C, u8)]
pub enum AzCallbackDataVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzCallbackDataVecDestructorType),
}

/// `AzCallbackDataVecDestructorType` struct
pub type AzCallbackDataVecDestructorType = extern "C" fn(&mut AzCallbackDataVec);

/// Re-export of rust-allocated (stack based) `DebugMessageVecDestructor` struct
#[repr(C, u8)]
pub enum AzDebugMessageVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzDebugMessageVecDestructorType),
}

/// `AzDebugMessageVecDestructorType` struct
pub type AzDebugMessageVecDestructorType = extern "C" fn(&mut AzDebugMessageVec);

/// Re-export of rust-allocated (stack based) `GLuintVecDestructor` struct
#[repr(C, u8)]
pub enum AzGLuintVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzGLuintVecDestructorType),
}

/// `AzGLuintVecDestructorType` struct
pub type AzGLuintVecDestructorType = extern "C" fn(&mut AzGLuintVec);

/// Re-export of rust-allocated (stack based) `GLintVecDestructor` struct
#[repr(C, u8)]
pub enum AzGLintVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzGLintVecDestructorType),
}

/// `AzGLintVecDestructorType` struct
pub type AzGLintVecDestructorType = extern "C" fn(&mut AzGLintVec);

/// Re-export of rust-allocated (stack based) `StringVecDestructor` struct
#[repr(C, u8)]
pub enum AzStringVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStringVecDestructorType),
}

/// `AzStringVecDestructorType` struct
pub type AzStringVecDestructorType = extern "C" fn(&mut AzStringVec);

/// Re-export of rust-allocated (stack based) `StringPairVecDestructor` struct
#[repr(C, u8)]
pub enum AzStringPairVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStringPairVecDestructorType),
}

/// `AzStringPairVecDestructorType` struct
pub type AzStringPairVecDestructorType = extern "C" fn(&mut AzStringPairVec);

/// Re-export of rust-allocated (stack based) `NormalizedLinearColorStopVecDestructor` struct
#[repr(C, u8)]
pub enum AzNormalizedLinearColorStopVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNormalizedLinearColorStopVecDestructorType),
}

/// `AzNormalizedLinearColorStopVecDestructorType` struct
pub type AzNormalizedLinearColorStopVecDestructorType =
    extern "C" fn(&mut AzNormalizedLinearColorStopVec);

/// Re-export of rust-allocated (stack based) `NormalizedRadialColorStopVecDestructor` struct
#[repr(C, u8)]
pub enum AzNormalizedRadialColorStopVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNormalizedRadialColorStopVecDestructorType),
}

/// `AzNormalizedRadialColorStopVecDestructorType` struct
pub type AzNormalizedRadialColorStopVecDestructorType =
    extern "C" fn(&mut AzNormalizedRadialColorStopVec);

/// Re-export of rust-allocated (stack based) `NodeIdVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeIdVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeIdVecDestructorType),
}

/// `AzNodeIdVecDestructorType` struct
pub type AzNodeIdVecDestructorType = extern "C" fn(&mut AzNodeIdVec);

/// Re-export of rust-allocated (stack based) `NodeHierarchyItemVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeHierarchyItemVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeHierarchyItemVecDestructorType),
}

/// `AzNodeHierarchyItemVecDestructorType` struct
pub type AzNodeHierarchyItemVecDestructorType = extern "C" fn(&mut AzNodeHierarchyItemVec);

/// Re-export of rust-allocated (stack based) `StyledNodeVecDestructor` struct
#[repr(C, u8)]
pub enum AzStyledNodeVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzStyledNodeVecDestructorType),
}

/// `AzStyledNodeVecDestructorType` struct
pub type AzStyledNodeVecDestructorType = extern "C" fn(&mut AzStyledNodeVec);

/// Re-export of rust-allocated (stack based) `TagIdToNodeIdMappingVecDestructor` struct
#[repr(C, u8)]
pub enum AzTagIdToNodeIdMappingVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzTagIdToNodeIdMappingVecDestructorType),
}

/// `AzTagIdToNodeIdMappingVecDestructorType` struct
pub type AzTagIdToNodeIdMappingVecDestructorType = extern "C" fn(&mut AzTagIdToNodeIdMappingVec);

/// Re-export of rust-allocated (stack based) `ParentWithNodeDepthVecDestructor` struct
#[repr(C, u8)]
pub enum AzParentWithNodeDepthVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzParentWithNodeDepthVecDestructorType),
}

/// `AzParentWithNodeDepthVecDestructorType` struct
pub type AzParentWithNodeDepthVecDestructorType = extern "C" fn(&mut AzParentWithNodeDepthVec);

/// Re-export of rust-allocated (stack based) `NodeDataVecDestructor` struct
#[repr(C, u8)]
pub enum AzNodeDataVecDestructor {
    DefaultRust,
    NoDestructor,
    External(AzNodeDataVecDestructorType),
}

/// `AzNodeDataVecDestructorType` struct
pub type AzNodeDataVecDestructorType = extern "C" fn(&mut AzNodeDataVec);

/// Re-export of rust-allocated (stack based) `OptionI16` struct
#[repr(C, u8)]
pub enum AzOptionI16 {
    None,
    Some(i16),
}

/// Re-export of rust-allocated (stack based) `OptionU16` struct
#[repr(C, u8)]
pub enum AzOptionU16 {
    None,
    Some(u16),
}

/// Re-export of rust-allocated (stack based) `OptionU32` struct
#[repr(C, u8)]
pub enum AzOptionU32 {
    None,
    Some(u32),
}

/// Re-export of rust-allocated (stack based) `OptionHwndHandle` struct
#[repr(C, u8)]
pub enum AzOptionHwndHandle {
    None,
    Some(*mut c_void),
}

/// Re-export of rust-allocated (stack based) `OptionX11Visual` struct
#[repr(C, u8)]
pub enum AzOptionX11Visual {
    None,
    Some(*const c_void),
}

/// Re-export of rust-allocated (stack based) `OptionI32` struct
#[repr(C, u8)]
pub enum AzOptionI32 {
    None,
    Some(i32),
}

/// Re-export of rust-allocated (stack based) `OptionF32` struct
#[repr(C, u8)]
pub enum AzOptionF32 {
    None,
    Some(f32),
}

/// Option<char> but the char is a u32, for C FFI stability reasons
#[repr(C, u8)]
pub enum AzOptionChar {
    None,
    Some(u32),
}

/// Re-export of rust-allocated (stack based) `OptionUsize` struct
#[repr(C, u8)]
pub enum AzOptionUsize {
    None,
    Some(usize),
}

/// Re-export of rust-allocated (stack based) `SvgParseErrorPosition` struct
#[repr(C)]
pub struct AzSvgParseErrorPosition {
    pub row: u32,
    pub col: u32,
}

/// External system callbacks to get the system time or create / manage threads
#[repr(C)]
pub struct AzSystemCallbacks {
    pub create_thread_fn: AzCreateThreadFn,
    pub get_system_time_fn: AzGetSystemTimeFn,
}

/// Force a specific renderer: note that azul will **crash** on startup if the `RendererOptions` are
/// not satisfied.
#[repr(C)]
pub struct AzRendererOptions {
    pub vsync: AzVsyncEnumWrapper,
    pub srgb: AzSrgbEnumWrapper,
    pub hw_accel: AzHwAccelerationEnumWrapper,
}

/// Represents a rectangle in physical pixels (integer units)
#[repr(C)]
pub struct AzLayoutRect {
    pub origin: AzLayoutPoint,
    pub size: AzLayoutSize,
}

/// Raw platform handle, for integration in / with other toolkits and custom non-azul window
/// extensions
#[repr(C, u8)]
pub enum AzRawWindowHandle {
    IOS(AzIOSHandle),
    MacOS(AzMacOSHandle),
    Xlib(AzXlibHandle),
    Xcb(AzXcbHandle),
    Wayland(AzWaylandHandle),
    Windows(AzWindowsHandle),
    Web(AzWebHandle),
    Android(AzAndroidHandle),
    Unsupported,
}

/// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd want for
/// hit-testing and positioning elements.
#[repr(C)]
pub struct AzLogicalRect {
    pub origin: AzLogicalPosition,
    pub size: AzLogicalSize,
}

/// Symbolic accelerator key (ctrl, alt, shift)
#[repr(C, u8)]
pub enum AzAcceleratorKey {
    Ctrl,
    Alt,
    Shift,
    Key(AzVirtualKeyCode),
}

/// Boolean flags relating to the current window state
#[repr(C)]
pub struct AzWindowFlags {
    pub frame: AzWindowFrameEnumWrapper,
    pub is_about_to_close: bool,
    pub has_decorations: bool,
    pub is_visible: bool,
    pub is_always_on_top: bool,
    pub is_resizable: bool,
    pub has_focus: bool,
    pub has_extended_window_frame: bool,
    pub has_blur_behind_window: bool,
    pub smooth_scroll_enabled: bool,
    pub autotab_enabled: bool,
}

/// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on startup
/// (gets initialized on the first frame).
#[repr(C, u8)]
pub enum AzCursorPosition {
    OutOfWindow(AzLogicalPosition),
    Uninitialized,
    InWindow(AzLogicalPosition),
}

/// Position of the top left corner of the window relative to the top left of the monitor
#[repr(C, u8)]
pub enum AzWindowPosition {
    Uninitialized,
    Initialized(AzPhysicalPositionI32),
}

/// Position of the virtual keyboard necessary to insert CJK characters
#[repr(C, u8)]
pub enum AzImePosition {
    Uninitialized,
    Initialized(AzLogicalPosition),
}

/// Describes a rendering configuration for a monitor
#[repr(C)]
pub struct AzVideoMode {
    pub size: AzLayoutSize,
    pub bit_depth: u16,
    pub refresh_rate: u16,
}

/// Combination of node ID + DOM ID, both together can identify a node
#[repr(C)]
pub struct AzDomNodeId {
    pub dom: AzDomId,
    pub node: AzNodeId,
}

/// Re-export of rust-allocated (stack based) `PositionInfo` struct
#[repr(C, u8)]
pub enum AzPositionInfo {
    Static(AzPositionInfoInner),
    Fixed(AzPositionInfoInner),
    Absolute(AzPositionInfoInner),
    Relative(AzPositionInfoInner),
}

/// Re-export of rust-allocated (stack based) `HidpiAdjustedBounds` struct
#[repr(C)]
pub struct AzHidpiAdjustedBounds {
    pub logical_size: AzLogicalSize,
    pub hidpi_factor: f32,
}

/// Re-export of rust-allocated (stack based) `InlineGlyph` struct
#[repr(C)]
pub struct AzInlineGlyph {
    pub bounds: AzLogicalRect,
    pub unicode_codepoint: AzOptionCharEnumWrapper,
    pub glyph_index: u32,
}

/// Re-export of rust-allocated (stack based) `InlineTextHit` struct
#[repr(C)]
pub struct AzInlineTextHit {
    pub unicode_codepoint: AzOptionCharEnumWrapper,
    pub hit_relative_to_inline_text: AzLogicalPosition,
    pub hit_relative_to_line: AzLogicalPosition,
    pub hit_relative_to_text_content: AzLogicalPosition,
    pub hit_relative_to_glyph: AzLogicalPosition,
    pub line_index_relative_to_text: usize,
    pub word_index_relative_to_text: usize,
    pub text_content_index_relative_to_text: usize,
    pub glyph_index_relative_to_text: usize,
    pub char_index_relative_to_text: usize,
    pub word_index_relative_to_line: usize,
    pub text_content_index_relative_to_line: usize,
    pub glyph_index_relative_to_line: usize,
    pub char_index_relative_to_line: usize,
    pub glyph_index_relative_to_word: usize,
    pub char_index_relative_to_word: usize,
}

/// Re-export of rust-allocated (stack based) `IFrameCallbackInfo` struct
#[repr(C)]
pub struct AzIFrameCallbackInfo {
    pub system_fonts: *const c_void,
    pub image_cache: *const c_void,
    pub window_theme: AzWindowThemeEnumWrapper,
    pub bounds: AzHidpiAdjustedBounds,
    pub scroll_size: AzLogicalSize,
    pub scroll_offset: AzLogicalPosition,
    pub virtual_scroll_size: AzLogicalSize,
    pub virtual_scroll_offset: AzLogicalPosition,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `TimerCallbackReturn` struct
#[repr(C)]
pub struct AzTimerCallbackReturn {
    pub should_update: AzUpdateEnumWrapper,
    pub should_terminate: AzTerminateTimerEnumWrapper,
}

/// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct. `RefAny`
/// can be up- and downcasted (this usually done via generics and can't be expressed in the Rust
/// API)
#[repr(C)]
pub struct AzRefAny {
    pub _internal_ptr: *const c_void,
    pub sharing_info: AzRefCount,
    pub instance_id: u64,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `IFrameNode` struct
#[repr(C)]
pub struct AzIFrameNode {
    pub callback: AzIFrameCallback,
    pub data: AzRefAny,
}

/// Re-export of rust-allocated (stack based) `NotEventFilter` struct
#[repr(C, u8)]
pub enum AzNotEventFilter {
    Hover(AzHoverEventFilter),
    Focus(AzFocusEventFilter),
}

/// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is activated
#[repr(C)]
pub struct AzMenuCallback {
    pub callback: AzCallback,
    pub data: AzRefAny,
}

/// Icon of a menu entry
#[repr(C, u8)]
pub enum AzMenuItemIcon {
    Checkbox(bool),
    Image(AzImageRef),
}

/// Re-export of rust-allocated (stack based) `CssNthChildSelector` struct
#[repr(C, u8)]
pub enum AzCssNthChildSelector {
    Number(u32),
    Even,
    Odd,
    Pattern(AzCssNthChildPattern),
}

/// Re-export of rust-allocated (stack based) `PixelValue` struct
#[repr(C)]
pub struct AzPixelValue {
    pub metric: AzSizeMetricEnumWrapper,
    pub number: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `PixelValueNoPercent` struct
#[repr(C)]
pub struct AzPixelValueNoPercent {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBoxShadow` struct
#[repr(C)]
pub struct AzStyleBoxShadow {
    pub offset: [AzPixelValueNoPercent; 2],
    pub color: AzColorU,
    pub blur_radius: AzPixelValueNoPercent,
    pub spread_radius: AzPixelValueNoPercent,
    pub clip_mode: AzBoxShadowClipModeEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `StyleBlur` struct
#[repr(C)]
pub struct AzStyleBlur {
    pub width: AzPixelValue,
    pub height: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleColorMatrix` struct
#[repr(C)]
pub struct AzStyleColorMatrix {
    pub matrix: [AzFloatValue; 20],
}

/// Re-export of rust-allocated (stack based) `StyleFilterOffset` struct
#[repr(C)]
pub struct AzStyleFilterOffset {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleCompositeFilter` struct
#[repr(C, u8)]
pub enum AzStyleCompositeFilter {
    Over,
    In,
    Atop,
    Out,
    Xor,
    Lighter,
    Arithmetic([AzFloatValue; 4]),
}

/// Re-export of rust-allocated (stack based) `LayoutBottom` struct
#[repr(C)]
pub struct AzLayoutBottom {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexGrow` struct
#[repr(C)]
pub struct AzLayoutFlexGrow {
    pub inner: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `LayoutFlexShrink` struct
#[repr(C)]
pub struct AzLayoutFlexShrink {
    pub inner: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `LayoutHeight` struct
#[repr(C)]
pub struct AzLayoutHeight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutLeft` struct
#[repr(C)]
pub struct AzLayoutLeft {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginBottom` struct
#[repr(C)]
pub struct AzLayoutMarginBottom {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginLeft` struct
#[repr(C)]
pub struct AzLayoutMarginLeft {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginRight` struct
#[repr(C)]
pub struct AzLayoutMarginRight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMarginTop` struct
#[repr(C)]
pub struct AzLayoutMarginTop {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMaxHeight` struct
#[repr(C)]
pub struct AzLayoutMaxHeight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMaxWidth` struct
#[repr(C)]
pub struct AzLayoutMaxWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMinHeight` struct
#[repr(C)]
pub struct AzLayoutMinHeight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutMinWidth` struct
#[repr(C)]
pub struct AzLayoutMinWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingBottom` struct
#[repr(C)]
pub struct AzLayoutPaddingBottom {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingLeft` struct
#[repr(C)]
pub struct AzLayoutPaddingLeft {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingRight` struct
#[repr(C)]
pub struct AzLayoutPaddingRight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingTop` struct
#[repr(C)]
pub struct AzLayoutPaddingTop {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutRight` struct
#[repr(C)]
pub struct AzLayoutRight {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutTop` struct
#[repr(C)]
pub struct AzLayoutTop {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `LayoutWidth` struct
#[repr(C)]
pub struct AzLayoutWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `PercentageValue` struct
#[repr(C)]
pub struct AzPercentageValue {
    pub number: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `AngleValue` struct
#[repr(C)]
pub struct AzAngleValue {
    pub metric: AzAngleMetricEnumWrapper,
    pub number: AzFloatValue,
}

/// Re-export of rust-allocated (stack based) `NormalizedLinearColorStop` struct
#[repr(C)]
pub struct AzNormalizedLinearColorStop {
    pub offset: AzPercentageValue,
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `NormalizedRadialColorStop` struct
#[repr(C)]
pub struct AzNormalizedRadialColorStop {
    pub offset: AzAngleValue,
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `DirectionCorners` struct
#[repr(C)]
pub struct AzDirectionCorners {
    pub from: AzDirectionCornerEnumWrapper,
    pub to: AzDirectionCornerEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `Direction` struct
#[repr(C, u8)]
pub enum AzDirection {
    Angle(AzAngleValue),
    FromTo(AzDirectionCorners),
}

/// Re-export of rust-allocated (stack based) `BackgroundPositionHorizontal` struct
#[repr(C, u8)]
pub enum AzBackgroundPositionHorizontal {
    Left,
    Center,
    Right,
    Exact(AzPixelValue),
}

/// Re-export of rust-allocated (stack based) `BackgroundPositionVertical` struct
#[repr(C, u8)]
pub enum AzBackgroundPositionVertical {
    Top,
    Center,
    Bottom,
    Exact(AzPixelValue),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundPosition` struct
#[repr(C)]
pub struct AzStyleBackgroundPosition {
    pub horizontal: AzBackgroundPositionHorizontalEnumWrapper,
    pub vertical: AzBackgroundPositionVerticalEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundSize` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundSize {
    ExactSize([AzPixelValue; 2]),
    Contain,
    Cover,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomColor` struct
#[repr(C)]
pub struct AzStyleBorderBottomColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadius` struct
#[repr(C)]
pub struct AzStyleBorderBottomLeftRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadius` struct
#[repr(C)]
pub struct AzStyleBorderBottomRightRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomStyle` struct
#[repr(C)]
pub struct AzStyleBorderBottomStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidth` struct
#[repr(C)]
pub struct AzLayoutBorderBottomWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftColor` struct
#[repr(C)]
pub struct AzStyleBorderLeftColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftStyle` struct
#[repr(C)]
pub struct AzStyleBorderLeftStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidth` struct
#[repr(C)]
pub struct AzLayoutBorderLeftWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightColor` struct
#[repr(C)]
pub struct AzStyleBorderRightColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightStyle` struct
#[repr(C)]
pub struct AzStyleBorderRightStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderRightWidth` struct
#[repr(C)]
pub struct AzLayoutBorderRightWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopColor` struct
#[repr(C)]
pub struct AzStyleBorderTopColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadius` struct
#[repr(C)]
pub struct AzStyleBorderTopLeftRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadius` struct
#[repr(C)]
pub struct AzStyleBorderTopRightRadius {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopStyle` struct
#[repr(C)]
pub struct AzStyleBorderTopStyle {
    pub inner: AzBorderStyleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `LayoutBorderTopWidth` struct
#[repr(C)]
pub struct AzLayoutBorderTopWidth {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleFontSize` struct
#[repr(C)]
pub struct AzStyleFontSize {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleLetterSpacing` struct
#[repr(C)]
pub struct AzStyleLetterSpacing {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleLineHeight` struct
#[repr(C)]
pub struct AzStyleLineHeight {
    pub inner: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTabWidth` struct
#[repr(C)]
pub struct AzStyleTabWidth {
    pub inner: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleOpacity` struct
#[repr(C)]
pub struct AzStyleOpacity {
    pub inner: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformOrigin` struct
#[repr(C)]
pub struct AzStyleTransformOrigin {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StylePerspectiveOrigin` struct
#[repr(C)]
pub struct AzStylePerspectiveOrigin {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformMatrix2D` struct
#[repr(C)]
pub struct AzStyleTransformMatrix2D {
    pub a: AzPixelValue,
    pub b: AzPixelValue,
    pub c: AzPixelValue,
    pub d: AzPixelValue,
    pub tx: AzPixelValue,
    pub ty: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformMatrix3D` struct
#[repr(C)]
pub struct AzStyleTransformMatrix3D {
    pub m11: AzPixelValue,
    pub m12: AzPixelValue,
    pub m13: AzPixelValue,
    pub m14: AzPixelValue,
    pub m21: AzPixelValue,
    pub m22: AzPixelValue,
    pub m23: AzPixelValue,
    pub m24: AzPixelValue,
    pub m31: AzPixelValue,
    pub m32: AzPixelValue,
    pub m33: AzPixelValue,
    pub m34: AzPixelValue,
    pub m41: AzPixelValue,
    pub m42: AzPixelValue,
    pub m43: AzPixelValue,
    pub m44: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformTranslate2D` struct
#[repr(C)]
pub struct AzStyleTransformTranslate2D {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformTranslate3D` struct
#[repr(C)]
pub struct AzStyleTransformTranslate3D {
    pub x: AzPixelValue,
    pub y: AzPixelValue,
    pub z: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformRotate3D` struct
#[repr(C)]
pub struct AzStyleTransformRotate3D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
    pub z: AzPercentageValue,
    pub angle: AzAngleValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformScale2D` struct
#[repr(C)]
pub struct AzStyleTransformScale2D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformScale3D` struct
#[repr(C)]
pub struct AzStyleTransformScale3D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
    pub z: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTransformSkew2D` struct
#[repr(C)]
pub struct AzStyleTransformSkew2D {
    pub x: AzPercentageValue,
    pub y: AzPercentageValue,
}

/// Re-export of rust-allocated (stack based) `StyleTextColor` struct
#[repr(C)]
pub struct AzStyleTextColor {
    pub inner: AzColorU,
}

/// Re-export of rust-allocated (stack based) `StyleWordSpacing` struct
#[repr(C)]
pub struct AzStyleWordSpacing {
    pub inner: AzPixelValue,
}

/// Re-export of rust-allocated (stack based) `StyleBoxShadowValue` struct
#[repr(C, u8)]
pub enum AzStyleBoxShadowValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBoxShadow),
}

/// Re-export of rust-allocated (stack based) `LayoutAlignContentValue` struct
#[repr(C, u8)]
pub enum AzLayoutAlignContentValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutAlignContent),
}

/// Re-export of rust-allocated (stack based) `LayoutAlignItemsValue` struct
#[repr(C, u8)]
pub enum AzLayoutAlignItemsValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutAlignItems),
}

/// Re-export of rust-allocated (stack based) `LayoutBottomValue` struct
#[repr(C, u8)]
pub enum AzLayoutBottomValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBottom),
}

/// Re-export of rust-allocated (stack based) `LayoutBoxSizingValue` struct
#[repr(C, u8)]
pub enum AzLayoutBoxSizingValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBoxSizing),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexDirectionValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexDirectionValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexDirection),
}

/// Re-export of rust-allocated (stack based) `LayoutDisplayValue` struct
#[repr(C, u8)]
pub enum AzLayoutDisplayValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutDisplay),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexGrowValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexGrowValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexGrow),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexShrinkValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexShrinkValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexShrink),
}

/// Re-export of rust-allocated (stack based) `LayoutFloatValue` struct
#[repr(C, u8)]
pub enum AzLayoutFloatValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFloat),
}

/// Re-export of rust-allocated (stack based) `LayoutHeightValue` struct
#[repr(C, u8)]
pub enum AzLayoutHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutHeight),
}

/// Re-export of rust-allocated (stack based) `LayoutJustifyContentValue` struct
#[repr(C, u8)]
pub enum AzLayoutJustifyContentValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutJustifyContent),
}

/// Re-export of rust-allocated (stack based) `LayoutLeftValue` struct
#[repr(C, u8)]
pub enum AzLayoutLeftValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutLeft),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginBottomValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginBottomValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginBottom),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginLeftValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginLeftValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginLeft),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginRightValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginRightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginRight),
}

/// Re-export of rust-allocated (stack based) `LayoutMarginTopValue` struct
#[repr(C, u8)]
pub enum AzLayoutMarginTopValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMarginTop),
}

/// Re-export of rust-allocated (stack based) `LayoutMaxHeightValue` struct
#[repr(C, u8)]
pub enum AzLayoutMaxHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMaxHeight),
}

/// Re-export of rust-allocated (stack based) `LayoutMaxWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutMaxWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMaxWidth),
}

/// Re-export of rust-allocated (stack based) `LayoutMinHeightValue` struct
#[repr(C, u8)]
pub enum AzLayoutMinHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMinHeight),
}

/// Re-export of rust-allocated (stack based) `LayoutMinWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutMinWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutMinWidth),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingBottomValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingBottomValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingBottom),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingLeftValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingLeftValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingLeft),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingRightValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingRightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingRight),
}

/// Re-export of rust-allocated (stack based) `LayoutPaddingTopValue` struct
#[repr(C, u8)]
pub enum AzLayoutPaddingTopValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPaddingTop),
}

/// Re-export of rust-allocated (stack based) `LayoutPositionValue` struct
#[repr(C, u8)]
pub enum AzLayoutPositionValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutPosition),
}

/// Re-export of rust-allocated (stack based) `LayoutRightValue` struct
#[repr(C, u8)]
pub enum AzLayoutRightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutRight),
}

/// Re-export of rust-allocated (stack based) `LayoutTopValue` struct
#[repr(C, u8)]
pub enum AzLayoutTopValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutTop),
}

/// Re-export of rust-allocated (stack based) `LayoutWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutWidth),
}

/// Re-export of rust-allocated (stack based) `LayoutFlexWrapValue` struct
#[repr(C, u8)]
pub enum AzLayoutFlexWrapValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutFlexWrap),
}

/// Re-export of rust-allocated (stack based) `LayoutOverflowValue` struct
#[repr(C, u8)]
pub enum AzLayoutOverflowValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutOverflow),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomLeftRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomLeftRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomRightRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomRightRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderBottomStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderBottomStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderBottomStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderBottomWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderBottomWidth),
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderLeftColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderLeftColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderLeftStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderLeftStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderLeftStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderLeftWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderLeftWidth),
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderRightColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderRightColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderRightStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderRightStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderRightStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderRightWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderRightWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderRightWidth),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopColorValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopColor),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopLeftRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopLeftRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadiusValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopRightRadiusValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopRightRadius),
}

/// Re-export of rust-allocated (stack based) `StyleBorderTopStyleValue` struct
#[repr(C, u8)]
pub enum AzStyleBorderTopStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBorderTopStyle),
}

/// Re-export of rust-allocated (stack based) `LayoutBorderTopWidthValue` struct
#[repr(C, u8)]
pub enum AzLayoutBorderTopWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzLayoutBorderTopWidth),
}

/// Re-export of rust-allocated (stack based) `StyleCursorValue` struct
#[repr(C, u8)]
pub enum AzStyleCursorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleCursor),
}

/// Re-export of rust-allocated (stack based) `StyleFontSizeValue` struct
#[repr(C, u8)]
pub enum AzStyleFontSizeValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleFontSize),
}

/// Re-export of rust-allocated (stack based) `StyleLetterSpacingValue` struct
#[repr(C, u8)]
pub enum AzStyleLetterSpacingValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleLetterSpacing),
}

/// Re-export of rust-allocated (stack based) `StyleLineHeightValue` struct
#[repr(C, u8)]
pub enum AzStyleLineHeightValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleLineHeight),
}

/// Re-export of rust-allocated (stack based) `StyleTabWidthValue` struct
#[repr(C, u8)]
pub enum AzStyleTabWidthValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTabWidth),
}

/// Re-export of rust-allocated (stack based) `StyleTextAlignValue` struct
#[repr(C, u8)]
pub enum AzStyleTextAlignValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTextAlign),
}

/// Re-export of rust-allocated (stack based) `StyleTextColorValue` struct
#[repr(C, u8)]
pub enum AzStyleTextColorValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTextColor),
}

/// Re-export of rust-allocated (stack based) `StyleWordSpacingValue` struct
#[repr(C, u8)]
pub enum AzStyleWordSpacingValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleWordSpacing),
}

/// Re-export of rust-allocated (stack based) `StyleOpacityValue` struct
#[repr(C, u8)]
pub enum AzStyleOpacityValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleOpacity),
}

/// Re-export of rust-allocated (stack based) `StyleTransformOriginValue` struct
#[repr(C, u8)]
pub enum AzStyleTransformOriginValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTransformOrigin),
}

/// Re-export of rust-allocated (stack based) `StylePerspectiveOriginValue` struct
#[repr(C, u8)]
pub enum AzStylePerspectiveOriginValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStylePerspectiveOrigin),
}

/// Re-export of rust-allocated (stack based) `StyleBackfaceVisibilityValue` struct
#[repr(C, u8)]
pub enum AzStyleBackfaceVisibilityValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackfaceVisibility),
}

/// Re-export of rust-allocated (stack based) `StyleMixBlendModeValue` struct
#[repr(C, u8)]
pub enum AzStyleMixBlendModeValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleMixBlendMode),
}

/// Re-export of rust-allocated (stack based) `ButtonOnClick` struct
#[repr(C)]
pub struct AzButtonOnClick {
    pub data: AzRefAny,
    pub callback: AzCallback,
}

/// Re-export of rust-allocated (stack based) `FileInputOnPathChange` struct
#[repr(C)]
pub struct AzFileInputOnPathChange {
    pub data: AzRefAny,
    pub callback: AzFileInputOnPathChangeCallback,
}

/// Re-export of rust-allocated (stack based) `CheckBoxOnToggle` struct
#[repr(C)]
pub struct AzCheckBoxOnToggle {
    pub data: AzRefAny,
    pub callback: AzCheckBoxOnToggleCallback,
}

/// Re-export of rust-allocated (stack based) `ColorInputState` struct
#[repr(C)]
pub struct AzColorInputState {
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `ColorInputOnValueChange` struct
#[repr(C)]
pub struct AzColorInputOnValueChange {
    pub data: AzRefAny,
    pub callback: AzColorInputOnValueChangeCallback,
}

/// Re-export of rust-allocated (stack based) `TextInputSelection` struct
#[repr(C, u8)]
pub enum AzTextInputSelection {
    All,
    FromTo(AzTextInputSelectionRange),
}

/// Re-export of rust-allocated (stack based) `TextInputOnTextInput` struct
#[repr(C)]
pub struct AzTextInputOnTextInput {
    pub data: AzRefAny,
    pub callback: AzTextInputOnTextInputCallback,
}

/// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDown` struct
#[repr(C)]
pub struct AzTextInputOnVirtualKeyDown {
    pub data: AzRefAny,
    pub callback: AzTextInputOnVirtualKeyDownCallback,
}

/// Re-export of rust-allocated (stack based) `TextInputOnFocusLost` struct
#[repr(C)]
pub struct AzTextInputOnFocusLost {
    pub data: AzRefAny,
    pub callback: AzTextInputOnFocusLostCallback,
}

/// Re-export of rust-allocated (stack based) `OnTextInputReturn` struct
#[repr(C)]
pub struct AzOnTextInputReturn {
    pub update: AzUpdateEnumWrapper,
    pub valid: AzTextInputValidEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `NumberInputOnValueChange` struct
#[repr(C)]
pub struct AzNumberInputOnValueChange {
    pub data: AzRefAny,
    pub callback: AzNumberInputOnValueChangeCallback,
}

/// Re-export of rust-allocated (stack based) `NumberInputOnFocusLost` struct
#[repr(C)]
pub struct AzNumberInputOnFocusLost {
    pub data: AzRefAny,
    pub callback: AzNumberInputOnFocusLostCallback,
}

/// Re-export of rust-allocated (stack based) `TabOnClick` struct
#[repr(C)]
pub struct AzTabOnClick {
    pub data: AzRefAny,
    pub callback: AzTabOnClickCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAdded` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeAdded {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeAddedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemoved` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeRemoved {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeRemovedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDragged` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeGraphDragged {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeGraphDraggedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDragged` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeDragged {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeDraggedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnected` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeConnected {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeConnectedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnected` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeInputDisconnected {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeInputDisconnectedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnected` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeOutputDisconnected {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeOutputDisconnectedCallback,
}

/// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEdited` struct
#[repr(C)]
pub struct AzNodeGraphOnNodeFieldEdited {
    pub data: AzRefAny,
    pub callback: AzNodeGraphOnNodeFieldEditedCallback,
}

/// Re-export of rust-allocated (stack based) `OutputNodeAndIndex` struct
#[repr(C)]
pub struct AzOutputNodeAndIndex {
    pub node_id: AzNodeGraphNodeId,
    pub output_index: usize,
}

/// Re-export of rust-allocated (stack based) `InputNodeAndIndex` struct
#[repr(C)]
pub struct AzInputNodeAndIndex {
    pub node_id: AzNodeGraphNodeId,
    pub input_index: usize,
}

/// Re-export of rust-allocated (stack based) `ListViewOnLazyLoadScroll` struct
#[repr(C)]
pub struct AzListViewOnLazyLoadScroll {
    pub data: AzRefAny,
    pub callback: AzListViewOnLazyLoadScrollCallback,
}

/// Re-export of rust-allocated (stack based) `ListViewOnColumnClick` struct
#[repr(C)]
pub struct AzListViewOnColumnClick {
    pub data: AzRefAny,
    pub callback: AzListViewOnColumnClickCallback,
}

/// Re-export of rust-allocated (stack based) `ListViewOnRowClick` struct
#[repr(C)]
pub struct AzListViewOnRowClick {
    pub data: AzRefAny,
    pub callback: AzListViewOnRowClickCallback,
}

/// Re-export of rust-allocated (stack based) `DropDownOnChoiceChange` struct
#[repr(C)]
pub struct AzDropDownOnChoiceChange {
    pub data: AzRefAny,
    pub callback: AzDropDownOnChoiceChangeCallback,
}

/// Re-export of rust-allocated (stack based) `ParentWithNodeDepth` struct
#[repr(C)]
pub struct AzParentWithNodeDepth {
    pub depth: usize,
    pub node_id: AzNodeId,
}

/// Re-export of rust-allocated (stack based) `Gl` struct
#[repr(C)]
pub struct AzGl {
    pub ptr: *const c_void,
    pub renderer_type: AzRendererTypeEnumWrapper,
    pub run_destructor: bool,
}

/// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`
#[repr(C)]
pub struct AzRefstrVecRef {
    pub(crate) ptr: *const AzRefstr,
    pub len: usize,
}

/// Re-export of rust-allocated (stack based) `ImageMask` struct
#[repr(C)]
pub struct AzImageMask {
    pub image: AzImageRef,
    pub rect: AzLogicalRect,
    pub repeat: bool,
}

/// Re-export of rust-allocated (stack based) `FontMetrics` struct
#[repr(C)]
pub struct AzFontMetrics {
    pub units_per_em: u16,
    pub font_flags: u16,
    pub x_min: i16,
    pub y_min: i16,
    pub x_max: i16,
    pub y_max: i16,
    pub ascender: i16,
    pub descender: i16,
    pub line_gap: i16,
    pub advance_width_max: u16,
    pub min_left_side_bearing: i16,
    pub min_right_side_bearing: i16,
    pub x_max_extent: i16,
    pub caret_slope_rise: i16,
    pub caret_slope_run: i16,
    pub caret_offset: i16,
    pub num_h_metrics: u16,
    pub x_avg_char_width: i16,
    pub us_weight_class: u16,
    pub us_width_class: u16,
    pub fs_type: u16,
    pub y_subscript_x_size: i16,
    pub y_subscript_y_size: i16,
    pub y_subscript_x_offset: i16,
    pub y_subscript_y_offset: i16,
    pub y_superscript_x_size: i16,
    pub y_superscript_y_size: i16,
    pub y_superscript_x_offset: i16,
    pub y_superscript_y_offset: i16,
    pub y_strikeout_size: i16,
    pub y_strikeout_position: i16,
    pub s_family_class: i16,
    pub panose: [u8; 10],
    pub ul_unicode_range1: u32,
    pub ul_unicode_range2: u32,
    pub ul_unicode_range3: u32,
    pub ul_unicode_range4: u32,
    pub ach_vend_id: u32,
    pub fs_selection: u16,
    pub us_first_char_index: u16,
    pub us_last_char_index: u16,
    pub s_typo_ascender: AzOptionI16EnumWrapper,
    pub s_typo_descender: AzOptionI16EnumWrapper,
    pub s_typo_line_gap: AzOptionI16EnumWrapper,
    pub us_win_ascent: AzOptionU16EnumWrapper,
    pub us_win_descent: AzOptionU16EnumWrapper,
    pub ul_code_page_range1: AzOptionU32EnumWrapper,
    pub ul_code_page_range2: AzOptionU32EnumWrapper,
    pub sx_height: AzOptionI16EnumWrapper,
    pub s_cap_height: AzOptionI16EnumWrapper,
    pub us_default_char: AzOptionU16EnumWrapper,
    pub us_break_char: AzOptionU16EnumWrapper,
    pub us_max_context: AzOptionU16EnumWrapper,
    pub us_lower_optical_point_size: AzOptionU16EnumWrapper,
    pub us_upper_optical_point_size: AzOptionU16EnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgLine` struct
#[repr(C)]
pub struct AzSvgLine {
    pub start: AzSvgPoint,
    pub end: AzSvgPoint,
}

/// Re-export of rust-allocated (stack based) `SvgQuadraticCurve` struct
#[repr(C)]
pub struct AzSvgQuadraticCurve {
    pub start: AzSvgPoint,
    pub ctrl: AzSvgPoint,
    pub end: AzSvgPoint,
}

/// Re-export of rust-allocated (stack based) `SvgCubicCurve` struct
#[repr(C)]
pub struct AzSvgCubicCurve {
    pub start: AzSvgPoint,
    pub ctrl_1: AzSvgPoint,
    pub ctrl_2: AzSvgPoint,
    pub end: AzSvgPoint,
}

/// Re-export of rust-allocated (stack based) `SvgStringFormatOptions` struct
#[repr(C)]
pub struct AzSvgStringFormatOptions {
    pub use_single_quote: bool,
    pub indent: AzIndentEnumWrapper,
    pub attributes_indent: AzIndentEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgFillStyle` struct
#[repr(C)]
pub struct AzSvgFillStyle {
    pub line_join: AzSvgLineJoinEnumWrapper,
    pub miter_limit: f32,
    pub tolerance: f32,
    pub fill_rule: AzSvgFillRuleEnumWrapper,
    pub transform: AzSvgTransform,
    pub anti_alias: bool,
    pub high_quality_aa: bool,
}

/// Re-export of rust-allocated (stack based) `InstantPtr` struct
#[repr(C)]
pub struct AzInstantPtr {
    pub ptr: *const c_void,
    pub clone_fn: AzInstantPtrCloneFn,
    pub destructor: AzInstantPtrDestructorFn,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `Duration` struct
#[repr(C, u8)]
pub enum AzDuration {
    System(AzSystemTimeDiff),
    Tick(AzSystemTickDiff),
}

/// Re-export of rust-allocated (stack based) `ThreadSendMsg` struct
#[repr(C, u8)]
pub enum AzThreadSendMsg {
    TerminateThread,
    Tick,
    Custom(AzRefAny),
}

/// Re-export of rust-allocated (stack based) `ThreadWriteBackMsg` struct
#[repr(C)]
pub struct AzThreadWriteBackMsg {
    pub data: AzRefAny,
    pub callback: AzWriteBackCallback,
}

/// Wrapper over a Rust-allocated `Vec<LogicalRect>`
#[repr(C)]
pub struct AzLogicalRectVec {
    pub(crate) ptr: *const AzLogicalRect,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzLogicalRectVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`
#[repr(C)]
pub struct AzInputOutputTypeIdVec {
    pub(crate) ptr: *const AzInputOutputTypeId,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputOutputTypeIdVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`
#[repr(C)]
pub struct AzOutputNodeAndIndexVec {
    pub(crate) ptr: *const AzOutputNodeAndIndex,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzOutputNodeAndIndexVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`
#[repr(C)]
pub struct AzInputNodeAndIndexVec {
    pub(crate) ptr: *const AzInputNodeAndIndex,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputNodeAndIndexVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<AccessibilityState>`
#[repr(C)]
pub struct AzAccessibilityStateVec {
    pub(crate) ptr: *const AzAccessibilityStateEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzAccessibilityStateVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<MenuItem>`
#[repr(C)]
pub struct AzMenuItemVec {
    pub(crate) ptr: *const AzMenuItemEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzMenuItemVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<XmlNode>`
#[repr(C)]
pub struct AzXmlNodeVec {
    pub(crate) ptr: *const AzXmlNode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzXmlNodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineGlyph>`
#[repr(C)]
pub struct AzInlineGlyphVec {
    pub(crate) ptr: *const AzInlineGlyph,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineGlyphVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineTextHit>`
#[repr(C)]
pub struct AzInlineTextHitVec {
    pub(crate) ptr: *const AzInlineTextHit,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineTextHitVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<VideoMode>`
#[repr(C)]
pub struct AzVideoModeVec {
    pub(crate) ptr: *const AzVideoMode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzVideoModeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<Dom>`
#[repr(C)]
pub struct AzDomVec {
    pub(crate) ptr: *const AzDom,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzDomVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`
#[repr(C)]
pub struct AzStyleBackgroundPositionVec {
    pub(crate) ptr: *const AzStyleBackgroundPosition,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundPositionVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`
#[repr(C)]
pub struct AzStyleBackgroundRepeatVec {
    pub(crate) ptr: *const AzStyleBackgroundRepeatEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundRepeatVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`
#[repr(C)]
pub struct AzStyleBackgroundSizeVec {
    pub(crate) ptr: *const AzStyleBackgroundSizeEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundSizeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `SvgVertex`
#[repr(C)]
pub struct AzSvgVertexVec {
    pub(crate) ptr: *const AzSvgVertex,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgVertexVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `SvgColoredVertex`
#[repr(C)]
pub struct AzSvgColoredVertexVec {
    pub(crate) ptr: *const AzSvgColoredVertex,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgColoredVertexVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<u32>`
#[repr(C)]
pub struct AzU32Vec {
    pub ptr: *const u32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzU32VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `XWindowType`
#[repr(C)]
pub struct AzXWindowTypeVec {
    pub(crate) ptr: *const AzXWindowTypeEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzXWindowTypeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `VirtualKeyCode`
#[repr(C)]
pub struct AzVirtualKeyCodeVec {
    pub(crate) ptr: *const AzVirtualKeyCodeEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzVirtualKeyCodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CascadeInfo`
#[repr(C)]
pub struct AzCascadeInfoVec {
    pub(crate) ptr: *const AzCascadeInfo,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCascadeInfoVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `ScanCode`
#[repr(C)]
pub struct AzScanCodeVec {
    pub ptr: *const u32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzScanCodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<u16>`
#[repr(C)]
pub struct AzU16Vec {
    pub ptr: *const u16,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzU16VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<f32>`
#[repr(C)]
pub struct AzF32Vec {
    pub ptr: *const f32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzF32VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `U8Vec`
#[repr(C)]
pub struct AzU8Vec {
    pub ptr: *const u8,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzU8VecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `U32Vec`
#[repr(C)]
pub struct AzGLuintVec {
    pub ptr: *const u32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzGLuintVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `GLintVec`
#[repr(C)]
pub struct AzGLintVec {
    pub ptr: *const i32,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzGLintVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`
#[repr(C)]
pub struct AzNormalizedLinearColorStopVec {
    pub(crate) ptr: *const AzNormalizedLinearColorStop,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNormalizedLinearColorStopVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`
#[repr(C)]
pub struct AzNormalizedRadialColorStopVec {
    pub(crate) ptr: *const AzNormalizedRadialColorStop,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNormalizedRadialColorStopVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NodeIdVec`
#[repr(C)]
pub struct AzNodeIdVec {
    pub(crate) ptr: *const AzNodeId,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeIdVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`
#[repr(C)]
pub struct AzNodeHierarchyItemVec {
    pub(crate) ptr: *const AzNodeHierarchyItem,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeHierarchyItemVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`
#[repr(C)]
pub struct AzParentWithNodeDepthVec {
    pub(crate) ptr: *const AzParentWithNodeDepth,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzParentWithNodeDepthVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionSvgPoint` struct
#[repr(C, u8)]
pub enum AzOptionSvgPoint {
    None,
    Some(AzSvgPoint),
}

/// Re-export of rust-allocated (stack based) `OptionStyleTextAlign` struct
#[repr(C, u8)]
pub enum AzOptionStyleTextAlign {
    None,
    Some(AzStyleTextAlign),
}

/// Re-export of rust-allocated (stack based) `OptionListViewOnRowClick` struct
#[repr(C, u8)]
pub enum AzOptionListViewOnRowClick {
    None,
    Some(AzListViewOnRowClick),
}

/// Re-export of rust-allocated (stack based) `OptionListViewOnColumnClick` struct
#[repr(C, u8)]
pub enum AzOptionListViewOnColumnClick {
    None,
    Some(AzListViewOnColumnClick),
}

/// Re-export of rust-allocated (stack based) `OptionListViewOnLazyLoadScroll` struct
#[repr(C, u8)]
pub enum AzOptionListViewOnLazyLoadScroll {
    None,
    Some(AzListViewOnLazyLoadScroll),
}

/// Re-export of rust-allocated (stack based) `OptionPixelValueNoPercent` struct
#[repr(C, u8)]
pub enum AzOptionPixelValueNoPercent {
    None,
    Some(AzPixelValueNoPercent),
}

/// Re-export of rust-allocated (stack based) `OptionDropDownOnChoiceChange` struct
#[repr(C, u8)]
pub enum AzOptionDropDownOnChoiceChange {
    None,
    Some(AzDropDownOnChoiceChange),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeAdded` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeAdded {
    None,
    Some(AzNodeGraphOnNodeAdded),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeRemoved` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeRemoved {
    None,
    Some(AzNodeGraphOnNodeRemoved),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeGraphDragged` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeGraphDragged {
    None,
    Some(AzNodeGraphOnNodeGraphDragged),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeDragged` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeDragged {
    None,
    Some(AzNodeGraphOnNodeDragged),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeConnected` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeConnected {
    None,
    Some(AzNodeGraphOnNodeConnected),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeInputDisconnected` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeInputDisconnected {
    None,
    Some(AzNodeGraphOnNodeInputDisconnected),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeOutputDisconnected` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeOutputDisconnected {
    None,
    Some(AzNodeGraphOnNodeOutputDisconnected),
}

/// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeFieldEdited` struct
#[repr(C, u8)]
pub enum AzOptionNodeGraphOnNodeFieldEdited {
    None,
    Some(AzNodeGraphOnNodeFieldEdited),
}

/// Re-export of rust-allocated (stack based) `OptionColorInputOnValueChange` struct
#[repr(C, u8)]
pub enum AzOptionColorInputOnValueChange {
    None,
    Some(AzColorInputOnValueChange),
}

/// Re-export of rust-allocated (stack based) `OptionButtonOnClick` struct
#[repr(C, u8)]
pub enum AzOptionButtonOnClick {
    None,
    Some(AzButtonOnClick),
}

/// Re-export of rust-allocated (stack based) `OptionTabOnClick` struct
#[repr(C, u8)]
pub enum AzOptionTabOnClick {
    None,
    Some(AzTabOnClick),
}

/// Re-export of rust-allocated (stack based) `OptionFileInputOnPathChange` struct
#[repr(C, u8)]
pub enum AzOptionFileInputOnPathChange {
    None,
    Some(AzFileInputOnPathChange),
}

/// Re-export of rust-allocated (stack based) `OptionCheckBoxOnToggle` struct
#[repr(C, u8)]
pub enum AzOptionCheckBoxOnToggle {
    None,
    Some(AzCheckBoxOnToggle),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputOnTextInput` struct
#[repr(C, u8)]
pub enum AzOptionTextInputOnTextInput {
    None,
    Some(AzTextInputOnTextInput),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputOnVirtualKeyDown` struct
#[repr(C, u8)]
pub enum AzOptionTextInputOnVirtualKeyDown {
    None,
    Some(AzTextInputOnVirtualKeyDown),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputOnFocusLost` struct
#[repr(C, u8)]
pub enum AzOptionTextInputOnFocusLost {
    None,
    Some(AzTextInputOnFocusLost),
}

/// Re-export of rust-allocated (stack based) `OptionTextInputSelection` struct
#[repr(C, u8)]
pub enum AzOptionTextInputSelection {
    None,
    Some(AzTextInputSelection),
}

/// Re-export of rust-allocated (stack based) `OptionNumberInputOnFocusLost` struct
#[repr(C, u8)]
pub enum AzOptionNumberInputOnFocusLost {
    None,
    Some(AzNumberInputOnFocusLost),
}

/// Re-export of rust-allocated (stack based) `OptionNumberInputOnValueChange` struct
#[repr(C, u8)]
pub enum AzOptionNumberInputOnValueChange {
    None,
    Some(AzNumberInputOnValueChange),
}

/// Re-export of rust-allocated (stack based) `OptionMenuItemIcon` struct
#[repr(C, u8)]
pub enum AzOptionMenuItemIcon {
    None,
    Some(AzMenuItemIcon),
}

/// Re-export of rust-allocated (stack based) `OptionMenuCallback` struct
#[repr(C, u8)]
pub enum AzOptionMenuCallback {
    None,
    Some(AzMenuCallback),
}

/// Re-export of rust-allocated (stack based) `OptionPositionInfo` struct
#[repr(C, u8)]
pub enum AzOptionPositionInfo {
    None,
    Some(AzPositionInfo),
}

/// Re-export of rust-allocated (stack based) `OptionTimerId` struct
#[repr(C, u8)]
pub enum AzOptionTimerId {
    None,
    Some(AzTimerId),
}

/// Re-export of rust-allocated (stack based) `OptionThreadId` struct
#[repr(C, u8)]
pub enum AzOptionThreadId {
    None,
    Some(AzThreadId),
}

/// Re-export of rust-allocated (stack based) `OptionImageRef` struct
#[repr(C, u8)]
pub enum AzOptionImageRef {
    None,
    Some(AzImageRef),
}

/// Re-export of rust-allocated (stack based) `OptionFontRef` struct
#[repr(C, u8)]
pub enum AzOptionFontRef {
    None,
    Some(AzFontRef),
}

/// Re-export of rust-allocated (stack based) `OptionSystemClipboard` struct
#[repr(C, u8)]
pub enum AzOptionSystemClipboard {
    None,
    Some(AzSystemClipboard),
}

/// Re-export of rust-allocated (stack based) `OptionGl` struct
#[repr(C, u8)]
pub enum AzOptionGl {
    None,
    Some(AzGl),
}

/// Re-export of rust-allocated (stack based) `OptionPercentageValue` struct
#[repr(C, u8)]
pub enum AzOptionPercentageValue {
    None,
    Some(AzPercentageValue),
}

/// Re-export of rust-allocated (stack based) `OptionAngleValue` struct
#[repr(C, u8)]
pub enum AzOptionAngleValue {
    None,
    Some(AzAngleValue),
}

/// Re-export of rust-allocated (stack based) `OptionRendererOptions` struct
#[repr(C, u8)]
pub enum AzOptionRendererOptions {
    None,
    Some(AzRendererOptions),
}

/// Re-export of rust-allocated (stack based) `OptionCallback` struct
#[repr(C, u8)]
pub enum AzOptionCallback {
    None,
    Some(AzCallback),
}

/// Re-export of rust-allocated (stack based) `OptionThreadSendMsg` struct
#[repr(C, u8)]
pub enum AzOptionThreadSendMsg {
    None,
    Some(AzThreadSendMsg),
}

/// Re-export of rust-allocated (stack based) `OptionLayoutRect` struct
#[repr(C, u8)]
pub enum AzOptionLayoutRect {
    None,
    Some(AzLayoutRect),
}

/// Re-export of rust-allocated (stack based) `OptionRefAny` struct
#[repr(C, u8)]
pub enum AzOptionRefAny {
    None,
    Some(AzRefAny),
}

/// Re-export of rust-allocated (stack based) `OptionLayoutPoint` struct
#[repr(C, u8)]
pub enum AzOptionLayoutPoint {
    None,
    Some(AzLayoutPoint),
}

/// Re-export of rust-allocated (stack based) `OptionLayoutSize` struct
#[repr(C, u8)]
pub enum AzOptionLayoutSize {
    None,
    Some(AzLayoutSize),
}

/// Re-export of rust-allocated (stack based) `OptionWindowTheme` struct
#[repr(C, u8)]
pub enum AzOptionWindowTheme {
    None,
    Some(AzWindowTheme),
}

/// Re-export of rust-allocated (stack based) `OptionNodeId` struct
#[repr(C, u8)]
pub enum AzOptionNodeId {
    None,
    Some(AzNodeId),
}

/// Re-export of rust-allocated (stack based) `OptionDomNodeId` struct
#[repr(C, u8)]
pub enum AzOptionDomNodeId {
    None,
    Some(AzDomNodeId),
}

/// Re-export of rust-allocated (stack based) `OptionColorU` struct
#[repr(C, u8)]
pub enum AzOptionColorU {
    None,
    Some(AzColorU),
}

/// Re-export of rust-allocated (stack based) `OptionSvgDashPattern` struct
#[repr(C, u8)]
pub enum AzOptionSvgDashPattern {
    None,
    Some(AzSvgDashPattern),
}

/// Re-export of rust-allocated (stack based) `OptionLogicalPosition` struct
#[repr(C, u8)]
pub enum AzOptionLogicalPosition {
    None,
    Some(AzLogicalPosition),
}

/// Re-export of rust-allocated (stack based) `OptionPhysicalPositionI32` struct
#[repr(C, u8)]
pub enum AzOptionPhysicalPositionI32 {
    None,
    Some(AzPhysicalPositionI32),
}

/// Re-export of rust-allocated (stack based) `OptionMouseCursorType` struct
#[repr(C, u8)]
pub enum AzOptionMouseCursorType {
    None,
    Some(AzMouseCursorType),
}

/// Re-export of rust-allocated (stack based) `OptionLogicalSize` struct
#[repr(C, u8)]
pub enum AzOptionLogicalSize {
    None,
    Some(AzLogicalSize),
}

/// Re-export of rust-allocated (stack based) `OptionVirtualKeyCode` struct
#[repr(C, u8)]
pub enum AzOptionVirtualKeyCode {
    None,
    Some(AzVirtualKeyCode),
}

/// Re-export of rust-allocated (stack based) `OptionImageMask` struct
#[repr(C, u8)]
pub enum AzOptionImageMask {
    None,
    Some(AzImageMask),
}

/// Re-export of rust-allocated (stack based) `OptionTabIndex` struct
#[repr(C, u8)]
pub enum AzOptionTabIndex {
    None,
    Some(AzTabIndex),
}

/// Re-export of rust-allocated (stack based) `OptionTagId` struct
#[repr(C, u8)]
pub enum AzOptionTagId {
    None,
    Some(AzTagId),
}

/// Re-export of rust-allocated (stack based) `OptionDuration` struct
#[repr(C, u8)]
pub enum AzOptionDuration {
    None,
    Some(AzDuration),
}

/// Re-export of rust-allocated (stack based) `OptionU8Vec` struct
#[repr(C, u8)]
pub enum AzOptionU8Vec {
    None,
    Some(AzU8Vec),
}

/// Re-export of rust-allocated (stack based) `OptionU8VecRef` struct
#[repr(C, u8)]
pub enum AzOptionU8VecRef {
    None,
    Some(AzU8VecRef),
}

/// Re-export of rust-allocated (stack based) `ResultU8VecEncodeImageError` struct
#[repr(C, u8)]
pub enum AzResultU8VecEncodeImageError {
    Ok(AzU8Vec),
    Err(AzEncodeImageError),
}

/// Re-export of rust-allocated (stack based) `NonXmlCharError` struct
#[repr(C)]
pub struct AzNonXmlCharError {
    pub ch: u32,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidCharError` struct
#[repr(C)]
pub struct AzInvalidCharError {
    pub expected: u8,
    pub got: u8,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidCharMultipleError` struct
#[repr(C)]
pub struct AzInvalidCharMultipleError {
    pub expected: u8,
    pub got: AzU8Vec,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidQuoteError` struct
#[repr(C)]
pub struct AzInvalidQuoteError {
    pub got: u8,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidSpaceError` struct
#[repr(C)]
pub struct AzInvalidSpaceError {
    pub got: u8,
    pub pos: AzSvgParseErrorPosition,
}

/// Configuration for optional features, such as whether to enable logging or panic hooks
#[repr(C)]
pub struct AzAppConfig {
    pub layout_solver: AzLayoutSolverEnumWrapper,
    pub log_level: AzAppLogLevelEnumWrapper,
    pub enable_visual_panic_hook: bool,
    pub enable_logging_on_panic: bool,
    pub enable_tab_navigation: bool,
    pub system_callbacks: AzSystemCallbacks,
}

/// Small (16x16x4) window icon, usually shown in the window titlebar
#[repr(C)]
pub struct AzSmallWindowIconBytes {
    pub key: AzIconKey,
    pub rgba_bytes: AzU8Vec,
}

/// Large (32x32x4) window icon, usually used on high-resolution displays (instead of
/// `SmallWindowIcon`)
#[repr(C)]
pub struct AzLargeWindowIconBytes {
    pub key: AzIconKey,
    pub rgba_bytes: AzU8Vec,
}

/// Window "favicon", usually shown in the top left of the window on Windows
#[repr(C, u8)]
pub enum AzWindowIcon {
    Small(AzSmallWindowIconBytes),
    Large(AzLargeWindowIconBytes),
}

/// Application taskbar icon, 256x256x4 bytes in size
#[repr(C)]
pub struct AzTaskBarIcon {
    pub key: AzIconKey,
    pub rgba_bytes: AzU8Vec,
}

/// Minimum / maximum / current size of the window in logical dimensions
#[repr(C)]
pub struct AzWindowSize {
    pub dimensions: AzLogicalSize,
    pub dpi: u32,
    pub min_dimensions: AzOptionLogicalSizeEnumWrapper,
    pub max_dimensions: AzOptionLogicalSizeEnumWrapper,
}

/// Current keyboard state, stores what keys / characters have been pressed
#[repr(C)]
pub struct AzKeyboardState {
    pub current_char: AzOptionCharEnumWrapper,
    pub current_virtual_keycode: AzOptionVirtualKeyCodeEnumWrapper,
    pub pressed_virtual_keycodes: AzVirtualKeyCodeVec,
    pub pressed_scancodes: AzScanCodeVec,
}

/// Current mouse / cursor state
#[repr(C)]
pub struct AzMouseState {
    pub mouse_cursor_type: AzOptionMouseCursorTypeEnumWrapper,
    pub cursor_position: AzCursorPositionEnumWrapper,
    pub is_cursor_locked: bool,
    pub left_down: bool,
    pub right_down: bool,
    pub middle_down: bool,
    pub scroll_x: AzOptionF32EnumWrapper,
    pub scroll_y: AzOptionF32EnumWrapper,
}

/// C-ABI stable wrapper over a `MarshaledLayoutCallback`
#[repr(C)]
pub struct AzMarshaledLayoutCallback {
    pub marshal_data: AzRefAny,
    pub cb: AzMarshaledLayoutCallbackInner,
}

/// Re-export of rust-allocated (stack based) `InlineTextContents` struct
#[repr(C)]
pub struct AzInlineTextContents {
    pub glyphs: AzInlineGlyphVec,
    pub bounds: AzLogicalRect,
}

/// Re-export of rust-allocated (stack based) `ResolvedTextLayoutOptions` struct
#[repr(C)]
pub struct AzResolvedTextLayoutOptions {
    pub font_size_px: f32,
    pub line_height: AzOptionF32EnumWrapper,
    pub letter_spacing: AzOptionF32EnumWrapper,
    pub word_spacing: AzOptionF32EnumWrapper,
    pub tab_width: AzOptionF32EnumWrapper,
    pub max_horizontal_width: AzOptionF32EnumWrapper,
    pub leading: AzOptionF32EnumWrapper,
    pub holes: AzLogicalRectVec,
    pub max_vertical_height: AzOptionF32EnumWrapper,
    pub can_break: bool,
    pub can_hyphenate: bool,
    pub hyphenation_character: AzOptionCharEnumWrapper,
    pub is_rtl: AzScriptTypeEnumWrapper,
    pub text_justify: AzOptionStyleTextAlignEnumWrapper,
}

/// Easing function of the animation (ease-in, ease-out, ease-in-out, custom)
#[repr(C, u8)]
pub enum AzAnimationEasing {
    Ease,
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    CubicBezier(AzSvgCubicCurve),
}

/// Re-export of rust-allocated (stack based) `RenderImageCallbackInfo` struct
#[repr(C)]
pub struct AzRenderImageCallbackInfo {
    pub callback_node_id: AzDomNodeId,
    pub bounds: AzHidpiAdjustedBounds,
    pub gl_context: *const AzOptionGlEnumWrapper,
    pub image_cache: *const c_void,
    pub system_fonts: *const c_void,
    pub node_hierarchy: *const AzNodeHierarchyItemVec,
    pub words_cache: *const c_void,
    pub shaped_words_cache: *const c_void,
    pub positioned_words_cache: *const c_void,
    pub positioned_rects: *const c_void,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `LayoutCallbackInfo` struct
#[repr(C)]
pub struct AzLayoutCallbackInfo {
    pub window_size: AzWindowSize,
    pub theme: AzWindowThemeEnumWrapper,
    pub image_cache: *const c_void,
    pub gl_context: *const AzOptionGlEnumWrapper,
    pub system_fonts: *const c_void,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `EventFilter` struct
#[repr(C, u8)]
pub enum AzEventFilter {
    Hover(AzHoverEventFilter),
    Not(AzNotEventFilter),
    Focus(AzFocusEventFilter),
    Window(AzWindowEventFilter),
    Component(AzComponentEventFilter),
    Application(AzApplicationEventFilter),
}

/// Menu struct (application / window menu, dropdown menu, context menu). Modeled after the Windows
/// API
#[repr(C)]
pub struct AzMenu {
    pub items: AzMenuItemVec,
    pub position: AzMenuPopupPositionEnumWrapper,
    pub context_mouse_btn: AzContextMenuMouseButtonEnumWrapper,
}

/// Combination of virtual key codes that have to be pressed together
#[repr(C)]
pub struct AzVirtualKeyCodeCombo {
    pub keys: AzVirtualKeyCodeVec,
}

/// Re-export of rust-allocated (stack based) `CssPathPseudoSelector` struct
#[repr(C, u8)]
pub enum AzCssPathPseudoSelector {
    First,
    Last,
    NthChild(AzCssNthChildSelector),
    Hover,
    Active,
    Focus,
}

/// Re-export of rust-allocated (stack based) `AnimationInterpolationFunction` struct
#[repr(C, u8)]
pub enum AzAnimationInterpolationFunction {
    Ease,
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    CubicBezier(AzSvgCubicCurve),
}

/// Re-export of rust-allocated (stack based) `InterpolateContext` struct
#[repr(C)]
pub struct AzInterpolateContext {
    pub animation_func: AzAnimationInterpolationFunctionEnumWrapper,
    pub parent_rect_width: f32,
    pub parent_rect_height: f32,
    pub current_rect_width: f32,
    pub current_rect_height: f32,
}

/// Re-export of rust-allocated (stack based) `StyleFilter` struct
#[repr(C, u8)]
pub enum AzStyleFilter {
    Blend(AzStyleMixBlendMode),
    Flood(AzColorU),
    Blur(AzStyleBlur),
    Opacity(AzPercentageValue),
    ColorMatrix(AzStyleColorMatrix),
    DropShadow(AzStyleBoxShadow),
    ComponentTransfer,
    Offset(AzStyleFilterOffset),
    Composite(AzStyleCompositeFilter),
}

/// Re-export of rust-allocated (stack based) `LinearGradient` struct
#[repr(C)]
pub struct AzLinearGradient {
    pub direction: AzDirectionEnumWrapper,
    pub extend_mode: AzExtendModeEnumWrapper,
    pub stops: AzNormalizedLinearColorStopVec,
}

/// Re-export of rust-allocated (stack based) `RadialGradient` struct
#[repr(C)]
pub struct AzRadialGradient {
    pub shape: AzShapeEnumWrapper,
    pub size: AzRadialGradientSizeEnumWrapper,
    pub position: AzStyleBackgroundPosition,
    pub extend_mode: AzExtendModeEnumWrapper,
    pub stops: AzNormalizedLinearColorStopVec,
}

/// Re-export of rust-allocated (stack based) `ConicGradient` struct
#[repr(C)]
pub struct AzConicGradient {
    pub extend_mode: AzExtendModeEnumWrapper,
    pub center: AzStyleBackgroundPosition,
    pub angle: AzAngleValue,
    pub stops: AzNormalizedRadialColorStopVec,
}

/// Re-export of rust-allocated (stack based) `StyleTransform` struct
#[repr(C, u8)]
pub enum AzStyleTransform {
    Matrix(AzStyleTransformMatrix2D),
    Matrix3D(AzStyleTransformMatrix3D),
    Translate(AzStyleTransformTranslate2D),
    Translate3D(AzStyleTransformTranslate3D),
    TranslateX(AzPixelValue),
    TranslateY(AzPixelValue),
    TranslateZ(AzPixelValue),
    Rotate(AzAngleValue),
    Rotate3D(AzStyleTransformRotate3D),
    RotateX(AzAngleValue),
    RotateY(AzAngleValue),
    RotateZ(AzAngleValue),
    Scale(AzStyleTransformScale2D),
    Scale3D(AzStyleTransformScale3D),
    ScaleX(AzPercentageValue),
    ScaleY(AzPercentageValue),
    ScaleZ(AzPercentageValue),
    Skew(AzStyleTransformSkew2D),
    SkewX(AzPercentageValue),
    SkewY(AzPercentageValue),
    Perspective(AzPixelValue),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundPositionVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundPositionVec),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundRepeatVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundRepeatVec),
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundSizeVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundSizeVec),
}

/// Re-export of rust-allocated (stack based) `CheckBoxStateWrapper` struct
#[repr(C)]
pub struct AzCheckBoxStateWrapper {
    pub inner: AzCheckBoxState,
    pub on_toggle: AzOptionCheckBoxOnToggleEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `NumberInputStateWrapper` struct
#[repr(C)]
pub struct AzNumberInputStateWrapper {
    pub inner: AzNumberInputState,
    pub on_value_change: AzOptionNumberInputOnValueChangeEnumWrapper,
    pub on_focus_lost: AzOptionNumberInputOnFocusLostEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `NodeGraphCallbacks` struct
#[repr(C)]
pub struct AzNodeGraphCallbacks {
    pub on_node_added: AzOptionNodeGraphOnNodeAddedEnumWrapper,
    pub on_node_removed: AzOptionNodeGraphOnNodeRemovedEnumWrapper,
    pub on_node_dragged: AzOptionNodeGraphOnNodeDraggedEnumWrapper,
    pub on_node_graph_dragged: AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper,
    pub on_node_connected: AzOptionNodeGraphOnNodeConnectedEnumWrapper,
    pub on_node_input_disconnected: AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper,
    pub on_node_output_disconnected: AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper,
    pub on_node_field_edited: AzOptionNodeGraphOnNodeFieldEditedEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `InputConnection` struct
#[repr(C)]
pub struct AzInputConnection {
    pub input_index: usize,
    pub connects_to: AzOutputNodeAndIndexVec,
}

/// Re-export of rust-allocated (stack based) `OutputConnection` struct
#[repr(C)]
pub struct AzOutputConnection {
    pub output_index: usize,
    pub connects_to: AzInputNodeAndIndexVec,
}

/// Re-export of rust-allocated (stack based) `ListViewRow` struct
#[repr(C)]
pub struct AzListViewRow {
    pub cells: AzDomVec,
    pub height: AzOptionPixelValueNoPercentEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `StyledNode` struct
#[repr(C)]
pub struct AzStyledNode {
    pub state: AzStyledNodeState,
    pub tag_id: AzOptionTagIdEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `TagIdToNodeIdMapping` struct
#[repr(C)]
pub struct AzTagIdToNodeIdMapping {
    pub tag_id: AzTagId,
    pub node_id: AzNodeId,
    pub tab_index: AzOptionTabIndexEnumWrapper,
    pub parents: AzNodeIdVec,
}

/// Re-export of rust-allocated (stack based) `Texture` struct
#[repr(C)]
pub struct AzTexture {
    pub texture_id: u32,
    pub flags: AzTextureFlags,
    pub size: AzPhysicalSizeU32,
    pub background_color: AzColorU,
    pub gl_context: AzGl,
    pub format: AzRawImageFormatEnumWrapper,
    pub refcount: *const c_void,
    pub run_destructor: bool,
}

/// C-ABI stable reexport of `(U8Vec, u32)`
#[repr(C)]
pub struct AzGetProgramBinaryReturn {
    pub _0: AzU8Vec,
    pub _1: u32,
}

/// Re-export of rust-allocated (stack based) `RawImageData` struct
#[repr(C, u8)]
pub enum AzRawImageData {
    U8(AzU8Vec),
    U16(AzU16Vec),
    F32(AzF32Vec),
}

/// Source data of a font file (bytes)
#[repr(C)]
pub struct AzFontSource {
    pub data: AzU8Vec,
    pub font_index: u32,
    pub parse_glyph_outlines: bool,
}

/// Re-export of rust-allocated (stack based) `SvgPathElement` struct
#[repr(C, u8)]
pub enum AzSvgPathElement {
    Line(AzSvgLine),
    QuadraticCurve(AzSvgQuadraticCurve),
    CubicCurve(AzSvgCubicCurve),
}

/// Re-export of rust-allocated (stack based) `TessellatedColoredSvgNode` struct
#[repr(C)]
pub struct AzTessellatedColoredSvgNode {
    pub vertices: AzSvgColoredVertexVec,
    pub indices: AzU32Vec,
}

/// Rust wrapper over a `&[TessellatedColoredSvgNode]` or `&Vec<TessellatedColoredSvgNode>`
#[repr(C)]
pub struct AzTessellatedColoredSvgNodeVecRef {
    pub(crate) ptr: *const AzTessellatedColoredSvgNode,
    pub len: usize,
}

/// Re-export of rust-allocated (stack based) `TessellatedSvgNode` struct
#[repr(C)]
pub struct AzTessellatedSvgNode {
    pub vertices: AzSvgVertexVec,
    pub indices: AzU32Vec,
}

/// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`
#[repr(C)]
pub struct AzTessellatedSvgNodeVecRef {
    pub(crate) ptr: *const AzTessellatedSvgNode,
    pub len: usize,
}

/// Re-export of rust-allocated (stack based) `SvgRenderOptions` struct
#[repr(C)]
pub struct AzSvgRenderOptions {
    pub target_size: AzOptionLayoutSizeEnumWrapper,
    pub background_color: AzOptionColorUEnumWrapper,
    pub fit: AzSvgFitToEnumWrapper,
    pub transform: AzSvgRenderTransform,
}

/// Re-export of rust-allocated (stack based) `SvgStrokeStyle` struct
#[repr(C)]
pub struct AzSvgStrokeStyle {
    pub start_cap: AzSvgLineCapEnumWrapper,
    pub end_cap: AzSvgLineCapEnumWrapper,
    pub line_join: AzSvgLineJoinEnumWrapper,
    pub dash_pattern: AzOptionSvgDashPatternEnumWrapper,
    pub line_width: f32,
    pub miter_limit: f32,
    pub tolerance: f32,
    pub apply_line_width: bool,
    pub transform: AzSvgTransform,
    pub anti_alias: bool,
    pub high_quality_aa: bool,
}

/// Re-export of rust-allocated (stack based) `Xml` struct
#[repr(C)]
pub struct AzXml {
    pub root: AzXmlNodeVec,
}

/// Re-export of rust-allocated (stack based) `Instant` struct
#[repr(C, u8)]
pub enum AzInstant {
    System(AzInstantPtr),
    Tick(AzSystemTick),
}

/// Re-export of rust-allocated (stack based) `ThreadReceiveMsg` struct
#[repr(C, u8)]
pub enum AzThreadReceiveMsg {
    WriteBack(AzThreadWriteBackMsg),
    Update(AzUpdate),
}

/// Re-export of rust-allocated (stack based) `String` struct
#[repr(C)]
pub struct AzString {
    pub vec: AzU8Vec,
}

/// Wrapper over a Rust-allocated `Vec<ListViewRow>`
#[repr(C)]
pub struct AzListViewRowVec {
    pub(crate) ptr: *const AzListViewRow,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzListViewRowVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleFilter>`
#[repr(C)]
pub struct AzStyleFilterVec {
    pub(crate) ptr: *const AzStyleFilterEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleFilterVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InputConnection>`
#[repr(C)]
pub struct AzInputConnectionVec {
    pub(crate) ptr: *const AzInputConnection,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputConnectionVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<OutputConnection>`
#[repr(C)]
pub struct AzOutputConnectionVec {
    pub(crate) ptr: *const AzOutputConnection,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzOutputConnectionVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`
#[repr(C)]
pub struct AzTessellatedSvgNodeVec {
    pub(crate) ptr: *const AzTessellatedSvgNode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzTessellatedSvgNodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<TessellatedColoredSvgNode>`
#[repr(C)]
pub struct AzTessellatedColoredSvgNodeVec {
    pub(crate) ptr: *const AzTessellatedColoredSvgNode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzTessellatedColoredSvgNodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleTransform>`
#[repr(C)]
pub struct AzStyleTransformVec {
    pub(crate) ptr: *const AzStyleTransformEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleTransformVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `VertexAttribute`
#[repr(C)]
pub struct AzSvgPathElementVec {
    pub(crate) ptr: *const AzSvgPathElementEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgPathElementVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `StringVec`
#[repr(C)]
pub struct AzStringVec {
    pub(crate) ptr: *const AzString,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStringVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `StyledNodeVec`
#[repr(C)]
pub struct AzStyledNodeVec {
    pub(crate) ptr: *const AzStyledNode,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyledNodeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`
#[repr(C)]
pub struct AzTagIdToNodeIdMappingVec {
    pub(crate) ptr: *const AzTagIdToNodeIdMapping,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzTagIdToNodeIdMappingVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionMenu` struct
#[repr(C, u8)]
pub enum AzOptionMenu {
    None,
    Some(AzMenu),
}

/// Re-export of rust-allocated (stack based) `OptionResolvedTextLayoutOptions` struct
#[repr(C, u8)]
pub enum AzOptionResolvedTextLayoutOptions {
    None,
    Some(AzResolvedTextLayoutOptions),
}

/// Re-export of rust-allocated (stack based) `OptionVirtualKeyCodeCombo` struct
#[repr(C, u8)]
pub enum AzOptionVirtualKeyCodeCombo {
    None,
    Some(AzVirtualKeyCodeCombo),
}

/// Re-export of rust-allocated (stack based) `OptionMouseState` struct
#[repr(C, u8)]
pub enum AzOptionMouseState {
    None,
    Some(AzMouseState),
}

/// Re-export of rust-allocated (stack based) `OptionKeyboardState` struct
#[repr(C, u8)]
pub enum AzOptionKeyboardState {
    None,
    Some(AzKeyboardState),
}

/// Re-export of rust-allocated (stack based) `OptionStringVec` struct
#[repr(C, u8)]
pub enum AzOptionStringVec {
    None,
    Some(AzStringVec),
}

/// Re-export of rust-allocated (stack based) `OptionThreadReceiveMsg` struct
#[repr(C, u8)]
pub enum AzOptionThreadReceiveMsg {
    None,
    Some(AzThreadReceiveMsg),
}

/// Re-export of rust-allocated (stack based) `OptionTaskBarIcon` struct
#[repr(C, u8)]
pub enum AzOptionTaskBarIcon {
    None,
    Some(AzTaskBarIcon),
}

/// Re-export of rust-allocated (stack based) `OptionWindowIcon` struct
#[repr(C, u8)]
pub enum AzOptionWindowIcon {
    None,
    Some(AzWindowIcon),
}

/// Re-export of rust-allocated (stack based) `OptionString` struct
#[repr(C, u8)]
pub enum AzOptionString {
    None,
    Some(AzString),
}

/// Re-export of rust-allocated (stack based) `OptionTexture` struct
#[repr(C, u8)]
pub enum AzOptionTexture {
    None,
    Some(AzTexture),
}

/// Re-export of rust-allocated (stack based) `OptionInstant` struct
#[repr(C, u8)]
pub enum AzOptionInstant {
    None,
    Some(AzInstant),
}

/// Re-export of rust-allocated (stack based) `DuplicatedNamespaceError` struct
#[repr(C)]
pub struct AzDuplicatedNamespaceError {
    pub ns: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `UnknownNamespaceError` struct
#[repr(C)]
pub struct AzUnknownNamespaceError {
    pub ns: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `UnexpectedCloseTagError` struct
#[repr(C)]
pub struct AzUnexpectedCloseTagError {
    pub expected: AzString,
    pub actual: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `UnknownEntityReferenceError` struct
#[repr(C)]
pub struct AzUnknownEntityReferenceError {
    pub entity: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `DuplicatedAttributeError` struct
#[repr(C)]
pub struct AzDuplicatedAttributeError {
    pub attribute: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Re-export of rust-allocated (stack based) `InvalidStringError` struct
#[repr(C)]
pub struct AzInvalidStringError {
    pub got: AzString,
    pub pos: AzSvgParseErrorPosition,
}

/// Window configuration specific to Win32
#[repr(C)]
pub struct AzWindowsWindowOptions {
    pub allow_drag_drop: bool,
    pub no_redirection_bitmap: bool,
    pub window_icon: AzOptionWindowIconEnumWrapper,
    pub taskbar_icon: AzOptionTaskBarIconEnumWrapper,
    pub parent_window: AzOptionHwndHandleEnumWrapper,
}

/// CSD theme of the window title / button controls
#[repr(C)]
pub struct AzWaylandTheme {
    pub title_bar_active_background_color: [u8; 4],
    pub title_bar_active_separator_color: [u8; 4],
    pub title_bar_active_text_color: [u8; 4],
    pub title_bar_inactive_background_color: [u8; 4],
    pub title_bar_inactive_separator_color: [u8; 4],
    pub title_bar_inactive_text_color: [u8; 4],
    pub maximize_idle_foreground_inactive_color: [u8; 4],
    pub minimize_idle_foreground_inactive_color: [u8; 4],
    pub close_idle_foreground_inactive_color: [u8; 4],
    pub maximize_hovered_foreground_inactive_color: [u8; 4],
    pub minimize_hovered_foreground_inactive_color: [u8; 4],
    pub close_hovered_foreground_inactive_color: [u8; 4],
    pub maximize_disabled_foreground_inactive_color: [u8; 4],
    pub minimize_disabled_foreground_inactive_color: [u8; 4],
    pub close_disabled_foreground_inactive_color: [u8; 4],
    pub maximize_idle_background_inactive_color: [u8; 4],
    pub minimize_idle_background_inactive_color: [u8; 4],
    pub close_idle_background_inactive_color: [u8; 4],
    pub maximize_hovered_background_inactive_color: [u8; 4],
    pub minimize_hovered_background_inactive_color: [u8; 4],
    pub close_hovered_background_inactive_color: [u8; 4],
    pub maximize_disabled_background_inactive_color: [u8; 4],
    pub minimize_disabled_background_inactive_color: [u8; 4],
    pub close_disabled_background_inactive_color: [u8; 4],
    pub maximize_idle_foreground_active_color: [u8; 4],
    pub minimize_idle_foreground_active_color: [u8; 4],
    pub close_idle_foreground_active_color: [u8; 4],
    pub maximize_hovered_foreground_active_color: [u8; 4],
    pub minimize_hovered_foreground_active_color: [u8; 4],
    pub close_hovered_foreground_active_color: [u8; 4],
    pub maximize_disabled_foreground_active_color: [u8; 4],
    pub minimize_disabled_foreground_active_color: [u8; 4],
    pub close_disabled_foreground_active_color: [u8; 4],
    pub maximize_idle_background_active_color: [u8; 4],
    pub minimize_idle_background_active_color: [u8; 4],
    pub close_idle_background_active_color: [u8; 4],
    pub maximize_hovered_background_active_color: [u8; 4],
    pub minimize_hovered_background_active_color: [u8; 4],
    pub close_hovered_background_active_color: [u8; 4],
    pub maximize_disabled_background_active_color: [u8; 4],
    pub minimize_disabled_background_active_color: [u8; 4],
    pub close_disabled_background_active_color: [u8; 4],
    pub title_bar_font: AzString,
    pub title_bar_font_size: f32,
}

/// Key-value pair, used for setting WM hints values specific to GNOME
#[repr(C)]
pub struct AzStringPair {
    pub key: AzString,
    pub value: AzString,
}

/// Information about a single (or many) monitors, useful for dock widgets
#[repr(C)]
pub struct AzMonitor {
    pub id: usize,
    pub name: AzOptionStringEnumWrapper,
    pub size: AzLayoutSize,
    pub position: AzLayoutPoint,
    pub scale_factor: f64,
    pub video_modes: AzVideoModeVec,
    pub is_primary_monitor: bool,
}

/// Re-export of rust-allocated (stack based) `LayoutCallback` struct
#[repr(C, u8)]
pub enum AzLayoutCallback {
    Raw(AzLayoutCallbackInner),
    Marshaled(AzMarshaledLayoutCallback),
}

/// Re-export of rust-allocated (stack based) `InlineWord` struct
#[repr(C, u8)]
pub enum AzInlineWord {
    Tab,
    Return,
    Space,
    Word(AzInlineTextContents),
}

/// Re-export of rust-allocated (stack based) `CallbackData` struct
#[repr(C)]
pub struct AzCallbackData {
    pub event: AzEventFilterEnumWrapper,
    pub callback: AzCallback,
    pub data: AzRefAny,
}

/// List of core DOM node types built-into by `azul`
#[repr(C, u8)]
pub enum AzNodeType {
    Body,
    Div,
    Br,
    Text(AzString),
    Image(AzImageRef),
    IFrame(AzIFrameNode),
}

/// Accessibility information (MSAA wrapper). See `NodeData.set_accessibility_info()`
#[repr(C)]
pub struct AzAccessibilityInfo {
    pub name: AzOptionStringEnumWrapper,
    pub value: AzOptionStringEnumWrapper,
    pub role: AzAccessibilityRoleEnumWrapper,
    pub states: AzAccessibilityStateVec,
    pub accelerator: AzOptionVirtualKeyCodeComboEnumWrapper,
    pub default_action: AzOptionStringEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `IdOrClass` struct
#[repr(C, u8)]
pub enum AzIdOrClass {
    Id(AzString),
    Class(AzString),
}

/// Regular labeled menu item
#[repr(C)]
pub struct AzStringMenuItem {
    pub label: AzString,
    pub accelerator: AzOptionVirtualKeyCodeComboEnumWrapper,
    pub callback: AzOptionMenuCallbackEnumWrapper,
    pub state: AzMenuItemStateEnumWrapper,
    pub icon: AzOptionMenuItemIconEnumWrapper,
    pub children: AzMenuItemVec,
}

/// Re-export of rust-allocated (stack based) `CssPathSelector` struct
#[repr(C, u8)]
pub enum AzCssPathSelector {
    Global,
    Type(AzNodeTypeKey),
    Class(AzString),
    Id(AzString),
    PseudoSelector(AzCssPathPseudoSelector),
    DirectChildren,
    Children,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundContent` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundContent {
    LinearGradient(AzLinearGradient),
    RadialGradient(AzRadialGradient),
    ConicGradient(AzConicGradient),
    Image(AzString),
    Color(AzColorU),
}

/// Re-export of rust-allocated (stack based) `ScrollbarInfo` struct
#[repr(C)]
pub struct AzScrollbarInfo {
    pub width: AzLayoutWidth,
    pub padding_left: AzLayoutPaddingLeft,
    pub padding_right: AzLayoutPaddingRight,
    pub track: AzStyleBackgroundContentEnumWrapper,
    pub thumb: AzStyleBackgroundContentEnumWrapper,
    pub button: AzStyleBackgroundContentEnumWrapper,
    pub corner: AzStyleBackgroundContentEnumWrapper,
    pub resizer: AzStyleBackgroundContentEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ScrollbarStyle` struct
#[repr(C)]
pub struct AzScrollbarStyle {
    pub horizontal: AzScrollbarInfo,
    pub vertical: AzScrollbarInfo,
}

/// Re-export of rust-allocated (stack based) `StyleFontFamily` struct
#[repr(C, u8)]
pub enum AzStyleFontFamily {
    System(AzString),
    File(AzString),
    Ref(AzFontRef),
}

/// Re-export of rust-allocated (stack based) `ScrollbarStyleValue` struct
#[repr(C, u8)]
pub enum AzScrollbarStyleValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzScrollbarStyle),
}

/// Re-export of rust-allocated (stack based) `StyleTransformVecValue` struct
#[repr(C, u8)]
pub enum AzStyleTransformVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleTransformVec),
}

/// Re-export of rust-allocated (stack based) `StyleFilterVecValue` struct
#[repr(C, u8)]
pub enum AzStyleFilterVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleFilterVec),
}

/// Re-export of rust-allocated (stack based) `FileInputState` struct
#[repr(C)]
pub struct AzFileInputState {
    pub path: AzOptionStringEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ColorInputStateWrapper` struct
#[repr(C)]
pub struct AzColorInputStateWrapper {
    pub inner: AzColorInputState,
    pub title: AzString,
    pub on_value_change: AzOptionColorInputOnValueChangeEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `TextInputState` struct
#[repr(C)]
pub struct AzTextInputState {
    pub text: AzU32Vec,
    pub placeholder: AzOptionStringEnumWrapper,
    pub max_len: usize,
    pub selection: AzOptionTextInputSelectionEnumWrapper,
    pub cursor_pos: usize,
}

/// Re-export of rust-allocated (stack based) `TabHeader` struct
#[repr(C)]
pub struct AzTabHeader {
    pub tabs: AzStringVec,
    pub active_tab: usize,
    pub on_click: AzOptionTabOnClickEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `NodeTypeFieldValue` struct
#[repr(C, u8)]
pub enum AzNodeTypeFieldValue {
    TextInput(AzString),
    NumberInput(f32),
    CheckBox(bool),
    ColorInput(AzColorU),
    FileInput(AzOptionString),
}

/// Re-export of rust-allocated (stack based) `NodeTypeInfo` struct
#[repr(C)]
pub struct AzNodeTypeInfo {
    pub is_root: bool,
    pub name: AzString,
    pub inputs: AzInputOutputTypeIdVec,
    pub outputs: AzInputOutputTypeIdVec,
}

/// Re-export of rust-allocated (stack based) `InputOutputInfo` struct
#[repr(C)]
pub struct AzInputOutputInfo {
    pub data_type: AzString,
    pub color: AzColorU,
}

/// Re-export of rust-allocated (stack based) `ListView` struct
#[repr(C)]
pub struct AzListView {
    pub columns: AzStringVec,
    pub rows: AzListViewRowVec,
    pub sorted_by: AzOptionUsizeEnumWrapper,
    pub scroll_offset: AzPixelValueNoPercent,
    pub content_height: AzOptionPixelValueNoPercentEnumWrapper,
    pub column_context_menu: AzOptionMenuEnumWrapper,
    pub on_lazy_load_scroll: AzOptionListViewOnLazyLoadScrollEnumWrapper,
    pub on_column_click: AzOptionListViewOnColumnClickEnumWrapper,
    pub on_row_click: AzOptionListViewOnRowClickEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ListViewState` struct
#[repr(C)]
pub struct AzListViewState {
    pub columns: AzStringVec,
    pub sorted_by: AzOptionUsizeEnumWrapper,
    pub current_row_count: usize,
    pub scroll_offset: AzPixelValueNoPercent,
    pub current_scroll_position: AzLogicalPosition,
    pub current_content_height: AzLogicalSize,
}

/// Re-export of rust-allocated (stack based) `TreeView` struct
#[repr(C)]
pub struct AzTreeView {
    pub root: AzString,
}

/// Re-export of rust-allocated (stack based) `DropDown` struct
#[repr(C)]
pub struct AzDropDown {
    pub choices: AzStringVec,
    pub selected: usize,
    pub on_choice_change: AzOptionDropDownOnChoiceChangeEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `VertexAttribute` struct
#[repr(C)]
pub struct AzVertexAttribute {
    pub name: AzString,
    pub layout_location: AzOptionUsizeEnumWrapper,
    pub attribute_type: AzVertexAttributeTypeEnumWrapper,
    pub item_count: usize,
}

/// Re-export of rust-allocated (stack based) `DebugMessage` struct
#[repr(C)]
pub struct AzDebugMessage {
    pub message: AzString,
    pub source: u32,
    pub ty: u32,
    pub id: u32,
    pub severity: u32,
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)]
pub struct AzGetActiveAttribReturn {
    pub _0: i32,
    pub _1: u32,
    pub _2: AzString,
}

/// C-ABI stable reexport of `(i32, u32, AzString)`
#[repr(C)]
pub struct AzGetActiveUniformReturn {
    pub _0: i32,
    pub _1: u32,
    pub _2: AzString,
}

/// Re-export of rust-allocated (stack based) `RawImage` struct
#[repr(C)]
pub struct AzRawImage {
    pub pixels: AzRawImageDataEnumWrapper,
    pub width: usize,
    pub height: usize,
    pub alpha_premultiplied: bool,
    pub data_format: AzRawImageFormatEnumWrapper,
    pub tag: AzU8Vec,
}

/// Re-export of rust-allocated (stack based) `SvgPath` struct
#[repr(C)]
pub struct AzSvgPath {
    pub items: AzSvgPathElementVec,
}

/// Re-export of rust-allocated (stack based) `SvgParseOptions` struct
#[repr(C)]
pub struct AzSvgParseOptions {
    pub relative_image_path: AzOptionStringEnumWrapper,
    pub dpi: f32,
    pub default_font_family: AzString,
    pub font_size: f32,
    pub languages: AzStringVec,
    pub shape_rendering: AzShapeRenderingEnumWrapper,
    pub text_rendering: AzTextRenderingEnumWrapper,
    pub image_rendering: AzImageRenderingEnumWrapper,
    pub keep_named_groups: bool,
    pub fontdb: AzFontDatabaseEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `SvgStyle` struct
#[repr(C, u8)]
pub enum AzSvgStyle {
    Fill(AzSvgFillStyle),
    Stroke(AzSvgStrokeStyle),
}

/// **Reference-counted** file handle
#[repr(C)]
pub struct AzFile {
    pub ptr: *const c_void,
    pub path: AzString,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `FileTypeList` struct
#[repr(C)]
pub struct AzFileTypeList {
    pub document_types: AzStringVec,
    pub document_descriptor: AzString,
}

/// Re-export of rust-allocated (stack based) `Timer` struct
#[repr(C)]
pub struct AzTimer {
    pub data: AzRefAny,
    pub node_id: AzOptionDomNodeIdEnumWrapper,
    pub created: AzInstantEnumWrapper,
    pub last_run: AzOptionInstantEnumWrapper,
    pub run_count: usize,
    pub delay: AzOptionDurationEnumWrapper,
    pub interval: AzOptionDurationEnumWrapper,
    pub timeout: AzOptionDurationEnumWrapper,
    pub callback: AzTimerCallback,
}

/// Re-export of rust-allocated (stack based) `FmtValue` struct
#[repr(C, u8)]
pub enum AzFmtValue {
    Bool(bool),
    Uchar(u8),
    Schar(i8),
    Ushort(u16),
    Sshort(i16),
    Uint(u32),
    Sint(i32),
    Ulong(u64),
    Slong(i64),
    Isize(isize),
    Usize(usize),
    Float(f32),
    Double(f64),
    Str(AzString),
    StrVec(AzStringVec),
}

/// Re-export of rust-allocated (stack based) `FmtArg` struct
#[repr(C)]
pub struct AzFmtArg {
    pub key: AzString,
    pub value: AzFmtValueEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`
#[repr(C)]
pub struct AzStyleFontFamilyVec {
    pub(crate) ptr: *const AzStyleFontFamilyEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleFontFamilyVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<FmtArg>`
#[repr(C)]
pub struct AzFmtArgVec {
    pub(crate) ptr: *const AzFmtArg,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzFmtArgVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineWord>`
#[repr(C)]
pub struct AzInlineWordVec {
    pub(crate) ptr: *const AzInlineWordEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineWordVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<Monitor>`
#[repr(C)]
pub struct AzMonitorVec {
    pub(crate) ptr: *const AzMonitor,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzMonitorVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<IdOrClass>`
#[repr(C)]
pub struct AzIdOrClassVec {
    pub(crate) ptr: *const AzIdOrClassEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzIdOrClassVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`
#[repr(C)]
pub struct AzStyleBackgroundContentVec {
    pub(crate) ptr: *const AzStyleBackgroundContentEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStyleBackgroundContentVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<SvgPath>`
#[repr(C)]
pub struct AzSvgPathVec {
    pub(crate) ptr: *const AzSvgPath,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgPathVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<VertexAttribute>`
#[repr(C)]
pub struct AzVertexAttributeVec {
    pub(crate) ptr: *const AzVertexAttribute,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzVertexAttributeVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CssPathSelector`
#[repr(C)]
pub struct AzCssPathSelectorVec {
    pub(crate) ptr: *const AzCssPathSelectorEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssPathSelectorVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CallbackData`
#[repr(C)]
pub struct AzCallbackDataVec {
    pub(crate) ptr: *const AzCallbackData,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCallbackDataVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<DebugMessage>`
#[repr(C)]
pub struct AzDebugMessageVec {
    pub(crate) ptr: *const AzDebugMessage,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzDebugMessageVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `StringPairVec`
#[repr(C)]
pub struct AzStringPairVec {
    pub(crate) ptr: *const AzStringPair,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStringPairVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionFileTypeList` struct
#[repr(C, u8)]
pub enum AzOptionFileTypeList {
    None,
    Some(AzFileTypeList),
}

/// Re-export of rust-allocated (stack based) `OptionFile` struct
#[repr(C, u8)]
pub enum AzOptionFile {
    None,
    Some(AzFile),
}

/// Re-export of rust-allocated (stack based) `OptionRawImage` struct
#[repr(C, u8)]
pub enum AzOptionRawImage {
    None,
    Some(AzRawImage),
}

/// Re-export of rust-allocated (stack based) `OptionWaylandTheme` struct
#[repr(C, u8)]
pub enum AzOptionWaylandTheme {
    None,
    Some(AzWaylandTheme),
}

/// Re-export of rust-allocated (stack based) `ResultRawImageDecodeImageError` struct
#[repr(C, u8)]
pub enum AzResultRawImageDecodeImageError {
    Ok(AzRawImage),
    Err(AzDecodeImageError),
}

/// Re-export of rust-allocated (stack based) `XmlStreamError` struct
#[repr(C, u8)]
pub enum AzXmlStreamError {
    UnexpectedEndOfStream,
    InvalidName,
    NonXmlChar(AzNonXmlCharError),
    InvalidChar(AzInvalidCharError),
    InvalidCharMultiple(AzInvalidCharMultipleError),
    InvalidQuote(AzInvalidQuoteError),
    InvalidSpace(AzInvalidSpaceError),
    InvalidString(AzInvalidStringError),
    InvalidReference,
    InvalidExternalID,
    InvalidCommentData,
    InvalidCommentEnd,
    InvalidCharacterData,
}

/// Re-export of rust-allocated (stack based) `LinuxWindowOptions` struct
#[repr(C)]
pub struct AzLinuxWindowOptions {
    pub x11_visual: AzOptionX11VisualEnumWrapper,
    pub x11_screen: AzOptionI32EnumWrapper,
    pub x11_wm_classes: AzStringPairVec,
    pub x11_override_redirect: bool,
    pub x11_window_types: AzXWindowTypeVec,
    pub x11_gtk_theme_variant: AzOptionStringEnumWrapper,
    pub x11_resize_increments: AzOptionLogicalSizeEnumWrapper,
    pub x11_base_size: AzOptionLogicalSizeEnumWrapper,
    pub wayland_app_id: AzOptionStringEnumWrapper,
    pub wayland_theme: AzOptionWaylandThemeEnumWrapper,
    pub request_user_attention: bool,
    pub window_icon: AzOptionWindowIconEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `InlineLine` struct
#[repr(C)]
pub struct AzInlineLine {
    pub words: AzInlineWordVec,
    pub bounds: AzLogicalRect,
}

/// Item entry in a menu or menu bar
#[repr(C, u8)]
pub enum AzMenuItem {
    String(AzStringMenuItem),
    Separator,
    BreakLine,
}

/// Re-export of rust-allocated (stack based) `CssPath` struct
#[repr(C)]
pub struct AzCssPath {
    pub selectors: AzCssPathSelectorVec,
}

/// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecValue` struct
#[repr(C, u8)]
pub enum AzStyleBackgroundContentVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleBackgroundContentVec),
}

/// Re-export of rust-allocated (stack based) `StyleFontFamilyVecValue` struct
#[repr(C, u8)]
pub enum AzStyleFontFamilyVecValue {
    Auto,
    None,
    Inherit,
    Initial,
    Exact(AzStyleFontFamilyVec),
}

/// Parsed CSS key-value pair
#[repr(C, u8)]
pub enum AzCssProperty {
    TextColor(AzStyleTextColorValue),
    FontSize(AzStyleFontSizeValue),
    FontFamily(AzStyleFontFamilyVecValue),
    TextAlign(AzStyleTextAlignValue),
    LetterSpacing(AzStyleLetterSpacingValue),
    LineHeight(AzStyleLineHeightValue),
    WordSpacing(AzStyleWordSpacingValue),
    TabWidth(AzStyleTabWidthValue),
    Cursor(AzStyleCursorValue),
    Display(AzLayoutDisplayValue),
    Float(AzLayoutFloatValue),
    BoxSizing(AzLayoutBoxSizingValue),
    Width(AzLayoutWidthValue),
    Height(AzLayoutHeightValue),
    MinWidth(AzLayoutMinWidthValue),
    MinHeight(AzLayoutMinHeightValue),
    MaxWidth(AzLayoutMaxWidthValue),
    MaxHeight(AzLayoutMaxHeightValue),
    Position(AzLayoutPositionValue),
    Top(AzLayoutTopValue),
    Right(AzLayoutRightValue),
    Left(AzLayoutLeftValue),
    Bottom(AzLayoutBottomValue),
    FlexWrap(AzLayoutFlexWrapValue),
    FlexDirection(AzLayoutFlexDirectionValue),
    FlexGrow(AzLayoutFlexGrowValue),
    FlexShrink(AzLayoutFlexShrinkValue),
    JustifyContent(AzLayoutJustifyContentValue),
    AlignItems(AzLayoutAlignItemsValue),
    AlignContent(AzLayoutAlignContentValue),
    BackgroundContent(AzStyleBackgroundContentVecValue),
    BackgroundPosition(AzStyleBackgroundPositionVecValue),
    BackgroundSize(AzStyleBackgroundSizeVecValue),
    BackgroundRepeat(AzStyleBackgroundRepeatVecValue),
    OverflowX(AzLayoutOverflowValue),
    OverflowY(AzLayoutOverflowValue),
    PaddingTop(AzLayoutPaddingTopValue),
    PaddingLeft(AzLayoutPaddingLeftValue),
    PaddingRight(AzLayoutPaddingRightValue),
    PaddingBottom(AzLayoutPaddingBottomValue),
    MarginTop(AzLayoutMarginTopValue),
    MarginLeft(AzLayoutMarginLeftValue),
    MarginRight(AzLayoutMarginRightValue),
    MarginBottom(AzLayoutMarginBottomValue),
    BorderTopLeftRadius(AzStyleBorderTopLeftRadiusValue),
    BorderTopRightRadius(AzStyleBorderTopRightRadiusValue),
    BorderBottomLeftRadius(AzStyleBorderBottomLeftRadiusValue),
    BorderBottomRightRadius(AzStyleBorderBottomRightRadiusValue),
    BorderTopColor(AzStyleBorderTopColorValue),
    BorderRightColor(AzStyleBorderRightColorValue),
    BorderLeftColor(AzStyleBorderLeftColorValue),
    BorderBottomColor(AzStyleBorderBottomColorValue),
    BorderTopStyle(AzStyleBorderTopStyleValue),
    BorderRightStyle(AzStyleBorderRightStyleValue),
    BorderLeftStyle(AzStyleBorderLeftStyleValue),
    BorderBottomStyle(AzStyleBorderBottomStyleValue),
    BorderTopWidth(AzLayoutBorderTopWidthValue),
    BorderRightWidth(AzLayoutBorderRightWidthValue),
    BorderLeftWidth(AzLayoutBorderLeftWidthValue),
    BorderBottomWidth(AzLayoutBorderBottomWidthValue),
    BoxShadowLeft(AzStyleBoxShadowValue),
    BoxShadowRight(AzStyleBoxShadowValue),
    BoxShadowTop(AzStyleBoxShadowValue),
    BoxShadowBottom(AzStyleBoxShadowValue),
    ScrollbarStyle(AzScrollbarStyleValue),
    Opacity(AzStyleOpacityValue),
    Transform(AzStyleTransformVecValue),
    TransformOrigin(AzStyleTransformOriginValue),
    PerspectiveOrigin(AzStylePerspectiveOriginValue),
    BackfaceVisibility(AzStyleBackfaceVisibilityValue),
    MixBlendMode(AzStyleMixBlendModeValue),
    Filter(AzStyleFilterVecValue),
    BackdropFilter(AzStyleFilterVecValue),
    TextShadow(AzStyleBoxShadowValue),
}

/// Re-export of rust-allocated (stack based) `FileInputStateWrapper` struct
#[repr(C)]
pub struct AzFileInputStateWrapper {
    pub inner: AzFileInputState,
    pub on_file_path_change: AzOptionFileInputOnPathChangeEnumWrapper,
    pub file_dialog_title: AzString,
    pub default_dir: AzOptionStringEnumWrapper,
    pub file_types: AzOptionFileTypeListEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `TextInputStateWrapper` struct
#[repr(C)]
pub struct AzTextInputStateWrapper {
    pub inner: AzTextInputState,
    pub on_text_input: AzOptionTextInputOnTextInputEnumWrapper,
    pub on_virtual_key_down: AzOptionTextInputOnVirtualKeyDownEnumWrapper,
    pub on_focus_lost: AzOptionTextInputOnFocusLostEnumWrapper,
    pub update_text_input_before_calling_focus_lost_fn: bool,
    pub update_text_input_before_calling_vk_down_fn: bool,
    pub cursor_animation: AzOptionTimerIdEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ProgressBar` struct
#[repr(C)]
pub struct AzProgressBar {
    pub state: AzProgressBarState,
    pub height: AzPixelValue,
    pub bar_background: AzStyleBackgroundContentVec,
    pub container_background: AzStyleBackgroundContentVec,
}

/// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMap` struct
#[repr(C)]
pub struct AzNodeTypeIdInfoMap {
    pub node_type_id: AzNodeTypeId,
    pub node_type_info: AzNodeTypeInfo,
}

/// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMap` struct
#[repr(C)]
pub struct AzInputOutputTypeIdInfoMap {
    pub io_type_id: AzInputOutputTypeId,
    pub io_info: AzInputOutputInfo,
}

/// Re-export of rust-allocated (stack based) `NodeTypeField` struct
#[repr(C)]
pub struct AzNodeTypeField {
    pub key: AzString,
    pub value: AzNodeTypeFieldValueEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `CssPropertySource` struct
#[repr(C, u8)]
pub enum AzCssPropertySource {
    Css(AzCssPath),
    Inline,
}

/// Re-export of rust-allocated (stack based) `VertexLayout` struct
#[repr(C)]
pub struct AzVertexLayout {
    pub fields: AzVertexAttributeVec,
}

/// Re-export of rust-allocated (stack based) `VertexArrayObject` struct
#[repr(C)]
pub struct AzVertexArrayObject {
    pub vertex_layout: AzVertexLayout,
    pub vao_id: u32,
    pub gl_context: AzGl,
    pub refcount: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `VertexBuffer` struct
#[repr(C)]
pub struct AzVertexBuffer {
    pub vertex_buffer_id: u32,
    pub vertex_buffer_len: usize,
    pub vao: AzVertexArrayObject,
    pub index_buffer_id: u32,
    pub index_buffer_len: usize,
    pub index_buffer_format: AzIndexBufferFormatEnumWrapper,
    pub refcount: *const c_void,
    pub run_destructor: bool,
}

/// Re-export of rust-allocated (stack based) `SvgMultiPolygon` struct
#[repr(C)]
pub struct AzSvgMultiPolygon {
    pub rings: AzSvgPathVec,
}

/// Re-export of rust-allocated (stack based) `SvgSimpleNode` struct
#[repr(C, u8)]
pub enum AzSvgSimpleNode {
    Path(AzSvgPath),
    Circle(AzSvgCircle),
    Rect(AzSvgRect),
    CircleHole(AzSvgCircle),
    RectHole(AzSvgRect),
}

/// Re-export of rust-allocated (stack based) `TessellatedColoredGPUSvgNode` struct
#[repr(C)]
pub struct AzTessellatedColoredGPUSvgNode {
    pub vertex_index_buffer: AzVertexBuffer,
}

/// Re-export of rust-allocated (stack based) `TessellatedGPUSvgNode` struct
#[repr(C)]
pub struct AzTessellatedGPUSvgNode {
    pub vertex_index_buffer: AzVertexBuffer,
}

/// Re-export of rust-allocated (stack based) `XmlNode` struct
#[repr(C)]
pub struct AzXmlNode {
    pub tag: AzString,
    pub attributes: AzStringPairVec,
    pub children: AzXmlNodeVec,
    pub text: AzOptionStringEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`
#[repr(C)]
pub struct AzNodeTypeIdInfoMapVec {
    pub(crate) ptr: *const AzNodeTypeIdInfoMap,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeTypeIdInfoMapVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`
#[repr(C)]
pub struct AzInputOutputTypeIdInfoMapVec {
    pub(crate) ptr: *const AzInputOutputTypeIdInfoMap,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeTypeField>`
#[repr(C)]
pub struct AzNodeTypeFieldVec {
    pub(crate) ptr: *const AzNodeTypeField,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeTypeFieldVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<InlineLine>`
#[repr(C)]
pub struct AzInlineLineVec {
    pub(crate) ptr: *const AzInlineLine,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzInlineLineVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<CssProperty>`
#[repr(C)]
pub struct AzCssPropertyVec {
    pub(crate) ptr: *const AzCssPropertyEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssPropertyVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`
#[repr(C)]
pub struct AzSvgMultiPolygonVec {
    pub(crate) ptr: *const AzSvgMultiPolygon,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgMultiPolygonVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<SvgSimpleNode>`
#[repr(C)]
pub struct AzSvgSimpleNodeVec {
    pub(crate) ptr: *const AzSvgSimpleNodeEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzSvgSimpleNodeVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionCssProperty` struct
#[repr(C, u8)]
pub enum AzOptionCssProperty {
    None,
    Some(AzCssProperty),
}

/// Re-export of rust-allocated (stack based) `XmlTextError` struct
#[repr(C)]
pub struct AzXmlTextError {
    pub stream_error: AzXmlStreamErrorEnumWrapper,
    pub pos: AzSvgParseErrorPosition,
}

/// Platform-specific window configuration, i.e. WM options that are not cross-platform
#[repr(C)]
pub struct AzPlatformSpecificOptions {
    pub windows_options: AzWindowsWindowOptions,
    pub linux_options: AzLinuxWindowOptions,
    pub mac_options: AzMacWindowOptions,
    pub wasm_options: AzWasmWindowOptions,
}

/// Re-export of rust-allocated (stack based) `WindowState` struct
#[repr(C)]
pub struct AzWindowState {
    pub title: AzString,
    pub theme: AzWindowThemeEnumWrapper,
    pub size: AzWindowSize,
    pub position: AzWindowPositionEnumWrapper,
    pub flags: AzWindowFlags,
    pub debug_state: AzDebugState,
    pub keyboard_state: AzKeyboardState,
    pub mouse_state: AzMouseState,
    pub touch_state: AzTouchState,
    pub ime_position: AzImePositionEnumWrapper,
    pub monitor: AzMonitor,
    pub platform_specific_options: AzPlatformSpecificOptions,
    pub renderer_options: AzRendererOptions,
    pub background_color: AzColorU,
    pub layout_callback: AzLayoutCallbackEnumWrapper,
    pub close_callback: AzOptionCallbackEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `CallbackInfo` struct
#[repr(C)]
pub struct AzCallbackInfo {
    pub layout_results: *const c_void,
    pub layout_results_count: usize,
    pub renderer_resources: *const c_void,
    pub previous_window_state: *const c_void,
    pub current_window_state: *const c_void,
    pub modifiable_window_state: *mut AzWindowState,
    pub gl_context: *const AzOptionGlEnumWrapper,
    pub image_cache: *mut c_void,
    pub system_fonts: *mut c_void,
    pub timers: *mut c_void,
    pub threads: *mut c_void,
    pub timers_removed: *mut c_void,
    pub threads_removed: *mut c_void,
    pub current_window_handle: *const AzRawWindowHandleEnumWrapper,
    pub new_windows: *mut c_void,
    pub system_callbacks: *const AzSystemCallbacks,
    pub stop_propagation: *mut bool,
    pub focus_target: *mut c_void,
    pub words_changed_in_callbacks: *mut c_void,
    pub images_changed_in_callbacks: *mut c_void,
    pub image_masks_changed_in_callbacks: *mut c_void,
    pub css_properties_changed_in_callbacks: *mut c_void,
    pub current_scroll_states: *const c_void,
    pub nodes_scrolled_in_callback: *mut c_void,
    pub hit_dom_node: AzDomNodeId,
    pub cursor_relative_to_item: AzOptionLogicalPositionEnumWrapper,
    pub cursor_in_viewport: AzOptionLogicalPositionEnumWrapper,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `InlineText` struct
#[repr(C)]
pub struct AzInlineText {
    pub lines: AzInlineLineVec,
    pub content_size: AzLogicalSize,
    pub font_size_px: f32,
    pub last_word_index: usize,
    pub baseline_descender_px: f32,
}

/// CSS path to set the keyboard input focus
#[repr(C)]
pub struct AzFocusTargetPath {
    pub dom: AzDomId,
    pub css_path: AzCssPath,
}

/// Animation struct to start a new animation
#[repr(C)]
pub struct AzAnimation {
    pub from: AzCssPropertyEnumWrapper,
    pub to: AzCssPropertyEnumWrapper,
    pub duration: AzDurationEnumWrapper,
    pub repeat: AzAnimationRepeatEnumWrapper,
    pub repeat_count: AzAnimationRepeatCountEnumWrapper,
    pub easing: AzAnimationEasingEnumWrapper,
    pub relayout_on_finish: bool,
}

/// Re-export of rust-allocated (stack based) `TimerCallbackInfo` struct
#[repr(C)]
pub struct AzTimerCallbackInfo {
    pub callback_info: AzCallbackInfo,
    pub node_id: AzOptionDomNodeIdEnumWrapper,
    pub frame_start: AzInstantEnumWrapper,
    pub call_count: usize,
    pub is_about_to_finish: bool,
    pub _reserved_ref: *const c_void,
    pub _reserved_mut: *mut c_void,
}

/// Re-export of rust-allocated (stack based) `NodeDataInlineCssProperty` struct
#[repr(C, u8)]
pub enum AzNodeDataInlineCssProperty {
    Normal(AzCssProperty),
    Active(AzCssProperty),
    Focus(AzCssProperty),
    Hover(AzCssProperty),
}

/// Re-export of rust-allocated (stack based) `DynamicCssProperty` struct
#[repr(C)]
pub struct AzDynamicCssProperty {
    pub dynamic_id: AzString,
    pub default_value: AzCssPropertyEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `Node` struct
#[repr(C)]
pub struct AzNode {
    pub node_type: AzNodeTypeId,
    pub position: AzNodePosition,
    pub fields: AzNodeTypeFieldVec,
    pub connect_in: AzInputConnectionVec,
    pub connect_out: AzOutputConnectionVec,
}

/// Re-export of rust-allocated (stack based) `SvgNode` struct
#[repr(C, u8)]
pub enum AzSvgNode {
    MultiPolygonCollection(AzSvgMultiPolygonVec),
    MultiPolygon(AzSvgMultiPolygon),
    MultiShape(AzSvgSimpleNodeVec),
    Path(AzSvgPath),
    Circle(AzSvgCircle),
    Rect(AzSvgRect),
}

/// Re-export of rust-allocated (stack based) `SvgStyledNode` struct
#[repr(C)]
pub struct AzSvgStyledNode {
    pub geometry: AzSvgNodeEnumWrapper,
    pub style: AzSvgStyleEnumWrapper,
}

/// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`
#[repr(C)]
pub struct AzNodeDataInlineCssPropertyVec {
    pub(crate) ptr: *const AzNodeDataInlineCssPropertyEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeDataInlineCssPropertyVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionWindowState` struct
#[repr(C, u8)]
pub enum AzOptionWindowState {
    None,
    Some(AzWindowState),
}

/// Re-export of rust-allocated (stack based) `OptionInlineText` struct
#[repr(C, u8)]
pub enum AzOptionInlineText {
    None,
    Some(AzInlineText),
}

/// Re-export of rust-allocated (stack based) `XmlParseError` struct
#[repr(C, u8)]
pub enum AzXmlParseError {
    InvalidDeclaration(AzXmlTextError),
    InvalidComment(AzXmlTextError),
    InvalidPI(AzXmlTextError),
    InvalidDoctype(AzXmlTextError),
    InvalidEntity(AzXmlTextError),
    InvalidElement(AzXmlTextError),
    InvalidAttribute(AzXmlTextError),
    InvalidCdata(AzXmlTextError),
    InvalidCharData(AzXmlTextError),
    UnknownToken(AzSvgParseErrorPosition),
}

/// Options on how to initially create the window
#[repr(C)]
pub struct AzWindowCreateOptions {
    pub state: AzWindowState,
    pub size_to_content: bool,
    pub renderer_type: AzOptionRendererOptionsEnumWrapper,
    pub theme: AzOptionWindowThemeEnumWrapper,
    pub create_callback: AzOptionCallbackEnumWrapper,
    pub hot_reload: bool,
}

/// Defines the keyboard input focus target
#[repr(C, u8)]
pub enum AzFocusTarget {
    Id(AzDomNodeId),
    Path(AzFocusTargetPath),
    Previous,
    Next,
    First,
    Last,
    NoFocus,
}

/// Represents one single DOM node (node type, classes, ids and callbacks are stored here)
#[repr(C)]
pub struct AzNodeData {
    pub node_type: AzNodeTypeEnumWrapper,
    pub dataset: AzOptionRefAnyEnumWrapper,
    pub ids_and_classes: AzIdOrClassVec,
    pub callbacks: AzCallbackDataVec,
    pub inline_css_props: AzNodeDataInlineCssPropertyVec,
    pub tab_index: AzOptionTabIndexEnumWrapper,
    pub extra: *const c_void,
}

/// Re-export of rust-allocated (stack based) `CssDeclaration` struct
#[repr(C, u8)]
pub enum AzCssDeclaration {
    Static(AzCssProperty),
    Dynamic(AzDynamicCssProperty),
}

/// Re-export of rust-allocated (stack based) `Button` struct
#[repr(C)]
pub struct AzButton {
    pub label: AzString,
    pub image: AzOptionImageRefEnumWrapper,
    pub container_style: AzNodeDataInlineCssPropertyVec,
    pub label_style: AzNodeDataInlineCssPropertyVec,
    pub image_style: AzNodeDataInlineCssPropertyVec,
    pub on_click: AzOptionButtonOnClickEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `FileInput` struct
#[repr(C)]
pub struct AzFileInput {
    pub state: AzFileInputStateWrapper,
    pub default_text: AzString,
    pub image: AzOptionImageRefEnumWrapper,
    pub container_style: AzNodeDataInlineCssPropertyVec,
    pub label_style: AzNodeDataInlineCssPropertyVec,
    pub image_style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `CheckBox` struct
#[repr(C)]
pub struct AzCheckBox {
    pub state: AzCheckBoxStateWrapper,
    pub container_style: AzNodeDataInlineCssPropertyVec,
    pub content_style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `Label` struct
#[repr(C)]
pub struct AzLabel {
    pub text: AzString,
    pub style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `ColorInput` struct
#[repr(C)]
pub struct AzColorInput {
    pub state: AzColorInputStateWrapper,
    pub style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `TextInput` struct
#[repr(C)]
pub struct AzTextInput {
    pub state: AzTextInputStateWrapper,
    pub placeholder_style: AzNodeDataInlineCssPropertyVec,
    pub container_style: AzNodeDataInlineCssPropertyVec,
    pub label_style: AzNodeDataInlineCssPropertyVec,
}

/// Re-export of rust-allocated (stack based) `NumberInput` struct
#[repr(C)]
pub struct AzNumberInput {
    pub text_input: AzTextInput,
    pub state: AzNumberInputStateWrapper,
}

/// Re-export of rust-allocated (stack based) `NodeIdNodeMap` struct
#[repr(C)]
pub struct AzNodeIdNodeMap {
    pub node_id: AzNodeGraphNodeId,
    pub node: AzNode,
}

/// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`
#[repr(C)]
pub struct AzNodeIdNodeMapVec {
    pub(crate) ptr: *const AzNodeIdNodeMap,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeIdNodeMapVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `CssDeclaration`
#[repr(C)]
pub struct AzCssDeclarationVec {
    pub(crate) ptr: *const AzCssDeclarationEnumWrapper,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssDeclarationVecDestructorEnumWrapper,
}

/// Wrapper over a Rust-allocated `NodeDataVec`
#[repr(C)]
pub struct AzNodeDataVec {
    pub(crate) ptr: *const AzNodeData,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzNodeDataVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `XmlError` struct
#[repr(C, u8)]
pub enum AzXmlError {
    NoParserAvailable,
    InvalidXmlPrefixUri(AzSvgParseErrorPosition),
    UnexpectedXmlUri(AzSvgParseErrorPosition),
    UnexpectedXmlnsUri(AzSvgParseErrorPosition),
    InvalidElementNamePrefix(AzSvgParseErrorPosition),
    DuplicatedNamespace(AzDuplicatedNamespaceError),
    UnknownNamespace(AzUnknownNamespaceError),
    UnexpectedCloseTag(AzUnexpectedCloseTagError),
    UnexpectedEntityCloseTag(AzSvgParseErrorPosition),
    UnknownEntityReference(AzUnknownEntityReferenceError),
    MalformedEntityReference(AzSvgParseErrorPosition),
    EntityReferenceLoop(AzSvgParseErrorPosition),
    InvalidAttributeValue(AzSvgParseErrorPosition),
    DuplicatedAttribute(AzDuplicatedAttributeError),
    NoRootNode,
    SizeLimit,
    ParserError(AzXmlParseError),
}

/// Re-export of rust-allocated (stack based) `Dom` struct
#[repr(C)]
pub struct AzDom {
    pub root: AzNodeData,
    pub children: AzDomVec,
    pub total_children: usize,
}

/// Re-export of rust-allocated (stack based) `CssRuleBlock` struct
#[repr(C)]
pub struct AzCssRuleBlock {
    pub path: AzCssPath,
    pub declarations: AzCssDeclarationVec,
}

/// Re-export of rust-allocated (stack based) `TabContent` struct
#[repr(C)]
pub struct AzTabContent {
    pub content: AzDom,
    pub has_padding: bool,
}

/// Re-export of rust-allocated (stack based) `Frame` struct
#[repr(C)]
pub struct AzFrame {
    pub title: AzString,
    pub flex_grow: f32,
    pub content: AzDom,
}

/// Re-export of rust-allocated (stack based) `NodeGraph` struct
#[repr(C)]
pub struct AzNodeGraph {
    pub node_types: AzNodeTypeIdInfoMapVec,
    pub input_output_types: AzInputOutputTypeIdInfoMapVec,
    pub nodes: AzNodeIdNodeMapVec,
    pub allow_multiple_root_nodes: bool,
    pub offset: AzLogicalPosition,
    pub style: AzNodeGraphStyleEnumWrapper,
    pub callbacks: AzNodeGraphCallbacks,
    pub add_node_str: AzString,
    pub scale_factor: f32,
}

/// Re-export of rust-allocated (stack based) `StyledDom` struct
#[repr(C)]
pub struct AzStyledDom {
    pub root: AzNodeId,
    pub node_hierarchy: AzNodeHierarchyItemVec,
    pub node_data: AzNodeDataVec,
    pub styled_nodes: AzStyledNodeVec,
    pub cascade_info: AzCascadeInfoVec,
    pub nodes_with_window_callbacks: AzNodeIdVec,
    pub nodes_with_not_callbacks: AzNodeIdVec,
    pub nodes_with_datasets_and_callbacks: AzNodeIdVec,
    pub tag_ids_to_node_ids: AzTagIdToNodeIdMappingVec,
    pub non_leaf_nodes: AzParentWithNodeDepthVec,
    pub css_property_cache: AzCssPropertyCache,
}

/// Wrapper over a Rust-allocated `CssRuleBlock`
#[repr(C)]
pub struct AzCssRuleBlockVec {
    pub(crate) ptr: *const AzCssRuleBlock,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzCssRuleBlockVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `OptionDom` struct
#[repr(C, u8)]
pub enum AzOptionDom {
    None,
    Some(AzDom),
}

/// Re-export of rust-allocated (stack based) `ResultXmlXmlError` struct
#[repr(C, u8)]
pub enum AzResultXmlXmlError {
    Ok(AzXml),
    Err(AzXmlError),
}

/// Re-export of rust-allocated (stack based) `SvgParseError` struct
#[repr(C, u8)]
pub enum AzSvgParseError {
    NoParserAvailable,
    ElementsLimitReached,
    NotAnUtf8Str,
    MalformedGZip,
    InvalidSize,
    ParsingFailed(AzXmlError),
}

/// <img src="../images/scrollbounds.png"/>
#[repr(C)]
pub struct AzIFrameCallbackReturn {
    pub dom: AzStyledDom,
    pub scroll_size: AzLogicalSize,
    pub scroll_offset: AzLogicalPosition,
    pub virtual_scroll_size: AzLogicalSize,
    pub virtual_scroll_offset: AzLogicalPosition,
}

/// Re-export of rust-allocated (stack based) `Stylesheet` struct
#[repr(C)]
pub struct AzStylesheet {
    pub rules: AzCssRuleBlockVec,
}

/// Wrapper over a Rust-allocated `Stylesheet`
#[repr(C)]
pub struct AzStylesheetVec {
    pub(crate) ptr: *const AzStylesheet,
    pub len: usize,
    pub cap: usize,
    pub destructor: AzStylesheetVecDestructorEnumWrapper,
}

/// Re-export of rust-allocated (stack based) `ResultSvgXmlNodeSvgParseError` struct
#[repr(C, u8)]
pub enum AzResultSvgXmlNodeSvgParseError {
    Ok(AzSvgXmlNode),
    Err(AzSvgParseError),
}

/// Re-export of rust-allocated (stack based) `ResultSvgSvgParseError` struct
#[repr(C, u8)]
pub enum AzResultSvgSvgParseError {
    Ok(AzSvg),
    Err(AzSvgParseError),
}

/// Re-export of rust-allocated (stack based) `Css` struct
#[repr(C)]
pub struct AzCss {
    pub stylesheets: AzStylesheetVec,
}

/// `AzAppLogLevelEnumWrapper` struct
#[repr(transparent)]
pub struct AzAppLogLevelEnumWrapper {
    pub inner: AzAppLogLevel,
}

/// `AzLayoutSolverEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutSolverEnumWrapper {
    pub inner: AzLayoutSolver,
}

/// `AzVsyncEnumWrapper` struct
#[repr(transparent)]
pub struct AzVsyncEnumWrapper {
    pub inner: AzVsync,
}

/// `AzSrgbEnumWrapper` struct
#[repr(transparent)]
pub struct AzSrgbEnumWrapper {
    pub inner: AzSrgb,
}

/// `AzHwAccelerationEnumWrapper` struct
#[repr(transparent)]
pub struct AzHwAccelerationEnumWrapper {
    pub inner: AzHwAcceleration,
}

/// `AzXWindowTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzXWindowTypeEnumWrapper {
    pub inner: AzXWindowType,
}

/// `AzVirtualKeyCodeEnumWrapper` struct
#[repr(transparent)]
pub struct AzVirtualKeyCodeEnumWrapper {
    pub inner: AzVirtualKeyCode,
}

/// `AzWindowFrameEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowFrameEnumWrapper {
    pub inner: AzWindowFrame,
}

/// `AzMouseCursorTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzMouseCursorTypeEnumWrapper {
    pub inner: AzMouseCursorType,
}

/// `AzRendererTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzRendererTypeEnumWrapper {
    pub inner: AzRendererType,
}

/// `AzFullScreenModeEnumWrapper` struct
#[repr(transparent)]
pub struct AzFullScreenModeEnumWrapper {
    pub inner: AzFullScreenMode,
}

/// `AzWindowThemeEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowThemeEnumWrapper {
    pub inner: AzWindowTheme,
}

/// `AzUpdateImageTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzUpdateImageTypeEnumWrapper {
    pub inner: AzUpdateImageType,
}

/// `AzUpdateEnumWrapper` struct
#[repr(transparent)]
pub struct AzUpdateEnumWrapper {
    pub inner: AzUpdate,
}

/// `AzScriptTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzScriptTypeEnumWrapper {
    pub inner: AzScriptType,
}

/// `AzAnimationRepeatEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationRepeatEnumWrapper {
    pub inner: AzAnimationRepeat,
}

/// `AzAnimationRepeatCountEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationRepeatCountEnumWrapper {
    pub inner: AzAnimationRepeatCount,
}

/// `AzOnEnumWrapper` struct
#[repr(transparent)]
pub struct AzOnEnumWrapper {
    pub inner: AzOn,
}

/// `AzHoverEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzHoverEventFilterEnumWrapper {
    pub inner: AzHoverEventFilter,
}

/// `AzFocusEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzFocusEventFilterEnumWrapper {
    pub inner: AzFocusEventFilter,
}

/// `AzWindowEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowEventFilterEnumWrapper {
    pub inner: AzWindowEventFilter,
}

/// `AzComponentEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzComponentEventFilterEnumWrapper {
    pub inner: AzComponentEventFilter,
}

/// `AzApplicationEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzApplicationEventFilterEnumWrapper {
    pub inner: AzApplicationEventFilter,
}

/// `AzAccessibilityRoleEnumWrapper` struct
#[repr(transparent)]
pub struct AzAccessibilityRoleEnumWrapper {
    pub inner: AzAccessibilityRole,
}

/// `AzAccessibilityStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzAccessibilityStateEnumWrapper {
    pub inner: AzAccessibilityState,
}

/// `AzTabIndexEnumWrapper` struct
#[repr(transparent)]
pub struct AzTabIndexEnumWrapper {
    pub inner: AzTabIndex,
}

/// `AzContextMenuMouseButtonEnumWrapper` struct
#[repr(transparent)]
pub struct AzContextMenuMouseButtonEnumWrapper {
    pub inner: AzContextMenuMouseButton,
}

/// `AzMenuPopupPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuPopupPositionEnumWrapper {
    pub inner: AzMenuPopupPosition,
}

/// `AzMenuItemStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemStateEnumWrapper {
    pub inner: AzMenuItemState,
}

/// `AzNodeTypeKeyEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeKeyEnumWrapper {
    pub inner: AzNodeTypeKey,
}

/// `AzCssPropertyTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertyTypeEnumWrapper {
    pub inner: AzCssPropertyType,
}

/// `AzSizeMetricEnumWrapper` struct
#[repr(transparent)]
pub struct AzSizeMetricEnumWrapper {
    pub inner: AzSizeMetric,
}

/// `AzBoxShadowClipModeEnumWrapper` struct
#[repr(transparent)]
pub struct AzBoxShadowClipModeEnumWrapper {
    pub inner: AzBoxShadowClipMode,
}

/// `AzStyleMixBlendModeEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleMixBlendModeEnumWrapper {
    pub inner: AzStyleMixBlendMode,
}

/// `AzLayoutAlignContentEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignContentEnumWrapper {
    pub inner: AzLayoutAlignContent,
}

/// `AzLayoutAlignItemsEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignItemsEnumWrapper {
    pub inner: AzLayoutAlignItems,
}

/// `AzLayoutBoxSizingEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBoxSizingEnumWrapper {
    pub inner: AzLayoutBoxSizing,
}

/// `AzLayoutFlexDirectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexDirectionEnumWrapper {
    pub inner: AzLayoutFlexDirection,
}

/// `AzLayoutDisplayEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutDisplayEnumWrapper {
    pub inner: AzLayoutDisplay,
}

/// `AzLayoutFloatEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFloatEnumWrapper {
    pub inner: AzLayoutFloat,
}

/// `AzLayoutJustifyContentEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutJustifyContentEnumWrapper {
    pub inner: AzLayoutJustifyContent,
}

/// `AzLayoutPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPositionEnumWrapper {
    pub inner: AzLayoutPosition,
}

/// `AzLayoutFlexWrapEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexWrapEnumWrapper {
    pub inner: AzLayoutFlexWrap,
}

/// `AzLayoutOverflowEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutOverflowEnumWrapper {
    pub inner: AzLayoutOverflow,
}

/// `AzAngleMetricEnumWrapper` struct
#[repr(transparent)]
pub struct AzAngleMetricEnumWrapper {
    pub inner: AzAngleMetric,
}

/// `AzDirectionCornerEnumWrapper` struct
#[repr(transparent)]
pub struct AzDirectionCornerEnumWrapper {
    pub inner: AzDirectionCorner,
}

/// `AzExtendModeEnumWrapper` struct
#[repr(transparent)]
pub struct AzExtendModeEnumWrapper {
    pub inner: AzExtendMode,
}

/// `AzShapeEnumWrapper` struct
#[repr(transparent)]
pub struct AzShapeEnumWrapper {
    pub inner: AzShape,
}

/// `AzRadialGradientSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzRadialGradientSizeEnumWrapper {
    pub inner: AzRadialGradientSize,
}

/// `AzStyleBackgroundRepeatEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatEnumWrapper {
    pub inner: AzStyleBackgroundRepeat,
}

/// `AzBorderStyleEnumWrapper` struct
#[repr(transparent)]
pub struct AzBorderStyleEnumWrapper {
    pub inner: AzBorderStyle,
}

/// `AzStyleCursorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleCursorEnumWrapper {
    pub inner: AzStyleCursor,
}

/// `AzStyleBackfaceVisibilityEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackfaceVisibilityEnumWrapper {
    pub inner: AzStyleBackfaceVisibility,
}

/// `AzStyleTextAlignEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTextAlignEnumWrapper {
    pub inner: AzStyleTextAlign,
}

/// `AzTextInputValidEnumWrapper` struct
#[repr(transparent)]
pub struct AzTextInputValidEnumWrapper {
    pub inner: AzTextInputValid,
}

/// `AzNodeGraphStyleEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeGraphStyleEnumWrapper {
    pub inner: AzNodeGraphStyle,
}

/// `AzVertexAttributeTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzVertexAttributeTypeEnumWrapper {
    pub inner: AzVertexAttributeType,
}

/// `AzIndexBufferFormatEnumWrapper` struct
#[repr(transparent)]
pub struct AzIndexBufferFormatEnumWrapper {
    pub inner: AzIndexBufferFormat,
}

/// `AzGlTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzGlTypeEnumWrapper {
    pub inner: AzGlType,
}

/// `AzRawImageFormatEnumWrapper` struct
#[repr(transparent)]
pub struct AzRawImageFormatEnumWrapper {
    pub inner: AzRawImageFormat,
}

/// `AzEncodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzEncodeImageErrorEnumWrapper {
    pub inner: AzEncodeImageError,
}

/// `AzDecodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzDecodeImageErrorEnumWrapper {
    pub inner: AzDecodeImageError,
}

/// `AzShapeRenderingEnumWrapper` struct
#[repr(transparent)]
pub struct AzShapeRenderingEnumWrapper {
    pub inner: AzShapeRendering,
}

/// `AzTextRenderingEnumWrapper` struct
#[repr(transparent)]
pub struct AzTextRenderingEnumWrapper {
    pub inner: AzTextRendering,
}

/// `AzImageRenderingEnumWrapper` struct
#[repr(transparent)]
pub struct AzImageRenderingEnumWrapper {
    pub inner: AzImageRendering,
}

/// `AzFontDatabaseEnumWrapper` struct
#[repr(transparent)]
pub struct AzFontDatabaseEnumWrapper {
    pub inner: AzFontDatabase,
}

/// `AzIndentEnumWrapper` struct
#[repr(transparent)]
pub struct AzIndentEnumWrapper {
    pub inner: AzIndent,
}

/// `AzSvgFitToEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgFitToEnumWrapper {
    pub inner: AzSvgFitTo,
}

/// `AzSvgFillRuleEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgFillRuleEnumWrapper {
    pub inner: AzSvgFillRule,
}

/// `AzSvgLineJoinEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgLineJoinEnumWrapper {
    pub inner: AzSvgLineJoin,
}

/// `AzSvgLineCapEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgLineCapEnumWrapper {
    pub inner: AzSvgLineCap,
}

/// `AzMsgBoxIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzMsgBoxIconEnumWrapper {
    pub inner: AzMsgBoxIcon,
}

/// `AzMsgBoxYesNoEnumWrapper` struct
#[repr(transparent)]
pub struct AzMsgBoxYesNoEnumWrapper {
    pub inner: AzMsgBoxYesNo,
}

/// `AzMsgBoxOkCancelEnumWrapper` struct
#[repr(transparent)]
pub struct AzMsgBoxOkCancelEnumWrapper {
    pub inner: AzMsgBoxOkCancel,
}

/// `AzTerminateTimerEnumWrapper` struct
#[repr(transparent)]
pub struct AzTerminateTimerEnumWrapper {
    pub inner: AzTerminateTimer,
}

/// `AzStyleFontFamilyVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontFamilyVecDestructorEnumWrapper {
    pub inner: AzStyleFontFamilyVecDestructor,
}

/// `AzListViewRowVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzListViewRowVecDestructorEnumWrapper {
    pub inner: AzListViewRowVecDestructor,
}

/// `AzStyleFilterVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFilterVecDestructorEnumWrapper {
    pub inner: AzStyleFilterVecDestructor,
}

/// `AzLogicalRectVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzLogicalRectVecDestructorEnumWrapper {
    pub inner: AzLogicalRectVecDestructor,
}

/// `AzNodeTypeIdInfoMapVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    pub inner: AzNodeTypeIdInfoMapVecDestructor,
}

/// `AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    pub inner: AzInputOutputTypeIdInfoMapVecDestructor,
}

/// `AzNodeIdNodeMapVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeIdNodeMapVecDestructorEnumWrapper {
    pub inner: AzNodeIdNodeMapVecDestructor,
}

/// `AzInputOutputTypeIdVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputOutputTypeIdVecDestructorEnumWrapper {
    pub inner: AzInputOutputTypeIdVecDestructor,
}

/// `AzNodeTypeFieldVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeFieldVecDestructorEnumWrapper {
    pub inner: AzNodeTypeFieldVecDestructor,
}

/// `AzInputConnectionVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputConnectionVecDestructorEnumWrapper {
    pub inner: AzInputConnectionVecDestructor,
}

/// `AzOutputNodeAndIndexVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzOutputNodeAndIndexVecDestructorEnumWrapper {
    pub inner: AzOutputNodeAndIndexVecDestructor,
}

/// `AzOutputConnectionVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzOutputConnectionVecDestructorEnumWrapper {
    pub inner: AzOutputConnectionVecDestructor,
}

/// `AzInputNodeAndIndexVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInputNodeAndIndexVecDestructorEnumWrapper {
    pub inner: AzInputNodeAndIndexVecDestructor,
}

/// `AzAccessibilityStateVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzAccessibilityStateVecDestructorEnumWrapper {
    pub inner: AzAccessibilityStateVecDestructor,
}

/// `AzMenuItemVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemVecDestructorEnumWrapper {
    pub inner: AzMenuItemVecDestructor,
}

/// `AzTessellatedSvgNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzTessellatedSvgNodeVecDestructorEnumWrapper {
    pub inner: AzTessellatedSvgNodeVecDestructor,
}

/// `AzTessellatedColoredSvgNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
    pub inner: AzTessellatedColoredSvgNodeVecDestructor,
}

/// `AzXmlNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlNodeVecDestructorEnumWrapper {
    pub inner: AzXmlNodeVecDestructor,
}

/// `AzFmtArgVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzFmtArgVecDestructorEnumWrapper {
    pub inner: AzFmtArgVecDestructor,
}

/// `AzInlineLineVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineLineVecDestructorEnumWrapper {
    pub inner: AzInlineLineVecDestructor,
}

/// `AzInlineWordVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineWordVecDestructorEnumWrapper {
    pub inner: AzInlineWordVecDestructor,
}

/// `AzInlineGlyphVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineGlyphVecDestructorEnumWrapper {
    pub inner: AzInlineGlyphVecDestructor,
}

/// `AzInlineTextHitVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineTextHitVecDestructorEnumWrapper {
    pub inner: AzInlineTextHitVecDestructor,
}

/// `AzMonitorVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzMonitorVecDestructorEnumWrapper {
    pub inner: AzMonitorVecDestructor,
}

/// `AzVideoModeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzVideoModeVecDestructorEnumWrapper {
    pub inner: AzVideoModeVecDestructor,
}

/// `AzDomVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzDomVecDestructorEnumWrapper {
    pub inner: AzDomVecDestructor,
}

/// `AzIdOrClassVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzIdOrClassVecDestructorEnumWrapper {
    pub inner: AzIdOrClassVecDestructor,
}

/// `AzNodeDataInlineCssPropertyVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    pub inner: AzNodeDataInlineCssPropertyVecDestructor,
}

/// `AzStyleBackgroundContentVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundContentVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundContentVecDestructor,
}

/// `AzStyleBackgroundPositionVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundPositionVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundPositionVecDestructor,
}

/// `AzStyleBackgroundRepeatVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundRepeatVecDestructor,
}

/// `AzStyleBackgroundSizeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundSizeVecDestructorEnumWrapper {
    pub inner: AzStyleBackgroundSizeVecDestructor,
}

/// `AzStyleTransformVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformVecDestructorEnumWrapper {
    pub inner: AzStyleTransformVecDestructor,
}

/// `AzCssPropertyVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertyVecDestructorEnumWrapper {
    pub inner: AzCssPropertyVecDestructor,
}

/// `AzSvgMultiPolygonVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgMultiPolygonVecDestructorEnumWrapper {
    pub inner: AzSvgMultiPolygonVecDestructor,
}

/// `AzSvgSimpleNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgSimpleNodeVecDestructorEnumWrapper {
    pub inner: AzSvgSimpleNodeVecDestructor,
}

/// `AzSvgPathVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgPathVecDestructorEnumWrapper {
    pub inner: AzSvgPathVecDestructor,
}

/// `AzVertexAttributeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzVertexAttributeVecDestructorEnumWrapper {
    pub inner: AzVertexAttributeVecDestructor,
}

/// `AzSvgPathElementVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgPathElementVecDestructorEnumWrapper {
    pub inner: AzSvgPathElementVecDestructor,
}

/// `AzSvgVertexVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgVertexVecDestructorEnumWrapper {
    pub inner: AzSvgVertexVecDestructor,
}

/// `AzSvgColoredVertexVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgColoredVertexVecDestructorEnumWrapper {
    pub inner: AzSvgColoredVertexVecDestructor,
}

/// `AzU32VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzU32VecDestructorEnumWrapper {
    pub inner: AzU32VecDestructor,
}

/// `AzXWindowTypeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXWindowTypeVecDestructorEnumWrapper {
    pub inner: AzXWindowTypeVecDestructor,
}

/// `AzVirtualKeyCodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzVirtualKeyCodeVecDestructorEnumWrapper {
    pub inner: AzVirtualKeyCodeVecDestructor,
}

/// `AzCascadeInfoVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCascadeInfoVecDestructorEnumWrapper {
    pub inner: AzCascadeInfoVecDestructor,
}

/// `AzScanCodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzScanCodeVecDestructorEnumWrapper {
    pub inner: AzScanCodeVecDestructor,
}

/// `AzCssDeclarationVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssDeclarationVecDestructorEnumWrapper {
    pub inner: AzCssDeclarationVecDestructor,
}

/// `AzCssPathSelectorVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPathSelectorVecDestructorEnumWrapper {
    pub inner: AzCssPathSelectorVecDestructor,
}

/// `AzStylesheetVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStylesheetVecDestructorEnumWrapper {
    pub inner: AzStylesheetVecDestructor,
}

/// `AzCssRuleBlockVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssRuleBlockVecDestructorEnumWrapper {
    pub inner: AzCssRuleBlockVecDestructor,
}

/// `AzF32VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzF32VecDestructorEnumWrapper {
    pub inner: AzF32VecDestructor,
}

/// `AzU16VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzU16VecDestructorEnumWrapper {
    pub inner: AzU16VecDestructor,
}

/// `AzU8VecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzU8VecDestructorEnumWrapper {
    pub inner: AzU8VecDestructor,
}

/// `AzCallbackDataVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCallbackDataVecDestructorEnumWrapper {
    pub inner: AzCallbackDataVecDestructor,
}

/// `AzDebugMessageVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzDebugMessageVecDestructorEnumWrapper {
    pub inner: AzDebugMessageVecDestructor,
}

/// `AzGLuintVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzGLuintVecDestructorEnumWrapper {
    pub inner: AzGLuintVecDestructor,
}

/// `AzGLintVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzGLintVecDestructorEnumWrapper {
    pub inner: AzGLintVecDestructor,
}

/// `AzStringVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStringVecDestructorEnumWrapper {
    pub inner: AzStringVecDestructor,
}

/// `AzStringPairVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStringPairVecDestructorEnumWrapper {
    pub inner: AzStringPairVecDestructor,
}

/// `AzNormalizedLinearColorStopVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedLinearColorStopVecDestructor,
}

/// `AzNormalizedRadialColorStopVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    pub inner: AzNormalizedRadialColorStopVecDestructor,
}

/// `AzNodeIdVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeIdVecDestructorEnumWrapper {
    pub inner: AzNodeIdVecDestructor,
}

/// `AzNodeHierarchyItemVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeHierarchyItemVecDestructorEnumWrapper {
    pub inner: AzNodeHierarchyItemVecDestructor,
}

/// `AzStyledNodeVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyledNodeVecDestructorEnumWrapper {
    pub inner: AzStyledNodeVecDestructor,
}

/// `AzTagIdToNodeIdMappingVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    pub inner: AzTagIdToNodeIdMappingVecDestructor,
}

/// `AzParentWithNodeDepthVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzParentWithNodeDepthVecDestructorEnumWrapper {
    pub inner: AzParentWithNodeDepthVecDestructor,
}

/// `AzNodeDataVecDestructorEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeDataVecDestructorEnumWrapper {
    pub inner: AzNodeDataVecDestructor,
}

/// `AzOptionI16EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionI16EnumWrapper {
    pub inner: AzOptionI16,
}

/// `AzOptionU16EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU16EnumWrapper {
    pub inner: AzOptionU16,
}

/// `AzOptionU32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU32EnumWrapper {
    pub inner: AzOptionU32,
}

/// `AzOptionHwndHandleEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionHwndHandleEnumWrapper {
    pub inner: AzOptionHwndHandle,
}

/// `AzOptionX11VisualEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionX11VisualEnumWrapper {
    pub inner: AzOptionX11Visual,
}

/// `AzOptionI32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionI32EnumWrapper {
    pub inner: AzOptionI32,
}

/// `AzOptionF32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionF32EnumWrapper {
    pub inner: AzOptionF32,
}

/// `AzOptionCharEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCharEnumWrapper {
    pub inner: AzOptionChar,
}

/// `AzOptionUsizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionUsizeEnumWrapper {
    pub inner: AzOptionUsize,
}

/// `AzRawWindowHandleEnumWrapper` struct
#[repr(transparent)]
pub struct AzRawWindowHandleEnumWrapper {
    pub inner: AzRawWindowHandle,
}

/// `AzAcceleratorKeyEnumWrapper` struct
#[repr(transparent)]
pub struct AzAcceleratorKeyEnumWrapper {
    pub inner: AzAcceleratorKey,
}

/// `AzCursorPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzCursorPositionEnumWrapper {
    pub inner: AzCursorPosition,
}

/// `AzWindowPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowPositionEnumWrapper {
    pub inner: AzWindowPosition,
}

/// `AzImePositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzImePositionEnumWrapper {
    pub inner: AzImePosition,
}

/// `AzPositionInfoEnumWrapper` struct
#[repr(transparent)]
pub struct AzPositionInfoEnumWrapper {
    pub inner: AzPositionInfo,
}

/// `AzNotEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzNotEventFilterEnumWrapper {
    pub inner: AzNotEventFilter,
}

/// `AzMenuItemIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemIconEnumWrapper {
    pub inner: AzMenuItemIcon,
}

/// `AzCssNthChildSelectorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssNthChildSelectorEnumWrapper {
    pub inner: AzCssNthChildSelector,
}

/// `AzStyleCompositeFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleCompositeFilterEnumWrapper {
    pub inner: AzStyleCompositeFilter,
}

/// `AzDirectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzDirectionEnumWrapper {
    pub inner: AzDirection,
}

/// `AzBackgroundPositionHorizontalEnumWrapper` struct
#[repr(transparent)]
pub struct AzBackgroundPositionHorizontalEnumWrapper {
    pub inner: AzBackgroundPositionHorizontal,
}

/// `AzBackgroundPositionVerticalEnumWrapper` struct
#[repr(transparent)]
pub struct AzBackgroundPositionVerticalEnumWrapper {
    pub inner: AzBackgroundPositionVertical,
}

/// `AzStyleBackgroundSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundSizeEnumWrapper {
    pub inner: AzStyleBackgroundSize,
}

/// `AzStyleBoxShadowValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBoxShadowValueEnumWrapper {
    pub inner: AzStyleBoxShadowValue,
}

/// `AzLayoutAlignContentValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignContentValueEnumWrapper {
    pub inner: AzLayoutAlignContentValue,
}

/// `AzLayoutAlignItemsValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutAlignItemsValueEnumWrapper {
    pub inner: AzLayoutAlignItemsValue,
}

/// `AzLayoutBottomValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBottomValueEnumWrapper {
    pub inner: AzLayoutBottomValue,
}

/// `AzLayoutBoxSizingValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBoxSizingValueEnumWrapper {
    pub inner: AzLayoutBoxSizingValue,
}

/// `AzLayoutFlexDirectionValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexDirectionValueEnumWrapper {
    pub inner: AzLayoutFlexDirectionValue,
}

/// `AzLayoutDisplayValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutDisplayValueEnumWrapper {
    pub inner: AzLayoutDisplayValue,
}

/// `AzLayoutFlexGrowValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexGrowValueEnumWrapper {
    pub inner: AzLayoutFlexGrowValue,
}

/// `AzLayoutFlexShrinkValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexShrinkValueEnumWrapper {
    pub inner: AzLayoutFlexShrinkValue,
}

/// `AzLayoutFloatValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFloatValueEnumWrapper {
    pub inner: AzLayoutFloatValue,
}

/// `AzLayoutHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutHeightValueEnumWrapper {
    pub inner: AzLayoutHeightValue,
}

/// `AzLayoutJustifyContentValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutJustifyContentValueEnumWrapper {
    pub inner: AzLayoutJustifyContentValue,
}

/// `AzLayoutLeftValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutLeftValueEnumWrapper {
    pub inner: AzLayoutLeftValue,
}

/// `AzLayoutMarginBottomValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginBottomValueEnumWrapper {
    pub inner: AzLayoutMarginBottomValue,
}

/// `AzLayoutMarginLeftValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginLeftValueEnumWrapper {
    pub inner: AzLayoutMarginLeftValue,
}

/// `AzLayoutMarginRightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginRightValueEnumWrapper {
    pub inner: AzLayoutMarginRightValue,
}

/// `AzLayoutMarginTopValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMarginTopValueEnumWrapper {
    pub inner: AzLayoutMarginTopValue,
}

/// `AzLayoutMaxHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMaxHeightValueEnumWrapper {
    pub inner: AzLayoutMaxHeightValue,
}

/// `AzLayoutMaxWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMaxWidthValueEnumWrapper {
    pub inner: AzLayoutMaxWidthValue,
}

/// `AzLayoutMinHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMinHeightValueEnumWrapper {
    pub inner: AzLayoutMinHeightValue,
}

/// `AzLayoutMinWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutMinWidthValueEnumWrapper {
    pub inner: AzLayoutMinWidthValue,
}

/// `AzLayoutPaddingBottomValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingBottomValueEnumWrapper {
    pub inner: AzLayoutPaddingBottomValue,
}

/// `AzLayoutPaddingLeftValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingLeftValueEnumWrapper {
    pub inner: AzLayoutPaddingLeftValue,
}

/// `AzLayoutPaddingRightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingRightValueEnumWrapper {
    pub inner: AzLayoutPaddingRightValue,
}

/// `AzLayoutPaddingTopValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPaddingTopValueEnumWrapper {
    pub inner: AzLayoutPaddingTopValue,
}

/// `AzLayoutPositionValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutPositionValueEnumWrapper {
    pub inner: AzLayoutPositionValue,
}

/// `AzLayoutRightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutRightValueEnumWrapper {
    pub inner: AzLayoutRightValue,
}

/// `AzLayoutTopValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutTopValueEnumWrapper {
    pub inner: AzLayoutTopValue,
}

/// `AzLayoutWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutWidthValueEnumWrapper {
    pub inner: AzLayoutWidthValue,
}

/// `AzLayoutFlexWrapValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutFlexWrapValueEnumWrapper {
    pub inner: AzLayoutFlexWrapValue,
}

/// `AzLayoutOverflowValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutOverflowValueEnumWrapper {
    pub inner: AzLayoutOverflowValue,
}

/// `AzStyleBorderBottomColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomColorValueEnumWrapper {
    pub inner: AzStyleBorderBottomColorValue,
}

/// `AzStyleBorderBottomLeftRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    pub inner: AzStyleBorderBottomLeftRadiusValue,
}

/// `AzStyleBorderBottomRightRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomRightRadiusValueEnumWrapper {
    pub inner: AzStyleBorderBottomRightRadiusValue,
}

/// `AzStyleBorderBottomStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderBottomStyleValueEnumWrapper {
    pub inner: AzStyleBorderBottomStyleValue,
}

/// `AzLayoutBorderBottomWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderBottomWidthValueEnumWrapper {
    pub inner: AzLayoutBorderBottomWidthValue,
}

/// `AzStyleBorderLeftColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderLeftColorValueEnumWrapper {
    pub inner: AzStyleBorderLeftColorValue,
}

/// `AzStyleBorderLeftStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderLeftStyleValueEnumWrapper {
    pub inner: AzStyleBorderLeftStyleValue,
}

/// `AzLayoutBorderLeftWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderLeftWidthValueEnumWrapper {
    pub inner: AzLayoutBorderLeftWidthValue,
}

/// `AzStyleBorderRightColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderRightColorValueEnumWrapper {
    pub inner: AzStyleBorderRightColorValue,
}

/// `AzStyleBorderRightStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderRightStyleValueEnumWrapper {
    pub inner: AzStyleBorderRightStyleValue,
}

/// `AzLayoutBorderRightWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderRightWidthValueEnumWrapper {
    pub inner: AzLayoutBorderRightWidthValue,
}

/// `AzStyleBorderTopColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopColorValueEnumWrapper {
    pub inner: AzStyleBorderTopColorValue,
}

/// `AzStyleBorderTopLeftRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopLeftRadiusValueEnumWrapper {
    pub inner: AzStyleBorderTopLeftRadiusValue,
}

/// `AzStyleBorderTopRightRadiusValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopRightRadiusValueEnumWrapper {
    pub inner: AzStyleBorderTopRightRadiusValue,
}

/// `AzStyleBorderTopStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBorderTopStyleValueEnumWrapper {
    pub inner: AzStyleBorderTopStyleValue,
}

/// `AzLayoutBorderTopWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutBorderTopWidthValueEnumWrapper {
    pub inner: AzLayoutBorderTopWidthValue,
}

/// `AzStyleCursorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleCursorValueEnumWrapper {
    pub inner: AzStyleCursorValue,
}

/// `AzStyleFontSizeValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontSizeValueEnumWrapper {
    pub inner: AzStyleFontSizeValue,
}

/// `AzStyleLetterSpacingValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleLetterSpacingValueEnumWrapper {
    pub inner: AzStyleLetterSpacingValue,
}

/// `AzStyleLineHeightValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleLineHeightValueEnumWrapper {
    pub inner: AzStyleLineHeightValue,
}

/// `AzStyleTabWidthValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTabWidthValueEnumWrapper {
    pub inner: AzStyleTabWidthValue,
}

/// `AzStyleTextAlignValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTextAlignValueEnumWrapper {
    pub inner: AzStyleTextAlignValue,
}

/// `AzStyleTextColorValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTextColorValueEnumWrapper {
    pub inner: AzStyleTextColorValue,
}

/// `AzStyleWordSpacingValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleWordSpacingValueEnumWrapper {
    pub inner: AzStyleWordSpacingValue,
}

/// `AzStyleOpacityValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleOpacityValueEnumWrapper {
    pub inner: AzStyleOpacityValue,
}

/// `AzStyleTransformOriginValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformOriginValueEnumWrapper {
    pub inner: AzStyleTransformOriginValue,
}

/// `AzStylePerspectiveOriginValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStylePerspectiveOriginValueEnumWrapper {
    pub inner: AzStylePerspectiveOriginValue,
}

/// `AzStyleBackfaceVisibilityValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackfaceVisibilityValueEnumWrapper {
    pub inner: AzStyleBackfaceVisibilityValue,
}

/// `AzStyleMixBlendModeValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleMixBlendModeValueEnumWrapper {
    pub inner: AzStyleMixBlendModeValue,
}

/// `AzTextInputSelectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzTextInputSelectionEnumWrapper {
    pub inner: AzTextInputSelection,
}

/// `AzDurationEnumWrapper` struct
#[repr(transparent)]
pub struct AzDurationEnumWrapper {
    pub inner: AzDuration,
}

/// `AzThreadSendMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzThreadSendMsgEnumWrapper {
    pub inner: AzThreadSendMsg,
}

/// `AzOptionSvgPointEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionSvgPointEnumWrapper {
    pub inner: AzOptionSvgPoint,
}

/// `AzOptionStyleTextAlignEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionStyleTextAlignEnumWrapper {
    pub inner: AzOptionStyleTextAlign,
}

/// `AzOptionListViewOnRowClickEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionListViewOnRowClickEnumWrapper {
    pub inner: AzOptionListViewOnRowClick,
}

/// `AzOptionListViewOnColumnClickEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionListViewOnColumnClickEnumWrapper {
    pub inner: AzOptionListViewOnColumnClick,
}

/// `AzOptionListViewOnLazyLoadScrollEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionListViewOnLazyLoadScrollEnumWrapper {
    pub inner: AzOptionListViewOnLazyLoadScroll,
}

/// `AzOptionPixelValueNoPercentEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionPixelValueNoPercentEnumWrapper {
    pub inner: AzOptionPixelValueNoPercent,
}

/// `AzOptionDropDownOnChoiceChangeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDropDownOnChoiceChangeEnumWrapper {
    pub inner: AzOptionDropDownOnChoiceChange,
}

/// `AzOptionNodeGraphOnNodeAddedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeAddedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeAdded,
}

/// `AzOptionNodeGraphOnNodeRemovedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeRemovedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeRemoved,
}

/// `AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeGraphDragged,
}

/// `AzOptionNodeGraphOnNodeDraggedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeDraggedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeDragged,
}

/// `AzOptionNodeGraphOnNodeConnectedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeConnectedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeConnected,
}

/// `AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeInputDisconnected,
}

/// `AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeOutputDisconnected,
}

/// `AzOptionNodeGraphOnNodeFieldEditedEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
    pub inner: AzOptionNodeGraphOnNodeFieldEdited,
}

/// `AzOptionColorInputOnValueChangeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionColorInputOnValueChangeEnumWrapper {
    pub inner: AzOptionColorInputOnValueChange,
}

/// `AzOptionButtonOnClickEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionButtonOnClickEnumWrapper {
    pub inner: AzOptionButtonOnClick,
}

/// `AzOptionTabOnClickEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTabOnClickEnumWrapper {
    pub inner: AzOptionTabOnClick,
}

/// `AzOptionFileInputOnPathChangeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionFileInputOnPathChangeEnumWrapper {
    pub inner: AzOptionFileInputOnPathChange,
}

/// `AzOptionCheckBoxOnToggleEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCheckBoxOnToggleEnumWrapper {
    pub inner: AzOptionCheckBoxOnToggle,
}

/// `AzOptionTextInputOnTextInputEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputOnTextInputEnumWrapper {
    pub inner: AzOptionTextInputOnTextInput,
}

/// `AzOptionTextInputOnVirtualKeyDownEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    pub inner: AzOptionTextInputOnVirtualKeyDown,
}

/// `AzOptionTextInputOnFocusLostEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputOnFocusLostEnumWrapper {
    pub inner: AzOptionTextInputOnFocusLost,
}

/// `AzOptionTextInputSelectionEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextInputSelectionEnumWrapper {
    pub inner: AzOptionTextInputSelection,
}

/// `AzOptionNumberInputOnFocusLostEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNumberInputOnFocusLostEnumWrapper {
    pub inner: AzOptionNumberInputOnFocusLost,
}

/// `AzOptionNumberInputOnValueChangeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNumberInputOnValueChangeEnumWrapper {
    pub inner: AzOptionNumberInputOnValueChange,
}

/// `AzOptionMenuItemIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMenuItemIconEnumWrapper {
    pub inner: AzOptionMenuItemIcon,
}

/// `AzOptionMenuCallbackEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMenuCallbackEnumWrapper {
    pub inner: AzOptionMenuCallback,
}

/// `AzOptionPositionInfoEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionPositionInfoEnumWrapper {
    pub inner: AzOptionPositionInfo,
}

/// `AzOptionTimerIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTimerIdEnumWrapper {
    pub inner: AzOptionTimerId,
}

/// `AzOptionThreadIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionThreadIdEnumWrapper {
    pub inner: AzOptionThreadId,
}

/// `AzOptionImageRefEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionImageRefEnumWrapper {
    pub inner: AzOptionImageRef,
}

/// `AzOptionFontRefEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionFontRefEnumWrapper {
    pub inner: AzOptionFontRef,
}

/// `AzOptionSystemClipboardEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionSystemClipboardEnumWrapper {
    pub inner: AzOptionSystemClipboard,
}

/// `AzOptionGlEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionGlEnumWrapper {
    pub inner: AzOptionGl,
}

/// `AzOptionPercentageValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionPercentageValueEnumWrapper {
    pub inner: AzOptionPercentageValue,
}

/// `AzOptionAngleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionAngleValueEnumWrapper {
    pub inner: AzOptionAngleValue,
}

/// `AzOptionRendererOptionsEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionRendererOptionsEnumWrapper {
    pub inner: AzOptionRendererOptions,
}

/// `AzOptionCallbackEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCallbackEnumWrapper {
    pub inner: AzOptionCallback,
}

/// `AzOptionThreadSendMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionThreadSendMsgEnumWrapper {
    pub inner: AzOptionThreadSendMsg,
}

/// `AzOptionLayoutRectEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLayoutRectEnumWrapper {
    pub inner: AzOptionLayoutRect,
}

/// `AzOptionRefAnyEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionRefAnyEnumWrapper {
    pub inner: AzOptionRefAny,
}

/// `AzOptionLayoutPointEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLayoutPointEnumWrapper {
    pub inner: AzOptionLayoutPoint,
}

/// `AzOptionLayoutSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLayoutSizeEnumWrapper {
    pub inner: AzOptionLayoutSize,
}

/// `AzOptionWindowThemeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWindowThemeEnumWrapper {
    pub inner: AzOptionWindowTheme,
}

/// `AzOptionNodeIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionNodeIdEnumWrapper {
    pub inner: AzOptionNodeId,
}

/// `AzOptionDomNodeIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDomNodeIdEnumWrapper {
    pub inner: AzOptionDomNodeId,
}

/// `AzOptionColorUEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionColorUEnumWrapper {
    pub inner: AzOptionColorU,
}

/// `AzOptionSvgDashPatternEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionSvgDashPatternEnumWrapper {
    pub inner: AzOptionSvgDashPattern,
}

/// `AzOptionLogicalPositionEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLogicalPositionEnumWrapper {
    pub inner: AzOptionLogicalPosition,
}

/// `AzOptionPhysicalPositionI32EnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionPhysicalPositionI32EnumWrapper {
    pub inner: AzOptionPhysicalPositionI32,
}

/// `AzOptionMouseCursorTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMouseCursorTypeEnumWrapper {
    pub inner: AzOptionMouseCursorType,
}

/// `AzOptionLogicalSizeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionLogicalSizeEnumWrapper {
    pub inner: AzOptionLogicalSize,
}

/// `AzOptionVirtualKeyCodeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeEnumWrapper {
    pub inner: AzOptionVirtualKeyCode,
}

/// `AzOptionImageMaskEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionImageMaskEnumWrapper {
    pub inner: AzOptionImageMask,
}

/// `AzOptionTabIndexEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTabIndexEnumWrapper {
    pub inner: AzOptionTabIndex,
}

/// `AzOptionTagIdEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTagIdEnumWrapper {
    pub inner: AzOptionTagId,
}

/// `AzOptionDurationEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDurationEnumWrapper {
    pub inner: AzOptionDuration,
}

/// `AzOptionU8VecEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU8VecEnumWrapper {
    pub inner: AzOptionU8Vec,
}

/// `AzOptionU8VecRefEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionU8VecRefEnumWrapper {
    pub inner: AzOptionU8VecRef,
}

/// `AzResultU8VecEncodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultU8VecEncodeImageErrorEnumWrapper {
    pub inner: AzResultU8VecEncodeImageError,
}

/// `AzWindowIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzWindowIconEnumWrapper {
    pub inner: AzWindowIcon,
}

/// `AzAnimationEasingEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationEasingEnumWrapper {
    pub inner: AzAnimationEasing,
}

/// `AzEventFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzEventFilterEnumWrapper {
    pub inner: AzEventFilter,
}

/// `AzCssPathPseudoSelectorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPathPseudoSelectorEnumWrapper {
    pub inner: AzCssPathPseudoSelector,
}

/// `AzAnimationInterpolationFunctionEnumWrapper` struct
#[repr(transparent)]
pub struct AzAnimationInterpolationFunctionEnumWrapper {
    pub inner: AzAnimationInterpolationFunction,
}

/// `AzStyleFilterEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFilterEnumWrapper {
    pub inner: AzStyleFilter,
}

/// `AzStyleTransformEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformEnumWrapper {
    pub inner: AzStyleTransform,
}

/// `AzStyleBackgroundPositionVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundPositionVecValueEnumWrapper {
    pub inner: AzStyleBackgroundPositionVecValue,
}

/// `AzStyleBackgroundRepeatVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundRepeatVecValueEnumWrapper {
    pub inner: AzStyleBackgroundRepeatVecValue,
}

/// `AzStyleBackgroundSizeVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundSizeVecValueEnumWrapper {
    pub inner: AzStyleBackgroundSizeVecValue,
}

/// `AzRawImageDataEnumWrapper` struct
#[repr(transparent)]
pub struct AzRawImageDataEnumWrapper {
    pub inner: AzRawImageData,
}

/// `AzSvgPathElementEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgPathElementEnumWrapper {
    pub inner: AzSvgPathElement,
}

/// `AzInstantEnumWrapper` struct
#[repr(transparent)]
pub struct AzInstantEnumWrapper {
    pub inner: AzInstant,
}

/// `AzThreadReceiveMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzThreadReceiveMsgEnumWrapper {
    pub inner: AzThreadReceiveMsg,
}

/// `AzOptionMenuEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMenuEnumWrapper {
    pub inner: AzOptionMenu,
}

/// `AzOptionResolvedTextLayoutOptionsEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionResolvedTextLayoutOptionsEnumWrapper {
    pub inner: AzOptionResolvedTextLayoutOptions,
}

/// `AzOptionVirtualKeyCodeComboEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionVirtualKeyCodeComboEnumWrapper {
    pub inner: AzOptionVirtualKeyCodeCombo,
}

/// `AzOptionMouseStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionMouseStateEnumWrapper {
    pub inner: AzOptionMouseState,
}

/// `AzOptionKeyboardStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionKeyboardStateEnumWrapper {
    pub inner: AzOptionKeyboardState,
}

/// `AzOptionStringVecEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionStringVecEnumWrapper {
    pub inner: AzOptionStringVec,
}

/// `AzOptionThreadReceiveMsgEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionThreadReceiveMsgEnumWrapper {
    pub inner: AzOptionThreadReceiveMsg,
}

/// `AzOptionTaskBarIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTaskBarIconEnumWrapper {
    pub inner: AzOptionTaskBarIcon,
}

/// `AzOptionWindowIconEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWindowIconEnumWrapper {
    pub inner: AzOptionWindowIcon,
}

/// `AzOptionStringEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionStringEnumWrapper {
    pub inner: AzOptionString,
}

/// `AzOptionTextureEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionTextureEnumWrapper {
    pub inner: AzOptionTexture,
}

/// `AzOptionInstantEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionInstantEnumWrapper {
    pub inner: AzOptionInstant,
}

/// `AzLayoutCallbackEnumWrapper` struct
#[repr(transparent)]
pub struct AzLayoutCallbackEnumWrapper {
    pub inner: AzLayoutCallback,
}

/// `AzInlineWordEnumWrapper` struct
#[repr(transparent)]
pub struct AzInlineWordEnumWrapper {
    pub inner: AzInlineWord,
}

/// `AzNodeTypeEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeEnumWrapper {
    pub inner: AzNodeType,
}

/// `AzIdOrClassEnumWrapper` struct
#[repr(transparent)]
pub struct AzIdOrClassEnumWrapper {
    pub inner: AzIdOrClass,
}

/// `AzCssPathSelectorEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPathSelectorEnumWrapper {
    pub inner: AzCssPathSelector,
}

/// `AzStyleBackgroundContentEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundContentEnumWrapper {
    pub inner: AzStyleBackgroundContent,
}

/// `AzStyleFontFamilyEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontFamilyEnumWrapper {
    pub inner: AzStyleFontFamily,
}

/// `AzScrollbarStyleValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzScrollbarStyleValueEnumWrapper {
    pub inner: AzScrollbarStyleValue,
}

/// `AzStyleTransformVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleTransformVecValueEnumWrapper {
    pub inner: AzStyleTransformVecValue,
}

/// `AzStyleFilterVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFilterVecValueEnumWrapper {
    pub inner: AzStyleFilterVecValue,
}

/// `AzNodeTypeFieldValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeTypeFieldValueEnumWrapper {
    pub inner: AzNodeTypeFieldValue,
}

/// `AzSvgStyleEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgStyleEnumWrapper {
    pub inner: AzSvgStyle,
}

/// `AzFmtValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzFmtValueEnumWrapper {
    pub inner: AzFmtValue,
}

/// `AzOptionFileTypeListEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionFileTypeListEnumWrapper {
    pub inner: AzOptionFileTypeList,
}

/// `AzOptionFileEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionFileEnumWrapper {
    pub inner: AzOptionFile,
}

/// `AzOptionRawImageEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionRawImageEnumWrapper {
    pub inner: AzOptionRawImage,
}

/// `AzOptionWaylandThemeEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWaylandThemeEnumWrapper {
    pub inner: AzOptionWaylandTheme,
}

/// `AzResultRawImageDecodeImageErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultRawImageDecodeImageErrorEnumWrapper {
    pub inner: AzResultRawImageDecodeImageError,
}

/// `AzXmlStreamErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlStreamErrorEnumWrapper {
    pub inner: AzXmlStreamError,
}

/// `AzMenuItemEnumWrapper` struct
#[repr(transparent)]
pub struct AzMenuItemEnumWrapper {
    pub inner: AzMenuItem,
}

/// `AzStyleBackgroundContentVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleBackgroundContentVecValueEnumWrapper {
    pub inner: AzStyleBackgroundContentVecValue,
}

/// `AzStyleFontFamilyVecValueEnumWrapper` struct
#[repr(transparent)]
pub struct AzStyleFontFamilyVecValueEnumWrapper {
    pub inner: AzStyleFontFamilyVecValue,
}

/// `AzCssPropertyEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertyEnumWrapper {
    pub inner: AzCssProperty,
}

/// `AzCssPropertySourceEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssPropertySourceEnumWrapper {
    pub inner: AzCssPropertySource,
}

/// `AzSvgSimpleNodeEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgSimpleNodeEnumWrapper {
    pub inner: AzSvgSimpleNode,
}

/// `AzOptionCssPropertyEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionCssPropertyEnumWrapper {
    pub inner: AzOptionCssProperty,
}

/// `AzNodeDataInlineCssPropertyEnumWrapper` struct
#[repr(transparent)]
pub struct AzNodeDataInlineCssPropertyEnumWrapper {
    pub inner: AzNodeDataInlineCssProperty,
}

/// `AzSvgNodeEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgNodeEnumWrapper {
    pub inner: AzSvgNode,
}

/// `AzOptionWindowStateEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionWindowStateEnumWrapper {
    pub inner: AzOptionWindowState,
}

/// `AzOptionInlineTextEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionInlineTextEnumWrapper {
    pub inner: AzOptionInlineText,
}

/// `AzXmlParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlParseErrorEnumWrapper {
    pub inner: AzXmlParseError,
}

/// `AzFocusTargetEnumWrapper` struct
#[repr(transparent)]
pub struct AzFocusTargetEnumWrapper {
    pub inner: AzFocusTarget,
}

/// `AzCssDeclarationEnumWrapper` struct
#[repr(transparent)]
pub struct AzCssDeclarationEnumWrapper {
    pub inner: AzCssDeclaration,
}

/// `AzXmlErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzXmlErrorEnumWrapper {
    pub inner: AzXmlError,
}

/// `AzOptionDomEnumWrapper` struct
#[repr(transparent)]
pub struct AzOptionDomEnumWrapper {
    pub inner: AzOptionDom,
}

/// `AzResultXmlXmlErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultXmlXmlErrorEnumWrapper {
    pub inner: AzResultXmlXmlError,
}

/// `AzSvgParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzSvgParseErrorEnumWrapper {
    pub inner: AzSvgParseError,
}

/// `AzResultSvgXmlNodeSvgParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    pub inner: AzResultSvgXmlNodeSvgParseError,
}

/// `AzResultSvgSvgParseErrorEnumWrapper` struct
#[repr(transparent)]
pub struct AzResultSvgSvgParseErrorEnumWrapper {
    pub inner: AzResultSvgSvgParseError,
}

// Necessary because the Python interpreter may send structs across different threads
unsafe impl Send for AzApp {}
unsafe impl Send for AzIOSHandle {}
unsafe impl Send for AzMacOSHandle {}
unsafe impl Send for AzXlibHandle {}
unsafe impl Send for AzXcbHandle {}
unsafe impl Send for AzWaylandHandle {}
unsafe impl Send for AzWindowsHandle {}
unsafe impl Send for AzAndroidHandle {}
unsafe impl Send for AzRefCount {}
unsafe impl Send for AzCssPropertyCache {}
unsafe impl Send for AzGlVoidPtrConst {}
unsafe impl Send for AzGlVoidPtrMut {}
unsafe impl Send for AzU8VecRef {}
unsafe impl Send for AzU8VecRefMut {}
unsafe impl Send for AzF32VecRef {}
unsafe impl Send for AzI32VecRef {}
unsafe impl Send for AzGLuintVecRef {}
unsafe impl Send for AzGLenumVecRef {}
unsafe impl Send for AzGLintVecRefMut {}
unsafe impl Send for AzGLint64VecRefMut {}
unsafe impl Send for AzGLbooleanVecRefMut {}
unsafe impl Send for AzGLfloatVecRefMut {}
unsafe impl Send for AzRefstr {}
unsafe impl Send for AzGLsyncPtr {}
unsafe impl Send for AzImageRef {}
unsafe impl Send for AzFontRef {}
unsafe impl Send for AzSvg {}
unsafe impl Send for AzSvgXmlNode {}
unsafe impl Send for AzSystemClipboard {}
unsafe impl Send for AzThread {}
unsafe impl Send for AzThreadSender {}
unsafe impl Send for AzThreadReceiver {}
unsafe impl Send for AzOptionHwndHandle {}
unsafe impl Send for AzOptionX11Visual {}
unsafe impl Send for AzIFrameCallbackInfo {}
unsafe impl Send for AzRefAny {}
unsafe impl Send for AzStyleBoxShadow {}
unsafe impl Send for AzStyleColorMatrix {}
unsafe impl Send for AzStyleCompositeFilter {}
unsafe impl Send for AzStyleBackgroundSize {}
unsafe impl Send for AzGl {}
unsafe impl Send for AzRefstrVecRef {}
unsafe impl Send for AzFontMetrics {}
unsafe impl Send for AzInstantPtr {}
unsafe impl Send for AzLogicalRectVec {}
unsafe impl Send for AzInputOutputTypeIdVec {}
unsafe impl Send for AzOutputNodeAndIndexVec {}
unsafe impl Send for AzInputNodeAndIndexVec {}
unsafe impl Send for AzAccessibilityStateVec {}
unsafe impl Send for AzMenuItemVec {}
unsafe impl Send for AzXmlNodeVec {}
unsafe impl Send for AzInlineGlyphVec {}
unsafe impl Send for AzInlineTextHitVec {}
unsafe impl Send for AzVideoModeVec {}
unsafe impl Send for AzDomVec {}
unsafe impl Send for AzStyleBackgroundPositionVec {}
unsafe impl Send for AzStyleBackgroundRepeatVec {}
unsafe impl Send for AzStyleBackgroundSizeVec {}
unsafe impl Send for AzSvgVertexVec {}
unsafe impl Send for AzSvgColoredVertexVec {}
unsafe impl Send for AzU32Vec {}
unsafe impl Send for AzXWindowTypeVec {}
unsafe impl Send for AzVirtualKeyCodeVec {}
unsafe impl Send for AzCascadeInfoVec {}
unsafe impl Send for AzScanCodeVec {}
unsafe impl Send for AzU16Vec {}
unsafe impl Send for AzF32Vec {}
unsafe impl Send for AzU8Vec {}
unsafe impl Send for AzGLuintVec {}
unsafe impl Send for AzGLintVec {}
unsafe impl Send for AzNormalizedLinearColorStopVec {}
unsafe impl Send for AzNormalizedRadialColorStopVec {}
unsafe impl Send for AzNodeIdVec {}
unsafe impl Send for AzNodeHierarchyItemVec {}
unsafe impl Send for AzParentWithNodeDepthVec {}
unsafe impl Send for AzRenderImageCallbackInfo {}
unsafe impl Send for AzLayoutCallbackInfo {}
unsafe impl Send for AzTexture {}
unsafe impl Send for AzTessellatedColoredSvgNodeVecRef {}
unsafe impl Send for AzTessellatedSvgNodeVecRef {}
unsafe impl Send for AzListViewRowVec {}
unsafe impl Send for AzStyleFilterVec {}
unsafe impl Send for AzInputConnectionVec {}
unsafe impl Send for AzOutputConnectionVec {}
unsafe impl Send for AzTessellatedSvgNodeVec {}
unsafe impl Send for AzTessellatedColoredSvgNodeVec {}
unsafe impl Send for AzStyleTransformVec {}
unsafe impl Send for AzSvgPathElementVec {}
unsafe impl Send for AzStringVec {}
unsafe impl Send for AzStyledNodeVec {}
unsafe impl Send for AzTagIdToNodeIdMappingVec {}
unsafe impl Send for AzWaylandTheme {}
unsafe impl Send for AzFile {}
unsafe impl Send for AzStyleFontFamilyVec {}
unsafe impl Send for AzFmtArgVec {}
unsafe impl Send for AzInlineWordVec {}
unsafe impl Send for AzMonitorVec {}
unsafe impl Send for AzIdOrClassVec {}
unsafe impl Send for AzStyleBackgroundContentVec {}
unsafe impl Send for AzSvgPathVec {}
unsafe impl Send for AzVertexAttributeVec {}
unsafe impl Send for AzCssPathSelectorVec {}
unsafe impl Send for AzCallbackDataVec {}
unsafe impl Send for AzDebugMessageVec {}
unsafe impl Send for AzStringPairVec {}
unsafe impl Send for AzVertexArrayObject {}
unsafe impl Send for AzVertexBuffer {}
unsafe impl Send for AzNodeTypeIdInfoMapVec {}
unsafe impl Send for AzInputOutputTypeIdInfoMapVec {}
unsafe impl Send for AzNodeTypeFieldVec {}
unsafe impl Send for AzInlineLineVec {}
unsafe impl Send for AzCssPropertyVec {}
unsafe impl Send for AzSvgMultiPolygonVec {}
unsafe impl Send for AzSvgSimpleNodeVec {}
unsafe impl Send for AzCallbackInfo {}
unsafe impl Send for AzTimerCallbackInfo {}
unsafe impl Send for AzNodeDataInlineCssPropertyVec {}
unsafe impl Send for AzNodeData {}
unsafe impl Send for AzNodeIdNodeMapVec {}
unsafe impl Send for AzCssDeclarationVec {}
unsafe impl Send for AzNodeDataVec {}
unsafe impl Send for AzCssRuleBlockVec {}
unsafe impl Send for AzStylesheetVec {}

// Python objects must implement Clone at minimum
impl Clone for AzApp {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAppLogLevelEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutSolverEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::LayoutSolverVersion = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVsyncEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::Vsync = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSrgbEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::Srgb = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzHwAccelerationEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::HwAcceleration = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPoint {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LayoutPoint = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutSize {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LayoutSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIOSHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMacOSHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXlibHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXcbHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWaylandHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowsHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWebHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WebHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAndroidHandle {
    fn clone(&self) -> Self {
        let r: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXWindowTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::XWindowType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPhysicalPositionI32 {
    fn clone(&self) -> Self {
        let r: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPhysicalSizeU32 {
    fn clone(&self) -> Self {
        let r: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLogicalPosition {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LogicalPosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLogicalSize {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LogicalSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIconKey {
    fn clone(&self) -> Self {
        let r: &azul_core::window::IconKey = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVirtualKeyCodeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowFrameEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowFrame = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDebugState {
    fn clone(&self) -> Self {
        let r: &azul_core::window::DebugState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMouseCursorTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MouseCursorType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRendererTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::RendererType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMacWindowOptions {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWasmWindowOptions {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFullScreenModeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::FullScreenMode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowThemeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowTheme = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTouchState {
    fn clone(&self) -> Self {
        let r: &azul_core::window::TouchState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMarshaledLayoutCallbackInner {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::MarshaledLayoutCallbackInner =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutCallbackInner {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::Callback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzUpdateImageTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::UpdateImageType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzUpdateEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::Update = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeId {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDomId {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::DomId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPositionInfoInner {
    fn clone(&self) -> Self {
        let r: &azul_core::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzScriptTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::ui_solver::ScriptType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAnimationRepeatEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::AnimationRepeat = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAnimationRepeatCountEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::AnimationRepeatCount = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIFrameCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRenderImageCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::RenderImageCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTimerCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::TimerCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWriteBackCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::WriteBackCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::ThreadCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRefCount {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::RefCount = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOnEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::On = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzHoverEventFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::HoverEventFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFocusEventFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::FocusEventFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowEventFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::WindowEventFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzComponentEventFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::ComponentEventFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzApplicationEventFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::ApplicationEventFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAccessibilityRoleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAccessibilityStateEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTabIndexEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::TabIndex = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzContextMenuMouseButtonEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenuPopupPositionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MenuPopupPosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenuItemStateEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MenuItemState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeKeyEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::NodeTypeTag = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssNthChildPattern {
    fn clone(&self) -> Self {
        let r: &azul_css::CssNthChildPattern = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPropertyTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPropertyType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzColorU {
    fn clone(&self) -> Self {
        let r: &azul_css::ColorU = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSizeMetricEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::SizeMetric = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzBoxShadowClipModeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::BoxShadowClipMode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleMixBlendModeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleMixBlendMode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutAlignContentEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutAlignContent = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutAlignItemsEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutAlignItems = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBoxSizingEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBoxSizing = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexDirectionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexDirection = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutDisplayEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutDisplay = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFloatEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFloat = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutJustifyContentEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutJustifyContent = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPositionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexWrapEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexWrap = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutOverflowEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutOverflow = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFloatValue {
    fn clone(&self) -> Self {
        let r: &azul_css::FloatValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAngleMetricEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::AngleMetric = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDirectionCornerEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::DirectionCorner = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzExtendModeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::ExtendMode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzShapeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::Shape = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRadialGradientSizeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::RadialGradientSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundRepeatEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundRepeat = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzBorderStyleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::BorderStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleCursorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleCursor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackfaceVisibilityEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackfaceVisibility = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTextAlignEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTextAlign = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRibbon {
    fn clone(&self) -> Self {
        let r: &crate::widgets::ribbon::Ribbon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRibbonOnTabClickedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::ribbon::RibbonOnTabClickedCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFileInputOnPathChangeCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::file_input::FileInputOnPathChangeCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCheckBoxOnToggleCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::check_box::CheckBoxOnToggleCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCheckBoxState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzColorInputOnValueChangeCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::color_input::ColorInputOnValueChangeCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputSelectionRange {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputSelectionRange =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputOnTextInputCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputOnTextInputCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputOnVirtualKeyDownCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputOnVirtualKeyDownCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputOnFocusLostCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputOnFocusLostCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputValidEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputValid = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNumberInputState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNumberInputOnValueChangeCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::NumberInputOnValueChangeCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNumberInputOnFocusLostCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::NumberInputOnFocusLostCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzProgressBarState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTabHeaderState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTabOnClickCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphStyleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeAddedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeRemovedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeGraphDraggedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeGraphDraggedCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeDraggedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeConnectedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeConnectedCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeInputDisconnectedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeInputDisconnectedCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeOutputDisconnectedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeOutputDisconnectedCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeFieldEditedCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeFieldEditedCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputOutputTypeId {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeId {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphNodeId {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodePosition {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGraphDragAmount {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeDragAmount {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewOnLazyLoadScrollCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewOnLazyLoadScrollCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewOnColumnClickCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewOnColumnClickCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewOnRowClickCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewOnRowClickCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDropDownOnChoiceChangeCallback {
    fn clone(&self) -> Self {
        let r: &crate::widgets::drop_down::DropDownOnChoiceChangeCallback =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeHierarchyItem {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCascadeInfo {
    fn clone(&self) -> Self {
        let r: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyledNodeState {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTagId {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::AzTagId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPropertyCache {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGlVoidPtrConst {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGlVoidPtrMut {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGlShaderPrecisionFormatReturn {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVertexAttributeTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIndexBufferFormatEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGlTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::AzGlType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU8VecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU8VecRefMut {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzF32VecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzI32VecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLuintVecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLenumVecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLintVecRefMut {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLint64VecRefMut {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLbooleanVecRefMut {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLfloatVecRefMut {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRefstr {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::Refstr = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLsyncPtr {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextureFlags {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzImageRef {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRawImageFormatEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzEncodeImageErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDecodeImageErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFontRef {
    fn clone(&self) -> Self {
        let r: &azul_css::FontRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvg {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::Svg = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgXmlNode {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgXmlNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgCircle {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgCircle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgPoint {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgPoint = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgVector {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgVector = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgRect {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgRect = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgColoredVertex {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgColoredVertex = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgVertex {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgVertex = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzShapeRenderingEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextRenderingEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TextRendering = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzImageRenderingEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::ImageRendering = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFontDatabaseEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::FontDatabase = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgRenderTransform {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgRenderTransform = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIndentEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::Indent = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgFitToEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgFitTo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgFillRuleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgFillRule = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgTransform {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgTransform = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgLineJoinEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgLineJoin = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgLineCapEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgLineCap = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgDashPattern {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgDashPattern = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMsgBox {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMsgBoxIconEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMsgBoxYesNoEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::YesNo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMsgBoxOkCancelEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::OkCancel = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFileDialog {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzColorPickerDialog {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSystemClipboard {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::app::Clipboard = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInstantPtrCloneFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInstantPtrDestructorFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSystemTick {
    fn clone(&self) -> Self {
        let r: &azul_core::task::SystemTick = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSystemTimeDiff {
    fn clone(&self) -> Self {
        let r: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSystemTickDiff {
    fn clone(&self) -> Self {
        let r: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTimerId {
    fn clone(&self) -> Self {
        let r: &azul_core::task::TimerId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTerminateTimerEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::TerminateTimer = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadId {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThread {
    fn clone(&self) -> Self {
        let r: &azul_core::task::Thread = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadSender {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadSender = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadReceiver {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadReceiver = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCreateThreadFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::CreateThreadCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGetSystemTimeFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::GetSystemTimeCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCheckThreadFinishedFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLibrarySendThreadMsgFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLibraryReceiveThreadMsgFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadRecvFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadRecvCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadSendFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadSendCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadDestructorFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadDestructorCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadReceiverDestructorFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadSenderDestructorFn {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFontFamilyVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFontFamilyVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewRowVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewRowVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFilterVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFilterVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLogicalRectVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LogicalRectVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeIdNodeMapVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputOutputTypeIdVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeFieldVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeFieldVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputConnectionVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputConnectionVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOutputNodeAndIndexVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOutputConnectionVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OutputConnectionVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputNodeAndIndexVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAccessibilityStateVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::AccessibilityStateVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenuItemVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MenuItemVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedSvgNodeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedSvgNodeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedColoredSvgNodeVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXmlNodeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlNodeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFmtArgVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::str::FmtArgVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineLineVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineLineVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineWordVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineWordVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineGlyphVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineGlyphVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineTextHitVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineTextHitVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMonitorVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVideoModeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDomVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIdOrClassVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundContentVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundContentVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundPositionVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundPositionVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundRepeatVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundSizeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPropertyVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPropertyVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgMultiPolygonVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgMultiPolygonVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgSimpleNodeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgSimpleNodeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgPathVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgPathVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVertexAttributeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::VertexAttributeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgPathElementVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgPathElementVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgVertexVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgVertexVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgColoredVertexVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgColoredVertexVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU32VecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::U32VecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXWindowTypeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::XWindowTypeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVirtualKeyCodeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::VirtualKeyCodeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCascadeInfoVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzScanCodeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssDeclarationVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssDeclarationVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPathSelectorVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPathSelectorVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStylesheetVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StylesheetVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssRuleBlockVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssRuleBlockVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzF32VecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::F32VecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU16VecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::U16VecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU8VecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::U8VecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCallbackDataVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::CallbackDataVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDebugMessageVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLuintVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLintVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStringVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StringVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStringPairVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::NormalizedLinearColorStopVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::NormalizedRadialColorStopVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeIdVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeHierarchyItemVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::NodeHierarchyItemVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyledNodeVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::StyledNodeVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzParentWithNodeDepthVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeDataVecDestructorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionI16EnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionI16 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionU16EnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionU16 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionU32EnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionU32 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionHwndHandleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionX11VisualEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionI32EnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionI32 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionF32EnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionF32 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionCharEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionChar = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionUsizeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::OptionUsize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgParseErrorPosition {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSystemCallbacks {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRendererOptions {
    fn clone(&self) -> Self {
        let r: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutRect {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LayoutRect = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRawWindowHandleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLogicalRect {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LogicalRect = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAcceleratorKeyEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowFlags {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCursorPositionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::CursorPosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowPositionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowPosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzImePositionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::ImePosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVideoMode {
    fn clone(&self) -> Self {
        let r: &azul_core::window::VideoMode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDomNodeId {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::DomNodeId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPositionInfoEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::ui_solver::PositionInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzHidpiAdjustedBounds {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineGlyph {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineTextHit {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIFrameCallbackInfo {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTimerCallbackReturn {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRefAny {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::RefAny = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIFrameNode {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNotEventFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NotEventFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenuCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenuItemIconEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MenuItemIcon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssNthChildSelectorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssNthChildSelector = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPixelValue {
    fn clone(&self) -> Self {
        let r: &azul_css::PixelValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPixelValueNoPercent {
    fn clone(&self) -> Self {
        let r: &azul_css::PixelValueNoPercent = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBoxShadow {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBoxShadow = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBlur {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBlur = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleColorMatrix {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleColorMatrix = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFilterOffset {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFilterOffset = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleCompositeFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleCompositeFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBottom {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBottom = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexGrow {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexGrow = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexShrink {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexShrink = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutHeight {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutHeight = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutLeft {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutLeft = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginBottom {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginBottom = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginLeft {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginLeft = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginRight {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginRight = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginTop {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginTop = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMaxHeight {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMaxHeight = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMaxWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMaxWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMinHeight {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMinHeight = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMinWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMinWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingBottom {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingBottom = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingLeft {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingLeft = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingRight {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingRight = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingTop {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingTop = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutRight {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutRight = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutTop {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutTop = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPercentageValue {
    fn clone(&self) -> Self {
        let r: &azul_css::PercentageValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAngleValue {
    fn clone(&self) -> Self {
        let r: &azul_css::AngleValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNormalizedLinearColorStop {
    fn clone(&self) -> Self {
        let r: &azul_css::NormalizedLinearColorStop = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNormalizedRadialColorStop {
    fn clone(&self) -> Self {
        let r: &azul_css::NormalizedRadialColorStop = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDirectionCorners {
    fn clone(&self) -> Self {
        let r: &azul_css::DirectionCorners = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDirectionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::Direction = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzBackgroundPositionHorizontalEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::BackgroundPositionHorizontal = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzBackgroundPositionVerticalEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::BackgroundPositionVertical = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundPosition {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundPosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundSizeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomColor {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomColor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomLeftRadius {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomRightRadius {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomStyle {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderBottomWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderLeftColor {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderLeftColor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderLeftStyle {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderLeftStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderLeftWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderRightColor {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderRightColor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderRightStyle {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderRightStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderRightWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderRightWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopColor {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopColor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopLeftRadius {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopRightRadius {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopStyle {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderTopWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderTopWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFontSize {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFontSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleLetterSpacing {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleLetterSpacing = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleLineHeight {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleLineHeight = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTabWidth {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTabWidth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleOpacity {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleOpacity = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformOrigin {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformOrigin = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStylePerspectiveOrigin {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformOrigin = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformMatrix2D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformMatrix2D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformMatrix3D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformMatrix3D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformTranslate2D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformTranslate2D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformTranslate3D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformTranslate3D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformRotate3D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformRotate3D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformScale2D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformScale2D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformScale3D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformScale3D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformSkew2D {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformSkew2D = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTextColor {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTextColor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleWordSpacing {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleWordSpacing = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBoxShadowValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBoxShadowValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutAlignContentValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutAlignContentValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutAlignItemsValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutAlignItemsValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBottomValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBottomValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBoxSizingValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBoxSizingValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexDirectionValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexDirectionValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutDisplayValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutDisplayValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexGrowValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexGrowValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexShrinkValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexShrinkValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFloatValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFloatValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutHeightValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutHeightValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutJustifyContentValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutJustifyContentValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutLeftValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutLeftValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginBottomValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginBottomValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginLeftValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginLeftValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginRightValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginRightValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMarginTopValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMarginTopValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMaxHeightValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMaxHeightValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMaxWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMaxWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMinHeightValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMinHeightValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutMinWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutMinWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingBottomValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingBottomValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingLeftValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingLeftValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingRightValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingRightValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPaddingTopValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPaddingTopValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutPositionValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutPositionValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutRightValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutRightValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutTopValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutTopValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutFlexWrapValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutFlexWrapValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutOverflowValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutOverflowValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomColorValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomColorValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomRightRadiusValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomRightRadiusValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderBottomStyleValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderBottomStyleValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderBottomWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderBottomWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderLeftColorValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderLeftColorValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderLeftStyleValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderLeftStyleValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderLeftWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderLeftWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderRightColorValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderRightColorValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderRightStyleValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderRightStyleValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderRightWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderRightWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopColorValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopColorValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopLeftRadiusValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopRightRadiusValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBorderTopStyleValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBorderTopStyleValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutBorderTopWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::LayoutBorderTopWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleCursorValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleCursorValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFontSizeValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFontSizeValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleLetterSpacingValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleLetterSpacingValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleLineHeightValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleLineHeightValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTabWidthValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTabWidthValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTextAlignValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTextAlignValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTextColorValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTextColorValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleWordSpacingValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleWordSpacingValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleOpacityValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleOpacityValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformOriginValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformOriginValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStylePerspectiveOriginValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StylePerspectiveOriginValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackfaceVisibilityValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackfaceVisibilityValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleMixBlendModeValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleMixBlendModeValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzButtonOnClick {
    fn clone(&self) -> Self {
        let r: &crate::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFileInputOnPathChange {
    fn clone(&self) -> Self {
        let r: &crate::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCheckBoxOnToggle {
    fn clone(&self) -> Self {
        let r: &crate::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzColorInputState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzColorInputOnValueChange {
    fn clone(&self) -> Self {
        let r: &crate::widgets::color_input::ColorInputOnValueChange =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputSelectionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputSelection = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputOnTextInput {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputOnVirtualKeyDown {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputOnVirtualKeyDown =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputOnFocusLost {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOnTextInputReturn {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNumberInputOnValueChange {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::NumberInputOnValueChange =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNumberInputOnFocusLost {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::NumberInputOnFocusLost =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTabOnClick {
    fn clone(&self) -> Self {
        let r: &crate::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeAdded {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeRemoved {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeGraphDragged {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeDragged {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeConnected {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeInputDisconnected {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeInputDisconnected =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeOutputDisconnected {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeOutputDisconnected =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphOnNodeFieldEdited {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOutputNodeAndIndex {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputNodeAndIndex {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewOnLazyLoadScroll {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewOnLazyLoadScroll =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewOnColumnClick {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewOnRowClick {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDropDownOnChoiceChange {
    fn clone(&self) -> Self {
        let r: &crate::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzParentWithNodeDepth {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGl {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRefstrVecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzImageMask {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFontMetrics {
    fn clone(&self) -> Self {
        let r: &azul_css::FontMetrics = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgLine {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgLine = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgQuadraticCurve {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgCubicCurve {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgCubicCurve = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgStringFormatOptions {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgXmlOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgFillStyle {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgFillStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInstantPtr {
    fn clone(&self) -> Self {
        let r: &azul_core::task::AzInstantPtr = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDurationEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::Duration = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadSendMsgEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadSendMsg = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadWriteBackMsg {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLogicalRectVec {
    fn clone(&self) -> Self {
        let r: &azul_core::geom::LogicalRectVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputOutputTypeIdVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOutputNodeAndIndexVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputNodeAndIndexVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAccessibilityStateVec {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenuItemVec {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXmlNodeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineGlyphVec {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineTextHitVec {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVideoModeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDomVec {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::DomVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundPositionVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundRepeatVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundSizeVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgVertexVec {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgVertexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgColoredVertexVec {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgColoredVertexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU32Vec {
    fn clone(&self) -> Self {
        let r: &azul_css::U32Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXWindowTypeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVirtualKeyCodeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCascadeInfoVec {
    fn clone(&self) -> Self {
        let r: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzScanCodeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU16Vec {
    fn clone(&self) -> Self {
        let r: &azul_css::U16Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzF32Vec {
    fn clone(&self) -> Self {
        let r: &azul_css::F32Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzU8Vec {
    fn clone(&self) -> Self {
        let r: &azul_css::U8Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLuintVec {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGLintVec {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNormalizedLinearColorStopVec {
    fn clone(&self) -> Self {
        let r: &azul_css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNormalizedRadialColorStopVec {
    fn clone(&self) -> Self {
        let r: &azul_css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeIdVec {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeHierarchyItemVec {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzParentWithNodeDepthVec {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionSvgPointEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionSvgPoint = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionStyleTextAlignEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionStyleTextAlign = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionListViewOnRowClickEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::OptionListViewOnRowClick =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionListViewOnColumnClickEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::OptionListViewOnColumnClick =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionListViewOnLazyLoadScrollEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::OptionListViewOnLazyLoadScroll =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionPixelValueNoPercentEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionPixelValueNoPercent = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionDropDownOnChoiceChangeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::drop_down::OptionDropDownOnChoiceChange =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeAddedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeAdded = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeRemovedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeRemoved = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeGraphDragged =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeDraggedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeDragged = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeConnectedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeConnected = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeInputDisconnected =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OptionOnNodeFieldEdited =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionColorInputOnValueChangeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::color_input::OptionColorInputOnValueChange =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionButtonOnClickEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::button::OptionButtonOnClick = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTabOnClickEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionFileInputOnPathChangeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::file_input::OptionFileInputOnPathChange =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionCheckBoxOnToggleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::check_box::OptionCheckBoxOnToggle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTextInputOnTextInputEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::OptionTextInputOnTextInput =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTextInputOnFocusLostEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::OptionTextInputOnFocusLost =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTextInputSelectionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::OptionTextInputSelection =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNumberInputOnFocusLostEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::OptionNumberInputOnFocusLost =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNumberInputOnValueChangeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::OptionNumberInputOnValueChange =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionMenuItemIconEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionMenuItemIcon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionMenuCallbackEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionMenuCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionPositionInfoEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::ui_solver::OptionPositionInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTimerIdEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::OptionTimerId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionThreadIdEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::OptionThreadId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionImageRefEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionFontRefEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionFontRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionSystemClipboardEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::app::OptionClipboard = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionGlEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::OptionGlContextPtr = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionPercentageValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionPercentageValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionAngleValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionAngleValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionRendererOptionsEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionCallbackEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::OptionCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionThreadSendMsgEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::OptionThreadSendMsg = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionLayoutRectEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionLayoutRect = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionRefAnyEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::OptionRefAny = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionLayoutPointEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionLayoutPoint = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionLayoutSizeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionLayoutSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionWindowThemeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionNodeIdEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::OptionNodeId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionDomNodeIdEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::OptionDomNodeId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionColorUEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionColorU = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionSvgDashPatternEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionLogicalPositionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionLogicalPosition = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionPhysicalPositionI32EnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionPhysicalPositionI32 = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionMouseCursorTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionLogicalSizeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionLogicalSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionVirtualKeyCodeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionImageMaskEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::OptionImageMask = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTabIndexEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTagIdEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::OptionTagId = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionDurationEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::OptionDuration = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionU8VecEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionU8Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionU8VecRefEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzResultU8VecEncodeImageErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::image::encode::ResultU8VecEncodeImageError =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNonXmlCharError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInvalidCharError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInvalidCharMultipleError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInvalidQuoteError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInvalidSpaceError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAppConfig {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSmallWindowIconBytes {
    fn clone(&self) -> Self {
        let r: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLargeWindowIconBytes {
    fn clone(&self) -> Self {
        let r: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowIconEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowIcon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTaskBarIcon {
    fn clone(&self) -> Self {
        let r: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowSize {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowSize = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzKeyboardState {
    fn clone(&self) -> Self {
        let r: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMouseState {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MouseState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMarshaledLayoutCallback {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineTextContents {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzResolvedTextLayoutOptions {
    fn clone(&self) -> Self {
        let r: &azul_core::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAnimationEasingEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::AnimationInterpolationFunction = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRenderImageCallbackInfo {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutCallbackInfo {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzEventFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::EventFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenu {
    fn clone(&self) -> Self {
        let r: &azul_core::window::Menu = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVirtualKeyCodeCombo {
    fn clone(&self) -> Self {
        let r: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPathPseudoSelectorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPathPseudoSelector = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAnimationInterpolationFunctionEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::AnimationInterpolationFunction = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInterpolateContext {
    fn clone(&self) -> Self {
        let r: &azul_css::InterpolateResolver = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFilterEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFilter = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLinearGradient {
    fn clone(&self) -> Self {
        let r: &azul_css::LinearGradient = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRadialGradient {
    fn clone(&self) -> Self {
        let r: &azul_css::RadialGradient = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzConicGradient {
    fn clone(&self) -> Self {
        let r: &azul_css::ConicGradient = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransform = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundPositionVecValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundPositionVecValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundRepeatVecValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundSizeVecValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundSizeVecValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCheckBoxStateWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNumberInputStateWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::NumberInputStateWrapper =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraphCallbacks {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputConnection {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOutputConnection {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewRow {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyledNode {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTagIdToNodeIdMapping {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTexture {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::Texture = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGetProgramBinaryReturn {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRawImageDataEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::RawImageData = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFontSource {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgPathElementEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgPathElement = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedColoredSvgNode {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedColoredSvgNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedColoredSvgNodeVecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedColoredSvgNodeVecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedSvgNode {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedSvgNodeVecRef {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgRenderOptions {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgRenderOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgStrokeStyle {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgStrokeStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXml {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::Xml = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInstantEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::Instant = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzThreadReceiveMsgEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::ThreadReceiveMsg = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzString {
    fn clone(&self) -> Self {
        let r: &azul_css::AzString = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewRowVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFilterVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFilterVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputConnectionVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOutputConnectionVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedSvgNodeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedColoredSvgNodeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedColoredSvgNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgPathElementVec {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgPathElementVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStringVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StringVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyledNodeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTagIdToNodeIdMappingVec {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionMenuEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionMenu = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionResolvedTextLayoutOptionsEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::ui_solver::OptionResolvedTextLayoutOptions =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionVirtualKeyCodeComboEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionVirtualKeyCodeCombo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionMouseStateEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionMouseState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionKeyboardStateEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionStringVecEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionStringVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionThreadReceiveMsgEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::OptionThreadReceiveMsg = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTaskBarIconEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionWindowIconEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionStringEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionAzString = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionTextureEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::OptionTexture = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionInstantEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::task::OptionInstant = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDuplicatedNamespaceError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzUnknownNamespaceError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzUnexpectedCloseTagError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzUnknownEntityReferenceError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDuplicatedAttributeError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInvalidStringError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowsWindowOptions {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWaylandTheme {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStringPair {
    fn clone(&self) -> Self {
        let r: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMonitor {
    fn clone(&self) -> Self {
        let r: &azul_core::window::Monitor = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLayoutCallbackEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineWordEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCallbackData {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::CallbackData = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NodeType = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAccessibilityInfo {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIdOrClassEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::IdOrClass = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStringMenuItem {
    fn clone(&self) -> Self {
        let r: &azul_core::window::StringMenuItem = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPathSelectorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPathSelector = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundContentEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundContent = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzScrollbarInfo {
    fn clone(&self) -> Self {
        let r: &azul_css::ScrollbarInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzScrollbarStyle {
    fn clone(&self) -> Self {
        let r: &azul_css::ScrollbarStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFontFamilyEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFontFamily = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzScrollbarStyleValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::ScrollbarStyleValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleTransformVecValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleTransformVecValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFilterVecValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFilterVecValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFileInputState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::file_input::FileInputState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzColorInputStateWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::color_input::ColorInputStateWrapper =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTabHeader {
    fn clone(&self) -> Self {
        let r: &crate::widgets::tabs::TabHeader = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeFieldValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeFieldValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeInfo {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputOutputInfo {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListView {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListView = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzListViewState {
    fn clone(&self) -> Self {
        let r: &crate::widgets::list_view::ListViewState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTreeView {
    fn clone(&self) -> Self {
        let r: &crate::widgets::tree_view::TreeView = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDropDown {
    fn clone(&self) -> Self {
        let r: &crate::widgets::drop_down::DropDown = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVertexAttribute {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDebugMessage {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::AzDebugMessage = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGetActiveAttribReturn {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzGetActiveUniformReturn {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzRawImage {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::RawImage = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgPath {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgPath = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgParseOptions {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgParseOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgStyleEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgStyle = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFile {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::file::File = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFileTypeList {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTimer {
    fn clone(&self) -> Self {
        let r: &azul_core::task::Timer = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFmtValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::str::FmtValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFmtArg {
    fn clone(&self) -> Self {
        let r: &crate::str::FmtArg = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFontFamilyVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFontFamilyVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFmtArgVec {
    fn clone(&self) -> Self {
        let r: &crate::str::FmtArgVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineWordVec {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineWordVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMonitorVec {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIdOrClassVec {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundContentVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundContentVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgPathVec {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgPathVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVertexAttributeVec {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPathSelectorVec {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPathSelectorVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCallbackDataVec {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::CallbackDataVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDebugMessageVec {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::AzDebugMessageVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStringPairVec {
    fn clone(&self) -> Self {
        let r: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionFileTypeListEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::dialogs::OptionFileTypeList = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionFileEnumWrapper {
    fn clone(&self) -> Self {
        let r: &crate::azul_impl::file::OptionFile = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionRawImageEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionWaylandThemeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzResultRawImageDecodeImageErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::image::decode::ResultRawImageDecodeImageError =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXmlStreamErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLinuxWindowOptions {
    fn clone(&self) -> Self {
        let r: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineLine {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineLine = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzMenuItemEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::MenuItem = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPath {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPath = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleBackgroundContentVecValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleBackgroundContentVecValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyleFontFamilyVecValueEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::StyleFontFamilyVecValue = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPropertyEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssProperty = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFileInputStateWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInputStateWrapper {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzProgressBar {
    fn clone(&self) -> Self {
        let r: &crate::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeIdInfoMap {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputOutputTypeIdInfoMap {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMap =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeField {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPropertySourceEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::CssPropertySource = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVertexLayout {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVertexArrayObject {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzVertexBuffer {
    fn clone(&self) -> Self {
        let r: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgMultiPolygon {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgMultiPolygon = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgSimpleNodeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgSimpleNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedColoredGPUSvgNode {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTessellatedGPUSvgNode {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXmlNode {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeIdInfoMapVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInputOutputTypeIdInfoMapVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeTypeFieldVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineLineVec {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineLineVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssPropertyVec {
    fn clone(&self) -> Self {
        let r: &azul_css::CssPropertyVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgMultiPolygonVec {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgSimpleNodeVec {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionCssPropertyEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::OptionCssProperty = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXmlTextError {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzPlatformSpecificOptions {
    fn clone(&self) -> Self {
        let r: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowState {
    fn clone(&self) -> Self {
        let r: &azul_core::window::WindowState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCallbackInfo {
    fn clone(&self) -> Self {
        let r: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzInlineText {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::InlineText = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFocusTargetPath {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::FocusTargetPath = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzAnimation {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::Animation = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTimerCallbackInfo {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeDataInlineCssPropertyEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDynamicCssProperty {
    fn clone(&self) -> Self {
        let r: &azul_css::DynamicCssProperty = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNode {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgNodeEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgStyledNode {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgStyledNode = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeDataInlineCssPropertyVec {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionWindowStateEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::window::OptionWindowState = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionInlineTextEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::OptionInlineText = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXmlParseErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlParseError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzWindowCreateOptions {
    fn clone(&self) -> Self {
        let r: &azul_layout::window::WindowCreateOptions = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFocusTargetEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::FocusTarget = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeData {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NodeData = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssDeclarationEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_css::CssDeclaration = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzButton {
    fn clone(&self) -> Self {
        let r: &crate::widgets::button::Button = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFileInput {
    fn clone(&self) -> Self {
        let r: &crate::widgets::file_input::FileInput = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCheckBox {
    fn clone(&self) -> Self {
        let r: &crate::widgets::check_box::CheckBox = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzLabel {
    fn clone(&self) -> Self {
        let r: &crate::widgets::label::Label = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzColorInput {
    fn clone(&self) -> Self {
        let r: &crate::widgets::color_input::ColorInput = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTextInput {
    fn clone(&self) -> Self {
        let r: &crate::widgets::text_input::TextInput = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNumberInput {
    fn clone(&self) -> Self {
        let r: &crate::widgets::number_input::NumberInput = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeIdNodeMap {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeIdNodeMapVec {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssDeclarationVec {
    fn clone(&self) -> Self {
        let r: &azul_css::CssDeclarationVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeDataVec {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzXmlErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::XmlError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzDom {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::Dom = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssRuleBlock {
    fn clone(&self) -> Self {
        let r: &azul_css::CssRuleBlock = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzTabContent {
    fn clone(&self) -> Self {
        let r: &crate::widgets::tabs::TabContent = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzFrame {
    fn clone(&self) -> Self {
        let r: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzNodeGraph {
    fn clone(&self) -> Self {
        let r: &crate::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStyledDom {
    fn clone(&self) -> Self {
        let r: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCssRuleBlockVec {
    fn clone(&self) -> Self {
        let r: &azul_css::CssRuleBlockVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzOptionDomEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::dom::OptionDom = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzResultXmlXmlErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzSvgParseErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_layout::xml::svg::SvgParseError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzIFrameCallbackReturn {
    fn clone(&self) -> Self {
        let r: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStylesheet {
    fn clone(&self) -> Self {
        let r: &azul_css::Stylesheet = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzStylesheetVec {
    fn clone(&self) -> Self {
        let r: &azul_css::StylesheetVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::ResultSvgXmlNodeSvgParseError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzResultSvgSvgParseErrorEnumWrapper {
    fn clone(&self) -> Self {
        let r: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}
impl Clone for AzCss {
    fn clone(&self) -> Self {
        let r: &azul_css::Css = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(r.clone()) }
    }
}

// Implement Drop for all objects with drop constructors
impl Drop for AzApp {
    fn drop(&mut self) {
        crate::AzApp_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzRefCount {
    fn drop(&mut self) {
        crate::AzRefCount_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzCssPropertyCache {
    fn drop(&mut self) {
        crate::AzCssPropertyCache_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzGlVoidPtrConst {
    fn drop(&mut self) {
        crate::AzGlVoidPtrConst_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzGLsyncPtr {
    fn drop(&mut self) {
        crate::AzGLsyncPtr_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzImageRef {
    fn drop(&mut self) {
        crate::AzImageRef_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzFontRef {
    fn drop(&mut self) {
        crate::AzFontRef_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvg {
    fn drop(&mut self) {
        crate::AzSvg_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvgXmlNode {
    fn drop(&mut self) {
        crate::AzSvgXmlNode_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSystemClipboard {
    fn drop(&mut self) {
        crate::AzSystemClipboard_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzThread {
    fn drop(&mut self) {
        crate::AzThread_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzThreadSender {
    fn drop(&mut self) {
        crate::AzThreadSender_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzThreadReceiver {
    fn drop(&mut self) {
        crate::AzThreadReceiver_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzRefAny {
    fn drop(&mut self) {
        crate::AzRefAny_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzGl {
    fn drop(&mut self) {
        crate::AzGl_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInstantPtr {
    fn drop(&mut self) {
        crate::AzInstantPtr_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzLogicalRectVec {
    fn drop(&mut self) {
        crate::AzLogicalRectVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInputOutputTypeIdVec {
    fn drop(&mut self) {
        crate::AzInputOutputTypeIdVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzOutputNodeAndIndexVec {
    fn drop(&mut self) {
        crate::AzOutputNodeAndIndexVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInputNodeAndIndexVec {
    fn drop(&mut self) {
        crate::AzInputNodeAndIndexVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzAccessibilityStateVec {
    fn drop(&mut self) {
        crate::AzAccessibilityStateVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzMenuItemVec {
    fn drop(&mut self) {
        crate::AzMenuItemVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzXmlNodeVec {
    fn drop(&mut self) {
        crate::AzXmlNodeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInlineGlyphVec {
    fn drop(&mut self) {
        crate::AzInlineGlyphVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInlineTextHitVec {
    fn drop(&mut self) {
        crate::AzInlineTextHitVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzVideoModeVec {
    fn drop(&mut self) {
        crate::AzVideoModeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzDomVec {
    fn drop(&mut self) {
        crate::AzDomVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyleBackgroundPositionVec {
    fn drop(&mut self) {
        crate::AzStyleBackgroundPositionVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyleBackgroundRepeatVec {
    fn drop(&mut self) {
        crate::AzStyleBackgroundRepeatVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyleBackgroundSizeVec {
    fn drop(&mut self) {
        crate::AzStyleBackgroundSizeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvgVertexVec {
    fn drop(&mut self) {
        crate::AzSvgVertexVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvgColoredVertexVec {
    fn drop(&mut self) {
        crate::AzSvgColoredVertexVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzU32Vec {
    fn drop(&mut self) {
        crate::AzU32Vec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzXWindowTypeVec {
    fn drop(&mut self) {
        crate::AzXWindowTypeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzVirtualKeyCodeVec {
    fn drop(&mut self) {
        crate::AzVirtualKeyCodeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzCascadeInfoVec {
    fn drop(&mut self) {
        crate::AzCascadeInfoVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzScanCodeVec {
    fn drop(&mut self) {
        crate::AzScanCodeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzU16Vec {
    fn drop(&mut self) {
        crate::AzU16Vec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzF32Vec {
    fn drop(&mut self) {
        crate::AzF32Vec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzU8Vec {
    fn drop(&mut self) {
        crate::AzU8Vec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzGLuintVec {
    fn drop(&mut self) {
        crate::AzGLuintVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzGLintVec {
    fn drop(&mut self) {
        crate::AzGLintVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNormalizedLinearColorStopVec {
    fn drop(&mut self) {
        crate::AzNormalizedLinearColorStopVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNormalizedRadialColorStopVec {
    fn drop(&mut self) {
        crate::AzNormalizedRadialColorStopVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNodeIdVec {
    fn drop(&mut self) {
        crate::AzNodeIdVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNodeHierarchyItemVec {
    fn drop(&mut self) {
        crate::AzNodeHierarchyItemVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzParentWithNodeDepthVec {
    fn drop(&mut self) {
        crate::AzParentWithNodeDepthVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzTexture {
    fn drop(&mut self) {
        crate::AzTexture_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzListViewRowVec {
    fn drop(&mut self) {
        crate::AzListViewRowVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyleFilterVec {
    fn drop(&mut self) {
        crate::AzStyleFilterVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInputConnectionVec {
    fn drop(&mut self) {
        crate::AzInputConnectionVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzOutputConnectionVec {
    fn drop(&mut self) {
        crate::AzOutputConnectionVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzTessellatedSvgNodeVec {
    fn drop(&mut self) {
        crate::AzTessellatedSvgNodeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzTessellatedColoredSvgNodeVec {
    fn drop(&mut self) {
        crate::AzTessellatedColoredSvgNodeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyleTransformVec {
    fn drop(&mut self) {
        crate::AzStyleTransformVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvgPathElementVec {
    fn drop(&mut self) {
        crate::AzSvgPathElementVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStringVec {
    fn drop(&mut self) {
        crate::AzStringVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyledNodeVec {
    fn drop(&mut self) {
        crate::AzStyledNodeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzTagIdToNodeIdMappingVec {
    fn drop(&mut self) {
        crate::AzTagIdToNodeIdMappingVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzFile {
    fn drop(&mut self) {
        crate::AzFile_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyleFontFamilyVec {
    fn drop(&mut self) {
        crate::AzStyleFontFamilyVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzFmtArgVec {
    fn drop(&mut self) {
        crate::AzFmtArgVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInlineWordVec {
    fn drop(&mut self) {
        crate::AzInlineWordVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzMonitorVec {
    fn drop(&mut self) {
        crate::AzMonitorVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzIdOrClassVec {
    fn drop(&mut self) {
        crate::AzIdOrClassVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStyleBackgroundContentVec {
    fn drop(&mut self) {
        crate::AzStyleBackgroundContentVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvgPathVec {
    fn drop(&mut self) {
        crate::AzSvgPathVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzVertexAttributeVec {
    fn drop(&mut self) {
        crate::AzVertexAttributeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzCssPathSelectorVec {
    fn drop(&mut self) {
        crate::AzCssPathSelectorVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzCallbackDataVec {
    fn drop(&mut self) {
        crate::AzCallbackDataVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzDebugMessageVec {
    fn drop(&mut self) {
        crate::AzDebugMessageVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStringPairVec {
    fn drop(&mut self) {
        crate::AzStringPairVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzVertexArrayObject {
    fn drop(&mut self) {
        crate::AzVertexArrayObject_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzVertexBuffer {
    fn drop(&mut self) {
        crate::AzVertexBuffer_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNodeTypeIdInfoMapVec {
    fn drop(&mut self) {
        crate::AzNodeTypeIdInfoMapVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInputOutputTypeIdInfoMapVec {
    fn drop(&mut self) {
        crate::AzInputOutputTypeIdInfoMapVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNodeTypeFieldVec {
    fn drop(&mut self) {
        crate::AzNodeTypeFieldVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzInlineLineVec {
    fn drop(&mut self) {
        crate::AzInlineLineVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzCssPropertyVec {
    fn drop(&mut self) {
        crate::AzCssPropertyVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvgMultiPolygonVec {
    fn drop(&mut self) {
        crate::AzSvgMultiPolygonVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzSvgSimpleNodeVec {
    fn drop(&mut self) {
        crate::AzSvgSimpleNodeVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNodeDataInlineCssPropertyVec {
    fn drop(&mut self) {
        crate::AzNodeDataInlineCssPropertyVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNodeIdNodeMapVec {
    fn drop(&mut self) {
        crate::AzNodeIdNodeMapVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzCssDeclarationVec {
    fn drop(&mut self) {
        crate::AzCssDeclarationVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzNodeDataVec {
    fn drop(&mut self) {
        crate::AzNodeDataVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzCssRuleBlockVec {
    fn drop(&mut self) {
        crate::AzCssRuleBlockVec_delete(unsafe { mem::transmute(self) });
    }
}
impl Drop for AzStylesheetVec {
    fn drop(&mut self) {
        crate::AzStylesheetVec_delete(unsafe { mem::transmute(self) });
    }
}

#[pymethods]
impl AzApp {
    fn add_window(&mut self, window: AzWindowCreateOptions) -> () {
        unsafe {
            mem::transmute(crate::AzApp_addWindow(
                mem::transmute(self),
                mem::transmute(window),
            ))
        }
    }
    fn add_image(&mut self, id: String, image: AzImageRef) -> () {
        let id = pystring_to_azstring(&id);
        unsafe {
            mem::transmute(crate::AzApp_addImage(
                mem::transmute(self),
                mem::transmute(id),
                mem::transmute(image),
            ))
        }
    }
    fn get_monitors(&self) -> AzMonitorVec {
        unsafe { mem::transmute(crate::AzApp_getMonitors(mem::transmute(self))) }
    }
    fn run(&self, window: AzWindowCreateOptions) -> () {
        unsafe {
            mem::transmute(crate::AzApp_run(
                mem::transmute(self),
                mem::transmute(window),
            ))
        }
    }
    // impl App {

    #[new]
    pub fn new(py: Python, data: PyObject, config: AzAppConfig) -> Result<Self, PyErr> {
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in App.new: - argument \"data\" is a function callback, expected class"
            )));
        }

        let app_refany = azul_impl::callbacks::RefAny::new(AppDataTy {
            _py_app_data: Some(data),
        });
        Ok(unsafe { mem::transmute(crate::AzApp_new(app_refany, mem::transmute(config))) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzApp {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::app::AzAppPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppConfig {
    #[new]
    fn new(layout_solver: AzLayoutSolverEnumWrapper) -> AzAppConfig {
        unsafe { mem::transmute(crate::AzAppConfig_new(mem::transmute(layout_solver))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAppConfig {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::AppConfig = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAppLogLevelEnumWrapper {
    #[classattr]
    fn Off() -> AzAppLogLevelEnumWrapper {
        AzAppLogLevelEnumWrapper {
            inner: AzAppLogLevel::Off,
        }
    }
    #[classattr]
    fn Error() -> AzAppLogLevelEnumWrapper {
        AzAppLogLevelEnumWrapper {
            inner: AzAppLogLevel::Error,
        }
    }
    #[classattr]
    fn Warn() -> AzAppLogLevelEnumWrapper {
        AzAppLogLevelEnumWrapper {
            inner: AzAppLogLevel::Warn,
        }
    }
    #[classattr]
    fn Info() -> AzAppLogLevelEnumWrapper {
        AzAppLogLevelEnumWrapper {
            inner: AzAppLogLevel::Info,
        }
    }
    #[classattr]
    fn Debug() -> AzAppLogLevelEnumWrapper {
        AzAppLogLevelEnumWrapper {
            inner: AzAppLogLevel::Debug,
        }
    }
    #[classattr]
    fn Trace() -> AzAppLogLevelEnumWrapper {
        AzAppLogLevelEnumWrapper {
            inner: AzAppLogLevel::Trace,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAppLogLevelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::AppLogLevel = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzAppLogLevelEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutSolverEnumWrapper {
    #[classattr]
    fn Default() -> AzLayoutSolverEnumWrapper {
        AzLayoutSolverEnumWrapper {
            inner: AzLayoutSolver::Default,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutSolverEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::LayoutSolverVersion = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::LayoutSolverVersion = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutSolverEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzSystemCallbacks {
    #[staticmethod]
    fn library_internal() -> AzSystemCallbacks {
        unsafe { mem::transmute(crate::AzSystemCallbacks_libraryInternal()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSystemCallbacks {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ExternalSystemCallbacks = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowCreateOptions {
    // impl WindowCreateOptions {

    #[new]
    pub fn __new__(py: Python, cb: PyObject) -> Result<Self, PyErr> {
        let window = azul_layout::window::WindowCreateOptions {
            state: unsafe { mem::transmute(AzWindowState::__new__(py, cb)?) },
            ..Default::default()
        };
        Ok(unsafe { mem::transmute(window) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowCreateOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::window::WindowCreateOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::window::WindowCreateOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererOptions {
    #[new]
    fn __new__(
        vsync: AzVsyncEnumWrapper,
        srgb: AzSrgbEnumWrapper,
        hw_accel: AzHwAccelerationEnumWrapper,
    ) -> Self {
        Self {
            vsync,
            srgb,
            hw_accel,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRendererOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::RendererOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVsyncEnumWrapper {
    #[classattr]
    fn Enabled() -> AzVsyncEnumWrapper {
        AzVsyncEnumWrapper {
            inner: AzVsync::Enabled,
        }
    }
    #[classattr]
    fn Disabled() -> AzVsyncEnumWrapper {
        AzVsyncEnumWrapper {
            inner: AzVsync::Disabled,
        }
    }
    #[classattr]
    fn DontCare() -> AzVsyncEnumWrapper {
        AzVsyncEnumWrapper {
            inner: AzVsync::DontCare,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVsyncEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Vsync = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzVsyncEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzSrgbEnumWrapper {
    #[classattr]
    fn Enabled() -> AzSrgbEnumWrapper {
        AzSrgbEnumWrapper {
            inner: AzSrgb::Enabled,
        }
    }
    #[classattr]
    fn Disabled() -> AzSrgbEnumWrapper {
        AzSrgbEnumWrapper {
            inner: AzSrgb::Disabled,
        }
    }
    #[classattr]
    fn DontCare() -> AzSrgbEnumWrapper {
        AzSrgbEnumWrapper {
            inner: AzSrgb::DontCare,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSrgbEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Srgb = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzSrgbEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzHwAccelerationEnumWrapper {
    #[classattr]
    fn Enabled() -> AzHwAccelerationEnumWrapper {
        AzHwAccelerationEnumWrapper {
            inner: AzHwAcceleration::Enabled,
        }
    }
    #[classattr]
    fn Disabled() -> AzHwAccelerationEnumWrapper {
        AzHwAccelerationEnumWrapper {
            inner: AzHwAcceleration::Disabled,
        }
    }
    #[classattr]
    fn DontCare() -> AzHwAccelerationEnumWrapper {
        AzHwAccelerationEnumWrapper {
            inner: AzHwAcceleration::DontCare,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzHwAccelerationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::HwAcceleration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzHwAccelerationEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutPoint {
    #[new]
    fn __new__(x: isize, y: isize) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPoint {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LayoutPoint = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LayoutPoint = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutSize {
    #[new]
    fn __new__(width: isize, height: isize) -> Self {
        Self { width, height }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutSize {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LayoutSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LayoutSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutRect {
    #[new]
    fn __new__(origin: AzLayoutPoint, size: AzLayoutSize) -> Self {
        Self { origin, size }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRect {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LayoutRect = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LayoutRect = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawWindowHandleEnumWrapper {
    #[staticmethod]
    fn IOS(v: AzIOSHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::IOS(v),
        }
    }
    #[staticmethod]
    fn MacOS(v: AzMacOSHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::MacOS(v),
        }
    }
    #[staticmethod]
    fn Xlib(v: AzXlibHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::Xlib(v),
        }
    }
    #[staticmethod]
    fn Xcb(v: AzXcbHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::Xcb(v),
        }
    }
    #[staticmethod]
    fn Wayland(v: AzWaylandHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::Wayland(v),
        }
    }
    #[staticmethod]
    fn Windows(v: AzWindowsHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::Windows(v),
        }
    }
    #[staticmethod]
    fn Web(v: AzWebHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::Web(v),
        }
    }
    #[staticmethod]
    fn Android(v: AzAndroidHandle) -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::Android(v),
        }
    }
    #[classattr]
    fn Unsupported() -> AzRawWindowHandleEnumWrapper {
        AzRawWindowHandleEnumWrapper {
            inner: AzRawWindowHandle::Unsupported,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzRawWindowHandle;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawWindowHandle::IOS(v) => Ok(vec!["IOS".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::MacOS(v) => Ok(vec!["MacOS".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Xlib(v) => Ok(vec!["Xlib".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Xcb(v) => Ok(vec!["Xcb".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Wayland(v) => Ok(vec!["Wayland".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Windows(v) => Ok(vec!["Windows".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Web(v) => Ok(vec!["Web".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Android(v) => Ok(vec!["Android".into_py(py), v.clone().into_py(py)]),
            AzRawWindowHandle::Unsupported => Ok(vec!["Unsupported".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawWindowHandleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::RawWindowHandle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIOSHandle {}

#[pyproto]
impl PyObjectProtocol for AzIOSHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::IOSHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMacOSHandle {}

#[pyproto]
impl PyObjectProtocol for AzMacOSHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MacOSHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXlibHandle {}

#[pyproto]
impl PyObjectProtocol for AzXlibHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XlibHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXcbHandle {}

#[pyproto]
impl PyObjectProtocol for AzXcbHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XcbHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWaylandHandle {}

#[pyproto]
impl PyObjectProtocol for AzWaylandHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WaylandHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowsHandle {}

#[pyproto]
impl PyObjectProtocol for AzWindowsHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowsHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWebHandle {
    #[new]
    fn __new__(id: u32) -> Self {
        Self { id }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWebHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WebHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WebHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAndroidHandle {}

#[pyproto]
impl PyObjectProtocol for AzAndroidHandle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::AndroidHandle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeEnumWrapper {
    #[classattr]
    fn Desktop() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Desktop,
        }
    }
    #[classattr]
    fn Dock() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Dock,
        }
    }
    #[classattr]
    fn Toolbar() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Toolbar,
        }
    }
    #[classattr]
    fn Menu() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Menu,
        }
    }
    #[classattr]
    fn Utility() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Utility,
        }
    }
    #[classattr]
    fn Splash() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Splash,
        }
    }
    #[classattr]
    fn Dialog() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Dialog,
        }
    }
    #[classattr]
    fn DropdownMenu() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::DropdownMenu,
        }
    }
    #[classattr]
    fn PopupMenu() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::PopupMenu,
        }
    }
    #[classattr]
    fn Tooltip() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Tooltip,
        }
    }
    #[classattr]
    fn Notification() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Notification,
        }
    }
    #[classattr]
    fn Combo() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Combo,
        }
    }
    #[classattr]
    fn Dnd() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Dnd,
        }
    }
    #[classattr]
    fn Normal() -> AzXWindowTypeEnumWrapper {
        AzXWindowTypeEnumWrapper {
            inner: AzXWindowType::Normal,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XWindowType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzXWindowTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzPhysicalPositionI32 {
    #[new]
    fn __new__(x: i32, y: i32) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPhysicalPositionI32 {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::PhysicalPositionI32 = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPhysicalSizeU32 {
    #[new]
    fn __new__(width: u32, height: u32) -> Self {
        Self { width, height }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPhysicalSizeU32 {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::PhysicalSizeU32 = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRect {
    #[new]
    fn __new__(origin: AzLogicalPosition, size: AzLogicalSize) -> Self {
        Self { origin, size }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRect {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalRect = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalRect = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalPosition {
    #[new]
    fn new(x: f32, y: f32) -> AzLogicalPosition {
        unsafe {
            mem::transmute(crate::AzLogicalPosition_new(
                mem::transmute(x),
                mem::transmute(y),
            ))
        }
    }
    #[staticmethod]
    fn zero() -> AzLogicalPosition {
        unsafe { mem::transmute(crate::AzLogicalPosition_zero()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLogicalPosition {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalPosition = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalPosition = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalSize {
    #[new]
    fn __new__(width: f32, height: f32) -> Self {
        Self { width, height }
    }

    fn to_physical(&self, hidpi_factor: f32) -> AzPhysicalSizeU32 {
        unsafe {
            mem::transmute(crate::AzLogicalSize_toPhysical(
                mem::transmute(self),
                mem::transmute(hidpi_factor),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLogicalSize {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIconKey {
    #[new]
    fn __new__(id: usize) -> Self {
        Self { id }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIconKey {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::IconKey = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSmallWindowIconBytes {
    #[new]
    fn __new__(key: AzIconKey, rgba_bytes: AzU8Vec) -> Self {
        Self { key, rgba_bytes }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSmallWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::SmallWindowIconBytes = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLargeWindowIconBytes {
    #[new]
    fn __new__(key: AzIconKey, rgba_bytes: AzU8Vec) -> Self {
        Self { key, rgba_bytes }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLargeWindowIconBytes {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::LargeWindowIconBytes = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowIconEnumWrapper {
    #[staticmethod]
    fn Small(v: AzSmallWindowIconBytes) -> AzWindowIconEnumWrapper {
        AzWindowIconEnumWrapper {
            inner: AzWindowIcon::Small(v),
        }
    }
    #[staticmethod]
    fn Large(v: AzLargeWindowIconBytes) -> AzWindowIconEnumWrapper {
        AzWindowIconEnumWrapper {
            inner: AzWindowIcon::Large(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzWindowIcon;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowIcon::Small(v) => Ok(vec!["Small".into_py(py), v.clone().into_py(py)]),
            AzWindowIcon::Large(v) => Ok(vec!["Large".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTaskBarIcon {
    #[new]
    fn __new__(key: AzIconKey, rgba_bytes: AzU8Vec) -> Self {
        Self { key, rgba_bytes }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTaskBarIcon {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::TaskBarIcon = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeEnumWrapper {
    #[classattr]
    fn Key1() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key1,
        }
    }
    #[classattr]
    fn Key2() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key2,
        }
    }
    #[classattr]
    fn Key3() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key3,
        }
    }
    #[classattr]
    fn Key4() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key4,
        }
    }
    #[classattr]
    fn Key5() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key5,
        }
    }
    #[classattr]
    fn Key6() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key6,
        }
    }
    #[classattr]
    fn Key7() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key7,
        }
    }
    #[classattr]
    fn Key8() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key8,
        }
    }
    #[classattr]
    fn Key9() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key9,
        }
    }
    #[classattr]
    fn Key0() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Key0,
        }
    }
    #[classattr]
    fn A() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::A,
        }
    }
    #[classattr]
    fn B() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::B,
        }
    }
    #[classattr]
    fn C() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::C,
        }
    }
    #[classattr]
    fn D() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::D,
        }
    }
    #[classattr]
    fn E() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::E,
        }
    }
    #[classattr]
    fn F() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F,
        }
    }
    #[classattr]
    fn G() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::G,
        }
    }
    #[classattr]
    fn H() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::H,
        }
    }
    #[classattr]
    fn I() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::I,
        }
    }
    #[classattr]
    fn J() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::J,
        }
    }
    #[classattr]
    fn K() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::K,
        }
    }
    #[classattr]
    fn L() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::L,
        }
    }
    #[classattr]
    fn M() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::M,
        }
    }
    #[classattr]
    fn N() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::N,
        }
    }
    #[classattr]
    fn O() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::O,
        }
    }
    #[classattr]
    fn P() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::P,
        }
    }
    #[classattr]
    fn Q() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Q,
        }
    }
    #[classattr]
    fn R() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::R,
        }
    }
    #[classattr]
    fn S() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::S,
        }
    }
    #[classattr]
    fn T() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::T,
        }
    }
    #[classattr]
    fn U() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::U,
        }
    }
    #[classattr]
    fn V() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::V,
        }
    }
    #[classattr]
    fn W() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::W,
        }
    }
    #[classattr]
    fn X() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::X,
        }
    }
    #[classattr]
    fn Y() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Y,
        }
    }
    #[classattr]
    fn Z() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Z,
        }
    }
    #[classattr]
    fn Escape() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Escape,
        }
    }
    #[classattr]
    fn F1() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F1,
        }
    }
    #[classattr]
    fn F2() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F2,
        }
    }
    #[classattr]
    fn F3() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F3,
        }
    }
    #[classattr]
    fn F4() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F4,
        }
    }
    #[classattr]
    fn F5() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F5,
        }
    }
    #[classattr]
    fn F6() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F6,
        }
    }
    #[classattr]
    fn F7() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F7,
        }
    }
    #[classattr]
    fn F8() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F8,
        }
    }
    #[classattr]
    fn F9() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F9,
        }
    }
    #[classattr]
    fn F10() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F10,
        }
    }
    #[classattr]
    fn F11() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F11,
        }
    }
    #[classattr]
    fn F12() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F12,
        }
    }
    #[classattr]
    fn F13() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F13,
        }
    }
    #[classattr]
    fn F14() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F14,
        }
    }
    #[classattr]
    fn F15() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F15,
        }
    }
    #[classattr]
    fn F16() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F16,
        }
    }
    #[classattr]
    fn F17() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F17,
        }
    }
    #[classattr]
    fn F18() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F18,
        }
    }
    #[classattr]
    fn F19() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F19,
        }
    }
    #[classattr]
    fn F20() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F20,
        }
    }
    #[classattr]
    fn F21() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F21,
        }
    }
    #[classattr]
    fn F22() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F22,
        }
    }
    #[classattr]
    fn F23() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F23,
        }
    }
    #[classattr]
    fn F24() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::F24,
        }
    }
    #[classattr]
    fn Snapshot() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Snapshot,
        }
    }
    #[classattr]
    fn Scroll() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Scroll,
        }
    }
    #[classattr]
    fn Pause() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Pause,
        }
    }
    #[classattr]
    fn Insert() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Insert,
        }
    }
    #[classattr]
    fn Home() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Home,
        }
    }
    #[classattr]
    fn Delete() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Delete,
        }
    }
    #[classattr]
    fn End() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::End,
        }
    }
    #[classattr]
    fn PageDown() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::PageDown,
        }
    }
    #[classattr]
    fn PageUp() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::PageUp,
        }
    }
    #[classattr]
    fn Left() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Left,
        }
    }
    #[classattr]
    fn Up() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Up,
        }
    }
    #[classattr]
    fn Right() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Right,
        }
    }
    #[classattr]
    fn Down() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Down,
        }
    }
    #[classattr]
    fn Back() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Back,
        }
    }
    #[classattr]
    fn Return() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Return,
        }
    }
    #[classattr]
    fn Space() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Space,
        }
    }
    #[classattr]
    fn Compose() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Compose,
        }
    }
    #[classattr]
    fn Caret() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Caret,
        }
    }
    #[classattr]
    fn Numlock() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numlock,
        }
    }
    #[classattr]
    fn Numpad0() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad0,
        }
    }
    #[classattr]
    fn Numpad1() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad1,
        }
    }
    #[classattr]
    fn Numpad2() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad2,
        }
    }
    #[classattr]
    fn Numpad3() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad3,
        }
    }
    #[classattr]
    fn Numpad4() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad4,
        }
    }
    #[classattr]
    fn Numpad5() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad5,
        }
    }
    #[classattr]
    fn Numpad6() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad6,
        }
    }
    #[classattr]
    fn Numpad7() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad7,
        }
    }
    #[classattr]
    fn Numpad8() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad8,
        }
    }
    #[classattr]
    fn Numpad9() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Numpad9,
        }
    }
    #[classattr]
    fn NumpadAdd() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadAdd,
        }
    }
    #[classattr]
    fn NumpadDivide() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadDivide,
        }
    }
    #[classattr]
    fn NumpadDecimal() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadDecimal,
        }
    }
    #[classattr]
    fn NumpadComma() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadComma,
        }
    }
    #[classattr]
    fn NumpadEnter() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadEnter,
        }
    }
    #[classattr]
    fn NumpadEquals() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadEquals,
        }
    }
    #[classattr]
    fn NumpadMultiply() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadMultiply,
        }
    }
    #[classattr]
    fn NumpadSubtract() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NumpadSubtract,
        }
    }
    #[classattr]
    fn AbntC1() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::AbntC1,
        }
    }
    #[classattr]
    fn AbntC2() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::AbntC2,
        }
    }
    #[classattr]
    fn Apostrophe() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Apostrophe,
        }
    }
    #[classattr]
    fn Apps() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Apps,
        }
    }
    #[classattr]
    fn Asterisk() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Asterisk,
        }
    }
    #[classattr]
    fn At() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::At,
        }
    }
    #[classattr]
    fn Ax() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Ax,
        }
    }
    #[classattr]
    fn Backslash() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Backslash,
        }
    }
    #[classattr]
    fn Calculator() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Calculator,
        }
    }
    #[classattr]
    fn Capital() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Capital,
        }
    }
    #[classattr]
    fn Colon() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Colon,
        }
    }
    #[classattr]
    fn Comma() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Comma,
        }
    }
    #[classattr]
    fn Convert() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Convert,
        }
    }
    #[classattr]
    fn Equals() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Equals,
        }
    }
    #[classattr]
    fn Grave() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Grave,
        }
    }
    #[classattr]
    fn Kana() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Kana,
        }
    }
    #[classattr]
    fn Kanji() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Kanji,
        }
    }
    #[classattr]
    fn LAlt() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::LAlt,
        }
    }
    #[classattr]
    fn LBracket() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::LBracket,
        }
    }
    #[classattr]
    fn LControl() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::LControl,
        }
    }
    #[classattr]
    fn LShift() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::LShift,
        }
    }
    #[classattr]
    fn LWin() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::LWin,
        }
    }
    #[classattr]
    fn Mail() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Mail,
        }
    }
    #[classattr]
    fn MediaSelect() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::MediaSelect,
        }
    }
    #[classattr]
    fn MediaStop() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::MediaStop,
        }
    }
    #[classattr]
    fn Minus() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Minus,
        }
    }
    #[classattr]
    fn Mute() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Mute,
        }
    }
    #[classattr]
    fn MyComputer() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::MyComputer,
        }
    }
    #[classattr]
    fn NavigateForward() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NavigateForward,
        }
    }
    #[classattr]
    fn NavigateBackward() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NavigateBackward,
        }
    }
    #[classattr]
    fn NextTrack() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NextTrack,
        }
    }
    #[classattr]
    fn NoConvert() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::NoConvert,
        }
    }
    #[classattr]
    fn OEM102() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::OEM102,
        }
    }
    #[classattr]
    fn Period() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Period,
        }
    }
    #[classattr]
    fn PlayPause() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::PlayPause,
        }
    }
    #[classattr]
    fn Plus() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Plus,
        }
    }
    #[classattr]
    fn Power() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Power,
        }
    }
    #[classattr]
    fn PrevTrack() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::PrevTrack,
        }
    }
    #[classattr]
    fn RAlt() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::RAlt,
        }
    }
    #[classattr]
    fn RBracket() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::RBracket,
        }
    }
    #[classattr]
    fn RControl() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::RControl,
        }
    }
    #[classattr]
    fn RShift() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::RShift,
        }
    }
    #[classattr]
    fn RWin() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::RWin,
        }
    }
    #[classattr]
    fn Semicolon() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Semicolon,
        }
    }
    #[classattr]
    fn Slash() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Slash,
        }
    }
    #[classattr]
    fn Sleep() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Sleep,
        }
    }
    #[classattr]
    fn Stop() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Stop,
        }
    }
    #[classattr]
    fn Sysrq() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Sysrq,
        }
    }
    #[classattr]
    fn Tab() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Tab,
        }
    }
    #[classattr]
    fn Underline() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Underline,
        }
    }
    #[classattr]
    fn Unlabeled() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Unlabeled,
        }
    }
    #[classattr]
    fn VolumeDown() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::VolumeDown,
        }
    }
    #[classattr]
    fn VolumeUp() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::VolumeUp,
        }
    }
    #[classattr]
    fn Wake() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Wake,
        }
    }
    #[classattr]
    fn WebBack() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::WebBack,
        }
    }
    #[classattr]
    fn WebFavorites() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::WebFavorites,
        }
    }
    #[classattr]
    fn WebForward() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::WebForward,
        }
    }
    #[classattr]
    fn WebHome() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::WebHome,
        }
    }
    #[classattr]
    fn WebRefresh() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::WebRefresh,
        }
    }
    #[classattr]
    fn WebSearch() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::WebSearch,
        }
    }
    #[classattr]
    fn WebStop() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::WebStop,
        }
    }
    #[classattr]
    fn Yen() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Yen,
        }
    }
    #[classattr]
    fn Copy() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Copy,
        }
    }
    #[classattr]
    fn Paste() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Paste,
        }
    }
    #[classattr]
    fn Cut() -> AzVirtualKeyCodeEnumWrapper {
        AzVirtualKeyCodeEnumWrapper {
            inner: AzVirtualKeyCode::Cut,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzVirtualKeyCodeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzAcceleratorKeyEnumWrapper {
    #[classattr]
    fn Ctrl() -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper {
            inner: AzAcceleratorKey::Ctrl,
        }
    }
    #[classattr]
    fn Alt() -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper {
            inner: AzAcceleratorKey::Alt,
        }
    }
    #[classattr]
    fn Shift() -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper {
            inner: AzAcceleratorKey::Shift,
        }
    }
    #[staticmethod]
    fn Key(v: AzVirtualKeyCodeEnumWrapper) -> AzAcceleratorKeyEnumWrapper {
        AzAcceleratorKeyEnumWrapper {
            inner: AzAcceleratorKey::Key(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzAcceleratorKey;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAcceleratorKey::Ctrl => Ok(vec!["Ctrl".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Alt => Ok(vec!["Alt".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Shift => Ok(vec!["Shift".into_py(py), ().into_py(py)]),
            AzAcceleratorKey::Key(v) => Ok(vec![
                "Key".into_py(py),
                {
                    let m: &AzVirtualKeyCodeEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAcceleratorKeyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::AcceleratorKey = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowSize {
    #[new]
    fn __new__(
        dimensions: AzLogicalSize,
        dpi: u32,
        min_dimensions: AzOptionLogicalSizeEnumWrapper,
        max_dimensions: AzOptionLogicalSizeEnumWrapper,
    ) -> Self {
        Self {
            dimensions,
            dpi,
            min_dimensions,
            max_dimensions,
        }
    }

    fn get_hidpi_factor(&self) -> f32 {
        unsafe { mem::transmute(crate::AzWindowSize_getHidpiFactor(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowSize {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowFlags {
    #[new]
    fn __new__(
        frame: AzWindowFrameEnumWrapper,
        is_about_to_close: bool,
        has_decorations: bool,
        is_visible: bool,
        is_always_on_top: bool,
        is_resizable: bool,
        has_focus: bool,
        has_extended_window_frame: bool,
        has_blur_behind_window: bool,
        smooth_scroll_enabled: bool,
        autotab_enabled: bool,
    ) -> Self {
        Self {
            frame,
            is_about_to_close,
            has_decorations,
            is_visible,
            is_always_on_top,
            is_resizable,
            has_focus,
            has_extended_window_frame,
            has_blur_behind_window,
            smooth_scroll_enabled,
            autotab_enabled,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowFlags {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowFlags = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowFrameEnumWrapper {
    #[classattr]
    fn Normal() -> AzWindowFrameEnumWrapper {
        AzWindowFrameEnumWrapper {
            inner: AzWindowFrame::Normal,
        }
    }
    #[classattr]
    fn Minimized() -> AzWindowFrameEnumWrapper {
        AzWindowFrameEnumWrapper {
            inner: AzWindowFrame::Minimized,
        }
    }
    #[classattr]
    fn Maximized() -> AzWindowFrameEnumWrapper {
        AzWindowFrameEnumWrapper {
            inner: AzWindowFrame::Maximized,
        }
    }
    #[classattr]
    fn Fullscreen() -> AzWindowFrameEnumWrapper {
        AzWindowFrameEnumWrapper {
            inner: AzWindowFrame::Fullscreen,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowFrameEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowFrame = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzWindowFrameEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzDebugState {
    #[new]
    fn __new__(
        profiler_dbg: bool,
        render_target_dbg: bool,
        texture_cache_dbg: bool,
        gpu_time_queries: bool,
        gpu_sample_queries: bool,
        disable_batching: bool,
        epochs: bool,
        echo_driver_messages: bool,
        show_overdraw: bool,
        gpu_cache_dbg: bool,
        texture_cache_dbg_clear_evicted: bool,
        picture_caching_dbg: bool,
        primitive_dbg: bool,
        zoom_dbg: bool,
        small_screen: bool,
        disable_opaque_pass: bool,
        disable_alpha_pass: bool,
        disable_clip_masks: bool,
        disable_text_prims: bool,
        disable_gradient_prims: bool,
        obscure_images: bool,
        glyph_flashing: bool,
        smart_profiler: bool,
        invalidation_dbg: bool,
        tile_cache_logging_dbg: bool,
        profiler_capture: bool,
        force_picture_invalidation: bool,
    ) -> Self {
        Self {
            profiler_dbg,
            render_target_dbg,
            texture_cache_dbg,
            gpu_time_queries,
            gpu_sample_queries,
            disable_batching,
            epochs,
            echo_driver_messages,
            show_overdraw,
            gpu_cache_dbg,
            texture_cache_dbg_clear_evicted,
            picture_caching_dbg,
            primitive_dbg,
            zoom_dbg,
            small_screen,
            disable_opaque_pass,
            disable_alpha_pass,
            disable_clip_masks,
            disable_text_prims,
            disable_gradient_prims,
            obscure_images,
            glyph_flashing,
            smart_profiler,
            invalidation_dbg,
            tile_cache_logging_dbg,
            profiler_capture,
            force_picture_invalidation,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDebugState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::DebugState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzKeyboardState {
    #[new]
    fn __new__(
        current_char: AzOptionCharEnumWrapper,
        current_virtual_keycode: AzOptionVirtualKeyCodeEnumWrapper,
        pressed_virtual_keycodes: AzVirtualKeyCodeVec,
        pressed_scancodes: AzScanCodeVec,
    ) -> Self {
        Self {
            current_char,
            current_virtual_keycode,
            pressed_virtual_keycodes,
            pressed_scancodes,
        }
    }

    fn shift_down(&self) -> bool {
        unsafe { mem::transmute(crate::AzKeyboardState_shiftDown(mem::transmute(self))) }
    }
    fn ctrl_down(&self) -> bool {
        unsafe { mem::transmute(crate::AzKeyboardState_ctrlDown(mem::transmute(self))) }
    }
    fn alt_down(&self) -> bool {
        unsafe { mem::transmute(crate::AzKeyboardState_altDown(mem::transmute(self))) }
    }
    fn super_down(&self) -> bool {
        unsafe { mem::transmute(crate::AzKeyboardState_superDown(mem::transmute(self))) }
    }
    fn is_key_down(&self, key: AzVirtualKeyCodeEnumWrapper) -> bool {
        unsafe {
            mem::transmute(crate::AzKeyboardState_isKeyDown(
                mem::transmute(self),
                mem::transmute(key),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzKeyboardState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::KeyboardState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseCursorTypeEnumWrapper {
    #[classattr]
    fn Default() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Default,
        }
    }
    #[classattr]
    fn Crosshair() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Crosshair,
        }
    }
    #[classattr]
    fn Hand() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Hand,
        }
    }
    #[classattr]
    fn Arrow() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Arrow,
        }
    }
    #[classattr]
    fn Move() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Move,
        }
    }
    #[classattr]
    fn Text() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Text,
        }
    }
    #[classattr]
    fn Wait() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Wait,
        }
    }
    #[classattr]
    fn Help() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Help,
        }
    }
    #[classattr]
    fn Progress() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Progress,
        }
    }
    #[classattr]
    fn NotAllowed() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NotAllowed,
        }
    }
    #[classattr]
    fn ContextMenu() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::ContextMenu,
        }
    }
    #[classattr]
    fn Cell() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Cell,
        }
    }
    #[classattr]
    fn VerticalText() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::VerticalText,
        }
    }
    #[classattr]
    fn Alias() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Alias,
        }
    }
    #[classattr]
    fn Copy() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Copy,
        }
    }
    #[classattr]
    fn NoDrop() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NoDrop,
        }
    }
    #[classattr]
    fn Grab() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Grab,
        }
    }
    #[classattr]
    fn Grabbing() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::Grabbing,
        }
    }
    #[classattr]
    fn AllScroll() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::AllScroll,
        }
    }
    #[classattr]
    fn ZoomIn() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::ZoomIn,
        }
    }
    #[classattr]
    fn ZoomOut() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::ZoomOut,
        }
    }
    #[classattr]
    fn EResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::EResize,
        }
    }
    #[classattr]
    fn NResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NResize,
        }
    }
    #[classattr]
    fn NeResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NeResize,
        }
    }
    #[classattr]
    fn NwResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NwResize,
        }
    }
    #[classattr]
    fn SResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::SResize,
        }
    }
    #[classattr]
    fn SeResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::SeResize,
        }
    }
    #[classattr]
    fn SwResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::SwResize,
        }
    }
    #[classattr]
    fn WResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::WResize,
        }
    }
    #[classattr]
    fn EwResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::EwResize,
        }
    }
    #[classattr]
    fn NsResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NsResize,
        }
    }
    #[classattr]
    fn NeswResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NeswResize,
        }
    }
    #[classattr]
    fn NwseResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::NwseResize,
        }
    }
    #[classattr]
    fn ColResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::ColResize,
        }
    }
    #[classattr]
    fn RowResize() -> AzMouseCursorTypeEnumWrapper {
        AzMouseCursorTypeEnumWrapper {
            inner: AzMouseCursorType::RowResize,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MouseCursorType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzMouseCursorTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzCursorPositionEnumWrapper {
    #[staticmethod]
    fn OutOfWindow(v: AzLogicalPosition) -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper {
            inner: AzCursorPosition::OutOfWindow(v),
        }
    }
    #[classattr]
    fn Uninitialized() -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper {
            inner: AzCursorPosition::Uninitialized,
        }
    }
    #[staticmethod]
    fn InWindow(v: AzLogicalPosition) -> AzCursorPositionEnumWrapper {
        AzCursorPositionEnumWrapper {
            inner: AzCursorPosition::InWindow(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCursorPosition;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCursorPosition::OutOfWindow(v) => {
                Ok(vec!["OutOfWindow".into_py(py), v.clone().into_py(py)])
            }
            AzCursorPosition::Uninitialized => {
                Ok(vec!["Uninitialized".into_py(py), ().into_py(py)])
            }
            AzCursorPosition::InWindow(v) => {
                Ok(vec!["InWindow".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCursorPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::CursorPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMouseState {
    #[new]
    fn __new__(
        mouse_cursor_type: AzOptionMouseCursorTypeEnumWrapper,
        cursor_position: AzCursorPositionEnumWrapper,
        is_cursor_locked: bool,
        left_down: bool,
        right_down: bool,
        middle_down: bool,
        scroll_x: AzOptionF32EnumWrapper,
        scroll_y: AzOptionF32EnumWrapper,
    ) -> Self {
        Self {
            mouse_cursor_type,
            cursor_position,
            is_cursor_locked,
            left_down,
            right_down,
            middle_down,
            scroll_x,
            scroll_y,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMouseState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MouseState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPlatformSpecificOptions {
    #[new]
    fn __new__(
        windows_options: AzWindowsWindowOptions,
        linux_options: AzLinuxWindowOptions,
        mac_options: AzMacWindowOptions,
        wasm_options: AzWasmWindowOptions,
    ) -> Self {
        Self {
            windows_options,
            linux_options,
            mac_options,
            wasm_options,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPlatformSpecificOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::PlatformSpecificOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowsWindowOptions {
    #[new]
    fn __new__(
        allow_drag_drop: bool,
        no_redirection_bitmap: bool,
        window_icon: AzOptionWindowIconEnumWrapper,
        taskbar_icon: AzOptionTaskBarIconEnumWrapper,
        parent_window: AzOptionHwndHandleEnumWrapper,
    ) -> Self {
        Self {
            allow_drag_drop,
            no_redirection_bitmap,
            window_icon,
            taskbar_icon,
            parent_window,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowsWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowsWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWaylandTheme {}

#[pyproto]
impl PyObjectProtocol for AzWaylandTheme {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WaylandTheme = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRendererTypeEnumWrapper {
    #[classattr]
    fn Hardware() -> AzRendererTypeEnumWrapper {
        AzRendererTypeEnumWrapper {
            inner: AzRendererType::Hardware,
        }
    }
    #[classattr]
    fn Software() -> AzRendererTypeEnumWrapper {
        AzRendererTypeEnumWrapper {
            inner: AzRendererType::Software,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRendererTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::RendererType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzRendererTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStringPair {
    #[new]
    fn __new__(key: AzString, value: AzString) -> Self {
        Self { key, value }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringPair {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::AzStringPair = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLinuxWindowOptions {
    #[new]
    fn __new__(
        x11_visual: AzOptionX11VisualEnumWrapper,
        x11_screen: AzOptionI32EnumWrapper,
        x11_wm_classes: AzStringPairVec,
        x11_override_redirect: bool,
        x11_window_types: AzXWindowTypeVec,
        x11_gtk_theme_variant: AzOptionStringEnumWrapper,
        x11_resize_increments: AzOptionLogicalSizeEnumWrapper,
        x11_base_size: AzOptionLogicalSizeEnumWrapper,
        wayland_app_id: AzOptionStringEnumWrapper,
        wayland_theme: AzOptionWaylandThemeEnumWrapper,
        request_user_attention: bool,
        window_icon: AzOptionWindowIconEnumWrapper,
    ) -> Self {
        Self {
            x11_visual,
            x11_screen,
            x11_wm_classes,
            x11_override_redirect,
            x11_window_types,
            x11_gtk_theme_variant,
            x11_resize_increments,
            x11_base_size,
            wayland_app_id,
            wayland_theme,
            request_user_attention,
            window_icon,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLinuxWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::LinuxWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMacWindowOptions {
    #[new]
    fn __new__(_reserved: u8) -> Self {
        Self { _reserved }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMacWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MacWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWasmWindowOptions {
    #[new]
    fn __new__(_reserved: u8) -> Self {
        Self { _reserved }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWasmWindowOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WasmWindowOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFullScreenModeEnumWrapper {
    #[classattr]
    fn SlowFullScreen() -> AzFullScreenModeEnumWrapper {
        AzFullScreenModeEnumWrapper {
            inner: AzFullScreenMode::SlowFullScreen,
        }
    }
    #[classattr]
    fn FastFullScreen() -> AzFullScreenModeEnumWrapper {
        AzFullScreenModeEnumWrapper {
            inner: AzFullScreenMode::FastFullScreen,
        }
    }
    #[classattr]
    fn SlowWindowed() -> AzFullScreenModeEnumWrapper {
        AzFullScreenModeEnumWrapper {
            inner: AzFullScreenMode::SlowWindowed,
        }
    }
    #[classattr]
    fn FastWindowed() -> AzFullScreenModeEnumWrapper {
        AzFullScreenModeEnumWrapper {
            inner: AzFullScreenMode::FastWindowed,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFullScreenModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::FullScreenMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::FullScreenMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzFullScreenModeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzWindowThemeEnumWrapper {
    #[classattr]
    fn DarkMode() -> AzWindowThemeEnumWrapper {
        AzWindowThemeEnumWrapper {
            inner: AzWindowTheme::DarkMode,
        }
    }
    #[classattr]
    fn LightMode() -> AzWindowThemeEnumWrapper {
        AzWindowThemeEnumWrapper {
            inner: AzWindowTheme::LightMode,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowTheme = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzWindowThemeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzWindowPositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzWindowPositionEnumWrapper {
        AzWindowPositionEnumWrapper {
            inner: AzWindowPosition::Uninitialized,
        }
    }
    #[staticmethod]
    fn Initialized(v: AzPhysicalPositionI32) -> AzWindowPositionEnumWrapper {
        AzWindowPositionEnumWrapper {
            inner: AzWindowPosition::Initialized(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzWindowPosition;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzWindowPosition::Uninitialized => {
                Ok(vec!["Uninitialized".into_py(py), ().into_py(py)])
            }
            AzWindowPosition::Initialized(v) => {
                Ok(vec!["Initialized".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImePositionEnumWrapper {
    #[classattr]
    fn Uninitialized() -> AzImePositionEnumWrapper {
        AzImePositionEnumWrapper {
            inner: AzImePosition::Uninitialized,
        }
    }
    #[staticmethod]
    fn Initialized(v: AzLogicalPosition) -> AzImePositionEnumWrapper {
        AzImePositionEnumWrapper {
            inner: AzImePosition::Initialized(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzImePosition;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzImePosition::Uninitialized => Ok(vec!["Uninitialized".into_py(py), ().into_py(py)]),
            AzImePosition::Initialized(v) => {
                Ok(vec!["Initialized".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImePositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ImePosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTouchState {
    #[new]
    fn __new__(unused: u8) -> Self {
        Self { unused }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTouchState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::TouchState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitor {
    #[new]
    fn __new__(
        id: usize,
        name: AzOptionStringEnumWrapper,
        size: AzLayoutSize,
        position: AzLayoutPoint,
        scale_factor: f64,
        video_modes: AzVideoModeVec,
        is_primary_monitor: bool,
    ) -> Self {
        Self {
            id,
            name,
            size,
            position,
            scale_factor,
            video_modes,
            is_primary_monitor,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMonitor {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Monitor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoMode {
    #[new]
    fn __new__(size: AzLayoutSize, bit_depth: u16, refresh_rate: u16) -> Self {
        Self {
            size,
            bit_depth,
            refresh_rate,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVideoMode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VideoMode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowState {
    #[staticmethod]
    fn default() -> AzWindowState {
        unsafe { mem::transmute(crate::AzWindowState_default()) }
    }
    // impl AzWindowState {

    #[new]
    pub fn __new__(py: Python, cb: PyObject) -> Result<Self, PyErr> {
        let layout_callback = AzLayoutCallbackEnumWrapper::__new__(py, cb)?;
        let window = azul_core::window::WindowState {
            layout_callback: unsafe { mem::transmute(layout_callback) },
            ..Default::default()
        };
        Ok(unsafe { mem::transmute(window) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::WindowState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackEnumWrapper {
    #[staticmethod]
    fn Raw(v: AzLayoutCallbackInner) -> AzLayoutCallbackEnumWrapper {
        AzLayoutCallbackEnumWrapper {
            inner: AzLayoutCallback::Raw(v),
        }
    }
    #[staticmethod]
    fn Marshaled(v: AzMarshaledLayoutCallback) -> AzLayoutCallbackEnumWrapper {
        AzLayoutCallbackEnumWrapper {
            inner: AzLayoutCallback::Marshaled(v),
        }
    }
    // impl LayoutCallbackEnumWrapper { ...

    #[new]
    pub fn __new__(py: Python, cb: PyObject) -> Result<Self, PyErr> {
        use pyo3::type_object::PyTypeInfo;

        {
            let cb_any = cb.as_ref(py);
            if !cb_any.is_callable() {
                let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
                return Err(PyException::new_err(format!(
                    "ERROR in LayoutCallback.new: - argument \"cb\" is of type \"{}\", expected \
                     function",
                    type_name
                )));
            }
        }

        Ok(Self {
            inner: AzLayoutCallback::Marshaled(AzMarshaledLayoutCallback {
                marshal_data: unsafe {
                    mem::transmute(azul_impl::callbacks::RefAny::new(LayoutCallbackTy {
                        _py_layout_callback: Some(cb),
                    }))
                },
                cb: AzMarshaledLayoutCallbackInner {
                    cb: invoke_py_marshaled_layout_callback,
                },
            }),
        })
    }
    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutCallback;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutCallback::Raw(v) => Ok(vec!["Raw".into_py(py), v.clone().into_py(py)]),
            AzLayoutCallback::Marshaled(v) => {
                Ok(vec!["Marshaled".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::LayoutCallback = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallback {
    #[new]
    fn __new__(marshal_data: AzRefAny, cb: AzMarshaledLayoutCallbackInner) -> Self {
        Self { marshal_data, cb }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::MarshaledLayoutCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMarshaledLayoutCallbackInner {}

#[pyproto]
impl PyObjectProtocol for AzMarshaledLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::MarshaledLayoutCallbackInner =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::MarshaledLayoutCallbackInner =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackInner {}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInner {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::LayoutCallbackInner = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallback {}

#[pyproto]
impl PyObjectProtocol for AzCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::Callback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::Callback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackInfo {
    fn get_hit_node(&self) -> AzDomNodeId {
        unsafe { mem::transmute(crate::AzCallbackInfo_getHitNode(mem::transmute(self))) }
    }
    fn get_system_time_fn(&self) -> AzGetSystemTimeFn {
        unsafe { mem::transmute(crate::AzCallbackInfo_getSystemTimeFn(mem::transmute(self))) }
    }
    fn get_cursor_relative_to_viewport(&self) -> Option<AzLogicalPosition> {
        let m: AzOptionLogicalPosition = unsafe {
            mem::transmute(crate::AzCallbackInfo_getCursorRelativeToViewport(
                mem::transmute(self),
            ))
        };
        match m {
            AzOptionLogicalPosition::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalPosition::None => None,
        }
    }
    fn get_cursor_relative_to_node(&self) -> Option<AzLogicalPosition> {
        let m: AzOptionLogicalPosition = unsafe {
            mem::transmute(crate::AzCallbackInfo_getCursorRelativeToNode(
                mem::transmute(self),
            ))
        };
        match m {
            AzOptionLogicalPosition::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalPosition::None => None,
        }
    }
    fn get_current_window_state(&self) -> AzWindowState {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_getCurrentWindowState(mem::transmute(
                self,
            )))
        }
    }
    fn get_current_keyboard_state(&self) -> AzKeyboardState {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_getCurrentKeyboardState(
                mem::transmute(self),
            ))
        }
    }
    fn get_current_mouse_state(&self) -> AzMouseState {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_getCurrentMouseState(mem::transmute(
                self,
            )))
        }
    }
    fn get_previous_window_state(&self) -> Option<AzWindowState> {
        let m: AzOptionWindowState = unsafe {
            mem::transmute(crate::AzCallbackInfo_getPreviousWindowState(
                mem::transmute(self),
            ))
        };
        match m {
            AzOptionWindowState::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionWindowState::None => None,
        }
    }
    fn get_previous_keyboard_state(&self) -> Option<AzKeyboardState> {
        let m: AzOptionKeyboardState = unsafe {
            mem::transmute(crate::AzCallbackInfo_getPreviousKeyboardState(
                mem::transmute(self),
            ))
        };
        match m {
            AzOptionKeyboardState::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionKeyboardState::None => None,
        }
    }
    fn get_previous_mouse_state(&self) -> Option<AzMouseState> {
        let m: AzOptionMouseState = unsafe {
            mem::transmute(crate::AzCallbackInfo_getPreviousMouseState(mem::transmute(
                self,
            )))
        };
        match m {
            AzOptionMouseState::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionMouseState::None => None,
        }
    }
    fn get_current_window_handle(&self) -> AzRawWindowHandleEnumWrapper {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_getCurrentWindowHandle(
                mem::transmute(self),
            ))
        }
    }
    fn get_gl_context(&self) -> Option<AzGl> {
        let m: AzOptionGl =
            unsafe { mem::transmute(crate::AzCallbackInfo_getGlContext(mem::transmute(self))) };
        match m {
            AzOptionGl::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionGl::None => None,
        }
    }
    fn get_scroll_position(&self, node_id: AzDomNodeId) -> Option<AzLogicalPosition> {
        let m: AzOptionLogicalPosition = unsafe {
            mem::transmute(crate::AzCallbackInfo_getScrollPosition(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionLogicalPosition::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalPosition::None => None,
        }
    }
    fn get_dataset(&mut self, node_id: AzDomNodeId) -> Option<AzRefAny> {
        let m: AzOptionRefAny = unsafe {
            mem::transmute(crate::AzCallbackInfo_getDataset(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionRefAny::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionRefAny::None => None,
        }
    }
    fn get_string_contents(&self, node_id: AzDomNodeId) -> Option<String> {
        let m: AzOptionString = unsafe {
            mem::transmute(crate::AzCallbackInfo_getStringContents(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionString::Some(s) => Some({
                let s: AzString = unsafe { mem::transmute(s) };
                s.into()
            }),
            AzOptionString::None => None,
        }
    }
    fn get_inline_text(&self, node_id: AzDomNodeId) -> Option<AzInlineText> {
        let m: AzOptionInlineText = unsafe {
            mem::transmute(crate::AzCallbackInfo_getInlineText(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionInlineText::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionInlineText::None => None,
        }
    }
    fn get_font_ref(&self, node_id: AzDomNodeId) -> Option<AzFontRef> {
        let m: AzOptionFontRef = unsafe {
            mem::transmute(crate::AzCallbackInfo_getFontRef(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionFontRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFontRef::None => None,
        }
    }
    fn get_text_layout_options(&self, node_id: AzDomNodeId) -> Option<AzResolvedTextLayoutOptions> {
        let m: AzOptionResolvedTextLayoutOptions = unsafe {
            mem::transmute(crate::AzCallbackInfo_getTextLayoutOptions(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionResolvedTextLayoutOptions::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionResolvedTextLayoutOptions::None => None,
        }
    }
    fn shape_text(&self, node_id: AzDomNodeId, text: String) -> Option<AzInlineText> {
        let text = pystring_to_azstring(&text);
        let m: AzOptionInlineText = unsafe {
            mem::transmute(crate::AzCallbackInfo_shapeText(
                mem::transmute(self),
                mem::transmute(node_id),
                mem::transmute(text),
            ))
        };
        match m {
            AzOptionInlineText::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionInlineText::None => None,
        }
    }
    fn get_index_in_parent(&mut self, node_id: AzDomNodeId) -> usize {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_getIndexInParent(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        }
    }
    fn get_parent(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzCallbackInfo_getParent(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_previous_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzCallbackInfo_getPreviousSibling(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_next_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzCallbackInfo_getNextSibling(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_first_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzCallbackInfo_getFirstChild(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_last_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzCallbackInfo_getLastChild(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_node_position(&mut self, node_id: AzDomNodeId) -> Option<AzPositionInfoEnumWrapper> {
        let m: AzOptionPositionInfo = unsafe {
            mem::transmute(crate::AzCallbackInfo_getNodePosition(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionPositionInfo::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionPositionInfo::None => None,
        }
    }
    fn get_node_size(&mut self, node_id: AzDomNodeId) -> Option<AzLogicalSize> {
        let m: AzOptionLogicalSize = unsafe {
            mem::transmute(crate::AzCallbackInfo_getNodeSize(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionLogicalSize::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionLogicalSize::None => None,
        }
    }
    fn get_computed_css_property(
        &mut self,
        node_id: AzDomNodeId,
        property_type: AzCssPropertyTypeEnumWrapper,
    ) -> Option<AzCssPropertyEnumWrapper> {
        let m: AzOptionCssProperty = unsafe {
            mem::transmute(crate::AzCallbackInfo_getComputedCssProperty(
                mem::transmute(self),
                mem::transmute(node_id),
                mem::transmute(property_type),
            ))
        };
        match m {
            AzOptionCssProperty::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionCssProperty::None => None,
        }
    }
    fn set_window_state(&mut self, new_state: AzWindowState) -> () {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_setWindowState(
                mem::transmute(self),
                mem::transmute(new_state),
            ))
        }
    }
    fn set_focus(&mut self, target: AzFocusTargetEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_setFocus(
                mem::transmute(self),
                mem::transmute(target),
            ))
        }
    }
    fn set_css_property(
        &mut self,
        node_id: AzDomNodeId,
        new_property: AzCssPropertyEnumWrapper,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_setCssProperty(
                mem::transmute(self),
                mem::transmute(node_id),
                mem::transmute(new_property),
            ))
        }
    }
    fn set_scroll_position(
        &mut self,
        node_id: AzDomNodeId,
        scroll_position: AzLogicalPosition,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_setScrollPosition(
                mem::transmute(self),
                mem::transmute(node_id),
                mem::transmute(scroll_position),
            ))
        }
    }
    fn set_string_contents(&mut self, node_id: AzDomNodeId, string: String) -> () {
        let string = pystring_to_azstring(&string);
        unsafe {
            mem::transmute(crate::AzCallbackInfo_setStringContents(
                mem::transmute(self),
                mem::transmute(node_id),
                mem::transmute(string),
            ))
        }
    }
    fn add_image(&mut self, id: String, image: AzImageRef) -> () {
        let id = pystring_to_azstring(&id);
        unsafe {
            mem::transmute(crate::AzCallbackInfo_addImage(
                mem::transmute(self),
                mem::transmute(id),
                mem::transmute(image),
            ))
        }
    }
    fn has_image(&self, id: String) -> bool {
        let id = pystring_to_azstring(&id);
        unsafe {
            mem::transmute(crate::AzCallbackInfo_hasImage(
                mem::transmute(self),
                mem::transmute(id),
            ))
        }
    }
    fn get_image(&self, id: String) -> Option<AzImageRef> {
        let id = pystring_to_azstring(&id);
        let m: AzOptionImageRef = unsafe {
            mem::transmute(crate::AzCallbackInfo_getImage(
                mem::transmute(self),
                mem::transmute(id),
            ))
        };
        match m {
            AzOptionImageRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionImageRef::None => None,
        }
    }
    fn update_image(
        &mut self,
        node_id: AzDomNodeId,
        new_image: AzImageRef,
        image_type: AzUpdateImageTypeEnumWrapper,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_updateImage(
                mem::transmute(self),
                mem::transmute(node_id),
                mem::transmute(new_image),
                mem::transmute(image_type),
            ))
        }
    }
    fn delete_image(&mut self, id: String) -> () {
        let id = pystring_to_azstring(&id);
        unsafe {
            mem::transmute(crate::AzCallbackInfo_deleteImage(
                mem::transmute(self),
                mem::transmute(id),
            ))
        }
    }
    fn update_image_mask(&mut self, node_id: AzDomNodeId, new_mask: AzImageMask) -> () {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_updateImageMask(
                mem::transmute(self),
                mem::transmute(node_id),
                mem::transmute(new_mask),
            ))
        }
    }
    fn stop_propagation(&mut self) -> () {
        unsafe { mem::transmute(crate::AzCallbackInfo_stopPropagation(mem::transmute(self))) }
    }
    fn create_window(&mut self, new_window: AzWindowCreateOptions) -> () {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_createWindow(
                mem::transmute(self),
                mem::transmute(new_window),
            ))
        }
    }
    fn start_timer(&mut self, timer: AzTimer) -> AzTimerId {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_startTimer(
                mem::transmute(self),
                mem::transmute(timer),
            ))
        }
    }
    fn start_animation(&mut self, node: AzDomNodeId, animation: AzAnimation) -> Option<AzTimerId> {
        let m: AzOptionTimerId = unsafe {
            mem::transmute(crate::AzCallbackInfo_startAnimation(
                mem::transmute(self),
                mem::transmute(node),
                mem::transmute(animation),
            ))
        };
        match m {
            AzOptionTimerId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionTimerId::None => None,
        }
    }
    fn stop_timer(&mut self, timer_id: AzTimerId) -> bool {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_stopTimer(
                mem::transmute(self),
                mem::transmute(timer_id),
            ))
        }
    }
    fn send_thread_msg(&mut self, thread_id: AzThreadId, msg: AzThreadSendMsgEnumWrapper) -> bool {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_sendThreadMsg(
                mem::transmute(self),
                mem::transmute(thread_id),
                mem::transmute(msg),
            ))
        }
    }
    fn stop_thread(&mut self, thread_id: AzThreadId) -> bool {
        unsafe {
            mem::transmute(crate::AzCallbackInfo_stopThread(
                mem::transmute(self),
                mem::transmute(thread_id),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::callbacks::CallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUpdateImageTypeEnumWrapper {
    #[classattr]
    fn Background() -> AzUpdateImageTypeEnumWrapper {
        AzUpdateImageTypeEnumWrapper {
            inner: AzUpdateImageType::Background,
        }
    }
    #[classattr]
    fn Content() -> AzUpdateImageTypeEnumWrapper {
        AzUpdateImageTypeEnumWrapper {
            inner: AzUpdateImageType::Content,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzUpdateImageTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::UpdateImageType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::UpdateImageType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzUpdateImageTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzUpdateEnumWrapper {
    #[classattr]
    fn DoNothing() -> AzUpdateEnumWrapper {
        AzUpdateEnumWrapper {
            inner: AzUpdate::DoNothing,
        }
    }
    #[classattr]
    fn RefreshDom() -> AzUpdateEnumWrapper {
        AzUpdateEnumWrapper {
            inner: AzUpdate::RefreshDom,
        }
    }
    #[classattr]
    fn RefreshDomAllWindows() -> AzUpdateEnumWrapper {
        AzUpdateEnumWrapper {
            inner: AzUpdate::RefreshDomAllWindows,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzUpdateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::Update = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzUpdateEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzNodeId {
    #[new]
    fn __new__(inner: usize) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItemId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomId {
    #[new]
    fn __new__(inner: usize) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDomId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::DomId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::DomId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomNodeId {
    #[new]
    fn __new__(dom: AzDomId, node: AzNodeId) -> Self {
        Self { dom, node }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDomNodeId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::DomNodeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::DomNodeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPositionInfoEnumWrapper {
    #[staticmethod]
    fn Static(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper {
            inner: AzPositionInfo::Static(v),
        }
    }
    #[staticmethod]
    fn Fixed(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper {
            inner: AzPositionInfo::Fixed(v),
        }
    }
    #[staticmethod]
    fn Absolute(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper {
            inner: AzPositionInfo::Absolute(v),
        }
    }
    #[staticmethod]
    fn Relative(v: AzPositionInfoInner) -> AzPositionInfoEnumWrapper {
        AzPositionInfoEnumWrapper {
            inner: AzPositionInfo::Relative(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzPositionInfo;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzPositionInfo::Static(v) => Ok(vec!["Static".into_py(py), v.clone().into_py(py)]),
            AzPositionInfo::Fixed(v) => Ok(vec!["Fixed".into_py(py), v.clone().into_py(py)]),
            AzPositionInfo::Absolute(v) => Ok(vec!["Absolute".into_py(py), v.clone().into_py(py)]),
            AzPositionInfo::Relative(v) => Ok(vec!["Relative".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPositionInfoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::PositionInfo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::PositionInfo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPositionInfoInner {
    #[new]
    fn __new__(x_offset: f32, y_offset: f32, static_x_offset: f32, static_y_offset: f32) -> Self {
        Self {
            x_offset,
            y_offset,
            static_x_offset,
            static_y_offset,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPositionInfoInner {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::PositionInfoInner = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHidpiAdjustedBounds {
    #[new]
    fn __new__(logical_size: AzLogicalSize, hidpi_factor: f32) -> Self {
        Self {
            logical_size,
            hidpi_factor,
        }
    }

    fn get_logical_size(&self) -> AzLogicalSize {
        unsafe {
            mem::transmute(crate::AzHidpiAdjustedBounds_getLogicalSize(mem::transmute(
                self,
            )))
        }
    }
    fn get_physical_size(&self) -> AzPhysicalSizeU32 {
        unsafe {
            mem::transmute(crate::AzHidpiAdjustedBounds_getPhysicalSize(
                mem::transmute(self),
            ))
        }
    }
    fn get_hidpi_factor(&self) -> f32 {
        unsafe {
            mem::transmute(crate::AzHidpiAdjustedBounds_getHidpiFactor(mem::transmute(
                self,
            )))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzHidpiAdjustedBounds {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::HidpiAdjustedBounds = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineText {
    #[new]
    fn __new__(
        lines: AzInlineLineVec,
        content_size: AzLogicalSize,
        font_size_px: f32,
        last_word_index: usize,
        baseline_descender_px: f32,
    ) -> Self {
        Self {
            lines,
            content_size,
            font_size_px,
            last_word_index,
            baseline_descender_px,
        }
    }

    fn hit_test(&self, position: AzLogicalPosition) -> AzInlineTextHitVec {
        unsafe {
            mem::transmute(crate::AzInlineText_hitTest(
                mem::transmute(self),
                mem::transmute(position),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineText {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineText = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineText = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLine {
    #[new]
    fn __new__(words: AzInlineWordVec, bounds: AzLogicalRect) -> Self {
        Self { words, bounds }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineLine {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineLine = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineLine = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordEnumWrapper {
    #[classattr]
    fn Tab() -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper {
            inner: AzInlineWord::Tab,
        }
    }
    #[classattr]
    fn Return() -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper {
            inner: AzInlineWord::Return,
        }
    }
    #[classattr]
    fn Space() -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper {
            inner: AzInlineWord::Space,
        }
    }
    #[staticmethod]
    fn Word(v: AzInlineTextContents) -> AzInlineWordEnumWrapper {
        AzInlineWordEnumWrapper {
            inner: AzInlineWord::Word(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInlineWord;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineWord::Tab => Ok(vec!["Tab".into_py(py), ().into_py(py)]),
            AzInlineWord::Return => Ok(vec!["Return".into_py(py), ().into_py(py)]),
            AzInlineWord::Space => Ok(vec!["Space".into_py(py), ().into_py(py)]),
            AzInlineWord::Word(v) => Ok(vec!["Word".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineWord = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextContents {
    #[new]
    fn __new__(glyphs: AzInlineGlyphVec, bounds: AzLogicalRect) -> Self {
        Self { glyphs, bounds }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextContents {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextContents = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyph {
    #[new]
    fn __new__(
        bounds: AzLogicalRect,
        unicode_codepoint: AzOptionCharEnumWrapper,
        glyph_index: u32,
    ) -> Self {
        Self {
            bounds,
            unicode_codepoint,
            glyph_index,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyph {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineGlyph = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHit {
    #[new]
    fn __new__(
        unicode_codepoint: AzOptionCharEnumWrapper,
        hit_relative_to_inline_text: AzLogicalPosition,
        hit_relative_to_line: AzLogicalPosition,
        hit_relative_to_text_content: AzLogicalPosition,
        hit_relative_to_glyph: AzLogicalPosition,
        line_index_relative_to_text: usize,
        word_index_relative_to_text: usize,
        text_content_index_relative_to_text: usize,
        glyph_index_relative_to_text: usize,
        char_index_relative_to_text: usize,
        word_index_relative_to_line: usize,
        text_content_index_relative_to_line: usize,
        glyph_index_relative_to_line: usize,
        char_index_relative_to_line: usize,
        glyph_index_relative_to_word: usize,
        char_index_relative_to_word: usize,
    ) -> Self {
        Self {
            unicode_codepoint,
            hit_relative_to_inline_text,
            hit_relative_to_line,
            hit_relative_to_text_content,
            hit_relative_to_glyph,
            line_index_relative_to_text,
            word_index_relative_to_text,
            text_content_index_relative_to_text,
            glyph_index_relative_to_text,
            char_index_relative_to_text,
            word_index_relative_to_line,
            text_content_index_relative_to_line,
            glyph_index_relative_to_line,
            char_index_relative_to_line,
            glyph_index_relative_to_word,
            char_index_relative_to_word,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHit {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextHit = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFocusTargetEnumWrapper {
    #[staticmethod]
    fn Id(v: AzDomNodeId) -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper {
            inner: AzFocusTarget::Id(v),
        }
    }
    #[staticmethod]
    fn Path(v: AzFocusTargetPath) -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper {
            inner: AzFocusTarget::Path(v),
        }
    }
    #[classattr]
    fn Previous() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper {
            inner: AzFocusTarget::Previous,
        }
    }
    #[classattr]
    fn Next() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper {
            inner: AzFocusTarget::Next,
        }
    }
    #[classattr]
    fn First() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper {
            inner: AzFocusTarget::First,
        }
    }
    #[classattr]
    fn Last() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper {
            inner: AzFocusTarget::Last,
        }
    }
    #[classattr]
    fn NoFocus() -> AzFocusTargetEnumWrapper {
        AzFocusTargetEnumWrapper {
            inner: AzFocusTarget::NoFocus,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzFocusTarget;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFocusTarget::Id(v) => Ok(vec!["Id".into_py(py), v.clone().into_py(py)]),
            AzFocusTarget::Path(v) => Ok(vec!["Path".into_py(py), v.clone().into_py(py)]),
            AzFocusTarget::Previous => Ok(vec!["Previous".into_py(py), ().into_py(py)]),
            AzFocusTarget::Next => Ok(vec!["Next".into_py(py), ().into_py(py)]),
            AzFocusTarget::First => Ok(vec!["First".into_py(py), ().into_py(py)]),
            AzFocusTarget::Last => Ok(vec!["Last".into_py(py), ().into_py(py)]),
            AzFocusTarget::NoFocus => Ok(vec!["NoFocus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFocusTargetEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::FocusTarget = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::FocusTarget = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFocusTargetPath {
    #[new]
    fn __new__(dom: AzDomId, css_path: AzCssPath) -> Self {
        Self { dom, css_path }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFocusTargetPath {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::FocusTargetPath = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::FocusTargetPath = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScriptTypeEnumWrapper {
    #[classattr]
    fn Mixed() -> AzScriptTypeEnumWrapper {
        AzScriptTypeEnumWrapper {
            inner: AzScriptType::Mixed,
        }
    }
    #[classattr]
    fn LTR() -> AzScriptTypeEnumWrapper {
        AzScriptTypeEnumWrapper {
            inner: AzScriptType::LTR,
        }
    }
    #[classattr]
    fn RTL() -> AzScriptTypeEnumWrapper {
        AzScriptTypeEnumWrapper {
            inner: AzScriptType::RTL,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScriptTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::ScriptType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::ScriptType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzScriptTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzResolvedTextLayoutOptions {
    #[staticmethod]
    fn default() -> AzResolvedTextLayoutOptions {
        unsafe { mem::transmute(crate::AzResolvedTextLayoutOptions_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResolvedTextLayoutOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::ResolvedTextLayoutOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimation {
    #[new]
    fn __new__(
        from: AzCssPropertyEnumWrapper,
        to: AzCssPropertyEnumWrapper,
        duration: AzDurationEnumWrapper,
        repeat: AzAnimationRepeatEnumWrapper,
        repeat_count: AzAnimationRepeatCountEnumWrapper,
        easing: AzAnimationEasingEnumWrapper,
        relayout_on_finish: bool,
    ) -> Self {
        Self {
            from,
            to,
            duration,
            repeat,
            repeat_count,
            easing,
            relayout_on_finish,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimation {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::Animation = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::Animation = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimationRepeatEnumWrapper {
    #[classattr]
    fn NoRepeat() -> AzAnimationRepeatEnumWrapper {
        AzAnimationRepeatEnumWrapper {
            inner: AzAnimationRepeat::NoRepeat,
        }
    }
    #[classattr]
    fn Loop() -> AzAnimationRepeatEnumWrapper {
        AzAnimationRepeatEnumWrapper {
            inner: AzAnimationRepeat::Loop,
        }
    }
    #[classattr]
    fn PingPong() -> AzAnimationRepeatEnumWrapper {
        AzAnimationRepeatEnumWrapper {
            inner: AzAnimationRepeat::PingPong,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationRepeatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::AnimationRepeat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::AnimationRepeat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzAnimationRepeatEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzAnimationRepeatCountEnumWrapper {
    #[staticmethod]
    fn Times(v: usize) -> AzAnimationRepeatCountEnumWrapper {
        AzAnimationRepeatCountEnumWrapper {
            inner: AzAnimationRepeatCount::Times(v),
        }
    }
    #[classattr]
    fn Infinite() -> AzAnimationRepeatCountEnumWrapper {
        AzAnimationRepeatCountEnumWrapper {
            inner: AzAnimationRepeatCount::Infinite,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzAnimationRepeatCount;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationRepeatCount::Times(v) => Ok(vec!["Times".into_py(py), v.into_py(py)]),
            AzAnimationRepeatCount::Infinite => Ok(vec!["Infinite".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationRepeatCountEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::AnimationRepeatCount = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::AnimationRepeatCount = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAnimationEasingEnumWrapper {
    #[classattr]
    fn Ease() -> AzAnimationEasingEnumWrapper {
        AzAnimationEasingEnumWrapper {
            inner: AzAnimationEasing::Ease,
        }
    }
    #[classattr]
    fn Linear() -> AzAnimationEasingEnumWrapper {
        AzAnimationEasingEnumWrapper {
            inner: AzAnimationEasing::Linear,
        }
    }
    #[classattr]
    fn EaseIn() -> AzAnimationEasingEnumWrapper {
        AzAnimationEasingEnumWrapper {
            inner: AzAnimationEasing::EaseIn,
        }
    }
    #[classattr]
    fn EaseOut() -> AzAnimationEasingEnumWrapper {
        AzAnimationEasingEnumWrapper {
            inner: AzAnimationEasing::EaseOut,
        }
    }
    #[classattr]
    fn EaseInOut() -> AzAnimationEasingEnumWrapper {
        AzAnimationEasingEnumWrapper {
            inner: AzAnimationEasing::EaseInOut,
        }
    }
    #[staticmethod]
    fn CubicBezier(v: AzSvgCubicCurve) -> AzAnimationEasingEnumWrapper {
        AzAnimationEasingEnumWrapper {
            inner: AzAnimationEasing::CubicBezier(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzAnimationEasing;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationEasing::Ease => Ok(vec!["Ease".into_py(py), ().into_py(py)]),
            AzAnimationEasing::Linear => Ok(vec!["Linear".into_py(py), ().into_py(py)]),
            AzAnimationEasing::EaseIn => Ok(vec!["EaseIn".into_py(py), ().into_py(py)]),
            AzAnimationEasing::EaseOut => Ok(vec!["EaseOut".into_py(py), ().into_py(py)]),
            AzAnimationEasing::EaseInOut => Ok(vec!["EaseInOut".into_py(py), ().into_py(py)]),
            AzAnimationEasing::CubicBezier(v) => {
                Ok(vec!["CubicBezier".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationEasingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallback {}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::IFrameCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackInfo {}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::IFrameCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameCallbackReturn {
    #[new]
    fn __new__(
        dom: AzStyledDom,
        scroll_size: AzLogicalSize,
        scroll_offset: AzLogicalPosition,
        virtual_scroll_size: AzLogicalSize,
        virtual_scroll_offset: AzLogicalPosition,
    ) -> Self {
        Self {
            dom,
            scroll_size,
            scroll_offset,
            virtual_scroll_size,
            virtual_scroll_offset,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIFrameCallbackReturn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::IFrameCallbackReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRenderImageCallback {}

#[pyproto]
impl PyObjectProtocol for AzRenderImageCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RenderImageCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RenderImageCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRenderImageCallbackInfo {
    fn get_gl_context(&self) -> Option<AzGl> {
        let m: AzOptionGl = unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getGlContext(
                mem::transmute(self),
            ))
        };
        match m {
            AzOptionGl::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionGl::None => None,
        }
    }
    fn get_bounds(&self) -> AzHidpiAdjustedBounds {
        unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getBounds(mem::transmute(
                self,
            )))
        }
    }
    fn get_callback_node_id(&self) -> AzDomNodeId {
        unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getCallbackNodeId(
                mem::transmute(self),
            ))
        }
    }
    fn get_inline_text(&self, node_id: AzDomNodeId) -> Option<AzInlineText> {
        let m: AzOptionInlineText = unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getInlineText(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionInlineText::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionInlineText::None => None,
        }
    }
    fn get_index_in_parent(&mut self, node_id: AzDomNodeId) -> usize {
        unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getIndexInParent(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        }
    }
    fn get_parent(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getParent(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_previous_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getPreviousSibling(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_next_sibling(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getNextSibling(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_first_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getFirstChild(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
    fn get_last_child(&mut self, node_id: AzDomNodeId) -> Option<AzDomNodeId> {
        let m: AzOptionDomNodeId = unsafe {
            mem::transmute(crate::AzRenderImageCallbackInfo_getLastChild(
                mem::transmute(self),
                mem::transmute(node_id),
            ))
        };
        match m {
            AzOptionDomNodeId::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionDomNodeId::None => None,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRenderImageCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RenderImageCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallback {}

#[pyproto]
impl PyObjectProtocol for AzTimerCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::TimerCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::TimerCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallbackInfo {}

#[pyproto]
impl PyObjectProtocol for AzTimerCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::TimerCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerCallbackReturn {
    #[new]
    fn __new__(
        should_update: AzUpdateEnumWrapper,
        should_terminate: AzTerminateTimerEnumWrapper,
    ) -> Self {
        Self {
            should_update,
            should_terminate,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTimerCallbackReturn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::TimerCallbackReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWriteBackCallback {}

#[pyproto]
impl PyObjectProtocol for AzWriteBackCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::WriteBackCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::WriteBackCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadCallback {}

#[pyproto]
impl PyObjectProtocol for AzThreadCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::ThreadCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::ThreadCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefCount {
    fn can_be_shared(&self) -> bool {
        unsafe { mem::transmute(crate::AzRefCount_canBeShared(mem::transmute(self))) }
    }
    fn can_be_shared_mut(&self) -> bool {
        unsafe { mem::transmute(crate::AzRefCount_canBeSharedMut(mem::transmute(self))) }
    }
    fn increase_ref(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_increaseRef(mem::transmute(self))) }
    }
    fn decrease_ref(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_decreaseRef(mem::transmute(self))) }
    }
    fn increase_refmut(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_increaseRefmut(mem::transmute(self))) }
    }
    fn decrease_refmut(&mut self) -> () {
        unsafe { mem::transmute(crate::AzRefCount_decreaseRefmut(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRefCount {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RefCount = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RefCount = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefAny {
    fn get_type_id(&self) -> u64 {
        unsafe { mem::transmute(crate::AzRefAny_getTypeId(mem::transmute(self))) }
    }
    fn get_type_name(&self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzRefAny_getTypeName(mem::transmute(self)))
        })
    }
}

#[pyproto]
impl PyObjectProtocol for AzRefAny {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RefAny = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::RefAny = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutCallbackInfo {
    fn get_gl_context(&self) -> Option<AzGl> {
        let m: AzOptionGl = unsafe {
            mem::transmute(crate::AzLayoutCallbackInfo_getGlContext(mem::transmute(
                self,
            )))
        };
        match m {
            AzOptionGl::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionGl::None => None,
        }
    }
    fn get_system_fonts(&self) -> AzStringPairVec {
        unsafe {
            mem::transmute(crate::AzLayoutCallbackInfo_getSystemFonts(mem::transmute(
                self,
            )))
        }
    }
    fn get_image(&self, id: String) -> Option<AzImageRef> {
        let id = pystring_to_azstring(&id);
        let m: AzOptionImageRef = unsafe {
            mem::transmute(crate::AzLayoutCallbackInfo_getImage(
                mem::transmute(self),
                mem::transmute(id),
            ))
        };
        match m {
            AzOptionImageRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionImageRef::None => None,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutCallbackInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::LayoutCallbackInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDom {
    #[new]
    fn new(node_type: AzNodeTypeEnumWrapper) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_new(mem::transmute(node_type))) }
    }
    #[staticmethod]
    fn body() -> AzDom {
        unsafe { mem::transmute(crate::AzDom_body()) }
    }
    #[staticmethod]
    fn div() -> AzDom {
        unsafe { mem::transmute(crate::AzDom_div()) }
    }
    #[staticmethod]
    fn br() -> AzDom {
        unsafe { mem::transmute(crate::AzDom_br()) }
    }
    #[staticmethod]
    fn text(string: String) -> AzDom {
        let string = pystring_to_azstring(&string);
        unsafe { mem::transmute(crate::AzDom_text(mem::transmute(string))) }
    }
    #[staticmethod]
    fn image(image: AzImageRef) -> AzDom {
        unsafe { mem::transmute(crate::AzDom_image(mem::transmute(image))) }
    }
    fn set_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setNodeType(
                mem::transmute(self),
                mem::transmute(node_type),
            ))
        }
    }
    fn with_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withNodeType(
                mem::transmute(self),
                mem::transmute(node_type),
            ))
        }
    }
    fn set_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setIdsAndClasses(
                mem::transmute(self),
                mem::transmute(ids_and_classes),
            ))
        }
    }
    fn with_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withIdsAndClasses(
                mem::transmute(self),
                mem::transmute(ids_and_classes),
            ))
        }
    }
    fn set_callbacks(&mut self, callbacks: AzCallbackDataVec) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setCallbacks(
                mem::transmute(self),
                mem::transmute(callbacks),
            ))
        }
    }
    fn with_callbacks(&mut self, callbacks: AzCallbackDataVec) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withCallbacks(
                mem::transmute(self),
                mem::transmute(callbacks),
            ))
        }
    }
    fn set_inline_css_props(&mut self, css_properties: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setInlineCssProps(
                mem::transmute(self),
                mem::transmute(css_properties),
            ))
        }
    }
    fn with_inline_css_props(&mut self, css_properties: AzNodeDataInlineCssPropertyVec) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withInlineCssProps(
                mem::transmute(self),
                mem::transmute(css_properties),
            ))
        }
    }
    fn add_child(&mut self, child: AzDom) -> () {
        unsafe {
            mem::transmute(crate::AzDom_addChild(
                mem::transmute(self),
                mem::transmute(child),
            ))
        }
    }
    fn with_child(&mut self, child: AzDom) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withChild(
                mem::transmute(self),
                mem::transmute(child),
            ))
        }
    }
    fn set_children(&mut self, children: AzDomVec) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setChildren(
                mem::transmute(self),
                mem::transmute(children),
            ))
        }
    }
    fn with_children(&mut self, children: AzDomVec) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withChildren(
                mem::transmute(self),
                mem::transmute(children),
            ))
        }
    }
    fn add_id(&mut self, id: String) -> () {
        let id = pystring_to_azstring(&id);
        unsafe { mem::transmute(crate::AzDom_addId(mem::transmute(self), mem::transmute(id))) }
    }
    fn with_id(&mut self, id: String) -> AzDom {
        let id = pystring_to_azstring(&id);
        unsafe {
            mem::transmute(crate::AzDom_withId(
                mem::transmute(self),
                mem::transmute(id),
            ))
        }
    }
    fn add_class(&mut self, class: String) -> () {
        let class = pystring_to_azstring(&class);
        unsafe {
            mem::transmute(crate::AzDom_addClass(
                mem::transmute(self),
                mem::transmute(class),
            ))
        }
    }
    fn with_class(&mut self, class: String) -> AzDom {
        let class = pystring_to_azstring(&class);
        unsafe {
            mem::transmute(crate::AzDom_withClass(
                mem::transmute(self),
                mem::transmute(class),
            ))
        }
    }
    fn add_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzDom_addCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn with_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn add_hover_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzDom_addHoverCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn with_hover_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withHoverCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn add_active_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzDom_addActiveCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn with_active_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withActiveCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn add_focus_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzDom_addFocusCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn with_focus_css_property(&mut self, prop: AzCssPropertyEnumWrapper) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withFocusCssProperty(
                mem::transmute(self),
                mem::transmute(prop),
            ))
        }
    }
    fn set_inline_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_setInlineStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_withInlineStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_inline_hover_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_setInlineHoverStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_hover_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_withInlineHoverStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_inline_active_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_setInlineActiveStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_active_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_withInlineActiveStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_inline_focus_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_setInlineFocusStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_focus_style(&mut self, style: String) -> AzDom {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzDom_withInlineFocusStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_clip_mask(&mut self, clip_mask: AzImageMask) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setClipMask(
                mem::transmute(self),
                mem::transmute(clip_mask),
            ))
        }
    }
    fn with_clip_mask(&mut self, clip_mask: AzImageMask) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withClipMask(
                mem::transmute(self),
                mem::transmute(clip_mask),
            ))
        }
    }
    fn set_tab_index(&mut self, tab_index: AzTabIndexEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setTabIndex(
                mem::transmute(self),
                mem::transmute(tab_index),
            ))
        }
    }
    fn with_tab_index(&mut self, tab_index: AzTabIndexEnumWrapper) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withTabIndex(
                mem::transmute(self),
                mem::transmute(tab_index),
            ))
        }
    }
    fn set_accessibility_info(&mut self, accessibility_info: AzAccessibilityInfo) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setAccessibilityInfo(
                mem::transmute(self),
                mem::transmute(accessibility_info),
            ))
        }
    }
    fn with_accessibility_info(&mut self, accessibility_info: AzAccessibilityInfo) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withAccessibilityInfo(
                mem::transmute(self),
                mem::transmute(accessibility_info),
            ))
        }
    }
    fn set_menu_bar(&mut self, menu_bar: AzMenu) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setMenuBar(
                mem::transmute(self),
                mem::transmute(menu_bar),
            ))
        }
    }
    fn with_menu_bar(&mut self, menu_bar: AzMenu) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withMenuBar(
                mem::transmute(self),
                mem::transmute(menu_bar),
            ))
        }
    }
    fn set_context_menu(&mut self, context_menu: AzMenu) -> () {
        unsafe {
            mem::transmute(crate::AzDom_setContextMenu(
                mem::transmute(self),
                mem::transmute(context_menu),
            ))
        }
    }
    fn with_context_menu(&mut self, context_menu: AzMenu) -> AzDom {
        unsafe {
            mem::transmute(crate::AzDom_withContextMenu(
                mem::transmute(self),
                mem::transmute(context_menu),
            ))
        }
    }
    fn hash(&self) -> u64 {
        unsafe { mem::transmute(crate::AzDom_hash(mem::transmute(self))) }
    }
    fn node_count(&self) -> usize {
        unsafe { mem::transmute(crate::AzDom_nodeCount(mem::transmute(self))) }
    }
    fn get_html_string(&mut self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzDom_getHtmlString(mem::transmute(self)))
        })
    }
    fn get_html_string_test(&mut self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzDom_getHtmlStringTest(mem::transmute(self)))
        })
    }
    fn style(&mut self, css: AzCss) -> AzStyledDom {
        unsafe {
            mem::transmute(crate::AzDom_style(
                mem::transmute(self),
                mem::transmute(css),
            ))
        }
    }
    // impl Dom {
    // data: RefAny, callback: IFrameCallbackType) -> Self {

    #[staticmethod]
    fn iframe(py: Python, data: PyObject, callback: PyObject) -> Result<Self, PyErr> {
        // RefAny<IFrameCallbackTy>

        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in Dom.iframe: - argument \"data\" is a function callback, expected class"
            )));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!(
                "ERROR in Dom.iframe: - argument \"callback\" is of type \"{}\", expected function",
                type_name
            )));
        }

        let iframe_refany = azul_impl::callbacks::RefAny::new(IFrameCallbackTy {
            _py_iframe_data: Some(data),
            _py_iframe_callback: Some(callback),
        });

        Ok(unsafe { mem::transmute(crate::AzDom_iframe(iframe_refany, invoke_python_iframe)) })
    }

    fn set_dataset(&mut self, py: Python, dataset: PyObject) -> Result<(), PyErr> {
        // RefAny<DatasetTy>
        use pyo3::type_object::PyTypeInfo;

        if dataset.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in Dom.set_dataset: - argument \"dataset\" is a function callback, \
                 expected class"
            )));
        }

        let dataset_refany = azul_impl::callbacks::RefAny::new(DatasetTy {
            _py_data: Some(dataset),
        });

        crate::AzDom_setDataset(unsafe { mem::transmute(self) }, dataset_refany);

        Ok(())
    }

    fn with_dataset(&mut self, py: Python, dataset: PyObject) -> Result<Self, PyErr> {
        // RefAny<DatasetTy>
        self.set_dataset(py, dataset)?;
        let d: &mut azul_impl::dom::Dom = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }

    fn add_callback(
        &mut self,
        py: Python,
        event: AzEventFilterEnumWrapper,
        data: PyObject,
        callback: PyObject,
    ) -> Result<(), PyErr> {
        // RefAny<CallbackTy>
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in Dom.add_callback: - argument \"data\" is a function callback, expected \
                 class"
            )));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!(
                "ERROR in Dom.add_callback: - argument \"callback\" is of type \"{}\", expected \
                 function",
                type_name
            )));
        }

        let callback_refany = azul_impl::callbacks::RefAny::new(CallbackTy {
            _py_callback: Some(callback),
            _py_data: Some(data),
        });

        unsafe {
            crate::AzDom_addCallback(
                mem::transmute(self),
                mem::transmute(event),
                callback_refany,
                invoke_python_callback,
            );
        }

        Ok(())
    }

    fn with_callback(
        &mut self,
        py: Python,
        event: AzEventFilterEnumWrapper,
        data: PyObject,
        callback: PyObject,
    ) -> Result<Self, PyErr> {
        // RefAny<CallbackTy>
        self.add_callback(py, event, data, callback)?;
        let d: &mut azul_impl::dom::Dom = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzDom {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::Dom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::Dom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIFrameNode {
    #[new]
    fn __new__(callback: AzIFrameCallback, data: AzRefAny) -> Self {
        Self { callback, data }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIFrameNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IFrameNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackData {
    #[new]
    fn __new__(event: AzEventFilterEnumWrapper, callback: AzCallback, data: AzRefAny) -> Self {
        Self {
            event,
            callback,
            data,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCallbackData {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::CallbackData = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::CallbackData = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeData {
    #[new]
    fn new(node_type: AzNodeTypeEnumWrapper) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_new(mem::transmute(node_type))) }
    }
    #[staticmethod]
    fn body() -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_body()) }
    }
    #[staticmethod]
    fn div() -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_div()) }
    }
    #[staticmethod]
    fn br() -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_br()) }
    }
    #[staticmethod]
    fn text(string: String) -> AzNodeData {
        let string = pystring_to_azstring(&string);
        unsafe { mem::transmute(crate::AzNodeData_text(mem::transmute(string))) }
    }
    #[staticmethod]
    fn image(image: AzImageRef) -> AzNodeData {
        unsafe { mem::transmute(crate::AzNodeData_image(mem::transmute(image))) }
    }
    fn set_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setNodeType(
                mem::transmute(self),
                mem::transmute(node_type),
            ))
        }
    }
    fn with_node_type(&mut self, node_type: AzNodeTypeEnumWrapper) -> AzNodeData {
        unsafe {
            mem::transmute(crate::AzNodeData_withNodeType(
                mem::transmute(self),
                mem::transmute(node_type),
            ))
        }
    }
    fn set_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setIdsAndClasses(
                mem::transmute(self),
                mem::transmute(ids_and_classes),
            ))
        }
    }
    fn with_ids_and_classes(&mut self, ids_and_classes: AzIdOrClassVec) -> AzNodeData {
        unsafe {
            mem::transmute(crate::AzNodeData_withIdsAndClasses(
                mem::transmute(self),
                mem::transmute(ids_and_classes),
            ))
        }
    }
    fn set_callbacks(&mut self, callbacks: AzCallbackDataVec) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setCallbacks(
                mem::transmute(self),
                mem::transmute(callbacks),
            ))
        }
    }
    fn with_callbacks(&mut self, callbacks: AzCallbackDataVec) -> AzNodeData {
        unsafe {
            mem::transmute(crate::AzNodeData_withCallbacks(
                mem::transmute(self),
                mem::transmute(callbacks),
            ))
        }
    }
    fn set_inline_css_props(&mut self, css_properties: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setInlineCssProps(
                mem::transmute(self),
                mem::transmute(css_properties),
            ))
        }
    }
    fn with_inline_css_props(
        &mut self,
        css_properties: AzNodeDataInlineCssPropertyVec,
    ) -> AzNodeData {
        unsafe {
            mem::transmute(crate::AzNodeData_withInlineCssProps(
                mem::transmute(self),
                mem::transmute(css_properties),
            ))
        }
    }
    fn set_inline_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_setInlineStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_withInlineStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_inline_hover_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_setInlineHoverStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_hover_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_withInlineHoverStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_inline_active_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_setInlineActiveStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_active_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_withInlineActiveStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_inline_focus_style(&mut self, style: String) -> () {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_setInlineFocusStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_inline_focus_style(&mut self, style: String) -> AzNodeData {
        let style = pystring_to_azstring(&style);
        unsafe {
            mem::transmute(crate::AzNodeData_withInlineFocusStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_clip_mask(&mut self, image_mask: AzImageMask) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setClipMask(
                mem::transmute(self),
                mem::transmute(image_mask),
            ))
        }
    }
    fn set_tab_index(&mut self, tab_index: AzTabIndexEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setTabIndex(
                mem::transmute(self),
                mem::transmute(tab_index),
            ))
        }
    }
    fn set_accessibility_info(&mut self, accessibility_info: AzAccessibilityInfo) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setAccessibilityInfo(
                mem::transmute(self),
                mem::transmute(accessibility_info),
            ))
        }
    }
    fn set_menu_bar(&mut self, menu_bar: AzMenu) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setMenuBar(
                mem::transmute(self),
                mem::transmute(menu_bar),
            ))
        }
    }
    fn set_context_menu(&mut self, context_menu: AzMenu) -> () {
        unsafe {
            mem::transmute(crate::AzNodeData_setContextMenu(
                mem::transmute(self),
                mem::transmute(context_menu),
            ))
        }
    }
    fn hash(&self) -> u64 {
        unsafe { mem::transmute(crate::AzNodeData_hash(mem::transmute(self))) }
    }
    // impl NodeData {

    #[staticmethod]
    fn iframe(py: Python, data: PyObject, callback: PyObject) -> Result<Self, PyErr> {
        // RefAny<IFrameCallbackTy>

        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in Dom.iframe: - argument \"data\" is a function callback, expected class"
            )));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!(
                "ERROR in Dom.iframe: - argument \"callback\" is of type \"{}\", expected function",
                type_name
            )));
        }

        let iframe_refany = azul_impl::callbacks::RefAny::new(IFrameCallbackTy {
            _py_iframe_data: Some(data),
            _py_iframe_callback: Some(callback),
        });

        Ok(unsafe {
            mem::transmute(crate::AzNodeData_iframe(
                iframe_refany,
                invoke_python_iframe,
            ))
        })
    }

    fn set_dataset(&mut self, py: Python, dataset: PyObject) -> Result<(), PyErr> {
        // RefAny<DatasetTy>
        use pyo3::type_object::PyTypeInfo;

        if dataset.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in Dom.set_dataset: - argument \"dataset\" is a function callback, \
                 expected class"
            )));
        }

        let dataset_refany = azul_impl::callbacks::RefAny::new(DatasetTy {
            _py_data: Some(dataset),
        });

        crate::AzNodeData_setDataset(unsafe { mem::transmute(self) }, dataset_refany);

        Ok(())
    }

    fn with_dataset(&mut self, py: Python, dataset: PyObject) -> Result<Self, PyErr> {
        // RefAny<DatasetTy>
        self.set_dataset(py, dataset)?;
        let d: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }

    fn add_callback(
        &mut self,
        py: Python,
        event: AzEventFilterEnumWrapper,
        data: PyObject,
        callback: PyObject,
    ) -> Result<(), PyErr> {
        // RefAny<CallbackTy>
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in Dom.add_callback: - argument \"data\" is a function callback, expected \
                 class"
            )));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!(
                "ERROR in Dom.add_callback: - argument \"callback\" is of type \"{}\", expected \
                 function",
                type_name
            )));
        }

        let callback_refany = azul_impl::callbacks::RefAny::new(CallbackTy {
            _py_callback: Some(callback),
            _py_data: Some(data),
        });

        unsafe {
            crate::AzNodeData_addCallback(
                mem::transmute(self),
                mem::transmute(event),
                callback_refany,
                invoke_python_callback,
            );
        }

        Ok(())
    }

    fn with_callback(
        &mut self,
        py: Python,
        event: AzEventFilterEnumWrapper,
        data: PyObject,
        callback: PyObject,
    ) -> Result<Self, PyErr> {
        // RefAny<CallbackTy>
        self.add_callback(py, event, data, callback)?;
        let d: &mut azul_impl::dom::NodeData = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeData {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeData = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeData = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeEnumWrapper {
    #[classattr]
    fn Body() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper {
            inner: AzNodeType::Body,
        }
    }
    #[classattr]
    fn Div() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper {
            inner: AzNodeType::Div,
        }
    }
    #[classattr]
    fn Br() -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper {
            inner: AzNodeType::Br,
        }
    }
    #[staticmethod]
    fn Text(v: AzString) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper {
            inner: AzNodeType::Text(v),
        }
    }
    #[staticmethod]
    fn Image(v: AzImageRef) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper {
            inner: AzNodeType::Image(v),
        }
    }
    #[staticmethod]
    fn IFrame(v: AzIFrameNode) -> AzNodeTypeEnumWrapper {
        AzNodeTypeEnumWrapper {
            inner: AzNodeType::IFrame(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeType;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeType::Body => Ok(vec!["Body".into_py(py), ().into_py(py)]),
            AzNodeType::Div => Ok(vec!["Div".into_py(py), ().into_py(py)]),
            AzNodeType::Br => Ok(vec!["Br".into_py(py), ().into_py(py)]),
            AzNodeType::Text(v) => Ok(vec!["Text".into_py(py), v.clone().into_py(py)]),
            AzNodeType::Image(v) => Ok(vec!["Image".into_py(py), v.clone().into_py(py)]),
            AzNodeType::IFrame(v) => Ok(vec!["IFrame".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::MouseOver,
        }
    }
    #[classattr]
    fn MouseDown() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::MouseDown,
        }
    }
    #[classattr]
    fn LeftMouseDown() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::LeftMouseDown,
        }
    }
    #[classattr]
    fn MiddleMouseDown() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::MiddleMouseDown,
        }
    }
    #[classattr]
    fn RightMouseDown() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::RightMouseDown,
        }
    }
    #[classattr]
    fn MouseUp() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::MouseUp,
        }
    }
    #[classattr]
    fn LeftMouseUp() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::LeftMouseUp,
        }
    }
    #[classattr]
    fn MiddleMouseUp() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::MiddleMouseUp,
        }
    }
    #[classattr]
    fn RightMouseUp() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::RightMouseUp,
        }
    }
    #[classattr]
    fn MouseEnter() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::MouseEnter,
        }
    }
    #[classattr]
    fn MouseLeave() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::MouseLeave,
        }
    }
    #[classattr]
    fn Scroll() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::Scroll,
        }
    }
    #[classattr]
    fn TextInput() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::TextInput,
        }
    }
    #[classattr]
    fn VirtualKeyDown() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::VirtualKeyDown,
        }
    }
    #[classattr]
    fn VirtualKeyUp() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::VirtualKeyUp,
        }
    }
    #[classattr]
    fn HoveredFile() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::HoveredFile,
        }
    }
    #[classattr]
    fn DroppedFile() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::DroppedFile,
        }
    }
    #[classattr]
    fn HoveredFileCancelled() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::HoveredFileCancelled,
        }
    }
    #[classattr]
    fn FocusReceived() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::FocusReceived,
        }
    }
    #[classattr]
    fn FocusLost() -> AzOnEnumWrapper {
        AzOnEnumWrapper {
            inner: AzOn::FocusLost,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOnEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::On = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::On = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzOnEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: AzHoverEventFilterEnumWrapper) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper {
            inner: AzEventFilter::Hover(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Not(v: AzNotEventFilterEnumWrapper) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper {
            inner: AzEventFilter::Not(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Focus(v: AzFocusEventFilterEnumWrapper) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper {
            inner: AzEventFilter::Focus(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Window(v: AzWindowEventFilterEnumWrapper) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper {
            inner: AzEventFilter::Window(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Component(v: AzComponentEventFilterEnumWrapper) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper {
            inner: AzEventFilter::Component(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Application(v: AzApplicationEventFilterEnumWrapper) -> AzEventFilterEnumWrapper {
        AzEventFilterEnumWrapper {
            inner: AzEventFilter::Application(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzEventFilter;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzEventFilter::Hover(v) => Ok(vec![
                "Hover".into_py(py),
                {
                    let m: &AzHoverEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzEventFilter::Not(v) => Ok(vec![
                "Not".into_py(py),
                {
                    let m: &AzNotEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzEventFilter::Focus(v) => Ok(vec![
                "Focus".into_py(py),
                {
                    let m: &AzFocusEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzEventFilter::Window(v) => Ok(vec![
                "Window".into_py(py),
                {
                    let m: &AzWindowEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzEventFilter::Component(v) => Ok(vec![
                "Component".into_py(py),
                {
                    let m: &AzComponentEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzEventFilter::Application(v) => Ok(vec![
                "Application".into_py(py),
                {
                    let m: &AzApplicationEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::EventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::EventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzHoverEventFilterEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::MouseOver,
        }
    }
    #[classattr]
    fn MouseDown() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::MouseDown,
        }
    }
    #[classattr]
    fn LeftMouseDown() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::LeftMouseDown,
        }
    }
    #[classattr]
    fn RightMouseDown() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::RightMouseDown,
        }
    }
    #[classattr]
    fn MiddleMouseDown() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::MiddleMouseDown,
        }
    }
    #[classattr]
    fn MouseUp() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::MouseUp,
        }
    }
    #[classattr]
    fn LeftMouseUp() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::LeftMouseUp,
        }
    }
    #[classattr]
    fn RightMouseUp() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::RightMouseUp,
        }
    }
    #[classattr]
    fn MiddleMouseUp() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::MiddleMouseUp,
        }
    }
    #[classattr]
    fn MouseEnter() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::MouseEnter,
        }
    }
    #[classattr]
    fn MouseLeave() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::MouseLeave,
        }
    }
    #[classattr]
    fn Scroll() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::Scroll,
        }
    }
    #[classattr]
    fn ScrollStart() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::ScrollStart,
        }
    }
    #[classattr]
    fn ScrollEnd() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::ScrollEnd,
        }
    }
    #[classattr]
    fn TextInput() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::TextInput,
        }
    }
    #[classattr]
    fn VirtualKeyDown() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::VirtualKeyDown,
        }
    }
    #[classattr]
    fn VirtualKeyUp() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::VirtualKeyUp,
        }
    }
    #[classattr]
    fn HoveredFile() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::HoveredFile,
        }
    }
    #[classattr]
    fn DroppedFile() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::DroppedFile,
        }
    }
    #[classattr]
    fn HoveredFileCancelled() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::HoveredFileCancelled,
        }
    }
    #[classattr]
    fn TouchStart() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::TouchStart,
        }
    }
    #[classattr]
    fn TouchMove() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::TouchMove,
        }
    }
    #[classattr]
    fn TouchEnd() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::TouchEnd,
        }
    }
    #[classattr]
    fn TouchCancel() -> AzHoverEventFilterEnumWrapper {
        AzHoverEventFilterEnumWrapper {
            inner: AzHoverEventFilter::TouchCancel,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzHoverEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::HoverEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::HoverEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzHoverEventFilterEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzFocusEventFilterEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::MouseOver,
        }
    }
    #[classattr]
    fn MouseDown() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::MouseDown,
        }
    }
    #[classattr]
    fn LeftMouseDown() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::LeftMouseDown,
        }
    }
    #[classattr]
    fn RightMouseDown() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::RightMouseDown,
        }
    }
    #[classattr]
    fn MiddleMouseDown() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::MiddleMouseDown,
        }
    }
    #[classattr]
    fn MouseUp() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::MouseUp,
        }
    }
    #[classattr]
    fn LeftMouseUp() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::LeftMouseUp,
        }
    }
    #[classattr]
    fn RightMouseUp() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::RightMouseUp,
        }
    }
    #[classattr]
    fn MiddleMouseUp() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::MiddleMouseUp,
        }
    }
    #[classattr]
    fn MouseEnter() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::MouseEnter,
        }
    }
    #[classattr]
    fn MouseLeave() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::MouseLeave,
        }
    }
    #[classattr]
    fn Scroll() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::Scroll,
        }
    }
    #[classattr]
    fn ScrollStart() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::ScrollStart,
        }
    }
    #[classattr]
    fn ScrollEnd() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::ScrollEnd,
        }
    }
    #[classattr]
    fn TextInput() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::TextInput,
        }
    }
    #[classattr]
    fn VirtualKeyDown() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::VirtualKeyDown,
        }
    }
    #[classattr]
    fn VirtualKeyUp() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::VirtualKeyUp,
        }
    }
    #[classattr]
    fn FocusReceived() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::FocusReceived,
        }
    }
    #[classattr]
    fn FocusLost() -> AzFocusEventFilterEnumWrapper {
        AzFocusEventFilterEnumWrapper {
            inner: AzFocusEventFilter::FocusLost,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFocusEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::FocusEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::FocusEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzFocusEventFilterEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzNotEventFilterEnumWrapper {
    #[staticmethod]
    fn Hover(v: AzHoverEventFilterEnumWrapper) -> AzNotEventFilterEnumWrapper {
        AzNotEventFilterEnumWrapper {
            inner: AzNotEventFilter::Hover(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Focus(v: AzFocusEventFilterEnumWrapper) -> AzNotEventFilterEnumWrapper {
        AzNotEventFilterEnumWrapper {
            inner: AzNotEventFilter::Focus(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNotEventFilter;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNotEventFilter::Hover(v) => Ok(vec![
                "Hover".into_py(py),
                {
                    let m: &AzHoverEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzNotEventFilter::Focus(v) => Ok(vec![
                "Focus".into_py(py),
                {
                    let m: &AzFocusEventFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNotEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NotEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NotEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzWindowEventFilterEnumWrapper {
    #[classattr]
    fn MouseOver() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::MouseOver,
        }
    }
    #[classattr]
    fn MouseDown() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::MouseDown,
        }
    }
    #[classattr]
    fn LeftMouseDown() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::LeftMouseDown,
        }
    }
    #[classattr]
    fn RightMouseDown() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::RightMouseDown,
        }
    }
    #[classattr]
    fn MiddleMouseDown() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::MiddleMouseDown,
        }
    }
    #[classattr]
    fn MouseUp() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::MouseUp,
        }
    }
    #[classattr]
    fn LeftMouseUp() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::LeftMouseUp,
        }
    }
    #[classattr]
    fn RightMouseUp() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::RightMouseUp,
        }
    }
    #[classattr]
    fn MiddleMouseUp() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::MiddleMouseUp,
        }
    }
    #[classattr]
    fn MouseEnter() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::MouseEnter,
        }
    }
    #[classattr]
    fn MouseLeave() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::MouseLeave,
        }
    }
    #[classattr]
    fn Scroll() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::Scroll,
        }
    }
    #[classattr]
    fn ScrollStart() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::ScrollStart,
        }
    }
    #[classattr]
    fn ScrollEnd() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::ScrollEnd,
        }
    }
    #[classattr]
    fn TextInput() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::TextInput,
        }
    }
    #[classattr]
    fn VirtualKeyDown() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::VirtualKeyDown,
        }
    }
    #[classattr]
    fn VirtualKeyUp() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::VirtualKeyUp,
        }
    }
    #[classattr]
    fn HoveredFile() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::HoveredFile,
        }
    }
    #[classattr]
    fn DroppedFile() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::DroppedFile,
        }
    }
    #[classattr]
    fn HoveredFileCancelled() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::HoveredFileCancelled,
        }
    }
    #[classattr]
    fn Resized() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::Resized,
        }
    }
    #[classattr]
    fn Moved() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::Moved,
        }
    }
    #[classattr]
    fn TouchStart() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::TouchStart,
        }
    }
    #[classattr]
    fn TouchMove() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::TouchMove,
        }
    }
    #[classattr]
    fn TouchEnd() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::TouchEnd,
        }
    }
    #[classattr]
    fn TouchCancel() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::TouchCancel,
        }
    }
    #[classattr]
    fn FocusReceived() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::FocusReceived,
        }
    }
    #[classattr]
    fn FocusLost() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::FocusLost,
        }
    }
    #[classattr]
    fn CloseRequested() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::CloseRequested,
        }
    }
    #[classattr]
    fn ThemeChanged() -> AzWindowEventFilterEnumWrapper {
        AzWindowEventFilterEnumWrapper {
            inner: AzWindowEventFilter::ThemeChanged,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzWindowEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::WindowEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::WindowEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzWindowEventFilterEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzComponentEventFilterEnumWrapper {
    #[classattr]
    fn AfterMount() -> AzComponentEventFilterEnumWrapper {
        AzComponentEventFilterEnumWrapper {
            inner: AzComponentEventFilter::AfterMount,
        }
    }
    #[classattr]
    fn BeforeUnmount() -> AzComponentEventFilterEnumWrapper {
        AzComponentEventFilterEnumWrapper {
            inner: AzComponentEventFilter::BeforeUnmount,
        }
    }
    #[classattr]
    fn NodeResized() -> AzComponentEventFilterEnumWrapper {
        AzComponentEventFilterEnumWrapper {
            inner: AzComponentEventFilter::NodeResized,
        }
    }
    #[classattr]
    fn DefaultAction() -> AzComponentEventFilterEnumWrapper {
        AzComponentEventFilterEnumWrapper {
            inner: AzComponentEventFilter::DefaultAction,
        }
    }
    #[classattr]
    fn Selected() -> AzComponentEventFilterEnumWrapper {
        AzComponentEventFilterEnumWrapper {
            inner: AzComponentEventFilter::Selected,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzComponentEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::ComponentEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::ComponentEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzComponentEventFilterEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzApplicationEventFilterEnumWrapper {
    #[classattr]
    fn DeviceConnected() -> AzApplicationEventFilterEnumWrapper {
        AzApplicationEventFilterEnumWrapper {
            inner: AzApplicationEventFilter::DeviceConnected,
        }
    }
    #[classattr]
    fn DeviceDisconnected() -> AzApplicationEventFilterEnumWrapper {
        AzApplicationEventFilterEnumWrapper {
            inner: AzApplicationEventFilter::DeviceDisconnected,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzApplicationEventFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::ApplicationEventFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzApplicationEventFilterEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzAccessibilityInfo {
    #[new]
    fn __new__(
        name: AzOptionStringEnumWrapper,
        value: AzOptionStringEnumWrapper,
        role: AzAccessibilityRoleEnumWrapper,
        states: AzAccessibilityStateVec,
        accelerator: AzOptionVirtualKeyCodeComboEnumWrapper,
        default_action: AzOptionStringEnumWrapper,
    ) -> Self {
        Self {
            name,
            value,
            role,
            states,
            accelerator,
            default_action,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityRoleEnumWrapper {
    #[classattr]
    fn TitleBar() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::TitleBar,
        }
    }
    #[classattr]
    fn MenuBar() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::MenuBar,
        }
    }
    #[classattr]
    fn ScrollBar() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ScrollBar,
        }
    }
    #[classattr]
    fn Grip() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Grip,
        }
    }
    #[classattr]
    fn Sound() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Sound,
        }
    }
    #[classattr]
    fn Cursor() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Cursor,
        }
    }
    #[classattr]
    fn Caret() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Caret,
        }
    }
    #[classattr]
    fn Alert() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Alert,
        }
    }
    #[classattr]
    fn Window() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Window,
        }
    }
    #[classattr]
    fn Client() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Client,
        }
    }
    #[classattr]
    fn MenuPopup() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::MenuPopup,
        }
    }
    #[classattr]
    fn MenuItem() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::MenuItem,
        }
    }
    #[classattr]
    fn Tooltip() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Tooltip,
        }
    }
    #[classattr]
    fn Application() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Application,
        }
    }
    #[classattr]
    fn Document() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Document,
        }
    }
    #[classattr]
    fn Pane() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Pane,
        }
    }
    #[classattr]
    fn Chart() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Chart,
        }
    }
    #[classattr]
    fn Dialog() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Dialog,
        }
    }
    #[classattr]
    fn Border() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Border,
        }
    }
    #[classattr]
    fn Grouping() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Grouping,
        }
    }
    #[classattr]
    fn Separator() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Separator,
        }
    }
    #[classattr]
    fn Toolbar() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Toolbar,
        }
    }
    #[classattr]
    fn StatusBar() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::StatusBar,
        }
    }
    #[classattr]
    fn Table() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Table,
        }
    }
    #[classattr]
    fn ColumnHeader() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ColumnHeader,
        }
    }
    #[classattr]
    fn RowHeader() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::RowHeader,
        }
    }
    #[classattr]
    fn Column() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Column,
        }
    }
    #[classattr]
    fn Row() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Row,
        }
    }
    #[classattr]
    fn Cell() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Cell,
        }
    }
    #[classattr]
    fn Link() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Link,
        }
    }
    #[classattr]
    fn HelpBalloon() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::HelpBalloon,
        }
    }
    #[classattr]
    fn Character() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Character,
        }
    }
    #[classattr]
    fn List() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::List,
        }
    }
    #[classattr]
    fn ListItem() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ListItem,
        }
    }
    #[classattr]
    fn Outline() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Outline,
        }
    }
    #[classattr]
    fn OutlineItem() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::OutlineItem,
        }
    }
    #[classattr]
    fn Pagetab() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Pagetab,
        }
    }
    #[classattr]
    fn PropertyPage() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::PropertyPage,
        }
    }
    #[classattr]
    fn Indicator() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Indicator,
        }
    }
    #[classattr]
    fn Graphic() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Graphic,
        }
    }
    #[classattr]
    fn StaticText() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::StaticText,
        }
    }
    #[classattr]
    fn Text() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Text,
        }
    }
    #[classattr]
    fn PushButton() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::PushButton,
        }
    }
    #[classattr]
    fn CheckButton() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::CheckButton,
        }
    }
    #[classattr]
    fn RadioButton() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::RadioButton,
        }
    }
    #[classattr]
    fn ComboBox() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ComboBox,
        }
    }
    #[classattr]
    fn DropList() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::DropList,
        }
    }
    #[classattr]
    fn ProgressBar() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ProgressBar,
        }
    }
    #[classattr]
    fn Dial() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Dial,
        }
    }
    #[classattr]
    fn HotkeyField() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::HotkeyField,
        }
    }
    #[classattr]
    fn Slider() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Slider,
        }
    }
    #[classattr]
    fn SpinButton() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::SpinButton,
        }
    }
    #[classattr]
    fn Diagram() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Diagram,
        }
    }
    #[classattr]
    fn Animation() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Animation,
        }
    }
    #[classattr]
    fn Equation() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Equation,
        }
    }
    #[classattr]
    fn ButtonDropdown() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ButtonDropdown,
        }
    }
    #[classattr]
    fn ButtonMenu() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ButtonMenu,
        }
    }
    #[classattr]
    fn ButtonDropdownGrid() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::ButtonDropdownGrid,
        }
    }
    #[classattr]
    fn Whitespace() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Whitespace,
        }
    }
    #[classattr]
    fn PageTabList() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::PageTabList,
        }
    }
    #[classattr]
    fn Clock() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Clock,
        }
    }
    #[classattr]
    fn SplitButton() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::SplitButton,
        }
    }
    #[classattr]
    fn IpAddress() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::IpAddress,
        }
    }
    #[classattr]
    fn Nothing() -> AzAccessibilityRoleEnumWrapper {
        AzAccessibilityRoleEnumWrapper {
            inner: AzAccessibilityRole::Nothing,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityRoleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityRole = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzAccessibilityRoleEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzAccessibilityStateEnumWrapper {
    #[classattr]
    fn Unavailable() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Unavailable,
        }
    }
    #[classattr]
    fn Selected() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Selected,
        }
    }
    #[classattr]
    fn Focused() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Focused,
        }
    }
    #[classattr]
    fn Checked() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Checked,
        }
    }
    #[classattr]
    fn Readonly() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Readonly,
        }
    }
    #[classattr]
    fn Default() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Default,
        }
    }
    #[classattr]
    fn Expanded() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Expanded,
        }
    }
    #[classattr]
    fn Collapsed() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Collapsed,
        }
    }
    #[classattr]
    fn Busy() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Busy,
        }
    }
    #[classattr]
    fn Offscreen() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Offscreen,
        }
    }
    #[classattr]
    fn Focusable() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Focusable,
        }
    }
    #[classattr]
    fn Selectable() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Selectable,
        }
    }
    #[classattr]
    fn Linked() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Linked,
        }
    }
    #[classattr]
    fn Traversed() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Traversed,
        }
    }
    #[classattr]
    fn Multiselectable() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Multiselectable,
        }
    }
    #[classattr]
    fn Protected() -> AzAccessibilityStateEnumWrapper {
        AzAccessibilityStateEnumWrapper {
            inner: AzAccessibilityState::Protected,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzAccessibilityStateEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzTabIndexEnumWrapper {
    #[classattr]
    fn Auto() -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper {
            inner: AzTabIndex::Auto,
        }
    }
    #[staticmethod]
    fn OverrideInParent(v: u32) -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper {
            inner: AzTabIndex::OverrideInParent(v),
        }
    }
    #[classattr]
    fn NoKeyboardFocus() -> AzTabIndexEnumWrapper {
        AzTabIndexEnumWrapper {
            inner: AzTabIndex::NoKeyboardFocus,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzTabIndex;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTabIndex::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzTabIndex::OverrideInParent(v) => {
                Ok(vec!["OverrideInParent".into_py(py), v.into_py(py)])
            }
            AzTabIndex::NoKeyboardFocus => Ok(vec!["NoKeyboardFocus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::TabIndex = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassEnumWrapper {
    #[staticmethod]
    fn Id(v: AzString) -> AzIdOrClassEnumWrapper {
        AzIdOrClassEnumWrapper {
            inner: AzIdOrClass::Id(v),
        }
    }
    #[staticmethod]
    fn Class(v: AzString) -> AzIdOrClassEnumWrapper {
        AzIdOrClassEnumWrapper {
            inner: AzIdOrClass::Class(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzIdOrClass;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClass::Id(v) => Ok(vec!["Id".into_py(py), v.clone().into_py(py)]),
            AzIdOrClass::Class(v) => Ok(vec!["Class".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IdOrClass = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyEnumWrapper {
    #[staticmethod]
    fn Normal(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper {
            inner: AzNodeDataInlineCssProperty::Normal(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Active(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper {
            inner: AzNodeDataInlineCssProperty::Active(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Focus(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper {
            inner: AzNodeDataInlineCssProperty::Focus(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Hover(v: AzCssPropertyEnumWrapper) -> AzNodeDataInlineCssPropertyEnumWrapper {
        AzNodeDataInlineCssPropertyEnumWrapper {
            inner: AzNodeDataInlineCssProperty::Hover(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeDataInlineCssProperty;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssProperty::Normal(v) => Ok(vec![
                "Normal".into_py(py),
                {
                    let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzNodeDataInlineCssProperty::Active(v) => Ok(vec![
                "Active".into_py(py),
                {
                    let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzNodeDataInlineCssProperty::Focus(v) => Ok(vec![
                "Focus".into_py(py),
                {
                    let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzNodeDataInlineCssProperty::Hover(v) => Ok(vec![
                "Hover".into_py(py),
                {
                    let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataInlineCssProperty = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenu {
    #[new]
    fn new(items: AzMenuItemVec) -> AzMenu {
        unsafe { mem::transmute(crate::AzMenu_new(mem::transmute(items))) }
    }
    fn set_popup_position(&mut self, position: AzMenuPopupPositionEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzMenu_setPopupPosition(
                mem::transmute(self),
                mem::transmute(position),
            ))
        }
    }
    fn with_popup_position(&mut self, position: AzMenuPopupPositionEnumWrapper) -> AzMenu {
        unsafe {
            mem::transmute(crate::AzMenu_withPopupPosition(
                mem::transmute(self),
                mem::transmute(position),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenu {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Menu = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::Menu = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzContextMenuMouseButtonEnumWrapper {
    #[classattr]
    fn Right() -> AzContextMenuMouseButtonEnumWrapper {
        AzContextMenuMouseButtonEnumWrapper {
            inner: AzContextMenuMouseButton::Right,
        }
    }
    #[classattr]
    fn Middle() -> AzContextMenuMouseButtonEnumWrapper {
        AzContextMenuMouseButtonEnumWrapper {
            inner: AzContextMenuMouseButton::Middle,
        }
    }
    #[classattr]
    fn Left() -> AzContextMenuMouseButtonEnumWrapper {
        AzContextMenuMouseButtonEnumWrapper {
            inner: AzContextMenuMouseButton::Left,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzContextMenuMouseButtonEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ContextMenuMouseButton = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzContextMenuMouseButtonEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzMenuPopupPositionEnumWrapper {
    #[classattr]
    fn BottomLeftOfCursor() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::BottomLeftOfCursor,
        }
    }
    #[classattr]
    fn BottomRightOfCursor() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::BottomRightOfCursor,
        }
    }
    #[classattr]
    fn TopLeftOfCursor() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::TopLeftOfCursor,
        }
    }
    #[classattr]
    fn TopRightOfCursor() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::TopRightOfCursor,
        }
    }
    #[classattr]
    fn BottomOfHitRect() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::BottomOfHitRect,
        }
    }
    #[classattr]
    fn LeftOfHitRect() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::LeftOfHitRect,
        }
    }
    #[classattr]
    fn TopOfHitRect() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::TopOfHitRect,
        }
    }
    #[classattr]
    fn RightOfHitRect() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::RightOfHitRect,
        }
    }
    #[classattr]
    fn AutoCursor() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::AutoCursor,
        }
    }
    #[classattr]
    fn AutoHitRect() -> AzMenuPopupPositionEnumWrapper {
        AzMenuPopupPositionEnumWrapper {
            inner: AzMenuPopupPosition::AutoHitRect,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuPopupPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuPopupPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuPopupPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzMenuPopupPositionEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzMenuItemEnumWrapper {
    #[staticmethod]
    fn String(v: AzStringMenuItem) -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper {
            inner: AzMenuItem::String(v),
        }
    }
    #[classattr]
    fn Separator() -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper {
            inner: AzMenuItem::Separator,
        }
    }
    #[classattr]
    fn BreakLine() -> AzMenuItemEnumWrapper {
        AzMenuItemEnumWrapper {
            inner: AzMenuItem::BreakLine,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzMenuItem;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItem::String(v) => Ok(vec!["String".into_py(py), v.clone().into_py(py)]),
            AzMenuItem::Separator => Ok(vec!["Separator".into_py(py), ().into_py(py)]),
            AzMenuItem::BreakLine => Ok(vec!["BreakLine".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItem = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItem = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringMenuItem {
    #[new]
    fn new(label: String) -> AzStringMenuItem {
        let label = pystring_to_azstring(&label);
        unsafe { mem::transmute(crate::AzStringMenuItem_new(mem::transmute(label))) }
    }
    fn add_child(&mut self, child: AzMenuItemEnumWrapper) -> () {
        unsafe {
            mem::transmute(crate::AzStringMenuItem_addChild(
                mem::transmute(self),
                mem::transmute(child),
            ))
        }
    }
    fn with_child(&mut self, child: AzMenuItemEnumWrapper) -> AzStringMenuItem {
        unsafe {
            mem::transmute(crate::AzStringMenuItem_withChild(
                mem::transmute(self),
                mem::transmute(child),
            ))
        }
    }
    fn set_children(&mut self, children: AzMenuItemVec) -> () {
        unsafe {
            mem::transmute(crate::AzStringMenuItem_setChildren(
                mem::transmute(self),
                mem::transmute(children),
            ))
        }
    }
    fn with_children(&mut self, children: AzMenuItemVec) -> AzStringMenuItem {
        unsafe {
            mem::transmute(crate::AzStringMenuItem_withChildren(
                mem::transmute(self),
                mem::transmute(children),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringMenuItem {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::StringMenuItem = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::StringMenuItem = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeCombo {
    #[new]
    fn __new__(keys: AzVirtualKeyCodeVec) -> Self {
        Self { keys }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeCombo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCodeCombo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuCallback {}

#[pyproto]
impl PyObjectProtocol for AzMenuCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemIconEnumWrapper {
    #[staticmethod]
    fn Checkbox(v: bool) -> AzMenuItemIconEnumWrapper {
        AzMenuItemIconEnumWrapper {
            inner: AzMenuItemIcon::Checkbox(v),
        }
    }
    #[staticmethod]
    fn Image(v: AzImageRef) -> AzMenuItemIconEnumWrapper {
        AzMenuItemIconEnumWrapper {
            inner: AzMenuItemIcon::Image(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzMenuItemIcon;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemIcon::Checkbox(v) => Ok(vec!["Checkbox".into_py(py), v.into_py(py)]),
            AzMenuItemIcon::Image(v) => Ok(vec!["Image".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemStateEnumWrapper {
    #[classattr]
    fn Normal() -> AzMenuItemStateEnumWrapper {
        AzMenuItemStateEnumWrapper {
            inner: AzMenuItemState::Normal,
        }
    }
    #[classattr]
    fn Greyed() -> AzMenuItemStateEnumWrapper {
        AzMenuItemStateEnumWrapper {
            inner: AzMenuItemState::Greyed,
        }
    }
    #[classattr]
    fn Disabled() -> AzMenuItemStateEnumWrapper {
        AzMenuItemStateEnumWrapper {
            inner: AzMenuItemState::Disabled,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzMenuItemStateEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzCssRuleBlock {
    #[new]
    fn __new__(path: AzCssPath, declarations: AzCssDeclarationVec) -> Self {
        Self { path, declarations }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlock {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssRuleBlock = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssRuleBlock = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPath {
    #[new]
    fn __new__(selectors: AzCssPathSelectorVec) -> Self {
        Self { selectors }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPath {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPath = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPath = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorEnumWrapper {
    #[classattr]
    fn Global() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper {
            inner: AzCssPathSelector::Global,
        }
    }
    #[staticmethod]
    fn Type(v: AzNodeTypeKeyEnumWrapper) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper {
            inner: AzCssPathSelector::Type(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Class(v: AzString) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper {
            inner: AzCssPathSelector::Class(v),
        }
    }
    #[staticmethod]
    fn Id(v: AzString) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper {
            inner: AzCssPathSelector::Id(v),
        }
    }
    #[staticmethod]
    fn PseudoSelector(v: AzCssPathPseudoSelectorEnumWrapper) -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper {
            inner: AzCssPathSelector::PseudoSelector(unsafe { mem::transmute(v) }),
        }
    }
    #[classattr]
    fn DirectChildren() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper {
            inner: AzCssPathSelector::DirectChildren,
        }
    }
    #[classattr]
    fn Children() -> AzCssPathSelectorEnumWrapper {
        AzCssPathSelectorEnumWrapper {
            inner: AzCssPathSelector::Children,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssPathSelector;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelector::Global => Ok(vec!["Global".into_py(py), ().into_py(py)]),
            AzCssPathSelector::Type(v) => Ok(vec![
                "Type".into_py(py),
                {
                    let m: &AzNodeTypeKeyEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssPathSelector::Class(v) => Ok(vec!["Class".into_py(py), v.clone().into_py(py)]),
            AzCssPathSelector::Id(v) => Ok(vec!["Id".into_py(py), v.clone().into_py(py)]),
            AzCssPathSelector::PseudoSelector(v) => Ok(vec![
                "PseudoSelector".into_py(py),
                {
                    let m: &AzCssPathPseudoSelectorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssPathSelector::DirectChildren => {
                Ok(vec!["DirectChildren".into_py(py), ().into_py(py)])
            }
            AzCssPathSelector::Children => Ok(vec!["Children".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathSelector = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathSelector = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeKeyEnumWrapper {
    #[classattr]
    fn Body() -> AzNodeTypeKeyEnumWrapper {
        AzNodeTypeKeyEnumWrapper {
            inner: AzNodeTypeKey::Body,
        }
    }
    #[classattr]
    fn Div() -> AzNodeTypeKeyEnumWrapper {
        AzNodeTypeKeyEnumWrapper {
            inner: AzNodeTypeKey::Div,
        }
    }
    #[classattr]
    fn Br() -> AzNodeTypeKeyEnumWrapper {
        AzNodeTypeKeyEnumWrapper {
            inner: AzNodeTypeKey::Br,
        }
    }
    #[classattr]
    fn P() -> AzNodeTypeKeyEnumWrapper {
        AzNodeTypeKeyEnumWrapper {
            inner: AzNodeTypeKey::P,
        }
    }
    #[classattr]
    fn Img() -> AzNodeTypeKeyEnumWrapper {
        AzNodeTypeKeyEnumWrapper {
            inner: AzNodeTypeKey::Img,
        }
    }
    #[classattr]
    fn IFrame() -> AzNodeTypeKeyEnumWrapper {
        AzNodeTypeKeyEnumWrapper {
            inner: AzNodeTypeKey::IFrame,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeKeyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NodeTypeTag = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NodeTypeTag = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzNodeTypeKeyEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzCssPathPseudoSelectorEnumWrapper {
    #[classattr]
    fn First() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper {
            inner: AzCssPathPseudoSelector::First,
        }
    }
    #[classattr]
    fn Last() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper {
            inner: AzCssPathPseudoSelector::Last,
        }
    }
    #[staticmethod]
    fn NthChild(v: AzCssNthChildSelectorEnumWrapper) -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper {
            inner: AzCssPathPseudoSelector::NthChild(unsafe { mem::transmute(v) }),
        }
    }
    #[classattr]
    fn Hover() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper {
            inner: AzCssPathPseudoSelector::Hover,
        }
    }
    #[classattr]
    fn Active() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper {
            inner: AzCssPathPseudoSelector::Active,
        }
    }
    #[classattr]
    fn Focus() -> AzCssPathPseudoSelectorEnumWrapper {
        AzCssPathPseudoSelectorEnumWrapper {
            inner: AzCssPathPseudoSelector::Focus,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssPathPseudoSelector;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathPseudoSelector::First => Ok(vec!["First".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Last => Ok(vec!["Last".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::NthChild(v) => Ok(vec![
                "NthChild".into_py(py),
                {
                    let m: &AzCssNthChildSelectorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssPathPseudoSelector::Hover => Ok(vec!["Hover".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Active => Ok(vec!["Active".into_py(py), ().into_py(py)]),
            AzCssPathPseudoSelector::Focus => Ok(vec!["Focus".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathPseudoSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathPseudoSelector = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildSelectorEnumWrapper {
    #[staticmethod]
    fn Number(v: u32) -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper {
            inner: AzCssNthChildSelector::Number(v),
        }
    }
    #[classattr]
    fn Even() -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper {
            inner: AzCssNthChildSelector::Even,
        }
    }
    #[classattr]
    fn Odd() -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper {
            inner: AzCssNthChildSelector::Odd,
        }
    }
    #[staticmethod]
    fn Pattern(v: AzCssNthChildPattern) -> AzCssNthChildSelectorEnumWrapper {
        AzCssNthChildSelectorEnumWrapper {
            inner: AzCssNthChildSelector::Pattern(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssNthChildSelector;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssNthChildSelector::Number(v) => Ok(vec!["Number".into_py(py), v.into_py(py)]),
            AzCssNthChildSelector::Even => Ok(vec!["Even".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Odd => Ok(vec!["Odd".into_py(py), ().into_py(py)]),
            AzCssNthChildSelector::Pattern(v) => {
                Ok(vec!["Pattern".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildSelectorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssNthChildSelector = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssNthChildPattern {
    #[new]
    fn __new__(repeat: u32, offset: u32) -> Self {
        Self { repeat, offset }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssNthChildPattern {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssNthChildPattern = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssNthChildPattern = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheet {
    #[new]
    fn __new__(rules: AzCssRuleBlockVec) -> Self {
        Self { rules }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylesheet {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Stylesheet = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Stylesheet = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCss {
    #[staticmethod]
    fn empty() -> AzCss {
        unsafe { mem::transmute(crate::AzCss_empty()) }
    }
    #[staticmethod]
    fn from_string(s: String) -> AzCss {
        let s = pystring_to_azstring(&s);
        unsafe { mem::transmute(crate::AzCss_fromString(mem::transmute(s))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCss {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Css = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Css = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationEnumWrapper {
    #[staticmethod]
    fn Static(v: AzCssPropertyEnumWrapper) -> AzCssDeclarationEnumWrapper {
        AzCssDeclarationEnumWrapper {
            inner: AzCssDeclaration::Static(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Dynamic(v: AzDynamicCssProperty) -> AzCssDeclarationEnumWrapper {
        AzCssDeclarationEnumWrapper {
            inner: AzCssDeclaration::Dynamic(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssDeclaration;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclaration::Static(v) => Ok(vec![
                "Static".into_py(py),
                {
                    let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssDeclaration::Dynamic(v) => Ok(vec!["Dynamic".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssDeclaration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssDeclaration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDynamicCssProperty {
    #[new]
    fn __new__(dynamic_id: AzString, default_value: AzCssPropertyEnumWrapper) -> Self {
        Self {
            dynamic_id,
            default_value,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDynamicCssProperty {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::DynamicCssProperty = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::DynamicCssProperty = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyTypeEnumWrapper {
    #[classattr]
    fn TextColor() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::TextColor,
        }
    }
    #[classattr]
    fn FontSize() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::FontSize,
        }
    }
    #[classattr]
    fn FontFamily() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::FontFamily,
        }
    }
    #[classattr]
    fn TextAlign() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::TextAlign,
        }
    }
    #[classattr]
    fn LetterSpacing() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::LetterSpacing,
        }
    }
    #[classattr]
    fn LineHeight() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::LineHeight,
        }
    }
    #[classattr]
    fn WordSpacing() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::WordSpacing,
        }
    }
    #[classattr]
    fn TabWidth() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::TabWidth,
        }
    }
    #[classattr]
    fn Cursor() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Cursor,
        }
    }
    #[classattr]
    fn Display() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Display,
        }
    }
    #[classattr]
    fn Float() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Float,
        }
    }
    #[classattr]
    fn BoxSizing() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BoxSizing,
        }
    }
    #[classattr]
    fn Width() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Width,
        }
    }
    #[classattr]
    fn Height() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Height,
        }
    }
    #[classattr]
    fn MinWidth() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MinWidth,
        }
    }
    #[classattr]
    fn MinHeight() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MinHeight,
        }
    }
    #[classattr]
    fn MaxWidth() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MaxWidth,
        }
    }
    #[classattr]
    fn MaxHeight() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MaxHeight,
        }
    }
    #[classattr]
    fn Position() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Position,
        }
    }
    #[classattr]
    fn Top() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Top,
        }
    }
    #[classattr]
    fn Right() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Right,
        }
    }
    #[classattr]
    fn Left() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Left,
        }
    }
    #[classattr]
    fn Bottom() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Bottom,
        }
    }
    #[classattr]
    fn FlexWrap() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::FlexWrap,
        }
    }
    #[classattr]
    fn FlexDirection() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::FlexDirection,
        }
    }
    #[classattr]
    fn FlexGrow() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::FlexGrow,
        }
    }
    #[classattr]
    fn FlexShrink() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::FlexShrink,
        }
    }
    #[classattr]
    fn JustifyContent() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::JustifyContent,
        }
    }
    #[classattr]
    fn AlignItems() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::AlignItems,
        }
    }
    #[classattr]
    fn AlignContent() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::AlignContent,
        }
    }
    #[classattr]
    fn BackgroundContent() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BackgroundContent,
        }
    }
    #[classattr]
    fn BackgroundPosition() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BackgroundPosition,
        }
    }
    #[classattr]
    fn BackgroundSize() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BackgroundSize,
        }
    }
    #[classattr]
    fn BackgroundRepeat() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BackgroundRepeat,
        }
    }
    #[classattr]
    fn OverflowX() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::OverflowX,
        }
    }
    #[classattr]
    fn OverflowY() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::OverflowY,
        }
    }
    #[classattr]
    fn PaddingTop() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::PaddingTop,
        }
    }
    #[classattr]
    fn PaddingLeft() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::PaddingLeft,
        }
    }
    #[classattr]
    fn PaddingRight() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::PaddingRight,
        }
    }
    #[classattr]
    fn PaddingBottom() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::PaddingBottom,
        }
    }
    #[classattr]
    fn MarginTop() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MarginTop,
        }
    }
    #[classattr]
    fn MarginLeft() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MarginLeft,
        }
    }
    #[classattr]
    fn MarginRight() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MarginRight,
        }
    }
    #[classattr]
    fn MarginBottom() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MarginBottom,
        }
    }
    #[classattr]
    fn BorderTopLeftRadius() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderTopLeftRadius,
        }
    }
    #[classattr]
    fn BorderTopRightRadius() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderTopRightRadius,
        }
    }
    #[classattr]
    fn BorderBottomLeftRadius() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderBottomLeftRadius,
        }
    }
    #[classattr]
    fn BorderBottomRightRadius() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderBottomRightRadius,
        }
    }
    #[classattr]
    fn BorderTopColor() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderTopColor,
        }
    }
    #[classattr]
    fn BorderRightColor() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderRightColor,
        }
    }
    #[classattr]
    fn BorderLeftColor() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderLeftColor,
        }
    }
    #[classattr]
    fn BorderBottomColor() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderBottomColor,
        }
    }
    #[classattr]
    fn BorderTopStyle() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderTopStyle,
        }
    }
    #[classattr]
    fn BorderRightStyle() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderRightStyle,
        }
    }
    #[classattr]
    fn BorderLeftStyle() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderLeftStyle,
        }
    }
    #[classattr]
    fn BorderBottomStyle() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderBottomStyle,
        }
    }
    #[classattr]
    fn BorderTopWidth() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderTopWidth,
        }
    }
    #[classattr]
    fn BorderRightWidth() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderRightWidth,
        }
    }
    #[classattr]
    fn BorderLeftWidth() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderLeftWidth,
        }
    }
    #[classattr]
    fn BorderBottomWidth() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BorderBottomWidth,
        }
    }
    #[classattr]
    fn BoxShadowLeft() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BoxShadowLeft,
        }
    }
    #[classattr]
    fn BoxShadowRight() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BoxShadowRight,
        }
    }
    #[classattr]
    fn BoxShadowTop() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BoxShadowTop,
        }
    }
    #[classattr]
    fn BoxShadowBottom() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BoxShadowBottom,
        }
    }
    #[classattr]
    fn ScrollbarStyle() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::ScrollbarStyle,
        }
    }
    #[classattr]
    fn Opacity() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Opacity,
        }
    }
    #[classattr]
    fn Transform() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Transform,
        }
    }
    #[classattr]
    fn TransformOrigin() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::TransformOrigin,
        }
    }
    #[classattr]
    fn PerspectiveOrigin() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::PerspectiveOrigin,
        }
    }
    #[classattr]
    fn BackfaceVisibility() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BackfaceVisibility,
        }
    }
    #[classattr]
    fn MixBlendMode() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::MixBlendMode,
        }
    }
    #[classattr]
    fn Filter() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::Filter,
        }
    }
    #[classattr]
    fn BackdropFilter() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::BackdropFilter,
        }
    }
    #[classattr]
    fn TextShadow() -> AzCssPropertyTypeEnumWrapper {
        AzCssPropertyTypeEnumWrapper {
            inner: AzCssPropertyType::TextShadow,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPropertyType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPropertyType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzCssPropertyTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzAnimationInterpolationFunctionEnumWrapper {
    #[classattr]
    fn Ease() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper {
            inner: AzAnimationInterpolationFunction::Ease,
        }
    }
    #[classattr]
    fn Linear() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper {
            inner: AzAnimationInterpolationFunction::Linear,
        }
    }
    #[classattr]
    fn EaseIn() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper {
            inner: AzAnimationInterpolationFunction::EaseIn,
        }
    }
    #[classattr]
    fn EaseOut() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper {
            inner: AzAnimationInterpolationFunction::EaseOut,
        }
    }
    #[classattr]
    fn EaseInOut() -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper {
            inner: AzAnimationInterpolationFunction::EaseInOut,
        }
    }
    #[staticmethod]
    fn CubicBezier(v: AzSvgCubicCurve) -> AzAnimationInterpolationFunctionEnumWrapper {
        AzAnimationInterpolationFunctionEnumWrapper {
            inner: AzAnimationInterpolationFunction::CubicBezier(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzAnimationInterpolationFunction;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAnimationInterpolationFunction::Ease => Ok(vec!["Ease".into_py(py), ().into_py(py)]),
            AzAnimationInterpolationFunction::Linear => {
                Ok(vec!["Linear".into_py(py), ().into_py(py)])
            }
            AzAnimationInterpolationFunction::EaseIn => {
                Ok(vec!["EaseIn".into_py(py), ().into_py(py)])
            }
            AzAnimationInterpolationFunction::EaseOut => {
                Ok(vec!["EaseOut".into_py(py), ().into_py(py)])
            }
            AzAnimationInterpolationFunction::EaseInOut => {
                Ok(vec!["EaseInOut".into_py(py), ().into_py(py)])
            }
            AzAnimationInterpolationFunction::CubicBezier(v) => {
                Ok(vec!["CubicBezier".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAnimationInterpolationFunctionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AnimationInterpolationFunction = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInterpolateContext {
    #[new]
    fn __new__(
        animation_func: AzAnimationInterpolationFunctionEnumWrapper,
        parent_rect_width: f32,
        parent_rect_height: f32,
        current_rect_width: f32,
        current_rect_height: f32,
    ) -> Self {
        Self {
            animation_func,
            parent_rect_width,
            parent_rect_height,
            current_rect_width,
            current_rect_height,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInterpolateContext {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::InterpolateResolver = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::InterpolateResolver = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorU {
    #[staticmethod]
    fn from_str(string: String) -> AzColorU {
        let string = pystring_to_azstring(&string);
        unsafe { mem::transmute(crate::AzColorU_fromStr(mem::transmute(string))) }
    }
    #[staticmethod]
    fn transparent() -> AzColorU {
        unsafe { mem::transmute(crate::AzColorU_transparent()) }
    }
    #[staticmethod]
    fn white() -> AzColorU {
        unsafe { mem::transmute(crate::AzColorU_white()) }
    }
    #[staticmethod]
    fn black() -> AzColorU {
        unsafe { mem::transmute(crate::AzColorU_black()) }
    }
    fn to_hash(&self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzColorU_toHash(mem::transmute(self)))
        })
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorU {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ColorU = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ColorU = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSizeMetricEnumWrapper {
    #[classattr]
    fn Px() -> AzSizeMetricEnumWrapper {
        AzSizeMetricEnumWrapper {
            inner: AzSizeMetric::Px,
        }
    }
    #[classattr]
    fn Pt() -> AzSizeMetricEnumWrapper {
        AzSizeMetricEnumWrapper {
            inner: AzSizeMetric::Pt,
        }
    }
    #[classattr]
    fn Em() -> AzSizeMetricEnumWrapper {
        AzSizeMetricEnumWrapper {
            inner: AzSizeMetric::Em,
        }
    }
    #[classattr]
    fn Percent() -> AzSizeMetricEnumWrapper {
        AzSizeMetricEnumWrapper {
            inner: AzSizeMetric::Percent,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSizeMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::SizeMetric = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::SizeMetric = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzSizeMetricEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzPixelValue {
    #[new]
    fn __new__(metric: AzSizeMetricEnumWrapper, number: AzFloatValue) -> Self {
        Self { metric, number }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPixelValue {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::PixelValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::PixelValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPixelValueNoPercent {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPixelValueNoPercent {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::PixelValueNoPercent = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::PixelValueNoPercent = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBoxShadowClipModeEnumWrapper {
    #[classattr]
    fn Outset() -> AzBoxShadowClipModeEnumWrapper {
        AzBoxShadowClipModeEnumWrapper {
            inner: AzBoxShadowClipMode::Outset,
        }
    }
    #[classattr]
    fn Inset() -> AzBoxShadowClipModeEnumWrapper {
        AzBoxShadowClipModeEnumWrapper {
            inner: AzBoxShadowClipMode::Inset,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBoxShadowClipModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BoxShadowClipMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzBoxShadowClipModeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStyleBoxShadow {}

#[pyproto]
impl PyObjectProtocol for AzStyleBoxShadow {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBoxShadow = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBoxShadow = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleMixBlendModeEnumWrapper {
    #[classattr]
    fn Normal() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Normal,
        }
    }
    #[classattr]
    fn Multiply() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Multiply,
        }
    }
    #[classattr]
    fn Screen() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Screen,
        }
    }
    #[classattr]
    fn Overlay() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Overlay,
        }
    }
    #[classattr]
    fn Darken() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Darken,
        }
    }
    #[classattr]
    fn Lighten() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Lighten,
        }
    }
    #[classattr]
    fn ColorDodge() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::ColorDodge,
        }
    }
    #[classattr]
    fn ColorBurn() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::ColorBurn,
        }
    }
    #[classattr]
    fn HardLight() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::HardLight,
        }
    }
    #[classattr]
    fn SoftLight() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::SoftLight,
        }
    }
    #[classattr]
    fn Difference() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Difference,
        }
    }
    #[classattr]
    fn Exclusion() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Exclusion,
        }
    }
    #[classattr]
    fn Hue() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Hue,
        }
    }
    #[classattr]
    fn Saturation() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Saturation,
        }
    }
    #[classattr]
    fn Color() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Color,
        }
    }
    #[classattr]
    fn Luminosity() -> AzStyleMixBlendModeEnumWrapper {
        AzStyleMixBlendModeEnumWrapper {
            inner: AzStyleMixBlendMode::Luminosity,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleMixBlendModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleMixBlendMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzStyleMixBlendModeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStyleFilterEnumWrapper {
    #[staticmethod]
    fn Blend(v: AzStyleMixBlendModeEnumWrapper) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::Blend(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Flood(v: AzColorU) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::Flood(v),
        }
    }
    #[staticmethod]
    fn Blur(v: AzStyleBlur) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::Blur(v),
        }
    }
    #[staticmethod]
    fn Opacity(v: AzPercentageValue) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::Opacity(v),
        }
    }
    #[staticmethod]
    fn ColorMatrix(v: AzStyleColorMatrix) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::ColorMatrix(v),
        }
    }
    #[staticmethod]
    fn DropShadow(v: AzStyleBoxShadow) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::DropShadow(v),
        }
    }
    #[classattr]
    fn ComponentTransfer() -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::ComponentTransfer,
        }
    }
    #[staticmethod]
    fn Offset(v: AzStyleFilterOffset) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::Offset(v),
        }
    }
    #[staticmethod]
    fn Composite(v: AzStyleCompositeFilterEnumWrapper) -> AzStyleFilterEnumWrapper {
        AzStyleFilterEnumWrapper {
            inner: AzStyleFilter::Composite(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleFilter;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilter::Blend(v) => Ok(vec![
                "Blend".into_py(py),
                {
                    let m: &AzStyleMixBlendModeEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzStyleFilter::Flood(v) => Ok(vec!["Flood".into_py(py), v.clone().into_py(py)]),
            AzStyleFilter::Blur(v) => Ok(vec!["Blur".into_py(py), v.clone().into_py(py)]),
            AzStyleFilter::Opacity(v) => Ok(vec!["Opacity".into_py(py), v.clone().into_py(py)]),
            AzStyleFilter::ColorMatrix(v) => {
                Ok(vec!["ColorMatrix".into_py(py), v.clone().into_py(py)])
            }
            AzStyleFilter::DropShadow(v) => {
                Ok(vec!["DropShadow".into_py(py), v.clone().into_py(py)])
            }
            AzStyleFilter::ComponentTransfer => {
                Ok(vec!["ComponentTransfer".into_py(py), ().into_py(py)])
            }
            AzStyleFilter::Offset(v) => Ok(vec!["Offset".into_py(py), v.clone().into_py(py)]),
            AzStyleFilter::Composite(v) => Ok(vec![
                "Composite".into_py(py),
                {
                    let m: &AzStyleCompositeFilterEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBlur {
    #[new]
    fn __new__(width: AzPixelValue, height: AzPixelValue) -> Self {
        Self { width, height }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBlur {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBlur = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBlur = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleColorMatrix {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleColorMatrix {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleColorMatrix = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleColorMatrix = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterOffset {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterOffset {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterOffset = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterOffset = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCompositeFilterEnumWrapper {
    #[classattr]
    fn Over() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper {
            inner: AzStyleCompositeFilter::Over,
        }
    }
    #[classattr]
    fn In() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper {
            inner: AzStyleCompositeFilter::In,
        }
    }
    #[classattr]
    fn Atop() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper {
            inner: AzStyleCompositeFilter::Atop,
        }
    }
    #[classattr]
    fn Out() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper {
            inner: AzStyleCompositeFilter::Out,
        }
    }
    #[classattr]
    fn Xor() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper {
            inner: AzStyleCompositeFilter::Xor,
        }
    }
    #[classattr]
    fn Lighter() -> AzStyleCompositeFilterEnumWrapper {
        AzStyleCompositeFilterEnumWrapper {
            inner: AzStyleCompositeFilter::Lighter,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleCompositeFilter;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleCompositeFilter::Over => Ok(vec!["Over".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::In => Ok(vec!["In".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Atop => Ok(vec!["Atop".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Out => Ok(vec!["Out".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Xor => Ok(vec!["Xor".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Lighter => Ok(vec!["Lighter".into_py(py), ().into_py(py)]),
            AzStyleCompositeFilter::Arithmetic(v) => {
                Ok(vec!["Arithmetic".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCompositeFilterEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleCompositeFilter = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignContentEnumWrapper {
    #[classattr]
    fn Stretch() -> AzLayoutAlignContentEnumWrapper {
        AzLayoutAlignContentEnumWrapper {
            inner: AzLayoutAlignContent::Stretch,
        }
    }
    #[classattr]
    fn Center() -> AzLayoutAlignContentEnumWrapper {
        AzLayoutAlignContentEnumWrapper {
            inner: AzLayoutAlignContent::Center,
        }
    }
    #[classattr]
    fn Start() -> AzLayoutAlignContentEnumWrapper {
        AzLayoutAlignContentEnumWrapper {
            inner: AzLayoutAlignContent::Start,
        }
    }
    #[classattr]
    fn End() -> AzLayoutAlignContentEnumWrapper {
        AzLayoutAlignContentEnumWrapper {
            inner: AzLayoutAlignContent::End,
        }
    }
    #[classattr]
    fn SpaceBetween() -> AzLayoutAlignContentEnumWrapper {
        AzLayoutAlignContentEnumWrapper {
            inner: AzLayoutAlignContent::SpaceBetween,
        }
    }
    #[classattr]
    fn SpaceAround() -> AzLayoutAlignContentEnumWrapper {
        AzLayoutAlignContentEnumWrapper {
            inner: AzLayoutAlignContent::SpaceAround,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignContent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignContent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutAlignContentEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutAlignItemsEnumWrapper {
    #[classattr]
    fn Stretch() -> AzLayoutAlignItemsEnumWrapper {
        AzLayoutAlignItemsEnumWrapper {
            inner: AzLayoutAlignItems::Stretch,
        }
    }
    #[classattr]
    fn Center() -> AzLayoutAlignItemsEnumWrapper {
        AzLayoutAlignItemsEnumWrapper {
            inner: AzLayoutAlignItems::Center,
        }
    }
    #[classattr]
    fn FlexStart() -> AzLayoutAlignItemsEnumWrapper {
        AzLayoutAlignItemsEnumWrapper {
            inner: AzLayoutAlignItems::FlexStart,
        }
    }
    #[classattr]
    fn FlexEnd() -> AzLayoutAlignItemsEnumWrapper {
        AzLayoutAlignItemsEnumWrapper {
            inner: AzLayoutAlignItems::FlexEnd,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignItemsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignItems = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignItems = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutAlignItemsEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutBottom {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBottom {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBottom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBottom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBoxSizingEnumWrapper {
    #[classattr]
    fn ContentBox() -> AzLayoutBoxSizingEnumWrapper {
        AzLayoutBoxSizingEnumWrapper {
            inner: AzLayoutBoxSizing::ContentBox,
        }
    }
    #[classattr]
    fn BorderBox() -> AzLayoutBoxSizingEnumWrapper {
        AzLayoutBoxSizingEnumWrapper {
            inner: AzLayoutBoxSizing::BorderBox,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBoxSizingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBoxSizing = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutBoxSizingEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutFlexDirectionEnumWrapper {
    #[classattr]
    fn Row() -> AzLayoutFlexDirectionEnumWrapper {
        AzLayoutFlexDirectionEnumWrapper {
            inner: AzLayoutFlexDirection::Row,
        }
    }
    #[classattr]
    fn RowReverse() -> AzLayoutFlexDirectionEnumWrapper {
        AzLayoutFlexDirectionEnumWrapper {
            inner: AzLayoutFlexDirection::RowReverse,
        }
    }
    #[classattr]
    fn Column() -> AzLayoutFlexDirectionEnumWrapper {
        AzLayoutFlexDirectionEnumWrapper {
            inner: AzLayoutFlexDirection::Column,
        }
    }
    #[classattr]
    fn ColumnReverse() -> AzLayoutFlexDirectionEnumWrapper {
        AzLayoutFlexDirectionEnumWrapper {
            inner: AzLayoutFlexDirection::ColumnReverse,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexDirection = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutFlexDirectionEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutDisplayEnumWrapper {
    #[classattr]
    fn None() -> AzLayoutDisplayEnumWrapper {
        AzLayoutDisplayEnumWrapper {
            inner: AzLayoutDisplay::None,
        }
    }
    #[classattr]
    fn Flex() -> AzLayoutDisplayEnumWrapper {
        AzLayoutDisplayEnumWrapper {
            inner: AzLayoutDisplay::Flex,
        }
    }
    #[classattr]
    fn Block() -> AzLayoutDisplayEnumWrapper {
        AzLayoutDisplayEnumWrapper {
            inner: AzLayoutDisplay::Block,
        }
    }
    #[classattr]
    fn InlineBlock() -> AzLayoutDisplayEnumWrapper {
        AzLayoutDisplayEnumWrapper {
            inner: AzLayoutDisplay::InlineBlock,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutDisplayEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutDisplay = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutDisplay = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutDisplayEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutFlexGrow {
    #[new]
    fn __new__(inner: AzFloatValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexGrow {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexGrow = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexGrow = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexShrink {
    #[new]
    fn __new__(inner: AzFloatValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexShrink {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexShrink = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexShrink = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFloatEnumWrapper {
    #[classattr]
    fn Left() -> AzLayoutFloatEnumWrapper {
        AzLayoutFloatEnumWrapper {
            inner: AzLayoutFloat::Left,
        }
    }
    #[classattr]
    fn Right() -> AzLayoutFloatEnumWrapper {
        AzLayoutFloatEnumWrapper {
            inner: AzLayoutFloat::Right,
        }
    }
    #[classattr]
    fn None() -> AzLayoutFloatEnumWrapper {
        AzLayoutFloatEnumWrapper {
            inner: AzLayoutFloat::None,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFloatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFloat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFloat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutFloatEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutHeight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutHeight {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyContentEnumWrapper {
    #[classattr]
    fn Start() -> AzLayoutJustifyContentEnumWrapper {
        AzLayoutJustifyContentEnumWrapper {
            inner: AzLayoutJustifyContent::Start,
        }
    }
    #[classattr]
    fn End() -> AzLayoutJustifyContentEnumWrapper {
        AzLayoutJustifyContentEnumWrapper {
            inner: AzLayoutJustifyContent::End,
        }
    }
    #[classattr]
    fn Center() -> AzLayoutJustifyContentEnumWrapper {
        AzLayoutJustifyContentEnumWrapper {
            inner: AzLayoutJustifyContent::Center,
        }
    }
    #[classattr]
    fn SpaceBetween() -> AzLayoutJustifyContentEnumWrapper {
        AzLayoutJustifyContentEnumWrapper {
            inner: AzLayoutJustifyContent::SpaceBetween,
        }
    }
    #[classattr]
    fn SpaceAround() -> AzLayoutJustifyContentEnumWrapper {
        AzLayoutJustifyContentEnumWrapper {
            inner: AzLayoutJustifyContent::SpaceAround,
        }
    }
    #[classattr]
    fn SpaceEvenly() -> AzLayoutJustifyContentEnumWrapper {
        AzLayoutJustifyContentEnumWrapper {
            inner: AzLayoutJustifyContent::SpaceEvenly,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutJustifyContent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutJustifyContentEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutLeft {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutLeft {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutLeft = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutLeft = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginBottom {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginBottom {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginBottom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginBottom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginLeft {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginLeft {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginLeft = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginLeft = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginRight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginRight {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginRight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginRight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginTop {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginTop {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginTop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginTop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxHeight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxHeight {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinHeight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinHeight {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingBottom {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingBottom {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingBottom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingBottom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingLeft {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingLeft {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingLeft = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingLeft = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingRight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingRight {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingRight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingRight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingTop {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingTop {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingTop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingTop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPositionEnumWrapper {
    #[classattr]
    fn Static() -> AzLayoutPositionEnumWrapper {
        AzLayoutPositionEnumWrapper {
            inner: AzLayoutPosition::Static,
        }
    }
    #[classattr]
    fn Relative() -> AzLayoutPositionEnumWrapper {
        AzLayoutPositionEnumWrapper {
            inner: AzLayoutPosition::Relative,
        }
    }
    #[classattr]
    fn Absolute() -> AzLayoutPositionEnumWrapper {
        AzLayoutPositionEnumWrapper {
            inner: AzLayoutPosition::Absolute,
        }
    }
    #[classattr]
    fn Fixed() -> AzLayoutPositionEnumWrapper {
        AzLayoutPositionEnumWrapper {
            inner: AzLayoutPosition::Fixed,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutPositionEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutRight {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRight {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutRight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutRight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTop {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTop {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutTop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutTop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexWrapEnumWrapper {
    #[classattr]
    fn Wrap() -> AzLayoutFlexWrapEnumWrapper {
        AzLayoutFlexWrapEnumWrapper {
            inner: AzLayoutFlexWrap::Wrap,
        }
    }
    #[classattr]
    fn NoWrap() -> AzLayoutFlexWrapEnumWrapper {
        AzLayoutFlexWrapEnumWrapper {
            inner: AzLayoutFlexWrap::NoWrap,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexWrapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexWrap = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutFlexWrapEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLayoutOverflowEnumWrapper {
    #[classattr]
    fn Scroll() -> AzLayoutOverflowEnumWrapper {
        AzLayoutOverflowEnumWrapper {
            inner: AzLayoutOverflow::Scroll,
        }
    }
    #[classattr]
    fn Auto() -> AzLayoutOverflowEnumWrapper {
        AzLayoutOverflowEnumWrapper {
            inner: AzLayoutOverflow::Auto,
        }
    }
    #[classattr]
    fn Hidden() -> AzLayoutOverflowEnumWrapper {
        AzLayoutOverflowEnumWrapper {
            inner: AzLayoutOverflow::Hidden,
        }
    }
    #[classattr]
    fn Visible() -> AzLayoutOverflowEnumWrapper {
        AzLayoutOverflowEnumWrapper {
            inner: AzLayoutOverflow::Visible,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutOverflowEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutOverflow = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutOverflow = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzLayoutOverflowEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzFloatValue {
    #[new]
    fn __new__(number: isize) -> Self {
        Self { number }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFloatValue {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::FloatValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::FloatValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzPercentageValue {
    #[new]
    fn __new__(number: AzFloatValue) -> Self {
        Self { number }
    }
}

#[pyproto]
impl PyObjectProtocol for AzPercentageValue {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::PercentageValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::PercentageValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAngleMetricEnumWrapper {
    #[classattr]
    fn Degree() -> AzAngleMetricEnumWrapper {
        AzAngleMetricEnumWrapper {
            inner: AzAngleMetric::Degree,
        }
    }
    #[classattr]
    fn Radians() -> AzAngleMetricEnumWrapper {
        AzAngleMetricEnumWrapper {
            inner: AzAngleMetric::Radians,
        }
    }
    #[classattr]
    fn Grad() -> AzAngleMetricEnumWrapper {
        AzAngleMetricEnumWrapper {
            inner: AzAngleMetric::Grad,
        }
    }
    #[classattr]
    fn Turn() -> AzAngleMetricEnumWrapper {
        AzAngleMetricEnumWrapper {
            inner: AzAngleMetric::Turn,
        }
    }
    #[classattr]
    fn Percent() -> AzAngleMetricEnumWrapper {
        AzAngleMetricEnumWrapper {
            inner: AzAngleMetric::Percent,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAngleMetricEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AngleMetric = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AngleMetric = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzAngleMetricEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzAngleValue {
    #[new]
    fn __new__(metric: AzAngleMetricEnumWrapper, number: AzFloatValue) -> Self {
        Self { metric, number }
    }

    fn get_degrees(&self) -> f32 {
        unsafe { mem::transmute(crate::AzAngleValue_getDegrees(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAngleValue {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AngleValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AngleValue = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStop {
    #[new]
    fn __new__(offset: AzPercentageValue, color: AzColorU) -> Self {
        Self { offset, color }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStop {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedLinearColorStop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedLinearColorStop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStop {
    #[new]
    fn __new__(offset: AzAngleValue, color: AzColorU) -> Self {
        Self { offset, color }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStop {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedRadialColorStop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedRadialColorStop = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionCornerEnumWrapper {
    #[classattr]
    fn Right() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::Right,
        }
    }
    #[classattr]
    fn Left() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::Left,
        }
    }
    #[classattr]
    fn Top() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::Top,
        }
    }
    #[classattr]
    fn Bottom() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::Bottom,
        }
    }
    #[classattr]
    fn TopRight() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::TopRight,
        }
    }
    #[classattr]
    fn TopLeft() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::TopLeft,
        }
    }
    #[classattr]
    fn BottomRight() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::BottomRight,
        }
    }
    #[classattr]
    fn BottomLeft() -> AzDirectionCornerEnumWrapper {
        AzDirectionCornerEnumWrapper {
            inner: AzDirectionCorner::BottomLeft,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDirectionCornerEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::DirectionCorner = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::DirectionCorner = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzDirectionCornerEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzDirectionCorners {
    #[new]
    fn __new__(from: AzDirectionCornerEnumWrapper, to: AzDirectionCornerEnumWrapper) -> Self {
        Self { from, to }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDirectionCorners {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::DirectionCorners = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::DirectionCorners = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDirectionEnumWrapper {
    #[staticmethod]
    fn Angle(v: AzAngleValue) -> AzDirectionEnumWrapper {
        AzDirectionEnumWrapper {
            inner: AzDirection::Angle(v),
        }
    }
    #[staticmethod]
    fn FromTo(v: AzDirectionCorners) -> AzDirectionEnumWrapper {
        AzDirectionEnumWrapper {
            inner: AzDirection::FromTo(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzDirection;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDirection::Angle(v) => Ok(vec!["Angle".into_py(py), v.clone().into_py(py)]),
            AzDirection::FromTo(v) => Ok(vec!["FromTo".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDirectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Direction = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Direction = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzExtendModeEnumWrapper {
    #[classattr]
    fn Clamp() -> AzExtendModeEnumWrapper {
        AzExtendModeEnumWrapper {
            inner: AzExtendMode::Clamp,
        }
    }
    #[classattr]
    fn Repeat() -> AzExtendModeEnumWrapper {
        AzExtendModeEnumWrapper {
            inner: AzExtendMode::Repeat,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzExtendModeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ExtendMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ExtendMode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzExtendModeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzLinearGradient {
    #[new]
    fn __new__(
        direction: AzDirectionEnumWrapper,
        extend_mode: AzExtendModeEnumWrapper,
        stops: AzNormalizedLinearColorStopVec,
    ) -> Self {
        Self {
            direction,
            extend_mode,
            stops,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLinearGradient {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LinearGradient = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LinearGradient = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeEnumWrapper {
    #[classattr]
    fn Ellipse() -> AzShapeEnumWrapper {
        AzShapeEnumWrapper {
            inner: AzShape::Ellipse,
        }
    }
    #[classattr]
    fn Circle() -> AzShapeEnumWrapper {
        AzShapeEnumWrapper {
            inner: AzShape::Circle,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzShapeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Shape = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::Shape = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzShapeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzRadialGradientSizeEnumWrapper {
    #[classattr]
    fn ClosestSide() -> AzRadialGradientSizeEnumWrapper {
        AzRadialGradientSizeEnumWrapper {
            inner: AzRadialGradientSize::ClosestSide,
        }
    }
    #[classattr]
    fn ClosestCorner() -> AzRadialGradientSizeEnumWrapper {
        AzRadialGradientSizeEnumWrapper {
            inner: AzRadialGradientSize::ClosestCorner,
        }
    }
    #[classattr]
    fn FarthestSide() -> AzRadialGradientSizeEnumWrapper {
        AzRadialGradientSizeEnumWrapper {
            inner: AzRadialGradientSize::FarthestSide,
        }
    }
    #[classattr]
    fn FarthestCorner() -> AzRadialGradientSizeEnumWrapper {
        AzRadialGradientSizeEnumWrapper {
            inner: AzRadialGradientSize::FarthestCorner,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRadialGradientSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::RadialGradientSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::RadialGradientSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzRadialGradientSizeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzRadialGradient {
    #[new]
    fn __new__(
        shape: AzShapeEnumWrapper,
        size: AzRadialGradientSizeEnumWrapper,
        position: AzStyleBackgroundPosition,
        extend_mode: AzExtendModeEnumWrapper,
        stops: AzNormalizedLinearColorStopVec,
    ) -> Self {
        Self {
            shape,
            size,
            position,
            extend_mode,
            stops,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRadialGradient {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::RadialGradient = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::RadialGradient = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzConicGradient {
    #[new]
    fn __new__(
        extend_mode: AzExtendModeEnumWrapper,
        center: AzStyleBackgroundPosition,
        angle: AzAngleValue,
        stops: AzNormalizedRadialColorStopVec,
    ) -> Self {
        Self {
            extend_mode,
            center,
            angle,
            stops,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzConicGradient {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ConicGradient = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ConicGradient = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentEnumWrapper {
    #[staticmethod]
    fn LinearGradient(v: AzLinearGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper {
            inner: AzStyleBackgroundContent::LinearGradient(v),
        }
    }
    #[staticmethod]
    fn RadialGradient(v: AzRadialGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper {
            inner: AzStyleBackgroundContent::RadialGradient(v),
        }
    }
    #[staticmethod]
    fn ConicGradient(v: AzConicGradient) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper {
            inner: AzStyleBackgroundContent::ConicGradient(v),
        }
    }
    #[staticmethod]
    fn Image(v: AzString) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper {
            inner: AzStyleBackgroundContent::Image(v),
        }
    }
    #[staticmethod]
    fn Color(v: AzColorU) -> AzStyleBackgroundContentEnumWrapper {
        AzStyleBackgroundContentEnumWrapper {
            inner: AzStyleBackgroundContent::Color(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundContent;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContent::LinearGradient(v) => {
                Ok(vec!["LinearGradient".into_py(py), v.clone().into_py(py)])
            }
            AzStyleBackgroundContent::RadialGradient(v) => {
                Ok(vec!["RadialGradient".into_py(py), v.clone().into_py(py)])
            }
            AzStyleBackgroundContent::ConicGradient(v) => {
                Ok(vec!["ConicGradient".into_py(py), v.clone().into_py(py)])
            }
            AzStyleBackgroundContent::Image(v) => {
                Ok(vec!["Image".into_py(py), v.clone().into_py(py)])
            }
            AzStyleBackgroundContent::Color(v) => {
                Ok(vec!["Color".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionHorizontalEnumWrapper {
    #[classattr]
    fn Left() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper {
            inner: AzBackgroundPositionHorizontal::Left,
        }
    }
    #[classattr]
    fn Center() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper {
            inner: AzBackgroundPositionHorizontal::Center,
        }
    }
    #[classattr]
    fn Right() -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper {
            inner: AzBackgroundPositionHorizontal::Right,
        }
    }
    #[staticmethod]
    fn Exact(v: AzPixelValue) -> AzBackgroundPositionHorizontalEnumWrapper {
        AzBackgroundPositionHorizontalEnumWrapper {
            inner: AzBackgroundPositionHorizontal::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzBackgroundPositionHorizontal;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionHorizontal::Left => Ok(vec!["Left".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Center => {
                Ok(vec!["Center".into_py(py), ().into_py(py)])
            }
            AzBackgroundPositionHorizontal::Right => Ok(vec!["Right".into_py(py), ().into_py(py)]),
            AzBackgroundPositionHorizontal::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionHorizontalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BackgroundPositionHorizontal = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBackgroundPositionVerticalEnumWrapper {
    #[classattr]
    fn Top() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper {
            inner: AzBackgroundPositionVertical::Top,
        }
    }
    #[classattr]
    fn Center() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper {
            inner: AzBackgroundPositionVertical::Center,
        }
    }
    #[classattr]
    fn Bottom() -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper {
            inner: AzBackgroundPositionVertical::Bottom,
        }
    }
    #[staticmethod]
    fn Exact(v: AzPixelValue) -> AzBackgroundPositionVerticalEnumWrapper {
        AzBackgroundPositionVerticalEnumWrapper {
            inner: AzBackgroundPositionVertical::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzBackgroundPositionVertical;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzBackgroundPositionVertical::Top => Ok(vec!["Top".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Center => Ok(vec!["Center".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Bottom => Ok(vec!["Bottom".into_py(py), ().into_py(py)]),
            AzBackgroundPositionVertical::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBackgroundPositionVerticalEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BackgroundPositionVertical = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPosition {
    #[new]
    fn __new__(
        horizontal: AzBackgroundPositionHorizontalEnumWrapper,
        vertical: AzBackgroundPositionVerticalEnumWrapper,
    ) -> Self {
        Self {
            horizontal,
            vertical,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPosition {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPosition = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPosition = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatEnumWrapper {
    #[classattr]
    fn NoRepeat() -> AzStyleBackgroundRepeatEnumWrapper {
        AzStyleBackgroundRepeatEnumWrapper {
            inner: AzStyleBackgroundRepeat::NoRepeat,
        }
    }
    #[classattr]
    fn Repeat() -> AzStyleBackgroundRepeatEnumWrapper {
        AzStyleBackgroundRepeatEnumWrapper {
            inner: AzStyleBackgroundRepeat::Repeat,
        }
    }
    #[classattr]
    fn RepeatX() -> AzStyleBackgroundRepeatEnumWrapper {
        AzStyleBackgroundRepeatEnumWrapper {
            inner: AzStyleBackgroundRepeat::RepeatX,
        }
    }
    #[classattr]
    fn RepeatY() -> AzStyleBackgroundRepeatEnumWrapper {
        AzStyleBackgroundRepeatEnumWrapper {
            inner: AzStyleBackgroundRepeat::RepeatY,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzStyleBackgroundRepeatEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStyleBackgroundSizeEnumWrapper {
    #[classattr]
    fn Contain() -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper {
            inner: AzStyleBackgroundSize::Contain,
        }
    }
    #[classattr]
    fn Cover() -> AzStyleBackgroundSizeEnumWrapper {
        AzStyleBackgroundSizeEnumWrapper {
            inner: AzStyleBackgroundSize::Cover,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundSize;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSize::ExactSize(v) => {
                Ok(vec!["ExactSize".into_py(py), v.to_vec().into_py(py)])
            }
            AzStyleBackgroundSize::Contain => Ok(vec!["Contain".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSize::Cover => Ok(vec!["Cover".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomColor {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomLeftRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomLeftRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomRightRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomRightRadius {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomRightRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzBorderStyleEnumWrapper {
    #[classattr]
    fn None() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::None,
        }
    }
    #[classattr]
    fn Solid() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Solid,
        }
    }
    #[classattr]
    fn Double() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Double,
        }
    }
    #[classattr]
    fn Dotted() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Dotted,
        }
    }
    #[classattr]
    fn Dashed() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Dashed,
        }
    }
    #[classattr]
    fn Hidden() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Hidden,
        }
    }
    #[classattr]
    fn Groove() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Groove,
        }
    }
    #[classattr]
    fn Ridge() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Ridge,
        }
    }
    #[classattr]
    fn Inset() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Inset,
        }
    }
    #[classattr]
    fn Outset() -> AzBorderStyleEnumWrapper {
        AzBorderStyleEnumWrapper {
            inner: AzBorderStyle::Outset,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzBorderStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BorderStyle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::BorderStyle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzBorderStyleEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStyleBorderBottomStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomStyle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderBottomWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderBottomWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderBottomWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftColor {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftStyle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderLeftWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderLeftWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderLeftWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightColor {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightStyle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderRightWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderRightWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderRightWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderRightWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopColor {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopLeftRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopLeftRadius {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopLeftRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopRightRadius {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopRightRadius {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopRightRadius = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopStyle {
    #[new]
    fn __new__(inner: AzBorderStyleEnumWrapper) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopStyle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderTopWidth {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderTopWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderTopWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderTopWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarInfo {
    #[new]
    fn __new__(
        width: AzLayoutWidth,
        padding_left: AzLayoutPaddingLeft,
        padding_right: AzLayoutPaddingRight,
        track: AzStyleBackgroundContentEnumWrapper,
        thumb: AzStyleBackgroundContentEnumWrapper,
        button: AzStyleBackgroundContentEnumWrapper,
        corner: AzStyleBackgroundContentEnumWrapper,
        resizer: AzStyleBackgroundContentEnumWrapper,
    ) -> Self {
        Self {
            width,
            padding_left,
            padding_right,
            track,
            thumb,
            button,
            corner,
            resizer,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ScrollbarInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ScrollbarInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarStyle {
    #[new]
    fn __new__(horizontal: AzScrollbarInfo, vertical: AzScrollbarInfo) -> Self {
        Self {
            horizontal,
            vertical,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarStyle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ScrollbarStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ScrollbarStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCursorEnumWrapper {
    #[classattr]
    fn Alias() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Alias,
        }
    }
    #[classattr]
    fn AllScroll() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::AllScroll,
        }
    }
    #[classattr]
    fn Cell() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Cell,
        }
    }
    #[classattr]
    fn ColResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::ColResize,
        }
    }
    #[classattr]
    fn ContextMenu() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::ContextMenu,
        }
    }
    #[classattr]
    fn Copy() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Copy,
        }
    }
    #[classattr]
    fn Crosshair() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Crosshair,
        }
    }
    #[classattr]
    fn Default() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Default,
        }
    }
    #[classattr]
    fn EResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::EResize,
        }
    }
    #[classattr]
    fn EwResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::EwResize,
        }
    }
    #[classattr]
    fn Grab() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Grab,
        }
    }
    #[classattr]
    fn Grabbing() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Grabbing,
        }
    }
    #[classattr]
    fn Help() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Help,
        }
    }
    #[classattr]
    fn Move() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Move,
        }
    }
    #[classattr]
    fn NResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::NResize,
        }
    }
    #[classattr]
    fn NsResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::NsResize,
        }
    }
    #[classattr]
    fn NeswResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::NeswResize,
        }
    }
    #[classattr]
    fn NwseResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::NwseResize,
        }
    }
    #[classattr]
    fn Pointer() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Pointer,
        }
    }
    #[classattr]
    fn Progress() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Progress,
        }
    }
    #[classattr]
    fn RowResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::RowResize,
        }
    }
    #[classattr]
    fn SResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::SResize,
        }
    }
    #[classattr]
    fn SeResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::SeResize,
        }
    }
    #[classattr]
    fn Text() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Text,
        }
    }
    #[classattr]
    fn Unset() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Unset,
        }
    }
    #[classattr]
    fn VerticalText() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::VerticalText,
        }
    }
    #[classattr]
    fn WResize() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::WResize,
        }
    }
    #[classattr]
    fn Wait() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::Wait,
        }
    }
    #[classattr]
    fn ZoomIn() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::ZoomIn,
        }
    }
    #[classattr]
    fn ZoomOut() -> AzStyleCursorEnumWrapper {
        AzStyleCursorEnumWrapper {
            inner: AzStyleCursor::ZoomOut,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCursorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleCursor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleCursor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzStyleCursorEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStyleFontFamilyEnumWrapper {
    #[staticmethod]
    fn System(v: AzString) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper {
            inner: AzStyleFontFamily::System(v),
        }
    }
    #[staticmethod]
    fn File(v: AzString) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper {
            inner: AzStyleFontFamily::File(v),
        }
    }
    #[staticmethod]
    fn Ref(v: AzFontRef) -> AzStyleFontFamilyEnumWrapper {
        AzStyleFontFamilyEnumWrapper {
            inner: AzStyleFontFamily::Ref(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleFontFamily;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamily::System(v) => Ok(vec!["System".into_py(py), v.clone().into_py(py)]),
            AzStyleFontFamily::File(v) => Ok(vec!["File".into_py(py), v.clone().into_py(py)]),
            AzStyleFontFamily::Ref(v) => Ok(vec!["Ref".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamily = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamily = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontSize {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontSize {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontSize = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLetterSpacing {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLetterSpacing {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLetterSpacing = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLetterSpacing = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLineHeight {
    #[new]
    fn __new__(inner: AzPercentageValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLineHeight {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLineHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLineHeight = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTabWidth {
    #[new]
    fn __new__(inner: AzPercentageValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTabWidth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTabWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTabWidth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleOpacity {
    #[new]
    fn __new__(inner: AzPercentageValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleOpacity {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleOpacity = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleOpacity = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformOrigin {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformOrigin {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformOrigin = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformOrigin = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylePerspectiveOrigin {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylePerspectiveOrigin {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformOrigin = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformOrigin = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackfaceVisibilityEnumWrapper {
    #[classattr]
    fn Hidden() -> AzStyleBackfaceVisibilityEnumWrapper {
        AzStyleBackfaceVisibilityEnumWrapper {
            inner: AzStyleBackfaceVisibility::Hidden,
        }
    }
    #[classattr]
    fn Visible() -> AzStyleBackfaceVisibilityEnumWrapper {
        AzStyleBackfaceVisibilityEnumWrapper {
            inner: AzStyleBackfaceVisibility::Visible,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackfaceVisibilityEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackfaceVisibility = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzStyleBackfaceVisibilityEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStyleTransformEnumWrapper {
    #[staticmethod]
    fn Matrix(v: AzStyleTransformMatrix2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Matrix(v),
        }
    }
    #[staticmethod]
    fn Matrix3D(v: AzStyleTransformMatrix3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Matrix3D(v),
        }
    }
    #[staticmethod]
    fn Translate(v: AzStyleTransformTranslate2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Translate(v),
        }
    }
    #[staticmethod]
    fn Translate3D(v: AzStyleTransformTranslate3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Translate3D(v),
        }
    }
    #[staticmethod]
    fn TranslateX(v: AzPixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::TranslateX(v),
        }
    }
    #[staticmethod]
    fn TranslateY(v: AzPixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::TranslateY(v),
        }
    }
    #[staticmethod]
    fn TranslateZ(v: AzPixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::TranslateZ(v),
        }
    }
    #[staticmethod]
    fn Rotate(v: AzAngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Rotate(v),
        }
    }
    #[staticmethod]
    fn Rotate3D(v: AzStyleTransformRotate3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Rotate3D(v),
        }
    }
    #[staticmethod]
    fn RotateX(v: AzAngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::RotateX(v),
        }
    }
    #[staticmethod]
    fn RotateY(v: AzAngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::RotateY(v),
        }
    }
    #[staticmethod]
    fn RotateZ(v: AzAngleValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::RotateZ(v),
        }
    }
    #[staticmethod]
    fn Scale(v: AzStyleTransformScale2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Scale(v),
        }
    }
    #[staticmethod]
    fn Scale3D(v: AzStyleTransformScale3D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Scale3D(v),
        }
    }
    #[staticmethod]
    fn ScaleX(v: AzPercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::ScaleX(v),
        }
    }
    #[staticmethod]
    fn ScaleY(v: AzPercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::ScaleY(v),
        }
    }
    #[staticmethod]
    fn ScaleZ(v: AzPercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::ScaleZ(v),
        }
    }
    #[staticmethod]
    fn Skew(v: AzStyleTransformSkew2D) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Skew(v),
        }
    }
    #[staticmethod]
    fn SkewX(v: AzPercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::SkewX(v),
        }
    }
    #[staticmethod]
    fn SkewY(v: AzPercentageValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::SkewY(v),
        }
    }
    #[staticmethod]
    fn Perspective(v: AzPixelValue) -> AzStyleTransformEnumWrapper {
        AzStyleTransformEnumWrapper {
            inner: AzStyleTransform::Perspective(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleTransform;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransform::Matrix(v) => Ok(vec!["Matrix".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Matrix3D(v) => {
                Ok(vec!["Matrix3D".into_py(py), v.clone().into_py(py)])
            }
            AzStyleTransform::Translate(v) => {
                Ok(vec!["Translate".into_py(py), v.clone().into_py(py)])
            }
            AzStyleTransform::Translate3D(v) => {
                Ok(vec!["Translate3D".into_py(py), v.clone().into_py(py)])
            }
            AzStyleTransform::TranslateX(v) => {
                Ok(vec!["TranslateX".into_py(py), v.clone().into_py(py)])
            }
            AzStyleTransform::TranslateY(v) => {
                Ok(vec!["TranslateY".into_py(py), v.clone().into_py(py)])
            }
            AzStyleTransform::TranslateZ(v) => {
                Ok(vec!["TranslateZ".into_py(py), v.clone().into_py(py)])
            }
            AzStyleTransform::Rotate(v) => Ok(vec!["Rotate".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Rotate3D(v) => {
                Ok(vec!["Rotate3D".into_py(py), v.clone().into_py(py)])
            }
            AzStyleTransform::RotateX(v) => Ok(vec!["RotateX".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::RotateY(v) => Ok(vec!["RotateY".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::RotateZ(v) => Ok(vec!["RotateZ".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Scale(v) => Ok(vec!["Scale".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Scale3D(v) => Ok(vec!["Scale3D".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::ScaleX(v) => Ok(vec!["ScaleX".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::ScaleY(v) => Ok(vec!["ScaleY".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::ScaleZ(v) => Ok(vec!["ScaleZ".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Skew(v) => Ok(vec!["Skew".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::SkewX(v) => Ok(vec!["SkewX".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::SkewY(v) => Ok(vec!["SkewY".into_py(py), v.clone().into_py(py)]),
            AzStyleTransform::Perspective(v) => {
                Ok(vec!["Perspective".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransform = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransform = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix2D {
    #[new]
    fn __new__(
        a: AzPixelValue,
        b: AzPixelValue,
        c: AzPixelValue,
        d: AzPixelValue,
        tx: AzPixelValue,
        ty: AzPixelValue,
    ) -> Self {
        Self { a, b, c, d, tx, ty }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix2D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformMatrix2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformMatrix2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformMatrix3D {
    #[new]
    fn __new__(
        m11: AzPixelValue,
        m12: AzPixelValue,
        m13: AzPixelValue,
        m14: AzPixelValue,
        m21: AzPixelValue,
        m22: AzPixelValue,
        m23: AzPixelValue,
        m24: AzPixelValue,
        m31: AzPixelValue,
        m32: AzPixelValue,
        m33: AzPixelValue,
        m34: AzPixelValue,
        m41: AzPixelValue,
        m42: AzPixelValue,
        m43: AzPixelValue,
        m44: AzPixelValue,
    ) -> Self {
        Self {
            m11,
            m12,
            m13,
            m14,
            m21,
            m22,
            m23,
            m24,
            m31,
            m32,
            m33,
            m34,
            m41,
            m42,
            m43,
            m44,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformMatrix3D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformMatrix3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformMatrix3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate2D {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate2D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformTranslate2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformTranslate2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformTranslate3D {
    #[new]
    fn __new__(x: AzPixelValue, y: AzPixelValue, z: AzPixelValue) -> Self {
        Self { x, y, z }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformTranslate3D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformTranslate3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformTranslate3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformRotate3D {
    #[new]
    fn __new__(
        x: AzPercentageValue,
        y: AzPercentageValue,
        z: AzPercentageValue,
        angle: AzAngleValue,
    ) -> Self {
        Self { x, y, z, angle }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformRotate3D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformRotate3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformRotate3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale2D {
    #[new]
    fn __new__(x: AzPercentageValue, y: AzPercentageValue) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale2D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformScale2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformScale2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformScale3D {
    #[new]
    fn __new__(x: AzPercentageValue, y: AzPercentageValue, z: AzPercentageValue) -> Self {
        Self { x, y, z }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformScale3D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformScale3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformScale3D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformSkew2D {
    #[new]
    fn __new__(x: AzPercentageValue, y: AzPercentageValue) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformSkew2D {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformSkew2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformSkew2D = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextAlignEnumWrapper {
    #[classattr]
    fn Left() -> AzStyleTextAlignEnumWrapper {
        AzStyleTextAlignEnumWrapper {
            inner: AzStyleTextAlign::Left,
        }
    }
    #[classattr]
    fn Center() -> AzStyleTextAlignEnumWrapper {
        AzStyleTextAlignEnumWrapper {
            inner: AzStyleTextAlign::Center,
        }
    }
    #[classattr]
    fn Right() -> AzStyleTextAlignEnumWrapper {
        AzStyleTextAlignEnumWrapper {
            inner: AzStyleTextAlign::Right,
        }
    }
    #[classattr]
    fn Justify() -> AzStyleTextAlignEnumWrapper {
        AzStyleTextAlignEnumWrapper {
            inner: AzStyleTextAlign::Justify,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextAlignEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextAlign = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextAlign = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzStyleTextAlignEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzStyleTextColor {
    #[new]
    fn __new__(inner: AzColorU) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextColor {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextColor = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWordSpacing {
    #[new]
    fn __new__(inner: AzPixelValue) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleWordSpacing {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleWordSpacing = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleWordSpacing = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBoxShadowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper {
            inner: AzStyleBoxShadowValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper {
            inner: AzStyleBoxShadowValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper {
            inner: AzStyleBoxShadowValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper {
            inner: AzStyleBoxShadowValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBoxShadow) -> AzStyleBoxShadowValueEnumWrapper {
        AzStyleBoxShadowValueEnumWrapper {
            inner: AzStyleBoxShadowValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBoxShadowValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBoxShadowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBoxShadowValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBoxShadowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBoxShadowValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBoxShadowValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignContentValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper {
            inner: AzLayoutAlignContentValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper {
            inner: AzLayoutAlignContentValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper {
            inner: AzLayoutAlignContentValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper {
            inner: AzLayoutAlignContentValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutAlignContentEnumWrapper) -> AzLayoutAlignContentValueEnumWrapper {
        AzLayoutAlignContentValueEnumWrapper {
            inner: AzLayoutAlignContentValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutAlignContentValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutAlignContentValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutAlignContentValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutAlignContentEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignContentValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignContentValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignContentValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutAlignItemsValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper {
            inner: AzLayoutAlignItemsValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper {
            inner: AzLayoutAlignItemsValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper {
            inner: AzLayoutAlignItemsValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper {
            inner: AzLayoutAlignItemsValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutAlignItemsEnumWrapper) -> AzLayoutAlignItemsValueEnumWrapper {
        AzLayoutAlignItemsValueEnumWrapper {
            inner: AzLayoutAlignItemsValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutAlignItemsValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutAlignItemsValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutAlignItemsValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutAlignItemsEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutAlignItemsValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignItemsValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutAlignItemsValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper {
            inner: AzLayoutBottomValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper {
            inner: AzLayoutBottomValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper {
            inner: AzLayoutBottomValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper {
            inner: AzLayoutBottomValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutBottom) -> AzLayoutBottomValueEnumWrapper {
        AzLayoutBottomValueEnumWrapper {
            inner: AzLayoutBottomValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutBottomValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBottomValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBottomValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBottomValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBoxSizingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper {
            inner: AzLayoutBoxSizingValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper {
            inner: AzLayoutBoxSizingValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper {
            inner: AzLayoutBoxSizingValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper {
            inner: AzLayoutBoxSizingValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutBoxSizingEnumWrapper) -> AzLayoutBoxSizingValueEnumWrapper {
        AzLayoutBoxSizingValueEnumWrapper {
            inner: AzLayoutBoxSizingValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutBoxSizingValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBoxSizingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBoxSizingValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutBoxSizingEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBoxSizingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBoxSizingValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBoxSizingValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexDirectionValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper {
            inner: AzLayoutFlexDirectionValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper {
            inner: AzLayoutFlexDirectionValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper {
            inner: AzLayoutFlexDirectionValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper {
            inner: AzLayoutFlexDirectionValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexDirectionEnumWrapper) -> AzLayoutFlexDirectionValueEnumWrapper {
        AzLayoutFlexDirectionValueEnumWrapper {
            inner: AzLayoutFlexDirectionValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutFlexDirectionValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexDirectionValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexDirectionValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutFlexDirectionEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexDirectionValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexDirectionValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexDirectionValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutDisplayValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper {
            inner: AzLayoutDisplayValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper {
            inner: AzLayoutDisplayValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper {
            inner: AzLayoutDisplayValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper {
            inner: AzLayoutDisplayValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutDisplayEnumWrapper) -> AzLayoutDisplayValueEnumWrapper {
        AzLayoutDisplayValueEnumWrapper {
            inner: AzLayoutDisplayValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutDisplayValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutDisplayValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutDisplayValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutDisplayEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutDisplayValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutDisplayValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutDisplayValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexGrowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper {
            inner: AzLayoutFlexGrowValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper {
            inner: AzLayoutFlexGrowValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper {
            inner: AzLayoutFlexGrowValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper {
            inner: AzLayoutFlexGrowValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexGrow) -> AzLayoutFlexGrowValueEnumWrapper {
        AzLayoutFlexGrowValueEnumWrapper {
            inner: AzLayoutFlexGrowValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutFlexGrowValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexGrowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexGrowValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexGrowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexGrowValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexGrowValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexShrinkValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper {
            inner: AzLayoutFlexShrinkValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper {
            inner: AzLayoutFlexShrinkValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper {
            inner: AzLayoutFlexShrinkValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper {
            inner: AzLayoutFlexShrinkValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexShrink) -> AzLayoutFlexShrinkValueEnumWrapper {
        AzLayoutFlexShrinkValueEnumWrapper {
            inner: AzLayoutFlexShrinkValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutFlexShrinkValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexShrinkValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexShrinkValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexShrinkValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexShrinkValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexShrinkValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFloatValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper {
            inner: AzLayoutFloatValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper {
            inner: AzLayoutFloatValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper {
            inner: AzLayoutFloatValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper {
            inner: AzLayoutFloatValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutFloatEnumWrapper) -> AzLayoutFloatValueEnumWrapper {
        AzLayoutFloatValueEnumWrapper {
            inner: AzLayoutFloatValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutFloatValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFloatValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFloatValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutFloatEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFloatValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFloatValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFloatValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper {
            inner: AzLayoutHeightValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper {
            inner: AzLayoutHeightValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper {
            inner: AzLayoutHeightValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper {
            inner: AzLayoutHeightValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutHeight) -> AzLayoutHeightValueEnumWrapper {
        AzLayoutHeightValueEnumWrapper {
            inner: AzLayoutHeightValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutHeightValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutHeightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutJustifyContentValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper {
            inner: AzLayoutJustifyContentValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper {
            inner: AzLayoutJustifyContentValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper {
            inner: AzLayoutJustifyContentValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper {
            inner: AzLayoutJustifyContentValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutJustifyContentEnumWrapper) -> AzLayoutJustifyContentValueEnumWrapper {
        AzLayoutJustifyContentValueEnumWrapper {
            inner: AzLayoutJustifyContentValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutJustifyContentValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutJustifyContentValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutJustifyContentValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutJustifyContentEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutJustifyContentValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutJustifyContentValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutJustifyContentValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper {
            inner: AzLayoutLeftValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper {
            inner: AzLayoutLeftValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper {
            inner: AzLayoutLeftValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper {
            inner: AzLayoutLeftValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutLeft) -> AzLayoutLeftValueEnumWrapper {
        AzLayoutLeftValueEnumWrapper {
            inner: AzLayoutLeftValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutLeftValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutLeftValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutLeftValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutLeftValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper {
            inner: AzLayoutMarginBottomValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper {
            inner: AzLayoutMarginBottomValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper {
            inner: AzLayoutMarginBottomValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper {
            inner: AzLayoutMarginBottomValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginBottom) -> AzLayoutMarginBottomValueEnumWrapper {
        AzLayoutMarginBottomValueEnumWrapper {
            inner: AzLayoutMarginBottomValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMarginBottomValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginBottomValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginBottomValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginBottomValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper {
            inner: AzLayoutMarginLeftValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper {
            inner: AzLayoutMarginLeftValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper {
            inner: AzLayoutMarginLeftValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper {
            inner: AzLayoutMarginLeftValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginLeft) -> AzLayoutMarginLeftValueEnumWrapper {
        AzLayoutMarginLeftValueEnumWrapper {
            inner: AzLayoutMarginLeftValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMarginLeftValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginLeftValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginLeftValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginLeftValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper {
            inner: AzLayoutMarginRightValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper {
            inner: AzLayoutMarginRightValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper {
            inner: AzLayoutMarginRightValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper {
            inner: AzLayoutMarginRightValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginRight) -> AzLayoutMarginRightValueEnumWrapper {
        AzLayoutMarginRightValueEnumWrapper {
            inner: AzLayoutMarginRightValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMarginRightValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginRightValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginRightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginRightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMarginTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper {
            inner: AzLayoutMarginTopValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper {
            inner: AzLayoutMarginTopValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper {
            inner: AzLayoutMarginTopValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper {
            inner: AzLayoutMarginTopValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMarginTop) -> AzLayoutMarginTopValueEnumWrapper {
        AzLayoutMarginTopValueEnumWrapper {
            inner: AzLayoutMarginTopValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMarginTopValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMarginTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMarginTopValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMarginTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginTopValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMarginTopValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper {
            inner: AzLayoutMaxHeightValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper {
            inner: AzLayoutMaxHeightValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper {
            inner: AzLayoutMaxHeightValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper {
            inner: AzLayoutMaxHeightValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMaxHeight) -> AzLayoutMaxHeightValueEnumWrapper {
        AzLayoutMaxHeightValueEnumWrapper {
            inner: AzLayoutMaxHeightValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMaxHeightValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMaxHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMaxHeightValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMaxWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper {
            inner: AzLayoutMaxWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper {
            inner: AzLayoutMaxWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper {
            inner: AzLayoutMaxWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper {
            inner: AzLayoutMaxWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMaxWidth) -> AzLayoutMaxWidthValueEnumWrapper {
        AzLayoutMaxWidthValueEnumWrapper {
            inner: AzLayoutMaxWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMaxWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMaxWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMaxWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMaxWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMaxWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper {
            inner: AzLayoutMinHeightValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper {
            inner: AzLayoutMinHeightValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper {
            inner: AzLayoutMinHeightValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper {
            inner: AzLayoutMinHeightValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMinHeight) -> AzLayoutMinHeightValueEnumWrapper {
        AzLayoutMinHeightValueEnumWrapper {
            inner: AzLayoutMinHeightValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMinHeightValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMinHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMinHeightValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutMinWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper {
            inner: AzLayoutMinWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper {
            inner: AzLayoutMinWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper {
            inner: AzLayoutMinWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper {
            inner: AzLayoutMinWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutMinWidth) -> AzLayoutMinWidthValueEnumWrapper {
        AzLayoutMinWidthValueEnumWrapper {
            inner: AzLayoutMinWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutMinWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutMinWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutMinWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutMinWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutMinWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingBottomValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper {
            inner: AzLayoutPaddingBottomValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper {
            inner: AzLayoutPaddingBottomValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper {
            inner: AzLayoutPaddingBottomValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper {
            inner: AzLayoutPaddingBottomValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingBottom) -> AzLayoutPaddingBottomValueEnumWrapper {
        AzLayoutPaddingBottomValueEnumWrapper {
            inner: AzLayoutPaddingBottomValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutPaddingBottomValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingBottomValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingBottomValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingBottomValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingBottomValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingBottomValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingLeftValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper {
            inner: AzLayoutPaddingLeftValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper {
            inner: AzLayoutPaddingLeftValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper {
            inner: AzLayoutPaddingLeftValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper {
            inner: AzLayoutPaddingLeftValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingLeft) -> AzLayoutPaddingLeftValueEnumWrapper {
        AzLayoutPaddingLeftValueEnumWrapper {
            inner: AzLayoutPaddingLeftValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutPaddingLeftValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingLeftValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingLeftValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingLeftValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingLeftValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingLeftValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper {
            inner: AzLayoutPaddingRightValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper {
            inner: AzLayoutPaddingRightValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper {
            inner: AzLayoutPaddingRightValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper {
            inner: AzLayoutPaddingRightValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingRight) -> AzLayoutPaddingRightValueEnumWrapper {
        AzLayoutPaddingRightValueEnumWrapper {
            inner: AzLayoutPaddingRightValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutPaddingRightValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingRightValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingRightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingRightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPaddingTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper {
            inner: AzLayoutPaddingTopValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper {
            inner: AzLayoutPaddingTopValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper {
            inner: AzLayoutPaddingTopValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper {
            inner: AzLayoutPaddingTopValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutPaddingTop) -> AzLayoutPaddingTopValueEnumWrapper {
        AzLayoutPaddingTopValueEnumWrapper {
            inner: AzLayoutPaddingTopValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutPaddingTopValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPaddingTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPaddingTopValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPaddingTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingTopValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPaddingTopValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutPositionValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper {
            inner: AzLayoutPositionValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper {
            inner: AzLayoutPositionValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper {
            inner: AzLayoutPositionValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper {
            inner: AzLayoutPositionValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutPositionEnumWrapper) -> AzLayoutPositionValueEnumWrapper {
        AzLayoutPositionValueEnumWrapper {
            inner: AzLayoutPositionValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutPositionValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutPositionValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutPositionValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutPositionEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutPositionValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPositionValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutPositionValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutRightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper {
            inner: AzLayoutRightValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper {
            inner: AzLayoutRightValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper {
            inner: AzLayoutRightValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper {
            inner: AzLayoutRightValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutRight) -> AzLayoutRightValueEnumWrapper {
        AzLayoutRightValueEnumWrapper {
            inner: AzLayoutRightValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutRightValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutRightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutRightValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutRightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutRightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutRightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutTopValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper {
            inner: AzLayoutTopValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper {
            inner: AzLayoutTopValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper {
            inner: AzLayoutTopValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper {
            inner: AzLayoutTopValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutTop) -> AzLayoutTopValueEnumWrapper {
        AzLayoutTopValueEnumWrapper {
            inner: AzLayoutTopValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutTopValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutTopValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutTopValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutTopValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutTopValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutTopValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper {
            inner: AzLayoutWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper {
            inner: AzLayoutWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper {
            inner: AzLayoutWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper {
            inner: AzLayoutWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutWidth) -> AzLayoutWidthValueEnumWrapper {
        AzLayoutWidthValueEnumWrapper {
            inner: AzLayoutWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutFlexWrapValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper {
            inner: AzLayoutFlexWrapValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper {
            inner: AzLayoutFlexWrapValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper {
            inner: AzLayoutFlexWrapValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper {
            inner: AzLayoutFlexWrapValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutFlexWrapEnumWrapper) -> AzLayoutFlexWrapValueEnumWrapper {
        AzLayoutFlexWrapValueEnumWrapper {
            inner: AzLayoutFlexWrapValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutFlexWrapValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutFlexWrapValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutFlexWrapValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutFlexWrapEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutFlexWrapValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexWrapValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutFlexWrapValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutOverflowValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper {
            inner: AzLayoutOverflowValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper {
            inner: AzLayoutOverflowValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper {
            inner: AzLayoutOverflowValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper {
            inner: AzLayoutOverflowValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutOverflowEnumWrapper) -> AzLayoutOverflowValueEnumWrapper {
        AzLayoutOverflowValueEnumWrapper {
            inner: AzLayoutOverflowValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutOverflowValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutOverflowValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutOverflowValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzLayoutOverflowEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutOverflowValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutOverflowValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutOverflowValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScrollbarStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper {
            inner: AzScrollbarStyleValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper {
            inner: AzScrollbarStyleValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper {
            inner: AzScrollbarStyleValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper {
            inner: AzScrollbarStyleValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzScrollbarStyle) -> AzScrollbarStyleValueEnumWrapper {
        AzScrollbarStyleValueEnumWrapper {
            inner: AzScrollbarStyleValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzScrollbarStyleValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzScrollbarStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzScrollbarStyleValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScrollbarStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ScrollbarStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::ScrollbarStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper {
            inner: AzStyleBackgroundContentVecValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper {
            inner: AzStyleBackgroundContentVecValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper {
            inner: AzStyleBackgroundContentVecValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper {
            inner: AzStyleBackgroundContentVecValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundContentVec) -> AzStyleBackgroundContentVecValueEnumWrapper {
        AzStyleBackgroundContentVecValueEnumWrapper {
            inner: AzStyleBackgroundContentVecValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundContentVecValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContentVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundContentVecValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundContentVecValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundContentVecValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContentVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContentVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper {
            inner: AzStyleBackgroundPositionVecValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper {
            inner: AzStyleBackgroundPositionVecValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper {
            inner: AzStyleBackgroundPositionVecValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper {
            inner: AzStyleBackgroundPositionVecValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundPositionVec) -> AzStyleBackgroundPositionVecValueEnumWrapper {
        AzStyleBackgroundPositionVecValueEnumWrapper {
            inner: AzStyleBackgroundPositionVecValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundPositionVecValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundPositionVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundPositionVecValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundPositionVecValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundPositionVecValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPositionVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPositionVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper {
            inner: AzStyleBackgroundRepeatVecValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper {
            inner: AzStyleBackgroundRepeatVecValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper {
            inner: AzStyleBackgroundRepeatVecValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper {
            inner: AzStyleBackgroundRepeatVecValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundRepeatVec) -> AzStyleBackgroundRepeatVecValueEnumWrapper {
        AzStyleBackgroundRepeatVecValueEnumWrapper {
            inner: AzStyleBackgroundRepeatVecValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundRepeatVecValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundRepeatVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundRepeatVecValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundRepeatVecValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundRepeatVecValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeatVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper {
            inner: AzStyleBackgroundSizeVecValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper {
            inner: AzStyleBackgroundSizeVecValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper {
            inner: AzStyleBackgroundSizeVecValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper {
            inner: AzStyleBackgroundSizeVecValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBackgroundSizeVec) -> AzStyleBackgroundSizeVecValueEnumWrapper {
        AzStyleBackgroundSizeVecValueEnumWrapper {
            inner: AzStyleBackgroundSizeVecValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundSizeVecValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSizeVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackgroundSizeVecValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundSizeVecValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundSizeVecValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSizeVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSizeVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper {
            inner: AzStyleBorderBottomColorValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper {
            inner: AzStyleBorderBottomColorValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper {
            inner: AzStyleBorderBottomColorValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper {
            inner: AzStyleBorderBottomColorValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomColor) -> AzStyleBorderBottomColorValueEnumWrapper {
        AzStyleBorderBottomColorValueEnumWrapper {
            inner: AzStyleBorderBottomColorValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderBottomColorValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomColorValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomColorValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomColorValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomLeftRadiusValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomLeftRadiusValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomLeftRadiusValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomLeftRadiusValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomLeftRadius) -> AzStyleBorderBottomLeftRadiusValueEnumWrapper {
        AzStyleBorderBottomLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomLeftRadiusValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderBottomLeftRadiusValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomLeftRadiusValue::Auto => {
                Ok(vec!["Auto".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomLeftRadiusValue::None => {
                Ok(vec!["None".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomLeftRadiusValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomLeftRadiusValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomLeftRadiusValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomLeftRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomLeftRadiusValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomRightRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomRightRadiusValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomRightRadiusValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomRightRadiusValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomRightRadiusValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomRightRadius) -> AzStyleBorderBottomRightRadiusValueEnumWrapper {
        AzStyleBorderBottomRightRadiusValueEnumWrapper {
            inner: AzStyleBorderBottomRightRadiusValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderBottomRightRadiusValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomRightRadiusValue::Auto => {
                Ok(vec!["Auto".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomRightRadiusValue::None => {
                Ok(vec!["None".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomRightRadiusValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomRightRadiusValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomRightRadiusValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomRightRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomRightRadiusValue =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomRightRadiusValue =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderBottomStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper {
            inner: AzStyleBorderBottomStyleValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper {
            inner: AzStyleBorderBottomStyleValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper {
            inner: AzStyleBorderBottomStyleValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper {
            inner: AzStyleBorderBottomStyleValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderBottomStyle) -> AzStyleBorderBottomStyleValueEnumWrapper {
        AzStyleBorderBottomStyleValueEnumWrapper {
            inner: AzStyleBorderBottomStyleValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderBottomStyleValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderBottomStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderBottomStyleValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomStyleValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderBottomStyleValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderBottomStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderBottomStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderBottomWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper {
            inner: AzLayoutBorderBottomWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper {
            inner: AzLayoutBorderBottomWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper {
            inner: AzLayoutBorderBottomWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper {
            inner: AzLayoutBorderBottomWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderBottomWidth) -> AzLayoutBorderBottomWidthValueEnumWrapper {
        AzLayoutBorderBottomWidthValueEnumWrapper {
            inner: AzLayoutBorderBottomWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutBorderBottomWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderBottomWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderBottomWidthValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzLayoutBorderBottomWidthValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzLayoutBorderBottomWidthValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderBottomWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderBottomWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderBottomWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper {
            inner: AzStyleBorderLeftColorValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper {
            inner: AzStyleBorderLeftColorValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper {
            inner: AzStyleBorderLeftColorValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper {
            inner: AzStyleBorderLeftColorValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderLeftColor) -> AzStyleBorderLeftColorValueEnumWrapper {
        AzStyleBorderLeftColorValueEnumWrapper {
            inner: AzStyleBorderLeftColorValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderLeftColorValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderLeftColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftColorValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderLeftStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper {
            inner: AzStyleBorderLeftStyleValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper {
            inner: AzStyleBorderLeftStyleValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper {
            inner: AzStyleBorderLeftStyleValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper {
            inner: AzStyleBorderLeftStyleValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderLeftStyle) -> AzStyleBorderLeftStyleValueEnumWrapper {
        AzStyleBorderLeftStyleValueEnumWrapper {
            inner: AzStyleBorderLeftStyleValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderLeftStyleValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderLeftStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderLeftStyleValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderLeftStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderLeftStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderLeftWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper {
            inner: AzLayoutBorderLeftWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper {
            inner: AzLayoutBorderLeftWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper {
            inner: AzLayoutBorderLeftWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper {
            inner: AzLayoutBorderLeftWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderLeftWidth) -> AzLayoutBorderLeftWidthValueEnumWrapper {
        AzLayoutBorderLeftWidthValueEnumWrapper {
            inner: AzLayoutBorderLeftWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutBorderLeftWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderLeftWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderLeftWidthValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzLayoutBorderLeftWidthValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzLayoutBorderLeftWidthValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderLeftWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderLeftWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderLeftWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper {
            inner: AzStyleBorderRightColorValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper {
            inner: AzStyleBorderRightColorValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper {
            inner: AzStyleBorderRightColorValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper {
            inner: AzStyleBorderRightColorValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderRightColor) -> AzStyleBorderRightColorValueEnumWrapper {
        AzStyleBorderRightColorValueEnumWrapper {
            inner: AzStyleBorderRightColorValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderRightColorValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderRightColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderRightColorValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderRightColorValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderRightColorValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderRightStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper {
            inner: AzStyleBorderRightStyleValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper {
            inner: AzStyleBorderRightStyleValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper {
            inner: AzStyleBorderRightStyleValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper {
            inner: AzStyleBorderRightStyleValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderRightStyle) -> AzStyleBorderRightStyleValueEnumWrapper {
        AzStyleBorderRightStyleValueEnumWrapper {
            inner: AzStyleBorderRightStyleValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderRightStyleValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderRightStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderRightStyleValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderRightStyleValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderRightStyleValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderRightStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderRightStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderRightWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper {
            inner: AzLayoutBorderRightWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper {
            inner: AzLayoutBorderRightWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper {
            inner: AzLayoutBorderRightWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper {
            inner: AzLayoutBorderRightWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderRightWidth) -> AzLayoutBorderRightWidthValueEnumWrapper {
        AzLayoutBorderRightWidthValueEnumWrapper {
            inner: AzLayoutBorderRightWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutBorderRightWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderRightWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderRightWidthValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzLayoutBorderRightWidthValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzLayoutBorderRightWidthValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderRightWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderRightWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderRightWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper {
            inner: AzStyleBorderTopColorValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper {
            inner: AzStyleBorderTopColorValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper {
            inner: AzStyleBorderTopColorValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper {
            inner: AzStyleBorderTopColorValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopColor) -> AzStyleBorderTopColorValueEnumWrapper {
        AzStyleBorderTopColorValueEnumWrapper {
            inner: AzStyleBorderTopColorValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderTopColorValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopColorValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopLeftRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderTopLeftRadiusValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderTopLeftRadiusValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderTopLeftRadiusValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderTopLeftRadiusValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopLeftRadius) -> AzStyleBorderTopLeftRadiusValueEnumWrapper {
        AzStyleBorderTopLeftRadiusValueEnumWrapper {
            inner: AzStyleBorderTopLeftRadiusValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderTopLeftRadiusValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopLeftRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopLeftRadiusValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderTopLeftRadiusValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderTopLeftRadiusValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopLeftRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopLeftRadiusValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopRightRadiusValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper {
            inner: AzStyleBorderTopRightRadiusValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper {
            inner: AzStyleBorderTopRightRadiusValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper {
            inner: AzStyleBorderTopRightRadiusValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper {
            inner: AzStyleBorderTopRightRadiusValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopRightRadius) -> AzStyleBorderTopRightRadiusValueEnumWrapper {
        AzStyleBorderTopRightRadiusValueEnumWrapper {
            inner: AzStyleBorderTopRightRadiusValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderTopRightRadiusValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopRightRadiusValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopRightRadiusValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBorderTopRightRadiusValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBorderTopRightRadiusValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopRightRadiusValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopRightRadiusValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBorderTopStyleValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper {
            inner: AzStyleBorderTopStyleValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper {
            inner: AzStyleBorderTopStyleValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper {
            inner: AzStyleBorderTopStyleValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper {
            inner: AzStyleBorderTopStyleValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBorderTopStyle) -> AzStyleBorderTopStyleValueEnumWrapper {
        AzStyleBorderTopStyleValueEnumWrapper {
            inner: AzStyleBorderTopStyleValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBorderTopStyleValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBorderTopStyleValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleBorderTopStyleValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBorderTopStyleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBorderTopStyleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLayoutBorderTopWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper {
            inner: AzLayoutBorderTopWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper {
            inner: AzLayoutBorderTopWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper {
            inner: AzLayoutBorderTopWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper {
            inner: AzLayoutBorderTopWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzLayoutBorderTopWidth) -> AzLayoutBorderTopWidthValueEnumWrapper {
        AzLayoutBorderTopWidthValueEnumWrapper {
            inner: AzLayoutBorderTopWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLayoutBorderTopWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLayoutBorderTopWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzLayoutBorderTopWidthValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLayoutBorderTopWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderTopWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::LayoutBorderTopWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleCursorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper {
            inner: AzStyleCursorValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper {
            inner: AzStyleCursorValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper {
            inner: AzStyleCursorValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper {
            inner: AzStyleCursorValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleCursorEnumWrapper) -> AzStyleCursorValueEnumWrapper {
        AzStyleCursorValueEnumWrapper {
            inner: AzStyleCursorValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleCursorValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleCursorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleCursorValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzStyleCursorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleCursorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleCursorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleCursorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper {
            inner: AzStyleFontFamilyVecValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper {
            inner: AzStyleFontFamilyVecValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper {
            inner: AzStyleFontFamilyVecValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper {
            inner: AzStyleFontFamilyVecValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleFontFamilyVec) -> AzStyleFontFamilyVecValueEnumWrapper {
        AzStyleFontFamilyVecValueEnumWrapper {
            inner: AzStyleFontFamilyVecValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleFontFamilyVecValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamilyVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFontFamilyVecValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamilyVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamilyVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontSizeValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper {
            inner: AzStyleFontSizeValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper {
            inner: AzStyleFontSizeValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper {
            inner: AzStyleFontSizeValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper {
            inner: AzStyleFontSizeValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleFontSize) -> AzStyleFontSizeValueEnumWrapper {
        AzStyleFontSizeValueEnumWrapper {
            inner: AzStyleFontSizeValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleFontSizeValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontSizeValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFontSizeValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontSizeValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontSizeValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontSizeValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLetterSpacingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper {
            inner: AzStyleLetterSpacingValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper {
            inner: AzStyleLetterSpacingValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper {
            inner: AzStyleLetterSpacingValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper {
            inner: AzStyleLetterSpacingValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleLetterSpacing) -> AzStyleLetterSpacingValueEnumWrapper {
        AzStyleLetterSpacingValueEnumWrapper {
            inner: AzStyleLetterSpacingValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleLetterSpacingValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleLetterSpacingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleLetterSpacingValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLetterSpacingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLetterSpacingValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLetterSpacingValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleLineHeightValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper {
            inner: AzStyleLineHeightValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper {
            inner: AzStyleLineHeightValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper {
            inner: AzStyleLineHeightValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper {
            inner: AzStyleLineHeightValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleLineHeight) -> AzStyleLineHeightValueEnumWrapper {
        AzStyleLineHeightValueEnumWrapper {
            inner: AzStyleLineHeightValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleLineHeightValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleLineHeightValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleLineHeightValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleLineHeightValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLineHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleLineHeightValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTabWidthValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper {
            inner: AzStyleTabWidthValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper {
            inner: AzStyleTabWidthValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper {
            inner: AzStyleTabWidthValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper {
            inner: AzStyleTabWidthValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleTabWidth) -> AzStyleTabWidthValueEnumWrapper {
        AzStyleTabWidthValueEnumWrapper {
            inner: AzStyleTabWidthValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleTabWidthValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTabWidthValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTabWidthValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTabWidthValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTabWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTabWidthValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextAlignValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper {
            inner: AzStyleTextAlignValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper {
            inner: AzStyleTextAlignValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper {
            inner: AzStyleTextAlignValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper {
            inner: AzStyleTextAlignValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleTextAlignEnumWrapper) -> AzStyleTextAlignValueEnumWrapper {
        AzStyleTextAlignValueEnumWrapper {
            inner: AzStyleTextAlignValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleTextAlignValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTextAlignValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTextAlignValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzStyleTextAlignEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextAlignValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextAlignValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextAlignValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTextColorValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper {
            inner: AzStyleTextColorValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper {
            inner: AzStyleTextColorValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper {
            inner: AzStyleTextColorValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper {
            inner: AzStyleTextColorValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleTextColor) -> AzStyleTextColorValueEnumWrapper {
        AzStyleTextColorValueEnumWrapper {
            inner: AzStyleTextColorValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleTextColorValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTextColorValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTextColorValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTextColorValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTextColorValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleWordSpacingValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper {
            inner: AzStyleWordSpacingValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper {
            inner: AzStyleWordSpacingValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper {
            inner: AzStyleWordSpacingValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper {
            inner: AzStyleWordSpacingValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleWordSpacing) -> AzStyleWordSpacingValueEnumWrapper {
        AzStyleWordSpacingValueEnumWrapper {
            inner: AzStyleWordSpacingValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleWordSpacingValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleWordSpacingValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleWordSpacingValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleWordSpacingValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleWordSpacingValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleWordSpacingValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleOpacityValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper {
            inner: AzStyleOpacityValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper {
            inner: AzStyleOpacityValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper {
            inner: AzStyleOpacityValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper {
            inner: AzStyleOpacityValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleOpacity) -> AzStyleOpacityValueEnumWrapper {
        AzStyleOpacityValueEnumWrapper {
            inner: AzStyleOpacityValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleOpacityValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleOpacityValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleOpacityValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleOpacityValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleOpacityValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleOpacityValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper {
            inner: AzStyleTransformVecValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper {
            inner: AzStyleTransformVecValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper {
            inner: AzStyleTransformVecValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper {
            inner: AzStyleTransformVecValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleTransformVec) -> AzStyleTransformVecValueEnumWrapper {
        AzStyleTransformVecValueEnumWrapper {
            inner: AzStyleTransformVecValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleTransformVecValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTransformVecValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformOriginValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper {
            inner: AzStyleTransformOriginValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper {
            inner: AzStyleTransformOriginValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper {
            inner: AzStyleTransformOriginValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper {
            inner: AzStyleTransformOriginValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleTransformOrigin) -> AzStyleTransformOriginValueEnumWrapper {
        AzStyleTransformOriginValueEnumWrapper {
            inner: AzStyleTransformOriginValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleTransformOriginValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformOriginValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleTransformOriginValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformOriginValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformOriginValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformOriginValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylePerspectiveOriginValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper {
            inner: AzStylePerspectiveOriginValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper {
            inner: AzStylePerspectiveOriginValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper {
            inner: AzStylePerspectiveOriginValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper {
            inner: AzStylePerspectiveOriginValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStylePerspectiveOrigin) -> AzStylePerspectiveOriginValueEnumWrapper {
        AzStylePerspectiveOriginValueEnumWrapper {
            inner: AzStylePerspectiveOriginValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStylePerspectiveOriginValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStylePerspectiveOriginValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStylePerspectiveOriginValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStylePerspectiveOriginValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStylePerspectiveOriginValue::Exact(v) => {
                Ok(vec!["Exact".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylePerspectiveOriginValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StylePerspectiveOriginValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StylePerspectiveOriginValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackfaceVisibilityValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper {
            inner: AzStyleBackfaceVisibilityValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper {
            inner: AzStyleBackfaceVisibilityValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper {
            inner: AzStyleBackfaceVisibilityValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper {
            inner: AzStyleBackfaceVisibilityValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleBackfaceVisibilityEnumWrapper) -> AzStyleBackfaceVisibilityValueEnumWrapper {
        AzStyleBackfaceVisibilityValueEnumWrapper {
            inner: AzStyleBackfaceVisibilityValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackfaceVisibilityValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackfaceVisibilityValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleBackfaceVisibilityValue::Inherit => {
                Ok(vec!["Inherit".into_py(py), ().into_py(py)])
            }
            AzStyleBackfaceVisibilityValue::Initial => {
                Ok(vec!["Initial".into_py(py), ().into_py(py)])
            }
            AzStyleBackfaceVisibilityValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzStyleBackfaceVisibilityEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackfaceVisibilityValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackfaceVisibilityValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackfaceVisibilityValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleMixBlendModeValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper {
            inner: AzStyleMixBlendModeValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper {
            inner: AzStyleMixBlendModeValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper {
            inner: AzStyleMixBlendModeValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper {
            inner: AzStyleMixBlendModeValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleMixBlendModeEnumWrapper) -> AzStyleMixBlendModeValueEnumWrapper {
        AzStyleMixBlendModeValueEnumWrapper {
            inner: AzStyleMixBlendModeValue::Exact(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleMixBlendModeValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleMixBlendModeValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleMixBlendModeValue::Exact(v) => Ok(vec![
                "Exact".into_py(py),
                {
                    let m: &AzStyleMixBlendModeEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleMixBlendModeValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleMixBlendModeValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleMixBlendModeValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVecValueEnumWrapper {
    #[classattr]
    fn Auto() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper {
            inner: AzStyleFilterVecValue::Auto,
        }
    }
    #[classattr]
    fn None() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper {
            inner: AzStyleFilterVecValue::None,
        }
    }
    #[classattr]
    fn Inherit() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper {
            inner: AzStyleFilterVecValue::Inherit,
        }
    }
    #[classattr]
    fn Initial() -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper {
            inner: AzStyleFilterVecValue::Initial,
        }
    }
    #[staticmethod]
    fn Exact(v: AzStyleFilterVec) -> AzStyleFilterVecValueEnumWrapper {
        AzStyleFilterVecValueEnumWrapper {
            inner: AzStyleFilterVecValue::Exact(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleFilterVecValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilterVecValue::Auto => Ok(vec!["Auto".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::Inherit => Ok(vec!["Inherit".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::Initial => Ok(vec!["Initial".into_py(py), ().into_py(py)]),
            AzStyleFilterVecValue::Exact(v) => Ok(vec!["Exact".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVecValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterVecValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyEnumWrapper {
    #[staticmethod]
    fn TextColor(v: AzStyleTextColorValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::TextColor(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn FontSize(v: AzStyleFontSizeValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::FontSize(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn FontFamily(v: AzStyleFontFamilyVecValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::FontFamily(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn TextAlign(v: AzStyleTextAlignValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::TextAlign(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn LetterSpacing(v: AzStyleLetterSpacingValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::LetterSpacing(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn LineHeight(v: AzStyleLineHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::LineHeight(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn WordSpacing(v: AzStyleWordSpacingValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::WordSpacing(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn TabWidth(v: AzStyleTabWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::TabWidth(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Cursor(v: AzStyleCursorValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Cursor(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Display(v: AzLayoutDisplayValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Display(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Float(v: AzLayoutFloatValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Float(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BoxSizing(v: AzLayoutBoxSizingValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BoxSizing(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Width(v: AzLayoutWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Width(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Height(v: AzLayoutHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Height(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MinWidth(v: AzLayoutMinWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MinWidth(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MinHeight(v: AzLayoutMinHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MinHeight(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MaxWidth(v: AzLayoutMaxWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MaxWidth(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MaxHeight(v: AzLayoutMaxHeightValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MaxHeight(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Position(v: AzLayoutPositionValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Position(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Top(v: AzLayoutTopValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Top(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Right(v: AzLayoutRightValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Right(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Left(v: AzLayoutLeftValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Left(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Bottom(v: AzLayoutBottomValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Bottom(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn FlexWrap(v: AzLayoutFlexWrapValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::FlexWrap(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn FlexDirection(v: AzLayoutFlexDirectionValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::FlexDirection(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn FlexGrow(v: AzLayoutFlexGrowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::FlexGrow(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn FlexShrink(v: AzLayoutFlexShrinkValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::FlexShrink(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn JustifyContent(v: AzLayoutJustifyContentValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::JustifyContent(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn AlignItems(v: AzLayoutAlignItemsValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::AlignItems(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn AlignContent(v: AzLayoutAlignContentValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::AlignContent(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BackgroundContent(
        v: AzStyleBackgroundContentVecValueEnumWrapper,
    ) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BackgroundContent(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BackgroundPosition(
        v: AzStyleBackgroundPositionVecValueEnumWrapper,
    ) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BackgroundPosition(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BackgroundSize(v: AzStyleBackgroundSizeVecValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BackgroundSize(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BackgroundRepeat(v: AzStyleBackgroundRepeatVecValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BackgroundRepeat(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn OverflowX(v: AzLayoutOverflowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::OverflowX(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn OverflowY(v: AzLayoutOverflowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::OverflowY(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn PaddingTop(v: AzLayoutPaddingTopValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::PaddingTop(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn PaddingLeft(v: AzLayoutPaddingLeftValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::PaddingLeft(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn PaddingRight(v: AzLayoutPaddingRightValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::PaddingRight(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn PaddingBottom(v: AzLayoutPaddingBottomValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::PaddingBottom(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MarginTop(v: AzLayoutMarginTopValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MarginTop(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MarginLeft(v: AzLayoutMarginLeftValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MarginLeft(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MarginRight(v: AzLayoutMarginRightValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MarginRight(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MarginBottom(v: AzLayoutMarginBottomValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MarginBottom(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderTopLeftRadius(
        v: AzStyleBorderTopLeftRadiusValueEnumWrapper,
    ) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderTopLeftRadius(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderTopRightRadius(
        v: AzStyleBorderTopRightRadiusValueEnumWrapper,
    ) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderTopRightRadius(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderBottomLeftRadius(
        v: AzStyleBorderBottomLeftRadiusValueEnumWrapper,
    ) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderBottomLeftRadius(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderBottomRightRadius(
        v: AzStyleBorderBottomRightRadiusValueEnumWrapper,
    ) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderBottomRightRadius(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderTopColor(v: AzStyleBorderTopColorValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderTopColor(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderRightColor(v: AzStyleBorderRightColorValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderRightColor(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderLeftColor(v: AzStyleBorderLeftColorValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderLeftColor(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderBottomColor(v: AzStyleBorderBottomColorValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderBottomColor(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderTopStyle(v: AzStyleBorderTopStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderTopStyle(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderRightStyle(v: AzStyleBorderRightStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderRightStyle(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderLeftStyle(v: AzStyleBorderLeftStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderLeftStyle(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderBottomStyle(v: AzStyleBorderBottomStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderBottomStyle(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderTopWidth(v: AzLayoutBorderTopWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderTopWidth(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderRightWidth(v: AzLayoutBorderRightWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderRightWidth(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderLeftWidth(v: AzLayoutBorderLeftWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderLeftWidth(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BorderBottomWidth(v: AzLayoutBorderBottomWidthValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BorderBottomWidth(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BoxShadowLeft(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BoxShadowLeft(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BoxShadowRight(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BoxShadowRight(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BoxShadowTop(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BoxShadowTop(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BoxShadowBottom(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BoxShadowBottom(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn ScrollbarStyle(v: AzScrollbarStyleValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::ScrollbarStyle(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Opacity(v: AzStyleOpacityValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Opacity(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Transform(v: AzStyleTransformVecValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Transform(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn TransformOrigin(v: AzStyleTransformOriginValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::TransformOrigin(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn PerspectiveOrigin(v: AzStylePerspectiveOriginValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::PerspectiveOrigin(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BackfaceVisibility(
        v: AzStyleBackfaceVisibilityValueEnumWrapper,
    ) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BackfaceVisibility(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn MixBlendMode(v: AzStyleMixBlendModeValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::MixBlendMode(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn Filter(v: AzStyleFilterVecValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::Filter(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn BackdropFilter(v: AzStyleFilterVecValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::BackdropFilter(unsafe { mem::transmute(v) }),
        }
    }
    #[staticmethod]
    fn TextShadow(v: AzStyleBoxShadowValueEnumWrapper) -> AzCssPropertyEnumWrapper {
        AzCssPropertyEnumWrapper {
            inner: AzCssProperty::TextShadow(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssProperty;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssProperty::TextColor(v) => Ok(vec![
                "TextColor".into_py(py),
                {
                    let m: &AzStyleTextColorValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::FontSize(v) => Ok(vec![
                "FontSize".into_py(py),
                {
                    let m: &AzStyleFontSizeValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::FontFamily(v) => Ok(vec![
                "FontFamily".into_py(py),
                {
                    let m: &AzStyleFontFamilyVecValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::TextAlign(v) => Ok(vec![
                "TextAlign".into_py(py),
                {
                    let m: &AzStyleTextAlignValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::LetterSpacing(v) => Ok(vec![
                "LetterSpacing".into_py(py),
                {
                    let m: &AzStyleLetterSpacingValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::LineHeight(v) => Ok(vec![
                "LineHeight".into_py(py),
                {
                    let m: &AzStyleLineHeightValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::WordSpacing(v) => Ok(vec![
                "WordSpacing".into_py(py),
                {
                    let m: &AzStyleWordSpacingValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::TabWidth(v) => Ok(vec![
                "TabWidth".into_py(py),
                {
                    let m: &AzStyleTabWidthValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Cursor(v) => Ok(vec![
                "Cursor".into_py(py),
                {
                    let m: &AzStyleCursorValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Display(v) => Ok(vec![
                "Display".into_py(py),
                {
                    let m: &AzLayoutDisplayValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Float(v) => Ok(vec![
                "Float".into_py(py),
                {
                    let m: &AzLayoutFloatValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BoxSizing(v) => Ok(vec![
                "BoxSizing".into_py(py),
                {
                    let m: &AzLayoutBoxSizingValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Width(v) => Ok(vec![
                "Width".into_py(py),
                {
                    let m: &AzLayoutWidthValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Height(v) => Ok(vec![
                "Height".into_py(py),
                {
                    let m: &AzLayoutHeightValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MinWidth(v) => Ok(vec![
                "MinWidth".into_py(py),
                {
                    let m: &AzLayoutMinWidthValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MinHeight(v) => Ok(vec![
                "MinHeight".into_py(py),
                {
                    let m: &AzLayoutMinHeightValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MaxWidth(v) => Ok(vec![
                "MaxWidth".into_py(py),
                {
                    let m: &AzLayoutMaxWidthValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MaxHeight(v) => Ok(vec![
                "MaxHeight".into_py(py),
                {
                    let m: &AzLayoutMaxHeightValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Position(v) => Ok(vec![
                "Position".into_py(py),
                {
                    let m: &AzLayoutPositionValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Top(v) => Ok(vec![
                "Top".into_py(py),
                {
                    let m: &AzLayoutTopValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Right(v) => Ok(vec![
                "Right".into_py(py),
                {
                    let m: &AzLayoutRightValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Left(v) => Ok(vec![
                "Left".into_py(py),
                {
                    let m: &AzLayoutLeftValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Bottom(v) => Ok(vec![
                "Bottom".into_py(py),
                {
                    let m: &AzLayoutBottomValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::FlexWrap(v) => Ok(vec![
                "FlexWrap".into_py(py),
                {
                    let m: &AzLayoutFlexWrapValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::FlexDirection(v) => Ok(vec![
                "FlexDirection".into_py(py),
                {
                    let m: &AzLayoutFlexDirectionValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::FlexGrow(v) => Ok(vec![
                "FlexGrow".into_py(py),
                {
                    let m: &AzLayoutFlexGrowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::FlexShrink(v) => Ok(vec![
                "FlexShrink".into_py(py),
                {
                    let m: &AzLayoutFlexShrinkValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::JustifyContent(v) => Ok(vec![
                "JustifyContent".into_py(py),
                {
                    let m: &AzLayoutJustifyContentValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::AlignItems(v) => Ok(vec![
                "AlignItems".into_py(py),
                {
                    let m: &AzLayoutAlignItemsValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::AlignContent(v) => Ok(vec![
                "AlignContent".into_py(py),
                {
                    let m: &AzLayoutAlignContentValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BackgroundContent(v) => Ok(vec![
                "BackgroundContent".into_py(py),
                {
                    let m: &AzStyleBackgroundContentVecValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BackgroundPosition(v) => Ok(vec![
                "BackgroundPosition".into_py(py),
                {
                    let m: &AzStyleBackgroundPositionVecValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BackgroundSize(v) => Ok(vec![
                "BackgroundSize".into_py(py),
                {
                    let m: &AzStyleBackgroundSizeVecValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BackgroundRepeat(v) => Ok(vec![
                "BackgroundRepeat".into_py(py),
                {
                    let m: &AzStyleBackgroundRepeatVecValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::OverflowX(v) => Ok(vec![
                "OverflowX".into_py(py),
                {
                    let m: &AzLayoutOverflowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::OverflowY(v) => Ok(vec![
                "OverflowY".into_py(py),
                {
                    let m: &AzLayoutOverflowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::PaddingTop(v) => Ok(vec![
                "PaddingTop".into_py(py),
                {
                    let m: &AzLayoutPaddingTopValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::PaddingLeft(v) => Ok(vec![
                "PaddingLeft".into_py(py),
                {
                    let m: &AzLayoutPaddingLeftValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::PaddingRight(v) => Ok(vec![
                "PaddingRight".into_py(py),
                {
                    let m: &AzLayoutPaddingRightValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::PaddingBottom(v) => Ok(vec![
                "PaddingBottom".into_py(py),
                {
                    let m: &AzLayoutPaddingBottomValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MarginTop(v) => Ok(vec![
                "MarginTop".into_py(py),
                {
                    let m: &AzLayoutMarginTopValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MarginLeft(v) => Ok(vec![
                "MarginLeft".into_py(py),
                {
                    let m: &AzLayoutMarginLeftValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MarginRight(v) => Ok(vec![
                "MarginRight".into_py(py),
                {
                    let m: &AzLayoutMarginRightValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MarginBottom(v) => Ok(vec![
                "MarginBottom".into_py(py),
                {
                    let m: &AzLayoutMarginBottomValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderTopLeftRadius(v) => Ok(vec![
                "BorderTopLeftRadius".into_py(py),
                {
                    let m: &AzStyleBorderTopLeftRadiusValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderTopRightRadius(v) => Ok(vec![
                "BorderTopRightRadius".into_py(py),
                {
                    let m: &AzStyleBorderTopRightRadiusValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderBottomLeftRadius(v) => Ok(vec![
                "BorderBottomLeftRadius".into_py(py),
                {
                    let m: &AzStyleBorderBottomLeftRadiusValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderBottomRightRadius(v) => Ok(vec![
                "BorderBottomRightRadius".into_py(py),
                {
                    let m: &AzStyleBorderBottomRightRadiusValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderTopColor(v) => Ok(vec![
                "BorderTopColor".into_py(py),
                {
                    let m: &AzStyleBorderTopColorValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderRightColor(v) => Ok(vec![
                "BorderRightColor".into_py(py),
                {
                    let m: &AzStyleBorderRightColorValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderLeftColor(v) => Ok(vec![
                "BorderLeftColor".into_py(py),
                {
                    let m: &AzStyleBorderLeftColorValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderBottomColor(v) => Ok(vec![
                "BorderBottomColor".into_py(py),
                {
                    let m: &AzStyleBorderBottomColorValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderTopStyle(v) => Ok(vec![
                "BorderTopStyle".into_py(py),
                {
                    let m: &AzStyleBorderTopStyleValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderRightStyle(v) => Ok(vec![
                "BorderRightStyle".into_py(py),
                {
                    let m: &AzStyleBorderRightStyleValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderLeftStyle(v) => Ok(vec![
                "BorderLeftStyle".into_py(py),
                {
                    let m: &AzStyleBorderLeftStyleValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderBottomStyle(v) => Ok(vec![
                "BorderBottomStyle".into_py(py),
                {
                    let m: &AzStyleBorderBottomStyleValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderTopWidth(v) => Ok(vec![
                "BorderTopWidth".into_py(py),
                {
                    let m: &AzLayoutBorderTopWidthValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderRightWidth(v) => Ok(vec![
                "BorderRightWidth".into_py(py),
                {
                    let m: &AzLayoutBorderRightWidthValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderLeftWidth(v) => Ok(vec![
                "BorderLeftWidth".into_py(py),
                {
                    let m: &AzLayoutBorderLeftWidthValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BorderBottomWidth(v) => Ok(vec![
                "BorderBottomWidth".into_py(py),
                {
                    let m: &AzLayoutBorderBottomWidthValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BoxShadowLeft(v) => Ok(vec![
                "BoxShadowLeft".into_py(py),
                {
                    let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BoxShadowRight(v) => Ok(vec![
                "BoxShadowRight".into_py(py),
                {
                    let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BoxShadowTop(v) => Ok(vec![
                "BoxShadowTop".into_py(py),
                {
                    let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BoxShadowBottom(v) => Ok(vec![
                "BoxShadowBottom".into_py(py),
                {
                    let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::ScrollbarStyle(v) => Ok(vec![
                "ScrollbarStyle".into_py(py),
                {
                    let m: &AzScrollbarStyleValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Opacity(v) => Ok(vec![
                "Opacity".into_py(py),
                {
                    let m: &AzStyleOpacityValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Transform(v) => Ok(vec![
                "Transform".into_py(py),
                {
                    let m: &AzStyleTransformVecValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::TransformOrigin(v) => Ok(vec![
                "TransformOrigin".into_py(py),
                {
                    let m: &AzStyleTransformOriginValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::PerspectiveOrigin(v) => Ok(vec![
                "PerspectiveOrigin".into_py(py),
                {
                    let m: &AzStylePerspectiveOriginValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BackfaceVisibility(v) => Ok(vec![
                "BackfaceVisibility".into_py(py),
                {
                    let m: &AzStyleBackfaceVisibilityValueEnumWrapper =
                        unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::MixBlendMode(v) => Ok(vec![
                "MixBlendMode".into_py(py),
                {
                    let m: &AzStyleMixBlendModeValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::Filter(v) => Ok(vec![
                "Filter".into_py(py),
                {
                    let m: &AzStyleFilterVecValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::BackdropFilter(v) => Ok(vec![
                "BackdropFilter".into_py(py),
                {
                    let m: &AzStyleFilterVecValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
            AzCssProperty::TextShadow(v) => Ok(vec![
                "TextShadow".into_py(py),
                {
                    let m: &AzStyleBoxShadowValueEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssProperty = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssProperty = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRibbon {
    #[new]
    fn __new__(tab_active: i32) -> Self {
        Self { tab_active }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRibbon {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::ribbon::Ribbon = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::ribbon::Ribbon = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRibbonOnTabClickedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzRibbonOnTabClickedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::ribbon::RibbonOnTabClickedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::ribbon::RibbonOnTabClickedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButton {
    #[new]
    fn new(label: String) -> AzButton {
        let label = pystring_to_azstring(&label);
        unsafe { mem::transmute(crate::AzButton_new(mem::transmute(label))) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzButton_dom(mem::transmute(self))) }
    }
    // impl Button {

    fn set_on_click(
        &mut self,
        py: Python,
        data: PyObject,
        callback: PyObject,
    ) -> Result<(), PyErr> {
        // RefAny<CallbackTy>
        use pyo3::type_object::PyTypeInfo;

        if data.as_ref(py.clone()).is_callable() {
            return Err(PyException::new_err(format!(
                "ERROR in Button.set_on_click: - argument \"data\" is a function callback, \
                 expected class"
            )));
        }

        let cb_any = callback.as_ref(py);
        if !cb_any.is_callable() {
            let type_name = cb_any.get_type().name().unwrap_or("<unknown>");
            return Err(PyException::new_err(format!(
                "ERROR in Button.set_on_click: - argument \"callback\" is of type \"{}\", \
                 expected function",
                type_name
            )));
        }

        let callback_refany = azul_impl::callbacks::RefAny::new(CallbackTy {
            _py_callback: Some(callback),
            _py_data: Some(data),
        });

        unsafe {
            crate::AzButton_setOnClick(
                mem::transmute(self),
                callback_refany,
                invoke_python_callback,
            );
        }

        Ok(())
    }

    fn with_on_click(
        &mut self,
        py: Python,
        data: PyObject,
        callback: PyObject,
    ) -> Result<Self, PyErr> {
        // RefAny<CallbackTy>
        self.set_on_click(py, data, callback)?;
        let d: &mut crate::widgets::button::Button = unsafe { mem::transmute(self) };
        Ok(unsafe { mem::transmute(d.swap_with_default()) })
    }
}

#[pyproto]
impl PyObjectProtocol for AzButton {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::button::Button = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::button::Button = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzButtonOnClick {
    #[new]
    fn __new__(data: AzRefAny, callback: AzCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzButtonOnClick {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::button::ButtonOnClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInput {
    #[new]
    fn new(path: AzOptionStringEnumWrapper) -> AzFileInput {
        unsafe { mem::transmute(crate::AzFileInput_new(mem::transmute(path))) }
    }
    fn set_default_text(&mut self, default_text: String) -> () {
        let default_text = pystring_to_azstring(&default_text);
        unsafe {
            mem::transmute(crate::AzFileInput_setDefaultText(
                mem::transmute(self),
                mem::transmute(default_text),
            ))
        }
    }
    fn with_default_text(&mut self, default_text: String) -> AzFileInput {
        let default_text = pystring_to_azstring(&default_text);
        unsafe {
            mem::transmute(crate::AzFileInput_withDefaultText(
                mem::transmute(self),
                mem::transmute(default_text),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzFileInput_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFileInput {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputStateWrapper {
    #[new]
    fn __new__(
        inner: AzFileInputState,
        on_file_path_change: AzOptionFileInputOnPathChangeEnumWrapper,
        file_dialog_title: AzString,
        default_dir: AzOptionStringEnumWrapper,
        file_types: AzOptionFileTypeListEnumWrapper,
    ) -> Self {
        Self {
            inner,
            on_file_path_change,
            file_dialog_title,
            default_dir,
            file_types,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFileInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputStateWrapper = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputState {
    #[new]
    fn __new__(path: AzOptionStringEnumWrapper) -> Self {
        Self { path }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFileInputState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputOnPathChange {
    #[new]
    fn __new__(data: AzRefAny, callback: AzFileInputOnPathChangeCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFileInputOnPathChange {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputOnPathChange = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileInputOnPathChangeCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzFileInputOnPathChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputOnPathChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::FileInputOnPathChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBox {
    #[new]
    fn new(checked: bool) -> AzCheckBox {
        unsafe { mem::transmute(crate::AzCheckBox_new(mem::transmute(checked))) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzCheckBox_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCheckBox {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBox = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBox = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxStateWrapper {
    #[new]
    fn __new__(inner: AzCheckBoxState, on_toggle: AzOptionCheckBoxOnToggleEnumWrapper) -> Self {
        Self { inner, on_toggle }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxStateWrapper = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggle {
    #[new]
    fn __new__(data: AzRefAny, callback: AzCheckBoxOnToggleCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxOnToggle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxOnToggleCallback {}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxOnToggleCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxOnToggleCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxOnToggleCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckBoxState {
    #[new]
    fn __new__(checked: bool) -> Self {
        Self { checked }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCheckBoxState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::CheckBoxState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLabel {
    #[new]
    fn new(text: String) -> AzLabel {
        let text = pystring_to_azstring(&text);
        unsafe { mem::transmute(crate::AzLabel_new(mem::transmute(text))) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzLabel_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLabel {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::label::Label = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::label::Label = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInput {
    #[new]
    fn new(color: AzColorU) -> AzColorInput {
        unsafe { mem::transmute(crate::AzColorInput_new(mem::transmute(color))) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzColorInput_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorInput {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputStateWrapper {
    #[new]
    fn __new__(
        inner: AzColorInputState,
        title: AzString,
        on_value_change: AzOptionColorInputOnValueChangeEnumWrapper,
    ) -> Self {
        Self {
            inner,
            title,
            on_value_change,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputStateWrapper =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputStateWrapper =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputState {
    #[new]
    fn __new__(color: AzColorU) -> Self {
        Self { color }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorInputState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChange {
    #[new]
    fn __new__(data: AzRefAny, callback: AzColorInputOnValueChangeCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputOnValueChange =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputOnValueChange =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorInputOnValueChangeCallback {}

#[pyproto]
impl PyObjectProtocol for AzColorInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputOnValueChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::ColorInputOnValueChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInput {
    #[new]
    fn new() -> AzTextInput {
        unsafe { mem::transmute(crate::AzTextInput_new()) }
    }
    fn set_text(&mut self, text: String) -> () {
        let text = pystring_to_azstring(&text);
        unsafe {
            mem::transmute(crate::AzTextInput_setText(
                mem::transmute(self),
                mem::transmute(text),
            ))
        }
    }
    fn with_text(&mut self, text: String) -> AzTextInput {
        let text = pystring_to_azstring(&text);
        unsafe {
            mem::transmute(crate::AzTextInput_withText(
                mem::transmute(self),
                mem::transmute(text),
            ))
        }
    }
    fn set_placeholder(&mut self, text: String) -> () {
        let text = pystring_to_azstring(&text);
        unsafe {
            mem::transmute(crate::AzTextInput_setPlaceholder(
                mem::transmute(self),
                mem::transmute(text),
            ))
        }
    }
    fn with_placeholder(&mut self, text: String) -> AzTextInput {
        let text = pystring_to_azstring(&text);
        unsafe {
            mem::transmute(crate::AzTextInput_withPlaceholder(
                mem::transmute(self),
                mem::transmute(text),
            ))
        }
    }
    fn set_placeholder_style(&mut self, placeholder_style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzTextInput_setPlaceholderStyle(
                mem::transmute(self),
                mem::transmute(placeholder_style),
            ))
        }
    }
    fn with_placeholder_style(
        &mut self,
        placeholder_style: AzNodeDataInlineCssPropertyVec,
    ) -> AzTextInput {
        unsafe {
            mem::transmute(crate::AzTextInput_withPlaceholderStyle(
                mem::transmute(self),
                mem::transmute(placeholder_style),
            ))
        }
    }
    fn set_container_style(&mut self, container_style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzTextInput_setContainerStyle(
                mem::transmute(self),
                mem::transmute(container_style),
            ))
        }
    }
    fn with_container_style(
        &mut self,
        container_style: AzNodeDataInlineCssPropertyVec,
    ) -> AzTextInput {
        unsafe {
            mem::transmute(crate::AzTextInput_withContainerStyle(
                mem::transmute(self),
                mem::transmute(container_style),
            ))
        }
    }
    fn set_label_style(&mut self, label_style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzTextInput_setLabelStyle(
                mem::transmute(self),
                mem::transmute(label_style),
            ))
        }
    }
    fn with_label_style(&mut self, label_style: AzNodeDataInlineCssPropertyVec) -> AzTextInput {
        unsafe {
            mem::transmute(crate::AzTextInput_withLabelStyle(
                mem::transmute(self),
                mem::transmute(label_style),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzTextInput_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInput {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputStateWrapper {
    #[new]
    fn __new__(
        inner: AzTextInputState,
        on_text_input: AzOptionTextInputOnTextInputEnumWrapper,
        on_virtual_key_down: AzOptionTextInputOnVirtualKeyDownEnumWrapper,
        on_focus_lost: AzOptionTextInputOnFocusLostEnumWrapper,
        update_text_input_before_calling_focus_lost_fn: bool,
        update_text_input_before_calling_vk_down_fn: bool,
        cursor_animation: AzOptionTimerIdEnumWrapper,
    ) -> Self {
        Self {
            inner,
            on_text_input,
            on_virtual_key_down,
            on_focus_lost,
            update_text_input_before_calling_focus_lost_fn,
            update_text_input_before_calling_vk_down_fn,
            cursor_animation,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputStateWrapper = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputState {
    #[new]
    fn __new__(
        text: AzU32Vec,
        placeholder: AzOptionStringEnumWrapper,
        max_len: usize,
        selection: AzOptionTextInputSelectionEnumWrapper,
        cursor_pos: usize,
    ) -> Self {
        Self {
            text,
            placeholder,
            max_len,
            selection,
            cursor_pos,
        }
    }

    fn get_text(&self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzTextInputState_getText(mem::transmute(self)))
        })
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionEnumWrapper {
    #[classattr]
    fn All() -> AzTextInputSelectionEnumWrapper {
        AzTextInputSelectionEnumWrapper {
            inner: AzTextInputSelection::All,
        }
    }
    #[staticmethod]
    fn FromTo(v: AzTextInputSelectionRange) -> AzTextInputSelectionEnumWrapper {
        AzTextInputSelectionEnumWrapper {
            inner: AzTextInputSelection::FromTo(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzTextInputSelection;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTextInputSelection::All => Ok(vec!["All".into_py(py), ().into_py(py)]),
            AzTextInputSelection::FromTo(v) => {
                Ok(vec!["FromTo".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputSelection =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputSelection =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputSelectionRange {
    #[new]
    fn __new__(from: usize, to: usize) -> Self {
        Self { from, to }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputSelectionRange {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputSelectionRange =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputSelectionRange =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInput {
    #[new]
    fn __new__(data: AzRefAny, callback: AzTextInputOnTextInputCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInput {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnTextInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnTextInputCallback {}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnTextInputCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnTextInputCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnTextInputCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDown {
    #[new]
    fn __new__(data: AzRefAny, callback: AzTextInputOnVirtualKeyDownCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDown {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDown =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDown =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnVirtualKeyDownCallback {}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnVirtualKeyDownCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDownCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnVirtualKeyDownCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLost {
    #[new]
    fn __new__(data: AzRefAny, callback: AzTextInputOnFocusLostCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnFocusLost = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputOnFocusLostCallback {}

#[pyproto]
impl PyObjectProtocol for AzTextInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnFocusLostCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputOnFocusLostCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOnTextInputReturn {
    #[new]
    fn __new__(update: AzUpdateEnumWrapper, valid: AzTextInputValidEnumWrapper) -> Self {
        Self { update, valid }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOnTextInputReturn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OnTextInputReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextInputValidEnumWrapper {
    #[classattr]
    fn Yes() -> AzTextInputValidEnumWrapper {
        AzTextInputValidEnumWrapper {
            inner: AzTextInputValid::Yes,
        }
    }
    #[classattr]
    fn No() -> AzTextInputValidEnumWrapper {
        AzTextInputValidEnumWrapper {
            inner: AzTextInputValid::No,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextInputValidEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::TextInputValid = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzTextInputValidEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzNumberInput {
    #[new]
    fn new(number: f32) -> AzNumberInput {
        unsafe { mem::transmute(crate::AzNumberInput_new(mem::transmute(number))) }
    }
    fn set_placeholder_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzNumberInput_setPlaceholderStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_placeholder_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput {
        unsafe {
            mem::transmute(crate::AzNumberInput_withPlaceholderStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_container_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzNumberInput_setContainerStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_container_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput {
        unsafe {
            mem::transmute(crate::AzNumberInput_withContainerStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn set_label_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> () {
        unsafe {
            mem::transmute(crate::AzNumberInput_setLabelStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn with_label_style(&mut self, style: AzNodeDataInlineCssPropertyVec) -> AzNumberInput {
        unsafe {
            mem::transmute(crate::AzNumberInput_withLabelStyle(
                mem::transmute(self),
                mem::transmute(style),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzNumberInput_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNumberInput {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInput = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputStateWrapper {
    #[new]
    fn __new__(
        inner: AzNumberInputState,
        on_value_change: AzOptionNumberInputOnValueChangeEnumWrapper,
        on_focus_lost: AzOptionNumberInputOnFocusLostEnumWrapper,
    ) -> Self {
        Self {
            inner,
            on_value_change,
            on_focus_lost,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputStateWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputStateWrapper =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputStateWrapper =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputState {
    #[new]
    fn __new__(previous: f32, number: f32, min: f32, max: f32) -> Self {
        Self {
            previous,
            number,
            min,
            max,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChange {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNumberInputOnValueChangeCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChange {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnValueChange =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnValueChange =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnValueChangeCallback {}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnValueChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnValueChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnValueChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLost {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNumberInputOnFocusLostCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLost {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnFocusLost =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnFocusLost =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNumberInputOnFocusLostCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNumberInputOnFocusLostCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnFocusLostCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::NumberInputOnFocusLostCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBar {
    #[new]
    fn new(percent_done: f32) -> AzProgressBar {
        unsafe { mem::transmute(crate::AzProgressBar_new(mem::transmute(percent_done))) }
    }
    fn set_height(&mut self, height: AzPixelValue) -> () {
        unsafe {
            mem::transmute(crate::AzProgressBar_setHeight(
                mem::transmute(self),
                mem::transmute(height),
            ))
        }
    }
    fn with_height(&mut self, height: AzPixelValue) -> AzProgressBar {
        unsafe {
            mem::transmute(crate::AzProgressBar_withHeight(
                mem::transmute(self),
                mem::transmute(height),
            ))
        }
    }
    fn set_container_background(&mut self, background: AzStyleBackgroundContentVec) -> () {
        unsafe {
            mem::transmute(crate::AzProgressBar_setContainerBackground(
                mem::transmute(self),
                mem::transmute(background),
            ))
        }
    }
    fn with_container_style(&mut self, background: AzStyleBackgroundContentVec) -> AzProgressBar {
        unsafe {
            mem::transmute(crate::AzProgressBar_withContainerStyle(
                mem::transmute(self),
                mem::transmute(background),
            ))
        }
    }
    fn set_bar_background(&mut self, background: AzStyleBackgroundContentVec) -> () {
        unsafe {
            mem::transmute(crate::AzProgressBar_setBarBackground(
                mem::transmute(self),
                mem::transmute(background),
            ))
        }
    }
    fn with_bar_background(&mut self, background: AzStyleBackgroundContentVec) -> AzProgressBar {
        unsafe {
            mem::transmute(crate::AzProgressBar_withBarBackground(
                mem::transmute(self),
                mem::transmute(background),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzProgressBar_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzProgressBar {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::progressbar::ProgressBar = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzProgressBarState {
    #[new]
    fn __new__(percent_done: f32, display_percentage: bool) -> Self {
        Self {
            percent_done,
            display_percentage,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzProgressBarState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::progressbar::ProgressBarState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabHeader {
    #[new]
    fn new(tabs: AzStringVec) -> AzTabHeader {
        unsafe { mem::transmute(crate::AzTabHeader_new(mem::transmute(tabs))) }
    }
    fn set_active_tab(&mut self, active_tab: usize) -> () {
        unsafe {
            mem::transmute(crate::AzTabHeader_setActiveTab(
                mem::transmute(self),
                mem::transmute(active_tab),
            ))
        }
    }
    fn with_active_tab(&mut self, active_tab: usize) -> AzTabHeader {
        unsafe {
            mem::transmute(crate::AzTabHeader_withActiveTab(
                mem::transmute(self),
                mem::transmute(active_tab),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzTabHeader_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabHeader {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabHeader = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabHeader = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabHeaderState {
    #[new]
    fn __new__(active_tab: usize) -> Self {
        Self { active_tab }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabHeaderState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabHeaderState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabContent {
    #[new]
    fn new(content: AzDom) -> AzTabContent {
        unsafe { mem::transmute(crate::AzTabContent_new(mem::transmute(content))) }
    }
    fn set_padding(&mut self, has_padding: bool) -> () {
        unsafe {
            mem::transmute(crate::AzTabContent_setPadding(
                mem::transmute(self),
                mem::transmute(has_padding),
            ))
        }
    }
    fn with_padding(&mut self, has_padding: bool) -> AzTabContent {
        unsafe {
            mem::transmute(crate::AzTabContent_withPadding(
                mem::transmute(self),
                mem::transmute(has_padding),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzTabContent_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabContent {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabContent = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabContent = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabOnClick {
    #[new]
    fn __new__(data: AzRefAny, callback: AzTabOnClickCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabOnClick {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabOnClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTabOnClickCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzTabOnClickCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::TabOnClickCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFrame {
    #[new]
    fn new(title: String, dom: AzDom) -> AzFrame {
        let title = pystring_to_azstring(&title);
        unsafe {
            mem::transmute(crate::AzFrame_new(
                mem::transmute(title),
                mem::transmute(dom),
            ))
        }
    }
    fn set_flex_grow(&mut self, flex_grow: f32) -> () {
        unsafe {
            mem::transmute(crate::AzFrame_setFlexGrow(
                mem::transmute(self),
                mem::transmute(flex_grow),
            ))
        }
    }
    fn with_flex_grow(&mut self, flex_grow: f32) -> AzFrame {
        unsafe {
            mem::transmute(crate::AzFrame_withFlexGrow(
                mem::transmute(self),
                mem::transmute(flex_grow),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzFrame_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFrame {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::frame::Frame = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraph {
    #[new]
    fn __new__(
        node_types: AzNodeTypeIdInfoMapVec,
        input_output_types: AzInputOutputTypeIdInfoMapVec,
        nodes: AzNodeIdNodeMapVec,
        allow_multiple_root_nodes: bool,
        offset: AzLogicalPosition,
        style: AzNodeGraphStyleEnumWrapper,
        callbacks: AzNodeGraphCallbacks,
        add_node_str: AzString,
        scale_factor: f32,
    ) -> Self {
        Self {
            node_types,
            input_output_types,
            nodes,
            allow_multiple_root_nodes,
            offset,
            style,
            callbacks,
            add_node_str,
            scale_factor,
        }
    }

    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzNodeGraph_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraph {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraph = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMap {
    #[new]
    fn __new__(node_type_id: AzNodeTypeId, node_type_info: AzNodeTypeInfo) -> Self {
        Self {
            node_type_id,
            node_type_info,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMap {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMap = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMap {
    #[new]
    fn __new__(io_type_id: AzInputOutputTypeId, io_info: AzInputOutputInfo) -> Self {
        Self {
            io_type_id,
            io_info,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMap {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMap =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMap =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMap {
    #[new]
    fn __new__(node_id: AzNodeGraphNodeId, node: AzNode) -> Self {
        Self { node_id, node }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMap {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeIdNodeMap = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphStyleEnumWrapper {
    #[classattr]
    fn Default() -> AzNodeGraphStyleEnumWrapper {
        AzNodeGraphStyleEnumWrapper {
            inner: AzNodeGraphStyle::Default,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraphStyle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzNodeGraphStyleEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzNodeGraphCallbacks {
    #[new]
    fn __new__(
        on_node_added: AzOptionNodeGraphOnNodeAddedEnumWrapper,
        on_node_removed: AzOptionNodeGraphOnNodeRemovedEnumWrapper,
        on_node_dragged: AzOptionNodeGraphOnNodeDraggedEnumWrapper,
        on_node_graph_dragged: AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper,
        on_node_connected: AzOptionNodeGraphOnNodeConnectedEnumWrapper,
        on_node_input_disconnected: AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper,
        on_node_output_disconnected: AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper,
        on_node_field_edited: AzOptionNodeGraphOnNodeFieldEditedEnumWrapper,
    ) -> Self {
        Self {
            on_node_added,
            on_node_removed,
            on_node_dragged,
            on_node_graph_dragged,
            on_node_connected,
            on_node_input_disconnected,
            on_node_output_disconnected,
            on_node_field_edited,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphCallbacks {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraphCallbacks = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeAddedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeAddedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeAddedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeAdded {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeAddedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeAdded {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeAdded = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeRemovedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeRemovedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeRemovedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeRemoved {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeRemovedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeRemoved {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeRemoved = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeGraphDraggedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeGraphDraggedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeGraphDraggedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeGraphDraggedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeGraphDragged {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeGraphDraggedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeGraphDragged {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeGraphDragged = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeDraggedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeDraggedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeDraggedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeDragged {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeDraggedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeDragged {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeDragged = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeConnectedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeConnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeConnectedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeConnectedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeConnected {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeConnectedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeConnected {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeConnected = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeInputDisconnectedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeInputDisconnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeInputDisconnectedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeInputDisconnectedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeInputDisconnected {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeInputDisconnectedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeInputDisconnected {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeInputDisconnected =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeInputDisconnected =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeOutputDisconnectedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeOutputDisconnectedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnectedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnectedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeOutputDisconnected {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeOutputDisconnectedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeOutputDisconnected {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnected =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeOutputDisconnected =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeFieldEditedCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeFieldEditedCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeFieldEditedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeFieldEditedCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphOnNodeFieldEdited {
    #[new]
    fn __new__(data: AzRefAny, callback: AzNodeGraphOnNodeFieldEditedCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphOnNodeFieldEdited {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OnNodeFieldEdited = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeGraphNodeId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeGraphNodeId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeGraphNodeId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNode {
    #[new]
    fn __new__(
        node_type: AzNodeTypeId,
        position: AzNodePosition,
        fields: AzNodeTypeFieldVec,
        connect_in: AzInputConnectionVec,
        connect_out: AzOutputConnectionVec,
    ) -> Self {
        Self {
            node_type,
            position,
            fields,
            connect_in,
            connect_out,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::Node = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeField {
    #[new]
    fn __new__(key: AzString, value: AzNodeTypeFieldValueEnumWrapper) -> Self {
        Self { key, value }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeField {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeField = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldValueEnumWrapper {
    #[staticmethod]
    fn TextInput(v: AzString) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper {
            inner: AzNodeTypeFieldValue::TextInput(v),
        }
    }
    #[staticmethod]
    fn NumberInput(v: f32) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper {
            inner: AzNodeTypeFieldValue::NumberInput(v),
        }
    }
    #[staticmethod]
    fn CheckBox(v: bool) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper {
            inner: AzNodeTypeFieldValue::CheckBox(v),
        }
    }
    #[staticmethod]
    fn ColorInput(v: AzColorU) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper {
            inner: AzNodeTypeFieldValue::ColorInput(v),
        }
    }
    #[staticmethod]
    fn FileInput(v: AzOptionStringEnumWrapper) -> AzNodeTypeFieldValueEnumWrapper {
        AzNodeTypeFieldValueEnumWrapper {
            inner: AzNodeTypeFieldValue::FileInput(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeTypeFieldValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeFieldValue::TextInput(v) => {
                Ok(vec!["TextInput".into_py(py), v.clone().into_py(py)])
            }
            AzNodeTypeFieldValue::NumberInput(v) => {
                Ok(vec!["NumberInput".into_py(py), v.into_py(py)])
            }
            AzNodeTypeFieldValue::CheckBox(v) => Ok(vec!["CheckBox".into_py(py), v.into_py(py)]),
            AzNodeTypeFieldValue::ColorInput(v) => {
                Ok(vec!["ColorInput".into_py(py), v.clone().into_py(py)])
            }
            AzNodeTypeFieldValue::FileInput(v) => Ok(vec![
                "FileInput".into_py(py),
                {
                    let m: &AzOptionStringEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeFieldValue =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeFieldValue =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnection {
    #[new]
    fn __new__(input_index: usize, connects_to: AzOutputNodeAndIndexVec) -> Self {
        Self {
            input_index,
            connects_to,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputConnection {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputConnection = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndex {
    #[new]
    fn __new__(node_id: AzNodeGraphNodeId, output_index: usize) -> Self {
        Self {
            node_id,
            output_index,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndex {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnection {
    #[new]
    fn __new__(output_index: usize, connects_to: AzInputNodeAndIndexVec) -> Self {
        Self {
            output_index,
            connects_to,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputConnection {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputConnection = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndex {
    #[new]
    fn __new__(node_id: AzNodeGraphNodeId, input_index: usize) -> Self {
        Self {
            node_id,
            input_index,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndex {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputNodeAndIndex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeInfo {
    #[new]
    fn __new__(
        is_root: bool,
        name: AzString,
        inputs: AzInputOutputTypeIdVec,
        outputs: AzInputOutputTypeIdVec,
    ) -> Self {
        Self {
            is_root,
            name,
            inputs,
            outputs,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputInfo {
    #[new]
    fn __new__(data_type: AzString, color: AzColorU) -> Self {
        Self { data_type, color }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodePosition {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodePosition {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodePosition = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGraphDragAmount {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGraphDragAmount {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::GraphDragAmount = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDragAmount {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDragAmount {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeDragAmount = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListView {
    #[new]
    fn new(columns: AzStringVec) -> AzListView {
        unsafe { mem::transmute(crate::AzListView_new(mem::transmute(columns))) }
    }
    fn with_rows(&mut self, rows: AzListViewRowVec) -> AzListView {
        unsafe {
            mem::transmute(crate::AzListView_withRows(
                mem::transmute(self),
                mem::transmute(rows),
            ))
        }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzListView_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListView {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListView = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListView = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRow {
    #[new]
    fn __new__(cells: AzDomVec, height: AzOptionPixelValueNoPercentEnumWrapper) -> Self {
        Self { cells, height }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewRow {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewRow = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewState {
    #[new]
    fn __new__(
        columns: AzStringVec,
        sorted_by: AzOptionUsizeEnumWrapper,
        current_row_count: usize,
        scroll_offset: AzPixelValueNoPercent,
        current_scroll_position: AzLogicalPosition,
        current_content_height: AzLogicalSize,
    ) -> Self {
        Self {
            columns,
            sorted_by,
            current_row_count,
            scroll_offset,
            current_scroll_position,
            current_content_height,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnLazyLoadScrollCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnLazyLoadScrollCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnLazyLoadScrollCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnLazyLoadScrollCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnLazyLoadScroll {
    #[new]
    fn __new__(data: AzRefAny, callback: AzListViewOnLazyLoadScrollCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnLazyLoadScroll {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnLazyLoadScroll =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnLazyLoadScroll =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnColumnClickCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnColumnClickCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnColumnClickCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnColumnClickCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnColumnClick {
    #[new]
    fn __new__(data: AzRefAny, callback: AzListViewOnColumnClickCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnColumnClick {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnColumnClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnRowClickCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnRowClickCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnRowClickCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnRowClickCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewOnRowClick {
    #[new]
    fn __new__(data: AzRefAny, callback: AzListViewOnRowClickCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewOnRowClick {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewOnRowClick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTreeView {
    #[new]
    fn new(root: String) -> AzTreeView {
        let root = pystring_to_azstring(&root);
        unsafe { mem::transmute(crate::AzTreeView_new(mem::transmute(root))) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzTreeView_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTreeView {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tree_view::TreeView = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tree_view::TreeView = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDown {
    #[new]
    fn new(choices: AzStringVec) -> AzDropDown {
        unsafe { mem::transmute(crate::AzDropDown_new(mem::transmute(choices))) }
    }
    fn dom(&mut self) -> AzDom {
        unsafe { mem::transmute(crate::AzDropDown_dom(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDropDown {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::DropDown = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::DropDown = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDownOnChoiceChangeCallback {
    #[new]
    fn __new__() -> Self {
        Self {}
    }
}

#[pyproto]
impl PyObjectProtocol for AzDropDownOnChoiceChangeCallback {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::DropDownOnChoiceChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::DropDownOnChoiceChangeCallback =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDropDownOnChoiceChange {
    #[new]
    fn __new__(data: AzRefAny, callback: AzDropDownOnChoiceChangeCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDropDownOnChoiceChange {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::DropDownOnChoiceChange = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItem {
    #[new]
    fn __new__(
        parent: usize,
        previous_sibling: usize,
        next_sibling: usize,
        last_child: usize,
    ) -> Self {
        Self {
            parent,
            previous_sibling,
            next_sibling,
            last_child,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItem {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItem = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfo {
    #[new]
    fn __new__(index_in_parent: u32, is_last_child: bool) -> Self {
        Self {
            index_in_parent,
            is_last_child,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfo {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::style::CascadeInfo = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertySourceEnumWrapper {
    #[staticmethod]
    fn Css(v: AzCssPath) -> AzCssPropertySourceEnumWrapper {
        AzCssPropertySourceEnumWrapper {
            inner: AzCssPropertySource::Css(v),
        }
    }
    #[classattr]
    fn Inline() -> AzCssPropertySourceEnumWrapper {
        AzCssPropertySourceEnumWrapper {
            inner: AzCssPropertySource::Inline,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssPropertySource;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertySource::Css(v) => Ok(vec!["Css".into_py(py), v.clone().into_py(py)]),
            AzCssPropertySource::Inline => Ok(vec!["Inline".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertySourceEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::CssPropertySource = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::CssPropertySource = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeState {
    #[new]
    fn __new__(normal: bool, hover: bool, active: bool, focused: bool) -> Self {
        Self {
            normal,
            hover,
            active,
            focused,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeState {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNodeState = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNode {
    #[new]
    fn __new__(state: AzStyledNodeState, tag_id: AzOptionTagIdEnumWrapper) -> Self {
        Self { state, tag_id }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagId {
    #[new]
    fn __new__(inner: u64) -> Self {
        Self { inner }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTagId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::AzTagId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::AzTagId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMapping {
    #[new]
    fn __new__(
        tag_id: AzTagId,
        node_id: AzNodeId,
        tab_index: AzOptionTabIndexEnumWrapper,
        parents: AzNodeIdVec,
    ) -> Self {
        Self {
            tag_id,
            node_id,
            tab_index,
            parents,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMapping {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::TagIdToNodeIdMapping = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepth {
    #[new]
    fn __new__(depth: usize, node_id: AzNodeId) -> Self {
        Self { depth, node_id }
    }
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepth {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::ParentWithNodeDepth = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyCache {}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyCache {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::CssPropertyCachePtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledDom {
    #[new]
    fn new(dom: AzDom, css: AzCss) -> AzStyledDom {
        unsafe {
            mem::transmute(crate::AzStyledDom_new(
                mem::transmute(dom),
                mem::transmute(css),
            ))
        }
    }
    #[staticmethod]
    fn default() -> AzStyledDom {
        unsafe { mem::transmute(crate::AzStyledDom_default()) }
    }
    #[staticmethod]
    fn from_xml(xml_string: String) -> AzStyledDom {
        let xml_string = pystring_to_azstring(&xml_string);
        unsafe { mem::transmute(crate::AzStyledDom_fromXml(mem::transmute(xml_string))) }
    }
    #[staticmethod]
    fn from_file(xml_file_path: String) -> AzStyledDom {
        let xml_file_path = pystring_to_azstring(&xml_file_path);
        unsafe { mem::transmute(crate::AzStyledDom_fromFile(mem::transmute(xml_file_path))) }
    }
    fn append_child(&mut self, dom: AzStyledDom) -> () {
        unsafe {
            mem::transmute(crate::AzStyledDom_appendChild(
                mem::transmute(self),
                mem::transmute(dom),
            ))
        }
    }
    fn with_child(&mut self, dom: AzStyledDom) -> AzStyledDom {
        unsafe {
            mem::transmute(crate::AzStyledDom_withChild(
                mem::transmute(self),
                mem::transmute(dom),
            ))
        }
    }
    fn restyle(&mut self, css: AzCss) -> () {
        unsafe {
            mem::transmute(crate::AzStyledDom_restyle(
                mem::transmute(self),
                mem::transmute(css),
            ))
        }
    }
    fn node_count(&self) -> usize {
        unsafe { mem::transmute(crate::AzStyledDom_nodeCount(mem::transmute(self))) }
    }
    fn get_html_string(&self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzStyledDom_getHtmlString(mem::transmute(self)))
        })
    }
    fn get_html_string_test(&self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzStyledDom_getHtmlStringTest(mem::transmute(self)))
        })
    }
    fn set_menu_bar(&mut self, menu: AzMenu) -> () {
        unsafe {
            mem::transmute(crate::AzStyledDom_setMenuBar(
                mem::transmute(self),
                mem::transmute(menu),
            ))
        }
    }
    fn with_menu_bar(&mut self, menu: AzMenu) -> AzStyledDom {
        unsafe {
            mem::transmute(crate::AzStyledDom_withMenuBar(
                mem::transmute(self),
                mem::transmute(menu),
            ))
        }
    }
    fn set_context_menu(&mut self, menu: AzMenu) -> () {
        unsafe {
            mem::transmute(crate::AzStyledDom_setContextMenu(
                mem::transmute(self),
                mem::transmute(menu),
            ))
        }
    }
    fn with_context_menu(&mut self, menu: AzMenu) -> AzStyledDom {
        unsafe {
            mem::transmute(crate::AzStyledDom_withContextMenu(
                mem::transmute(self),
                mem::transmute(menu),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledDom {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledDom = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTexture {
    #[new]
    fn new(
        texture_id: u32,
        flags: AzTextureFlags,
        size: AzPhysicalSizeU32,
        background_color: AzColorU,
        gl_context: AzGl,
        format: AzRawImageFormatEnumWrapper,
    ) -> AzTexture {
        unsafe {
            mem::transmute(crate::AzTexture_new(
                mem::transmute(texture_id),
                mem::transmute(flags),
                mem::transmute(size),
                mem::transmute(background_color),
                mem::transmute(gl_context),
                mem::transmute(format),
            ))
        }
    }
    #[staticmethod]
    fn allocate_rgba8(gl: AzGl, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture {
        unsafe {
            mem::transmute(crate::AzTexture_allocateRgba8(
                mem::transmute(gl),
                mem::transmute(size),
                mem::transmute(background),
            ))
        }
    }
    #[staticmethod]
    fn allocate_clip_mask(gl: AzGl, size: AzPhysicalSizeU32, background: AzColorU) -> AzTexture {
        unsafe {
            mem::transmute(crate::AzTexture_allocateClipMask(
                mem::transmute(gl),
                mem::transmute(size),
                mem::transmute(background),
            ))
        }
    }
    fn clear(&mut self) -> () {
        unsafe { mem::transmute(crate::AzTexture_clear(mem::transmute(self))) }
    }
    fn draw_clip_mask(&mut self, node: AzTessellatedSvgNode) -> bool {
        unsafe {
            mem::transmute(crate::AzTexture_drawClipMask(
                mem::transmute(self),
                mem::transmute(node),
            ))
        }
    }
    fn apply_fxaa(&mut self) -> bool {
        unsafe { mem::transmute(crate::AzTexture_applyFxaa(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTexture {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::Texture = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::Texture = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrConst {}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrConst {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlVoidPtrConst = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlVoidPtrMut {}

#[pyproto]
impl PyObjectProtocol for AzGlVoidPtrMut {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlVoidPtrMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGl {
    #[classattr]
    const ACCUM: u32 = 0x0100;
    #[classattr]
    const ACCUM_ALPHA_BITS: u32 = 0x0D5B;
    #[classattr]
    const ACCUM_BLUE_BITS: u32 = 0x0D5A;
    #[classattr]
    const ACCUM_BUFFER_BIT: u32 = 0x00000200;
    #[classattr]
    const ACCUM_CLEAR_VALUE: u32 = 0x0B80;
    #[classattr]
    const ACCUM_GREEN_BITS: u32 = 0x0D59;
    #[classattr]
    const ACCUM_RED_BITS: u32 = 0x0D58;
    #[classattr]
    const ACTIVE_ATTRIBUTES: u32 = 0x8B89;
    #[classattr]
    const ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
    #[classattr]
    const ACTIVE_TEXTURE: u32 = 0x84E0;
    #[classattr]
    const ACTIVE_UNIFORMS: u32 = 0x8B86;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
    #[classattr]
    const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
    #[classattr]
    const ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
    #[classattr]
    const ADD: u32 = 0x0104;
    #[classattr]
    const ADD_SIGNED: u32 = 0x8574;
    #[classattr]
    const ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
    #[classattr]
    const ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
    #[classattr]
    const ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const ALPHA: u32 = 0x1906;
    #[classattr]
    const ALPHA12: u32 = 0x803D;
    #[classattr]
    const ALPHA16: u32 = 0x803E;
    #[classattr]
    const ALPHA16F_EXT: u32 = 0x881C;
    #[classattr]
    const ALPHA32F_EXT: u32 = 0x8816;
    #[classattr]
    const ALPHA4: u32 = 0x803B;
    #[classattr]
    const ALPHA8: u32 = 0x803C;
    #[classattr]
    const ALPHA8_EXT: u32 = 0x803C;
    #[classattr]
    const ALPHA_BIAS: u32 = 0x0D1D;
    #[classattr]
    const ALPHA_BITS: u32 = 0x0D55;
    #[classattr]
    const ALPHA_INTEGER: u32 = 0x8D97;
    #[classattr]
    const ALPHA_SCALE: u32 = 0x0D1C;
    #[classattr]
    const ALPHA_TEST: u32 = 0x0BC0;
    #[classattr]
    const ALPHA_TEST_FUNC: u32 = 0x0BC1;
    #[classattr]
    const ALPHA_TEST_REF: u32 = 0x0BC2;
    #[classattr]
    const ALREADY_SIGNALED: u32 = 0x911A;
    #[classattr]
    const ALWAYS: u32 = 0x0207;
    #[classattr]
    const AMBIENT: u32 = 0x1200;
    #[classattr]
    const AMBIENT_AND_DIFFUSE: u32 = 0x1602;
    #[classattr]
    const AND: u32 = 0x1501;
    #[classattr]
    const AND_INVERTED: u32 = 0x1504;
    #[classattr]
    const AND_REVERSE: u32 = 0x1502;
    #[classattr]
    const ANY_SAMPLES_PASSED: u32 = 0x8C2F;
    #[classattr]
    const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
    #[classattr]
    const ARRAY_BUFFER: u32 = 0x8892;
    #[classattr]
    const ARRAY_BUFFER_BINDING: u32 = 0x8894;
    #[classattr]
    const ATTACHED_SHADERS: u32 = 0x8B85;
    #[classattr]
    const ATTRIB_STACK_DEPTH: u32 = 0x0BB0;
    #[classattr]
    const AUTO_NORMAL: u32 = 0x0D80;
    #[classattr]
    const AUX0: u32 = 0x0409;
    #[classattr]
    const AUX1: u32 = 0x040A;
    #[classattr]
    const AUX2: u32 = 0x040B;
    #[classattr]
    const AUX3: u32 = 0x040C;
    #[classattr]
    const AUX_BUFFERS: u32 = 0x0C00;
    #[classattr]
    const BACK: u32 = 0x0405;
    #[classattr]
    const BACK_LEFT: u32 = 0x0402;
    #[classattr]
    const BACK_RIGHT: u32 = 0x0403;
    #[classattr]
    const BGR: u32 = 0x80E0;
    #[classattr]
    const BGRA: u32 = 0x80E1;
    #[classattr]
    const BGRA8_EXT: u32 = 0x93A1;
    #[classattr]
    const BGRA_EXT: u32 = 0x80E1;
    #[classattr]
    const BGRA_INTEGER: u32 = 0x8D9B;
    #[classattr]
    const BGR_INTEGER: u32 = 0x8D9A;
    #[classattr]
    const BITMAP: u32 = 0x1A00;
    #[classattr]
    const BITMAP_TOKEN: u32 = 0x0704;
    #[classattr]
    const BLEND: u32 = 0x0BE2;
    #[classattr]
    const BLEND_ADVANCED_COHERENT_KHR: u32 = 0x9285;
    #[classattr]
    const BLEND_COLOR: u32 = 0x8005;
    #[classattr]
    const BLEND_DST: u32 = 0x0BE0;
    #[classattr]
    const BLEND_DST_ALPHA: u32 = 0x80CA;
    #[classattr]
    const BLEND_DST_RGB: u32 = 0x80C8;
    #[classattr]
    const BLEND_EQUATION: u32 = 0x8009;
    #[classattr]
    const BLEND_EQUATION_ALPHA: u32 = 0x883D;
    #[classattr]
    const BLEND_EQUATION_RGB: u32 = 0x8009;
    #[classattr]
    const BLEND_SRC: u32 = 0x0BE1;
    #[classattr]
    const BLEND_SRC_ALPHA: u32 = 0x80CB;
    #[classattr]
    const BLEND_SRC_RGB: u32 = 0x80C9;
    #[classattr]
    const BLUE: u32 = 0x1905;
    #[classattr]
    const BLUE_BIAS: u32 = 0x0D1B;
    #[classattr]
    const BLUE_BITS: u32 = 0x0D54;
    #[classattr]
    const BLUE_INTEGER: u32 = 0x8D96;
    #[classattr]
    const BLUE_SCALE: u32 = 0x0D1A;
    #[classattr]
    const BOOL: u32 = 0x8B56;
    #[classattr]
    const BOOL_VEC2: u32 = 0x8B57;
    #[classattr]
    const BOOL_VEC3: u32 = 0x8B58;
    #[classattr]
    const BOOL_VEC4: u32 = 0x8B59;
    #[classattr]
    const BUFFER: u32 = 0x82E0;
    #[classattr]
    const BUFFER_ACCESS: u32 = 0x88BB;
    #[classattr]
    const BUFFER_ACCESS_FLAGS: u32 = 0x911F;
    #[classattr]
    const BUFFER_KHR: u32 = 0x82E0;
    #[classattr]
    const BUFFER_MAPPED: u32 = 0x88BC;
    #[classattr]
    const BUFFER_MAP_LENGTH: u32 = 0x9120;
    #[classattr]
    const BUFFER_MAP_OFFSET: u32 = 0x9121;
    #[classattr]
    const BUFFER_MAP_POINTER: u32 = 0x88BD;
    #[classattr]
    const BUFFER_SIZE: u32 = 0x8764;
    #[classattr]
    const BUFFER_USAGE: u32 = 0x8765;
    #[classattr]
    const BYTE: u32 = 0x1400;
    #[classattr]
    const C3F_V3F: u32 = 0x2A24;
    #[classattr]
    const C4F_N3F_V3F: u32 = 0x2A26;
    #[classattr]
    const C4UB_V2F: u32 = 0x2A22;
    #[classattr]
    const C4UB_V3F: u32 = 0x2A23;
    #[classattr]
    const CCW: u32 = 0x0901;
    #[classattr]
    const CLAMP: u32 = 0x2900;
    #[classattr]
    const CLAMP_FRAGMENT_COLOR: u32 = 0x891B;
    #[classattr]
    const CLAMP_READ_COLOR: u32 = 0x891C;
    #[classattr]
    const CLAMP_TO_BORDER: u32 = 0x812D;
    #[classattr]
    const CLAMP_TO_EDGE: u32 = 0x812F;
    #[classattr]
    const CLAMP_VERTEX_COLOR: u32 = 0x891A;
    #[classattr]
    const CLEAR: u32 = 0x1500;
    #[classattr]
    const CLIENT_ACTIVE_TEXTURE: u32 = 0x84E1;
    #[classattr]
    const CLIENT_ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
    #[classattr]
    const CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0BB1;
    #[classattr]
    const CLIENT_PIXEL_STORE_BIT: u32 = 0x00000001;
    #[classattr]
    const CLIENT_VERTEX_ARRAY_BIT: u32 = 0x00000002;
    #[classattr]
    const CLIP_DISTANCE0: u32 = 0x3000;
    #[classattr]
    const CLIP_DISTANCE1: u32 = 0x3001;
    #[classattr]
    const CLIP_DISTANCE2: u32 = 0x3002;
    #[classattr]
    const CLIP_DISTANCE3: u32 = 0x3003;
    #[classattr]
    const CLIP_DISTANCE4: u32 = 0x3004;
    #[classattr]
    const CLIP_DISTANCE5: u32 = 0x3005;
    #[classattr]
    const CLIP_DISTANCE6: u32 = 0x3006;
    #[classattr]
    const CLIP_DISTANCE7: u32 = 0x3007;
    #[classattr]
    const CLIP_PLANE0: u32 = 0x3000;
    #[classattr]
    const CLIP_PLANE1: u32 = 0x3001;
    #[classattr]
    const CLIP_PLANE2: u32 = 0x3002;
    #[classattr]
    const CLIP_PLANE3: u32 = 0x3003;
    #[classattr]
    const CLIP_PLANE4: u32 = 0x3004;
    #[classattr]
    const CLIP_PLANE5: u32 = 0x3005;
    #[classattr]
    const COEFF: u32 = 0x0A00;
    #[classattr]
    const COLOR: u32 = 0x1800;
    #[classattr]
    const COLORBURN_KHR: u32 = 0x929A;
    #[classattr]
    const COLORDODGE_KHR: u32 = 0x9299;
    #[classattr]
    const COLOR_ARRAY: u32 = 0x8076;
    #[classattr]
    const COLOR_ARRAY_BUFFER_BINDING: u32 = 0x8898;
    #[classattr]
    const COLOR_ARRAY_POINTER: u32 = 0x8090;
    #[classattr]
    const COLOR_ARRAY_SIZE: u32 = 0x8081;
    #[classattr]
    const COLOR_ARRAY_STRIDE: u32 = 0x8083;
    #[classattr]
    const COLOR_ARRAY_TYPE: u32 = 0x8082;
    #[classattr]
    const COLOR_ATTACHMENT0: u32 = 0x8CE0;
    #[classattr]
    const COLOR_ATTACHMENT1: u32 = 0x8CE1;
    #[classattr]
    const COLOR_ATTACHMENT10: u32 = 0x8CEA;
    #[classattr]
    const COLOR_ATTACHMENT11: u32 = 0x8CEB;
    #[classattr]
    const COLOR_ATTACHMENT12: u32 = 0x8CEC;
    #[classattr]
    const COLOR_ATTACHMENT13: u32 = 0x8CED;
    #[classattr]
    const COLOR_ATTACHMENT14: u32 = 0x8CEE;
    #[classattr]
    const COLOR_ATTACHMENT15: u32 = 0x8CEF;
    #[classattr]
    const COLOR_ATTACHMENT16: u32 = 0x8CF0;
    #[classattr]
    const COLOR_ATTACHMENT17: u32 = 0x8CF1;
    #[classattr]
    const COLOR_ATTACHMENT18: u32 = 0x8CF2;
    #[classattr]
    const COLOR_ATTACHMENT19: u32 = 0x8CF3;
    #[classattr]
    const COLOR_ATTACHMENT2: u32 = 0x8CE2;
    #[classattr]
    const COLOR_ATTACHMENT20: u32 = 0x8CF4;
    #[classattr]
    const COLOR_ATTACHMENT21: u32 = 0x8CF5;
    #[classattr]
    const COLOR_ATTACHMENT22: u32 = 0x8CF6;
    #[classattr]
    const COLOR_ATTACHMENT23: u32 = 0x8CF7;
    #[classattr]
    const COLOR_ATTACHMENT24: u32 = 0x8CF8;
    #[classattr]
    const COLOR_ATTACHMENT25: u32 = 0x8CF9;
    #[classattr]
    const COLOR_ATTACHMENT26: u32 = 0x8CFA;
    #[classattr]
    const COLOR_ATTACHMENT27: u32 = 0x8CFB;
    #[classattr]
    const COLOR_ATTACHMENT28: u32 = 0x8CFC;
    #[classattr]
    const COLOR_ATTACHMENT29: u32 = 0x8CFD;
    #[classattr]
    const COLOR_ATTACHMENT3: u32 = 0x8CE3;
    #[classattr]
    const COLOR_ATTACHMENT30: u32 = 0x8CFE;
    #[classattr]
    const COLOR_ATTACHMENT31: u32 = 0x8CFF;
    #[classattr]
    const COLOR_ATTACHMENT4: u32 = 0x8CE4;
    #[classattr]
    const COLOR_ATTACHMENT5: u32 = 0x8CE5;
    #[classattr]
    const COLOR_ATTACHMENT6: u32 = 0x8CE6;
    #[classattr]
    const COLOR_ATTACHMENT7: u32 = 0x8CE7;
    #[classattr]
    const COLOR_ATTACHMENT8: u32 = 0x8CE8;
    #[classattr]
    const COLOR_ATTACHMENT9: u32 = 0x8CE9;
    #[classattr]
    const COLOR_BUFFER_BIT: u32 = 0x00004000;
    #[classattr]
    const COLOR_CLEAR_VALUE: u32 = 0x0C22;
    #[classattr]
    const COLOR_INDEX: u32 = 0x1900;
    #[classattr]
    const COLOR_INDEXES: u32 = 0x1603;
    #[classattr]
    const COLOR_LOGIC_OP: u32 = 0x0BF2;
    #[classattr]
    const COLOR_MATERIAL: u32 = 0x0B57;
    #[classattr]
    const COLOR_MATERIAL_FACE: u32 = 0x0B55;
    #[classattr]
    const COLOR_MATERIAL_PARAMETER: u32 = 0x0B56;
    #[classattr]
    const COLOR_SUM: u32 = 0x8458;
    #[classattr]
    const COLOR_WRITEMASK: u32 = 0x0C23;
    #[classattr]
    const COMBINE: u32 = 0x8570;
    #[classattr]
    const COMBINE_ALPHA: u32 = 0x8572;
    #[classattr]
    const COMBINE_RGB: u32 = 0x8571;
    #[classattr]
    const COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPARE_R_TO_TEXTURE: u32 = 0x884E;
    #[classattr]
    const COMPILE: u32 = 0x1300;
    #[classattr]
    const COMPILE_AND_EXECUTE: u32 = 0x1301;
    #[classattr]
    const COMPILE_STATUS: u32 = 0x8B81;
    #[classattr]
    const COMPRESSED_ALPHA: u32 = 0x84E9;
    #[classattr]
    const COMPRESSED_INTENSITY: u32 = 0x84EC;
    #[classattr]
    const COMPRESSED_LUMINANCE: u32 = 0x84EA;
    #[classattr]
    const COMPRESSED_LUMINANCE_ALPHA: u32 = 0x84EB;
    #[classattr]
    const COMPRESSED_R11_EAC: u32 = 0x9270;
    #[classattr]
    const COMPRESSED_RED: u32 = 0x8225;
    #[classattr]
    const COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
    #[classattr]
    const COMPRESSED_RG: u32 = 0x8226;
    #[classattr]
    const COMPRESSED_RG11_EAC: u32 = 0x9272;
    #[classattr]
    const COMPRESSED_RGB: u32 = 0x84ED;
    #[classattr]
    const COMPRESSED_RGB8_ETC2: u32 = 0x9274;
    #[classattr]
    const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
    #[classattr]
    const COMPRESSED_RGBA: u32 = 0x84EE;
    #[classattr]
    const COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
    #[classattr]
    const COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
    #[classattr]
    const COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
    #[classattr]
    const COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
    #[classattr]
    const COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
    #[classattr]
    const COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
    #[classattr]
    const COMPRESSED_SLUMINANCE: u32 = 0x8C4A;
    #[classattr]
    const COMPRESSED_SLUMINANCE_ALPHA: u32 = 0x8C4B;
    #[classattr]
    const COMPRESSED_SRGB: u32 = 0x8C48;
    #[classattr]
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
    #[classattr]
    const COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
    #[classattr]
    const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
    #[classattr]
    const COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
    #[classattr]
    const COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
    #[classattr]
    const CONDITION_SATISFIED: u32 = 0x911C;
    #[classattr]
    const CONSTANT: u32 = 0x8576;
    #[classattr]
    const CONSTANT_ALPHA: u32 = 0x8003;
    #[classattr]
    const CONSTANT_ATTENUATION: u32 = 0x1207;
    #[classattr]
    const CONSTANT_COLOR: u32 = 0x8001;
    #[classattr]
    const CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_FLAGS: u32 = 0x821E;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
    #[classattr]
    const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
    #[classattr]
    const CONTEXT_PROFILE_MASK: u32 = 0x9126;
    #[classattr]
    const COORD_REPLACE: u32 = 0x8862;
    #[classattr]
    const COPY: u32 = 0x1503;
    #[classattr]
    const COPY_INVERTED: u32 = 0x150C;
    #[classattr]
    const COPY_PIXEL_TOKEN: u32 = 0x0706;
    #[classattr]
    const COPY_READ_BUFFER: u32 = 0x8F36;
    #[classattr]
    const COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
    #[classattr]
    const COPY_WRITE_BUFFER: u32 = 0x8F37;
    #[classattr]
    const COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
    #[classattr]
    const CULL_FACE: u32 = 0x0B44;
    #[classattr]
    const CULL_FACE_MODE: u32 = 0x0B45;
    #[classattr]
    const CURRENT_BIT: u32 = 0x00000001;
    #[classattr]
    const CURRENT_COLOR: u32 = 0x0B00;
    #[classattr]
    const CURRENT_FOG_COORD: u32 = 0x8453;
    #[classattr]
    const CURRENT_FOG_COORDINATE: u32 = 0x8453;
    #[classattr]
    const CURRENT_INDEX: u32 = 0x0B01;
    #[classattr]
    const CURRENT_NORMAL: u32 = 0x0B02;
    #[classattr]
    const CURRENT_PROGRAM: u32 = 0x8B8D;
    #[classattr]
    const CURRENT_QUERY: u32 = 0x8865;
    #[classattr]
    const CURRENT_QUERY_EXT: u32 = 0x8865;
    #[classattr]
    const CURRENT_RASTER_COLOR: u32 = 0x0B04;
    #[classattr]
    const CURRENT_RASTER_DISTANCE: u32 = 0x0B09;
    #[classattr]
    const CURRENT_RASTER_INDEX: u32 = 0x0B05;
    #[classattr]
    const CURRENT_RASTER_POSITION: u32 = 0x0B07;
    #[classattr]
    const CURRENT_RASTER_POSITION_VALID: u32 = 0x0B08;
    #[classattr]
    const CURRENT_RASTER_SECONDARY_COLOR: u32 = 0x845F;
    #[classattr]
    const CURRENT_RASTER_TEXTURE_COORDS: u32 = 0x0B06;
    #[classattr]
    const CURRENT_SECONDARY_COLOR: u32 = 0x8459;
    #[classattr]
    const CURRENT_TEXTURE_COORDS: u32 = 0x0B03;
    #[classattr]
    const CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
    #[classattr]
    const CW: u32 = 0x0900;
    #[classattr]
    const DARKEN_KHR: u32 = 0x9297;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
    #[classattr]
    const DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
    #[classattr]
    const DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
    #[classattr]
    const DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
    #[classattr]
    const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
    #[classattr]
    const DEBUG_OUTPUT: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_KHR: u32 = 0x92E0;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
    #[classattr]
    const DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
    #[classattr]
    const DEBUG_SEVERITY_HIGH: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
    #[classattr]
    const DEBUG_SEVERITY_LOW: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
    #[classattr]
    const DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
    #[classattr]
    const DEBUG_SOURCE_API: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_API_KHR: u32 = 0x8246;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
    #[classattr]
    const DEBUG_SOURCE_OTHER: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
    #[classattr]
    const DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
    #[classattr]
    const DEBUG_TYPE_ERROR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
    #[classattr]
    const DEBUG_TYPE_MARKER: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
    #[classattr]
    const DEBUG_TYPE_OTHER: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
    #[classattr]
    const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
    #[classattr]
    const DECAL: u32 = 0x2101;
    #[classattr]
    const DECR: u32 = 0x1E03;
    #[classattr]
    const DECR_WRAP: u32 = 0x8508;
    #[classattr]
    const DELETE_STATUS: u32 = 0x8B80;
    #[classattr]
    const DEPTH: u32 = 0x1801;
    #[classattr]
    const DEPTH24_STENCIL8: u32 = 0x88F0;
    #[classattr]
    const DEPTH32F_STENCIL8: u32 = 0x8CAD;
    #[classattr]
    const DEPTH_ATTACHMENT: u32 = 0x8D00;
    #[classattr]
    const DEPTH_BIAS: u32 = 0x0D1F;
    #[classattr]
    const DEPTH_BITS: u32 = 0x0D56;
    #[classattr]
    const DEPTH_BUFFER_BIT: u32 = 0x00000100;
    #[classattr]
    const DEPTH_CLAMP: u32 = 0x864F;
    #[classattr]
    const DEPTH_CLEAR_VALUE: u32 = 0x0B73;
    #[classattr]
    const DEPTH_COMPONENT: u32 = 0x1902;
    #[classattr]
    const DEPTH_COMPONENT16: u32 = 0x81A5;
    #[classattr]
    const DEPTH_COMPONENT24: u32 = 0x81A6;
    #[classattr]
    const DEPTH_COMPONENT32: u32 = 0x81A7;
    #[classattr]
    const DEPTH_COMPONENT32F: u32 = 0x8CAC;
    #[classattr]
    const DEPTH_FUNC: u32 = 0x0B74;
    #[classattr]
    const DEPTH_RANGE: u32 = 0x0B70;
    #[classattr]
    const DEPTH_SCALE: u32 = 0x0D1E;
    #[classattr]
    const DEPTH_STENCIL: u32 = 0x84F9;
    #[classattr]
    const DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
    #[classattr]
    const DEPTH_TEST: u32 = 0x0B71;
    #[classattr]
    const DEPTH_TEXTURE_MODE: u32 = 0x884B;
    #[classattr]
    const DEPTH_WRITEMASK: u32 = 0x0B72;
    #[classattr]
    const DIFFERENCE_KHR: u32 = 0x929E;
    #[classattr]
    const DIFFUSE: u32 = 0x1201;
    #[classattr]
    const DISPLAY_LIST: u32 = 0x82E7;
    #[classattr]
    const DITHER: u32 = 0x0BD0;
    #[classattr]
    const DOMAIN: u32 = 0x0A02;
    #[classattr]
    const DONT_CARE: u32 = 0x1100;
    #[classattr]
    const DOT3_RGB: u32 = 0x86AE;
    #[classattr]
    const DOT3_RGBA: u32 = 0x86AF;
    #[classattr]
    const DOUBLE: u32 = 0x140A;
    #[classattr]
    const DOUBLEBUFFER: u32 = 0x0C32;
    #[classattr]
    const DRAW_BUFFER: u32 = 0x0C01;
    #[classattr]
    const DRAW_BUFFER0: u32 = 0x8825;
    #[classattr]
    const DRAW_BUFFER1: u32 = 0x8826;
    #[classattr]
    const DRAW_BUFFER10: u32 = 0x882F;
    #[classattr]
    const DRAW_BUFFER11: u32 = 0x8830;
    #[classattr]
    const DRAW_BUFFER12: u32 = 0x8831;
    #[classattr]
    const DRAW_BUFFER13: u32 = 0x8832;
    #[classattr]
    const DRAW_BUFFER14: u32 = 0x8833;
    #[classattr]
    const DRAW_BUFFER15: u32 = 0x8834;
    #[classattr]
    const DRAW_BUFFER2: u32 = 0x8827;
    #[classattr]
    const DRAW_BUFFER3: u32 = 0x8828;
    #[classattr]
    const DRAW_BUFFER4: u32 = 0x8829;
    #[classattr]
    const DRAW_BUFFER5: u32 = 0x882A;
    #[classattr]
    const DRAW_BUFFER6: u32 = 0x882B;
    #[classattr]
    const DRAW_BUFFER7: u32 = 0x882C;
    #[classattr]
    const DRAW_BUFFER8: u32 = 0x882D;
    #[classattr]
    const DRAW_BUFFER9: u32 = 0x882E;
    #[classattr]
    const DRAW_FRAMEBUFFER: u32 = 0x8CA9;
    #[classattr]
    const DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const DRAW_PIXELS_APPLE: u32 = 0x8A0A;
    #[classattr]
    const DRAW_PIXEL_TOKEN: u32 = 0x0705;
    #[classattr]
    const DST_ALPHA: u32 = 0x0304;
    #[classattr]
    const DST_COLOR: u32 = 0x0306;
    #[classattr]
    const DYNAMIC_COPY: u32 = 0x88EA;
    #[classattr]
    const DYNAMIC_DRAW: u32 = 0x88E8;
    #[classattr]
    const DYNAMIC_READ: u32 = 0x88E9;
    #[classattr]
    const EDGE_FLAG: u32 = 0x0B43;
    #[classattr]
    const EDGE_FLAG_ARRAY: u32 = 0x8079;
    #[classattr]
    const EDGE_FLAG_ARRAY_BUFFER_BINDING: u32 = 0x889B;
    #[classattr]
    const EDGE_FLAG_ARRAY_POINTER: u32 = 0x8093;
    #[classattr]
    const EDGE_FLAG_ARRAY_STRIDE: u32 = 0x808C;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
    #[classattr]
    const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
    #[classattr]
    const EMISSION: u32 = 0x1600;
    #[classattr]
    const ENABLE_BIT: u32 = 0x00002000;
    #[classattr]
    const EQUAL: u32 = 0x0202;
    #[classattr]
    const EQUIV: u32 = 0x1509;
    #[classattr]
    const EVAL_BIT: u32 = 0x00010000;
    #[classattr]
    const EXCLUSION_KHR: u32 = 0x92A0;
    #[classattr]
    const EXP: u32 = 0x0800;
    #[classattr]
    const EXP2: u32 = 0x0801;
    #[classattr]
    const EXTENSIONS: u32 = 0x1F03;
    #[classattr]
    const EYE_LINEAR: u32 = 0x2400;
    #[classattr]
    const EYE_PLANE: u32 = 0x2502;
    #[classattr]
    const FALSE: u8 = 0;
    #[classattr]
    const FASTEST: u32 = 0x1101;
    #[classattr]
    const FEEDBACK: u32 = 0x1C01;
    #[classattr]
    const FEEDBACK_BUFFER_POINTER: u32 = 0x0DF0;
    #[classattr]
    const FEEDBACK_BUFFER_SIZE: u32 = 0x0DF1;
    #[classattr]
    const FEEDBACK_BUFFER_TYPE: u32 = 0x0DF2;
    #[classattr]
    const FENCE_APPLE: u32 = 0x8A0B;
    #[classattr]
    const FILL: u32 = 0x1B02;
    #[classattr]
    const FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
    #[classattr]
    const FIXED: u32 = 0x140C;
    #[classattr]
    const FIXED_ONLY: u32 = 0x891D;
    #[classattr]
    const FLAT: u32 = 0x1D00;
    #[classattr]
    const FLOAT: u32 = 0x1406;
    #[classattr]
    const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
    #[classattr]
    const FLOAT_MAT2: u32 = 0x8B5A;
    #[classattr]
    const FLOAT_MAT2x3: u32 = 0x8B65;
    #[classattr]
    const FLOAT_MAT2x4: u32 = 0x8B66;
    #[classattr]
    const FLOAT_MAT3: u32 = 0x8B5B;
    #[classattr]
    const FLOAT_MAT3x2: u32 = 0x8B67;
    #[classattr]
    const FLOAT_MAT3x4: u32 = 0x8B68;
    #[classattr]
    const FLOAT_MAT4: u32 = 0x8B5C;
    #[classattr]
    const FLOAT_MAT4x2: u32 = 0x8B69;
    #[classattr]
    const FLOAT_MAT4x3: u32 = 0x8B6A;
    #[classattr]
    const FLOAT_VEC2: u32 = 0x8B50;
    #[classattr]
    const FLOAT_VEC3: u32 = 0x8B51;
    #[classattr]
    const FLOAT_VEC4: u32 = 0x8B52;
    #[classattr]
    const FOG: u32 = 0x0B60;
    #[classattr]
    const FOG_BIT: u32 = 0x00000080;
    #[classattr]
    const FOG_COLOR: u32 = 0x0B66;
    #[classattr]
    const FOG_COORD: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE: u32 = 0x8451;
    #[classattr]
    const FOG_COORDINATE_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORDINATE_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORDINATE_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORDINATE_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORDINATE_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORDINATE_SOURCE: u32 = 0x8450;
    #[classattr]
    const FOG_COORD_ARRAY: u32 = 0x8457;
    #[classattr]
    const FOG_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889D;
    #[classattr]
    const FOG_COORD_ARRAY_POINTER: u32 = 0x8456;
    #[classattr]
    const FOG_COORD_ARRAY_STRIDE: u32 = 0x8455;
    #[classattr]
    const FOG_COORD_ARRAY_TYPE: u32 = 0x8454;
    #[classattr]
    const FOG_COORD_SRC: u32 = 0x8450;
    #[classattr]
    const FOG_DENSITY: u32 = 0x0B62;
    #[classattr]
    const FOG_END: u32 = 0x0B64;
    #[classattr]
    const FOG_HINT: u32 = 0x0C54;
    #[classattr]
    const FOG_INDEX: u32 = 0x0B61;
    #[classattr]
    const FOG_MODE: u32 = 0x0B65;
    #[classattr]
    const FOG_START: u32 = 0x0B63;
    #[classattr]
    const FRAGMENT_DEPTH: u32 = 0x8452;
    #[classattr]
    const FRAGMENT_SHADER: u32 = 0x8B30;
    #[classattr]
    const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
    #[classattr]
    const FRAMEBUFFER: u32 = 0x8D40;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_ANGLE: u32 = 0x93A3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
    #[classattr]
    const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
    #[classattr]
    const FRAMEBUFFER_BINDING: u32 = 0x8CA6;
    #[classattr]
    const FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
    #[classattr]
    const FRAMEBUFFER_DEFAULT: u32 = 0x8218;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
    #[classattr]
    const FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
    #[classattr]
    const FRAMEBUFFER_SRGB: u32 = 0x8DB9;
    #[classattr]
    const FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
    #[classattr]
    const FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
    #[classattr]
    const FRONT: u32 = 0x0404;
    #[classattr]
    const FRONT_AND_BACK: u32 = 0x0408;
    #[classattr]
    const FRONT_FACE: u32 = 0x0B46;
    #[classattr]
    const FRONT_LEFT: u32 = 0x0400;
    #[classattr]
    const FRONT_RIGHT: u32 = 0x0401;
    #[classattr]
    const FUNC_ADD: u32 = 0x8006;
    #[classattr]
    const FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
    #[classattr]
    const FUNC_SUBTRACT: u32 = 0x800A;
    #[classattr]
    const GENERATE_MIPMAP: u32 = 0x8191;
    #[classattr]
    const GENERATE_MIPMAP_HINT: u32 = 0x8192;
    #[classattr]
    const GEOMETRY_INPUT_TYPE: u32 = 0x8917;
    #[classattr]
    const GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
    #[classattr]
    const GEOMETRY_SHADER: u32 = 0x8DD9;
    #[classattr]
    const GEOMETRY_VERTICES_OUT: u32 = 0x8916;
    #[classattr]
    const GEQUAL: u32 = 0x0206;
    #[classattr]
    const GPU_DISJOINT_EXT: u32 = 0x8FBB;
    #[classattr]
    const GREATER: u32 = 0x0204;
    #[classattr]
    const GREEN: u32 = 0x1904;
    #[classattr]
    const GREEN_BIAS: u32 = 0x0D19;
    #[classattr]
    const GREEN_BITS: u32 = 0x0D53;
    #[classattr]
    const GREEN_INTEGER: u32 = 0x8D95;
    #[classattr]
    const GREEN_SCALE: u32 = 0x0D18;
    #[classattr]
    const HALF_FLOAT: u32 = 0x140B;
    #[classattr]
    const HALF_FLOAT_OES: u32 = 0x8D61;
    #[classattr]
    const HARDLIGHT_KHR: u32 = 0x929B;
    #[classattr]
    const HIGH_FLOAT: u32 = 0x8DF2;
    #[classattr]
    const HIGH_INT: u32 = 0x8DF5;
    #[classattr]
    const HINT_BIT: u32 = 0x00008000;
    #[classattr]
    const HSL_COLOR_KHR: u32 = 0x92AF;
    #[classattr]
    const HSL_HUE_KHR: u32 = 0x92AD;
    #[classattr]
    const HSL_LUMINOSITY_KHR: u32 = 0x92B0;
    #[classattr]
    const HSL_SATURATION_KHR: u32 = 0x92AE;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
    #[classattr]
    const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
    #[classattr]
    const INCR: u32 = 0x1E02;
    #[classattr]
    const INCR_WRAP: u32 = 0x8507;
    #[classattr]
    const INDEX: u32 = 0x8222;
    #[classattr]
    const INDEX_ARRAY: u32 = 0x8077;
    #[classattr]
    const INDEX_ARRAY_BUFFER_BINDING: u32 = 0x8899;
    #[classattr]
    const INDEX_ARRAY_POINTER: u32 = 0x8091;
    #[classattr]
    const INDEX_ARRAY_STRIDE: u32 = 0x8086;
    #[classattr]
    const INDEX_ARRAY_TYPE: u32 = 0x8085;
    #[classattr]
    const INDEX_BITS: u32 = 0x0D51;
    #[classattr]
    const INDEX_CLEAR_VALUE: u32 = 0x0C20;
    #[classattr]
    const INDEX_LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const INDEX_MODE: u32 = 0x0C30;
    #[classattr]
    const INDEX_OFFSET: u32 = 0x0D13;
    #[classattr]
    const INDEX_SHIFT: u32 = 0x0D12;
    #[classattr]
    const INDEX_WRITEMASK: u32 = 0x0C21;
    #[classattr]
    const INFO_LOG_LENGTH: u32 = 0x8B84;
    #[classattr]
    const INT: u32 = 0x1404;
    #[classattr]
    const INTENSITY: u32 = 0x8049;
    #[classattr]
    const INTENSITY12: u32 = 0x804C;
    #[classattr]
    const INTENSITY16: u32 = 0x804D;
    #[classattr]
    const INTENSITY4: u32 = 0x804A;
    #[classattr]
    const INTENSITY8: u32 = 0x804B;
    #[classattr]
    const INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
    #[classattr]
    const INTERPOLATE: u32 = 0x8575;
    #[classattr]
    const INT_2_10_10_10_REV: u32 = 0x8D9F;
    #[classattr]
    const INT_SAMPLER_1D: u32 = 0x8DC9;
    #[classattr]
    const INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
    #[classattr]
    const INT_SAMPLER_2D: u32 = 0x8DCA;
    #[classattr]
    const INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
    #[classattr]
    const INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
    #[classattr]
    const INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
    #[classattr]
    const INT_SAMPLER_3D: u32 = 0x8DCB;
    #[classattr]
    const INT_SAMPLER_BUFFER: u32 = 0x8DD0;
    #[classattr]
    const INT_SAMPLER_CUBE: u32 = 0x8DCC;
    #[classattr]
    const INT_VEC2: u32 = 0x8B53;
    #[classattr]
    const INT_VEC3: u32 = 0x8B54;
    #[classattr]
    const INT_VEC4: u32 = 0x8B55;
    #[classattr]
    const INVALID_ENUM: u32 = 0x0500;
    #[classattr]
    const INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
    #[classattr]
    const INVALID_INDEX: u32 = 0xFFFFFFFF;
    #[classattr]
    const INVALID_OPERATION: u32 = 0x0502;
    #[classattr]
    const INVALID_VALUE: u32 = 0x0501;
    #[classattr]
    const INVERT: u32 = 0x150A;
    #[classattr]
    const KEEP: u32 = 0x1E00;
    #[classattr]
    const LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
    #[classattr]
    const LEFT: u32 = 0x0406;
    #[classattr]
    const LEQUAL: u32 = 0x0203;
    #[classattr]
    const LESS: u32 = 0x0201;
    #[classattr]
    const LIGHT0: u32 = 0x4000;
    #[classattr]
    const LIGHT1: u32 = 0x4001;
    #[classattr]
    const LIGHT2: u32 = 0x4002;
    #[classattr]
    const LIGHT3: u32 = 0x4003;
    #[classattr]
    const LIGHT4: u32 = 0x4004;
    #[classattr]
    const LIGHT5: u32 = 0x4005;
    #[classattr]
    const LIGHT6: u32 = 0x4006;
    #[classattr]
    const LIGHT7: u32 = 0x4007;
    #[classattr]
    const LIGHTEN_KHR: u32 = 0x9298;
    #[classattr]
    const LIGHTING: u32 = 0x0B50;
    #[classattr]
    const LIGHTING_BIT: u32 = 0x00000040;
    #[classattr]
    const LIGHT_MODEL_AMBIENT: u32 = 0x0B53;
    #[classattr]
    const LIGHT_MODEL_COLOR_CONTROL: u32 = 0x81F8;
    #[classattr]
    const LIGHT_MODEL_LOCAL_VIEWER: u32 = 0x0B51;
    #[classattr]
    const LIGHT_MODEL_TWO_SIDE: u32 = 0x0B52;
    #[classattr]
    const LINE: u32 = 0x1B01;
    #[classattr]
    const LINEAR: u32 = 0x2601;
    #[classattr]
    const LINEAR_ATTENUATION: u32 = 0x1208;
    #[classattr]
    const LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
    #[classattr]
    const LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
    #[classattr]
    const LINES: u32 = 0x0001;
    #[classattr]
    const LINES_ADJACENCY: u32 = 0x000A;
    #[classattr]
    const LINE_BIT: u32 = 0x00000004;
    #[classattr]
    const LINE_LOOP: u32 = 0x0002;
    #[classattr]
    const LINE_RESET_TOKEN: u32 = 0x0707;
    #[classattr]
    const LINE_SMOOTH: u32 = 0x0B20;
    #[classattr]
    const LINE_SMOOTH_HINT: u32 = 0x0C52;
    #[classattr]
    const LINE_STIPPLE: u32 = 0x0B24;
    #[classattr]
    const LINE_STIPPLE_PATTERN: u32 = 0x0B25;
    #[classattr]
    const LINE_STIPPLE_REPEAT: u32 = 0x0B26;
    #[classattr]
    const LINE_STRIP: u32 = 0x0003;
    #[classattr]
    const LINE_STRIP_ADJACENCY: u32 = 0x000B;
    #[classattr]
    const LINE_TOKEN: u32 = 0x0702;
    #[classattr]
    const LINE_WIDTH: u32 = 0x0B21;
    #[classattr]
    const LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const LINK_STATUS: u32 = 0x8B82;
    #[classattr]
    const LIST_BASE: u32 = 0x0B32;
    #[classattr]
    const LIST_BIT: u32 = 0x00020000;
    #[classattr]
    const LIST_INDEX: u32 = 0x0B33;
    #[classattr]
    const LIST_MODE: u32 = 0x0B30;
    #[classattr]
    const LOAD: u32 = 0x0101;
    #[classattr]
    const LOGIC_OP: u32 = 0x0BF1;
    #[classattr]
    const LOGIC_OP_MODE: u32 = 0x0BF0;
    #[classattr]
    const LOWER_LEFT: u32 = 0x8CA1;
    #[classattr]
    const LOW_FLOAT: u32 = 0x8DF0;
    #[classattr]
    const LOW_INT: u32 = 0x8DF3;
    #[classattr]
    const LUMINANCE: u32 = 0x1909;
    #[classattr]
    const LUMINANCE12: u32 = 0x8041;
    #[classattr]
    const LUMINANCE12_ALPHA12: u32 = 0x8047;
    #[classattr]
    const LUMINANCE12_ALPHA4: u32 = 0x8046;
    #[classattr]
    const LUMINANCE16: u32 = 0x8042;
    #[classattr]
    const LUMINANCE16F_EXT: u32 = 0x881E;
    #[classattr]
    const LUMINANCE16_ALPHA16: u32 = 0x8048;
    #[classattr]
    const LUMINANCE32F_EXT: u32 = 0x8818;
    #[classattr]
    const LUMINANCE4: u32 = 0x803F;
    #[classattr]
    const LUMINANCE4_ALPHA4: u32 = 0x8043;
    #[classattr]
    const LUMINANCE6_ALPHA2: u32 = 0x8044;
    #[classattr]
    const LUMINANCE8: u32 = 0x8040;
    #[classattr]
    const LUMINANCE8_ALPHA8: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_ALPHA8_EXT: u32 = 0x8045;
    #[classattr]
    const LUMINANCE8_EXT: u32 = 0x8040;
    #[classattr]
    const LUMINANCE_ALPHA: u32 = 0x190A;
    #[classattr]
    const LUMINANCE_ALPHA16F_EXT: u32 = 0x881F;
    #[classattr]
    const LUMINANCE_ALPHA32F_EXT: u32 = 0x8819;
    #[classattr]
    const MAJOR_VERSION: u32 = 0x821B;
    #[classattr]
    const MAP1_COLOR_4: u32 = 0x0D90;
    #[classattr]
    const MAP1_GRID_DOMAIN: u32 = 0x0DD0;
    #[classattr]
    const MAP1_GRID_SEGMENTS: u32 = 0x0DD1;
    #[classattr]
    const MAP1_INDEX: u32 = 0x0D91;
    #[classattr]
    const MAP1_NORMAL: u32 = 0x0D92;
    #[classattr]
    const MAP1_TEXTURE_COORD_1: u32 = 0x0D93;
    #[classattr]
    const MAP1_TEXTURE_COORD_2: u32 = 0x0D94;
    #[classattr]
    const MAP1_TEXTURE_COORD_3: u32 = 0x0D95;
    #[classattr]
    const MAP1_TEXTURE_COORD_4: u32 = 0x0D96;
    #[classattr]
    const MAP1_VERTEX_3: u32 = 0x0D97;
    #[classattr]
    const MAP1_VERTEX_4: u32 = 0x0D98;
    #[classattr]
    const MAP2_COLOR_4: u32 = 0x0DB0;
    #[classattr]
    const MAP2_GRID_DOMAIN: u32 = 0x0DD2;
    #[classattr]
    const MAP2_GRID_SEGMENTS: u32 = 0x0DD3;
    #[classattr]
    const MAP2_INDEX: u32 = 0x0DB1;
    #[classattr]
    const MAP2_NORMAL: u32 = 0x0DB2;
    #[classattr]
    const MAP2_TEXTURE_COORD_1: u32 = 0x0DB3;
    #[classattr]
    const MAP2_TEXTURE_COORD_2: u32 = 0x0DB4;
    #[classattr]
    const MAP2_TEXTURE_COORD_3: u32 = 0x0DB5;
    #[classattr]
    const MAP2_TEXTURE_COORD_4: u32 = 0x0DB6;
    #[classattr]
    const MAP2_VERTEX_3: u32 = 0x0DB7;
    #[classattr]
    const MAP2_VERTEX_4: u32 = 0x0DB8;
    #[classattr]
    const MAP_COLOR: u32 = 0x0D10;
    #[classattr]
    const MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
    #[classattr]
    const MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
    #[classattr]
    const MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
    #[classattr]
    const MAP_READ_BIT: u32 = 0x0001;
    #[classattr]
    const MAP_STENCIL: u32 = 0x0D11;
    #[classattr]
    const MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
    #[classattr]
    const MAP_WRITE_BIT: u32 = 0x0002;
    #[classattr]
    const MATRIX_MODE: u32 = 0x0BA0;
    #[classattr]
    const MAX: u32 = 0x8008;
    #[classattr]
    const MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
    #[classattr]
    const MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
    #[classattr]
    const MAX_ATTRIB_STACK_DEPTH: u32 = 0x0D35;
    #[classattr]
    const MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0D3B;
    #[classattr]
    const MAX_CLIP_DISTANCES: u32 = 0x0D32;
    #[classattr]
    const MAX_CLIP_PLANES: u32 = 0x0D32;
    #[classattr]
    const MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
    #[classattr]
    const MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
    #[classattr]
    const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
    #[classattr]
    const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
    #[classattr]
    const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
    #[classattr]
    const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
    #[classattr]
    const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
    #[classattr]
    const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
    #[classattr]
    const MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
    #[classattr]
    const MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
    #[classattr]
    const MAX_DRAW_BUFFERS: u32 = 0x8824;
    #[classattr]
    const MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
    #[classattr]
    const MAX_ELEMENTS_INDICES: u32 = 0x80E9;
    #[classattr]
    const MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
    #[classattr]
    const MAX_ELEMENT_INDEX: u32 = 0x8D6B;
    #[classattr]
    const MAX_EVAL_ORDER: u32 = 0x0D30;
    #[classattr]
    const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
    #[classattr]
    const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
    #[classattr]
    const MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
    #[classattr]
    const MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
    #[classattr]
    const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
    #[classattr]
    const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
    #[classattr]
    const MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
    #[classattr]
    const MAX_INTEGER_SAMPLES: u32 = 0x9110;
    #[classattr]
    const MAX_LABEL_LENGTH: u32 = 0x82E8;
    #[classattr]
    const MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
    #[classattr]
    const MAX_LIGHTS: u32 = 0x0D31;
    #[classattr]
    const MAX_LIST_NESTING: u32 = 0x0B31;
    #[classattr]
    const MAX_MODELVIEW_STACK_DEPTH: u32 = 0x0D36;
    #[classattr]
    const MAX_NAME_STACK_DEPTH: u32 = 0x0D37;
    #[classattr]
    const MAX_PIXEL_MAP_TABLE: u32 = 0x0D34;
    #[classattr]
    const MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
    #[classattr]
    const MAX_PROJECTION_STACK_DEPTH: u32 = 0x0D38;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
    #[classattr]
    const MAX_RECTANGLE_TEXTURE_SIZE_ARB: u32 = 0x84F8;
    #[classattr]
    const MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
    #[classattr]
    const MAX_SAMPLES: u32 = 0x8D57;
    #[classattr]
    const MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
    #[classattr]
    const MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT: u32 = 0x8F63;
    #[classattr]
    const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT: u32 = 0x8F67;
    #[classattr]
    const MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
    #[classattr]
    const MAX_TEXTURE_COORDS: u32 = 0x8871;
    #[classattr]
    const MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
    #[classattr]
    const MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
    #[classattr]
    const MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
    #[classattr]
    const MAX_TEXTURE_SIZE: u32 = 0x0D33;
    #[classattr]
    const MAX_TEXTURE_STACK_DEPTH: u32 = 0x0D39;
    #[classattr]
    const MAX_TEXTURE_UNITS: u32 = 0x84E2;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
    #[classattr]
    const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
    #[classattr]
    const MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
    #[classattr]
    const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
    #[classattr]
    const MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_FLOATS: u32 = 0x8B4B;
    #[classattr]
    const MAX_VARYING_VECTORS: u32 = 0x8DFC;
    #[classattr]
    const MAX_VERTEX_ATTRIBS: u32 = 0x8869;
    #[classattr]
    const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
    #[classattr]
    const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
    #[classattr]
    const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
    #[classattr]
    const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
    #[classattr]
    const MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
    #[classattr]
    const MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
    #[classattr]
    const MEDIUM_FLOAT: u32 = 0x8DF1;
    #[classattr]
    const MEDIUM_INT: u32 = 0x8DF4;
    #[classattr]
    const MIN: u32 = 0x8007;
    #[classattr]
    const MINOR_VERSION: u32 = 0x821C;
    #[classattr]
    const MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
    #[classattr]
    const MIRRORED_REPEAT: u32 = 0x8370;
    #[classattr]
    const MODELVIEW: u32 = 0x1700;
    #[classattr]
    const MODELVIEW_MATRIX: u32 = 0x0BA6;
    #[classattr]
    const MODELVIEW_STACK_DEPTH: u32 = 0x0BA3;
    #[classattr]
    const MODULATE: u32 = 0x2100;
    #[classattr]
    const MULT: u32 = 0x0103;
    #[classattr]
    const MULTIPLY_KHR: u32 = 0x9294;
    #[classattr]
    const MULTISAMPLE: u32 = 0x809D;
    #[classattr]
    const MULTISAMPLE_BIT: u32 = 0x20000000;
    #[classattr]
    const N3F_V3F: u32 = 0x2A25;
    #[classattr]
    const NAME_STACK_DEPTH: u32 = 0x0D70;
    #[classattr]
    const NAND: u32 = 0x150E;
    #[classattr]
    const NEAREST: u32 = 0x2600;
    #[classattr]
    const NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
    #[classattr]
    const NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
    #[classattr]
    const NEVER: u32 = 0x0200;
    #[classattr]
    const NICEST: u32 = 0x1102;
    #[classattr]
    const NONE: u32 = 0;
    #[classattr]
    const NOOP: u32 = 0x1505;
    #[classattr]
    const NOR: u32 = 0x1508;
    #[classattr]
    const NORMALIZE: u32 = 0x0BA1;
    #[classattr]
    const NORMAL_ARRAY: u32 = 0x8075;
    #[classattr]
    const NORMAL_ARRAY_BUFFER_BINDING: u32 = 0x8897;
    #[classattr]
    const NORMAL_ARRAY_POINTER: u32 = 0x808F;
    #[classattr]
    const NORMAL_ARRAY_STRIDE: u32 = 0x807F;
    #[classattr]
    const NORMAL_ARRAY_TYPE: u32 = 0x807E;
    #[classattr]
    const NORMAL_MAP: u32 = 0x8511;
    #[classattr]
    const NOTEQUAL: u32 = 0x0205;
    #[classattr]
    const NO_ERROR: u32 = 0;
    #[classattr]
    const NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
    #[classattr]
    const NUM_EXTENSIONS: u32 = 0x821D;
    #[classattr]
    const NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
    #[classattr]
    const NUM_SAMPLE_COUNTS: u32 = 0x9380;
    #[classattr]
    const NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
    #[classattr]
    const OBJECT_LINEAR: u32 = 0x2401;
    #[classattr]
    const OBJECT_PLANE: u32 = 0x2501;
    #[classattr]
    const OBJECT_TYPE: u32 = 0x9112;
    #[classattr]
    const ONE: u32 = 1;
    #[classattr]
    const ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
    #[classattr]
    const ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
    #[classattr]
    const ONE_MINUS_DST_ALPHA: u32 = 0x0305;
    #[classattr]
    const ONE_MINUS_DST_COLOR: u32 = 0x0307;
    #[classattr]
    const ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
    #[classattr]
    const ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
    #[classattr]
    const ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
    #[classattr]
    const ONE_MINUS_SRC_COLOR: u32 = 0x0301;
    #[classattr]
    const OPERAND0_ALPHA: u32 = 0x8598;
    #[classattr]
    const OPERAND0_RGB: u32 = 0x8590;
    #[classattr]
    const OPERAND1_ALPHA: u32 = 0x8599;
    #[classattr]
    const OPERAND1_RGB: u32 = 0x8591;
    #[classattr]
    const OPERAND2_ALPHA: u32 = 0x859A;
    #[classattr]
    const OPERAND2_RGB: u32 = 0x8592;
    #[classattr]
    const OR: u32 = 0x1507;
    #[classattr]
    const ORDER: u32 = 0x0A01;
    #[classattr]
    const OR_INVERTED: u32 = 0x150D;
    #[classattr]
    const OR_REVERSE: u32 = 0x150B;
    #[classattr]
    const OUT_OF_MEMORY: u32 = 0x0505;
    #[classattr]
    const OVERLAY_KHR: u32 = 0x9296;
    #[classattr]
    const PACK_ALIGNMENT: u32 = 0x0D05;
    #[classattr]
    const PACK_IMAGE_HEIGHT: u32 = 0x806C;
    #[classattr]
    const PACK_LSB_FIRST: u32 = 0x0D01;
    #[classattr]
    const PACK_ROW_LENGTH: u32 = 0x0D02;
    #[classattr]
    const PACK_SKIP_IMAGES: u32 = 0x806B;
    #[classattr]
    const PACK_SKIP_PIXELS: u32 = 0x0D04;
    #[classattr]
    const PACK_SKIP_ROWS: u32 = 0x0D03;
    #[classattr]
    const PACK_SWAP_BYTES: u32 = 0x0D00;
    #[classattr]
    const PASS_THROUGH_TOKEN: u32 = 0x0700;
    #[classattr]
    const PERSPECTIVE_CORRECTION_HINT: u32 = 0x0C50;
    #[classattr]
    const PIXEL_MAP_A_TO_A: u32 = 0x0C79;
    #[classattr]
    const PIXEL_MAP_A_TO_A_SIZE: u32 = 0x0CB9;
    #[classattr]
    const PIXEL_MAP_B_TO_B: u32 = 0x0C78;
    #[classattr]
    const PIXEL_MAP_B_TO_B_SIZE: u32 = 0x0CB8;
    #[classattr]
    const PIXEL_MAP_G_TO_G: u32 = 0x0C77;
    #[classattr]
    const PIXEL_MAP_G_TO_G_SIZE: u32 = 0x0CB7;
    #[classattr]
    const PIXEL_MAP_I_TO_A: u32 = 0x0C75;
    #[classattr]
    const PIXEL_MAP_I_TO_A_SIZE: u32 = 0x0CB5;
    #[classattr]
    const PIXEL_MAP_I_TO_B: u32 = 0x0C74;
    #[classattr]
    const PIXEL_MAP_I_TO_B_SIZE: u32 = 0x0CB4;
    #[classattr]
    const PIXEL_MAP_I_TO_G: u32 = 0x0C73;
    #[classattr]
    const PIXEL_MAP_I_TO_G_SIZE: u32 = 0x0CB3;
    #[classattr]
    const PIXEL_MAP_I_TO_I: u32 = 0x0C70;
    #[classattr]
    const PIXEL_MAP_I_TO_I_SIZE: u32 = 0x0CB0;
    #[classattr]
    const PIXEL_MAP_I_TO_R: u32 = 0x0C72;
    #[classattr]
    const PIXEL_MAP_I_TO_R_SIZE: u32 = 0x0CB2;
    #[classattr]
    const PIXEL_MAP_R_TO_R: u32 = 0x0C76;
    #[classattr]
    const PIXEL_MAP_R_TO_R_SIZE: u32 = 0x0CB6;
    #[classattr]
    const PIXEL_MAP_S_TO_S: u32 = 0x0C71;
    #[classattr]
    const PIXEL_MAP_S_TO_S_SIZE: u32 = 0x0CB1;
    #[classattr]
    const PIXEL_MODE_BIT: u32 = 0x00000020;
    #[classattr]
    const PIXEL_PACK_BUFFER: u32 = 0x88EB;
    #[classattr]
    const PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
    #[classattr]
    const PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
    #[classattr]
    const PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
    #[classattr]
    const POINT: u32 = 0x1B00;
    #[classattr]
    const POINTS: u32 = 0x0000;
    #[classattr]
    const POINT_BIT: u32 = 0x00000002;
    #[classattr]
    const POINT_DISTANCE_ATTENUATION: u32 = 0x8129;
    #[classattr]
    const POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
    #[classattr]
    const POINT_SIZE: u32 = 0x0B11;
    #[classattr]
    const POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const POINT_SIZE_MAX: u32 = 0x8127;
    #[classattr]
    const POINT_SIZE_MIN: u32 = 0x8126;
    #[classattr]
    const POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const POINT_SMOOTH: u32 = 0x0B10;
    #[classattr]
    const POINT_SMOOTH_HINT: u32 = 0x0C51;
    #[classattr]
    const POINT_SPRITE: u32 = 0x8861;
    #[classattr]
    const POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
    #[classattr]
    const POINT_TOKEN: u32 = 0x0701;
    #[classattr]
    const POLYGON: u32 = 0x0009;
    #[classattr]
    const POLYGON_BIT: u32 = 0x00000008;
    #[classattr]
    const POLYGON_MODE: u32 = 0x0B40;
    #[classattr]
    const POLYGON_OFFSET_FACTOR: u32 = 0x8038;
    #[classattr]
    const POLYGON_OFFSET_FILL: u32 = 0x8037;
    #[classattr]
    const POLYGON_OFFSET_LINE: u32 = 0x2A02;
    #[classattr]
    const POLYGON_OFFSET_POINT: u32 = 0x2A01;
    #[classattr]
    const POLYGON_OFFSET_UNITS: u32 = 0x2A00;
    #[classattr]
    const POLYGON_SMOOTH: u32 = 0x0B41;
    #[classattr]
    const POLYGON_SMOOTH_HINT: u32 = 0x0C53;
    #[classattr]
    const POLYGON_STIPPLE: u32 = 0x0B42;
    #[classattr]
    const POLYGON_STIPPLE_BIT: u32 = 0x00000010;
    #[classattr]
    const POLYGON_TOKEN: u32 = 0x0703;
    #[classattr]
    const POSITION: u32 = 0x1203;
    #[classattr]
    const PREVIOUS: u32 = 0x8578;
    #[classattr]
    const PRIMARY_COLOR: u32 = 0x8577;
    #[classattr]
    const PRIMITIVES_GENERATED: u32 = 0x8C87;
    #[classattr]
    const PRIMITIVE_RESTART: u32 = 0x8F9D;
    #[classattr]
    const PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
    #[classattr]
    const PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
    #[classattr]
    const PROGRAM: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
    #[classattr]
    const PROGRAM_BINARY_LENGTH: u32 = 0x8741;
    #[classattr]
    const PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
    #[classattr]
    const PROGRAM_KHR: u32 = 0x82E2;
    #[classattr]
    const PROGRAM_PIPELINE: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
    #[classattr]
    const PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const PROJECTION: u32 = 0x1701;
    #[classattr]
    const PROJECTION_MATRIX: u32 = 0x0BA7;
    #[classattr]
    const PROJECTION_STACK_DEPTH: u32 = 0x0BA4;
    #[classattr]
    const PROVOKING_VERTEX: u32 = 0x8E4F;
    #[classattr]
    const PROXY_TEXTURE_1D: u32 = 0x8063;
    #[classattr]
    const PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
    #[classattr]
    const PROXY_TEXTURE_2D: u32 = 0x8064;
    #[classattr]
    const PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
    #[classattr]
    const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
    #[classattr]
    const PROXY_TEXTURE_3D: u32 = 0x8070;
    #[classattr]
    const PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
    #[classattr]
    const PROXY_TEXTURE_RECTANGLE_ARB: u32 = 0x84F7;
    #[classattr]
    const Q: u32 = 0x2003;
    #[classattr]
    const QUADRATIC_ATTENUATION: u32 = 0x1209;
    #[classattr]
    const QUADS: u32 = 0x0007;
    #[classattr]
    const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
    #[classattr]
    const QUAD_STRIP: u32 = 0x0008;
    #[classattr]
    const QUERY: u32 = 0x82E3;
    #[classattr]
    const QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
    #[classattr]
    const QUERY_BY_REGION_WAIT: u32 = 0x8E15;
    #[classattr]
    const QUERY_COUNTER_BITS: u32 = 0x8864;
    #[classattr]
    const QUERY_COUNTER_BITS_EXT: u32 = 0x8864;
    #[classattr]
    const QUERY_KHR: u32 = 0x82E3;
    #[classattr]
    const QUERY_NO_WAIT: u32 = 0x8E14;
    #[classattr]
    const QUERY_RESULT: u32 = 0x8866;
    #[classattr]
    const QUERY_RESULT_AVAILABLE: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_AVAILABLE_EXT: u32 = 0x8867;
    #[classattr]
    const QUERY_RESULT_EXT: u32 = 0x8866;
    #[classattr]
    const QUERY_WAIT: u32 = 0x8E13;
    #[classattr]
    const R: u32 = 0x2002;
    #[classattr]
    const R11F_G11F_B10F: u32 = 0x8C3A;
    #[classattr]
    const R16: u32 = 0x822A;
    #[classattr]
    const R16F: u32 = 0x822D;
    #[classattr]
    const R16F_EXT: u32 = 0x822D;
    #[classattr]
    const R16I: u32 = 0x8233;
    #[classattr]
    const R16UI: u32 = 0x8234;
    #[classattr]
    const R16_SNORM: u32 = 0x8F98;
    #[classattr]
    const R32F: u32 = 0x822E;
    #[classattr]
    const R32F_EXT: u32 = 0x822E;
    #[classattr]
    const R32I: u32 = 0x8235;
    #[classattr]
    const R32UI: u32 = 0x8236;
    #[classattr]
    const R3_G3_B2: u32 = 0x2A10;
    #[classattr]
    const R8: u32 = 0x8229;
    #[classattr]
    const R8I: u32 = 0x8231;
    #[classattr]
    const R8UI: u32 = 0x8232;
    #[classattr]
    const R8_EXT: u32 = 0x8229;
    #[classattr]
    const R8_SNORM: u32 = 0x8F94;
    #[classattr]
    const RASTERIZER_DISCARD: u32 = 0x8C89;
    #[classattr]
    const READ_BUFFER: u32 = 0x0C02;
    #[classattr]
    const READ_FRAMEBUFFER: u32 = 0x8CA8;
    #[classattr]
    const READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
    #[classattr]
    const READ_ONLY: u32 = 0x88B8;
    #[classattr]
    const READ_WRITE: u32 = 0x88BA;
    #[classattr]
    const RED: u32 = 0x1903;
    #[classattr]
    const RED_BIAS: u32 = 0x0D15;
    #[classattr]
    const RED_BITS: u32 = 0x0D52;
    #[classattr]
    const RED_INTEGER: u32 = 0x8D94;
    #[classattr]
    const RED_SCALE: u32 = 0x0D14;
    #[classattr]
    const REFLECTION_MAP: u32 = 0x8512;
    #[classattr]
    const RENDER: u32 = 0x1C00;
    #[classattr]
    const RENDERBUFFER: u32 = 0x8D41;
    #[classattr]
    const RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
    #[classattr]
    const RENDERBUFFER_BINDING: u32 = 0x8CA7;
    #[classattr]
    const RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
    #[classattr]
    const RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
    #[classattr]
    const RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
    #[classattr]
    const RENDERBUFFER_HEIGHT: u32 = 0x8D43;
    #[classattr]
    const RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
    #[classattr]
    const RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
    #[classattr]
    const RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
    #[classattr]
    const RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
    #[classattr]
    const RENDERBUFFER_WIDTH: u32 = 0x8D42;
    #[classattr]
    const RENDERER: u32 = 0x1F01;
    #[classattr]
    const RENDER_MODE: u32 = 0x0C40;
    #[classattr]
    const REPEAT: u32 = 0x2901;
    #[classattr]
    const REPLACE: u32 = 0x1E01;
    #[classattr]
    const REQUIRED_TEXTURE_IMAGE_UNITS_OES: u32 = 0x8D68;
    #[classattr]
    const RESCALE_NORMAL: u32 = 0x803A;
    #[classattr]
    const RETURN: u32 = 0x0102;
    #[classattr]
    const RG: u32 = 0x8227;
    #[classattr]
    const RG16: u32 = 0x822C;
    #[classattr]
    const RG16F: u32 = 0x822F;
    #[classattr]
    const RG16F_EXT: u32 = 0x822F;
    #[classattr]
    const RG16I: u32 = 0x8239;
    #[classattr]
    const RG16UI: u32 = 0x823A;
    #[classattr]
    const RG16_SNORM: u32 = 0x8F99;
    #[classattr]
    const RG32F: u32 = 0x8230;
    #[classattr]
    const RG32F_EXT: u32 = 0x8230;
    #[classattr]
    const RG32I: u32 = 0x823B;
    #[classattr]
    const RG32UI: u32 = 0x823C;
    #[classattr]
    const RG8: u32 = 0x822B;
    #[classattr]
    const RG8I: u32 = 0x8237;
    #[classattr]
    const RG8UI: u32 = 0x8238;
    #[classattr]
    const RG8_EXT: u32 = 0x822B;
    #[classattr]
    const RG8_SNORM: u32 = 0x8F95;
    #[classattr]
    const RGB: u32 = 0x1907;
    #[classattr]
    const RGB10: u32 = 0x8052;
    #[classattr]
    const RGB10_A2: u32 = 0x8059;
    #[classattr]
    const RGB10_A2UI: u32 = 0x906F;
    #[classattr]
    const RGB10_A2_EXT: u32 = 0x8059;
    #[classattr]
    const RGB10_EXT: u32 = 0x8052;
    #[classattr]
    const RGB12: u32 = 0x8053;
    #[classattr]
    const RGB16: u32 = 0x8054;
    #[classattr]
    const RGB16F: u32 = 0x881B;
    #[classattr]
    const RGB16F_EXT: u32 = 0x881B;
    #[classattr]
    const RGB16I: u32 = 0x8D89;
    #[classattr]
    const RGB16UI: u32 = 0x8D77;
    #[classattr]
    const RGB16_SNORM: u32 = 0x8F9A;
    #[classattr]
    const RGB32F: u32 = 0x8815;
    #[classattr]
    const RGB32F_EXT: u32 = 0x8815;
    #[classattr]
    const RGB32I: u32 = 0x8D83;
    #[classattr]
    const RGB32UI: u32 = 0x8D71;
    #[classattr]
    const RGB4: u32 = 0x804F;
    #[classattr]
    const RGB5: u32 = 0x8050;
    #[classattr]
    const RGB565: u32 = 0x8D62;
    #[classattr]
    const RGB5_A1: u32 = 0x8057;
    #[classattr]
    const RGB8: u32 = 0x8051;
    #[classattr]
    const RGB8I: u32 = 0x8D8F;
    #[classattr]
    const RGB8UI: u32 = 0x8D7D;
    #[classattr]
    const RGB8_SNORM: u32 = 0x8F96;
    #[classattr]
    const RGB9_E5: u32 = 0x8C3D;
    #[classattr]
    const RGBA: u32 = 0x1908;
    #[classattr]
    const RGBA12: u32 = 0x805A;
    #[classattr]
    const RGBA16: u32 = 0x805B;
    #[classattr]
    const RGBA16F: u32 = 0x881A;
    #[classattr]
    const RGBA16F_EXT: u32 = 0x881A;
    #[classattr]
    const RGBA16I: u32 = 0x8D88;
    #[classattr]
    const RGBA16UI: u32 = 0x8D76;
    #[classattr]
    const RGBA16_SNORM: u32 = 0x8F9B;
    #[classattr]
    const RGBA2: u32 = 0x8055;
    #[classattr]
    const RGBA32F: u32 = 0x8814;
    #[classattr]
    const RGBA32F_EXT: u32 = 0x8814;
    #[classattr]
    const RGBA32I: u32 = 0x8D82;
    #[classattr]
    const RGBA32UI: u32 = 0x8D70;
    #[classattr]
    const RGBA4: u32 = 0x8056;
    #[classattr]
    const RGBA8: u32 = 0x8058;
    #[classattr]
    const RGBA8I: u32 = 0x8D8E;
    #[classattr]
    const RGBA8UI: u32 = 0x8D7C;
    #[classattr]
    const RGBA8_SNORM: u32 = 0x8F97;
    #[classattr]
    const RGBA_INTEGER: u32 = 0x8D99;
    #[classattr]
    const RGBA_MODE: u32 = 0x0C31;
    #[classattr]
    const RGB_INTEGER: u32 = 0x8D98;
    #[classattr]
    const RGB_SCALE: u32 = 0x8573;
    #[classattr]
    const RG_INTEGER: u32 = 0x8228;
    #[classattr]
    const RIGHT: u32 = 0x0407;
    #[classattr]
    const S: u32 = 0x2000;
    #[classattr]
    const SAMPLER: u32 = 0x82E6;
    #[classattr]
    const SAMPLER_1D: u32 = 0x8B5D;
    #[classattr]
    const SAMPLER_1D_ARRAY: u32 = 0x8DC0;
    #[classattr]
    const SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
    #[classattr]
    const SAMPLER_1D_SHADOW: u32 = 0x8B61;
    #[classattr]
    const SAMPLER_2D: u32 = 0x8B5E;
    #[classattr]
    const SAMPLER_2D_ARRAY: u32 = 0x8DC1;
    #[classattr]
    const SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
    #[classattr]
    const SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
    #[classattr]
    const SAMPLER_2D_RECT: u32 = 0x8B63;
    #[classattr]
    const SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
    #[classattr]
    const SAMPLER_2D_SHADOW: u32 = 0x8B62;
    #[classattr]
    const SAMPLER_3D: u32 = 0x8B5F;
    #[classattr]
    const SAMPLER_BINDING: u32 = 0x8919;
    #[classattr]
    const SAMPLER_BUFFER: u32 = 0x8DC2;
    #[classattr]
    const SAMPLER_CUBE: u32 = 0x8B60;
    #[classattr]
    const SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
    #[classattr]
    const SAMPLER_EXTERNAL_OES: u32 = 0x8D66;
    #[classattr]
    const SAMPLER_KHR: u32 = 0x82E6;
    #[classattr]
    const SAMPLES: u32 = 0x80A9;
    #[classattr]
    const SAMPLES_PASSED: u32 = 0x8914;
    #[classattr]
    const SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
    #[classattr]
    const SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
    #[classattr]
    const SAMPLE_BUFFERS: u32 = 0x80A8;
    #[classattr]
    const SAMPLE_COVERAGE: u32 = 0x80A0;
    #[classattr]
    const SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
    #[classattr]
    const SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
    #[classattr]
    const SAMPLE_MASK: u32 = 0x8E51;
    #[classattr]
    const SAMPLE_MASK_VALUE: u32 = 0x8E52;
    #[classattr]
    const SAMPLE_POSITION: u32 = 0x8E50;
    #[classattr]
    const SCISSOR_BIT: u32 = 0x00080000;
    #[classattr]
    const SCISSOR_BOX: u32 = 0x0C10;
    #[classattr]
    const SCISSOR_TEST: u32 = 0x0C11;
    #[classattr]
    const SCREEN_KHR: u32 = 0x9295;
    #[classattr]
    const SECONDARY_COLOR_ARRAY: u32 = 0x845E;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_BUFFER_BINDING: u32 = 0x889C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_POINTER: u32 = 0x845D;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_SIZE: u32 = 0x845A;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_STRIDE: u32 = 0x845C;
    #[classattr]
    const SECONDARY_COLOR_ARRAY_TYPE: u32 = 0x845B;
    #[classattr]
    const SELECT: u32 = 0x1C02;
    #[classattr]
    const SELECTION_BUFFER_POINTER: u32 = 0x0DF3;
    #[classattr]
    const SELECTION_BUFFER_SIZE: u32 = 0x0DF4;
    #[classattr]
    const SEPARATE_ATTRIBS: u32 = 0x8C8D;
    #[classattr]
    const SEPARATE_SPECULAR_COLOR: u32 = 0x81FA;
    #[classattr]
    const SET: u32 = 0x150F;
    #[classattr]
    const SHADER: u32 = 0x82E1;
    #[classattr]
    const SHADER_BINARY_FORMATS: u32 = 0x8DF8;
    #[classattr]
    const SHADER_COMPILER: u32 = 0x8DFA;
    #[classattr]
    const SHADER_KHR: u32 = 0x82E1;
    #[classattr]
    const SHADER_PIXEL_LOCAL_STORAGE_EXT: u32 = 0x8F64;
    #[classattr]
    const SHADER_SOURCE_LENGTH: u32 = 0x8B88;
    #[classattr]
    const SHADER_TYPE: u32 = 0x8B4F;
    #[classattr]
    const SHADE_MODEL: u32 = 0x0B54;
    #[classattr]
    const SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
    #[classattr]
    const SHININESS: u32 = 0x1601;
    #[classattr]
    const SHORT: u32 = 0x1402;
    #[classattr]
    const SIGNALED: u32 = 0x9119;
    #[classattr]
    const SIGNED_NORMALIZED: u32 = 0x8F9C;
    #[classattr]
    const SINGLE_COLOR: u32 = 0x81F9;
    #[classattr]
    const SLUMINANCE: u32 = 0x8C46;
    #[classattr]
    const SLUMINANCE8: u32 = 0x8C47;
    #[classattr]
    const SLUMINANCE8_ALPHA8: u32 = 0x8C45;
    #[classattr]
    const SLUMINANCE_ALPHA: u32 = 0x8C44;
    #[classattr]
    const SMOOTH: u32 = 0x1D01;
    #[classattr]
    const SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
    #[classattr]
    const SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
    #[classattr]
    const SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
    #[classattr]
    const SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
    #[classattr]
    const SOFTLIGHT_KHR: u32 = 0x929C;
    #[classattr]
    const SOURCE0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SOURCE0_RGB: u32 = 0x8580;
    #[classattr]
    const SOURCE1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SOURCE1_RGB: u32 = 0x8581;
    #[classattr]
    const SOURCE2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SOURCE2_RGB: u32 = 0x8582;
    #[classattr]
    const SPECULAR: u32 = 0x1202;
    #[classattr]
    const SPHERE_MAP: u32 = 0x2402;
    #[classattr]
    const SPOT_CUTOFF: u32 = 0x1206;
    #[classattr]
    const SPOT_DIRECTION: u32 = 0x1204;
    #[classattr]
    const SPOT_EXPONENT: u32 = 0x1205;
    #[classattr]
    const SRC0_ALPHA: u32 = 0x8588;
    #[classattr]
    const SRC0_RGB: u32 = 0x8580;
    #[classattr]
    const SRC1_ALPHA: u32 = 0x8589;
    #[classattr]
    const SRC1_COLOR: u32 = 0x88F9;
    #[classattr]
    const SRC1_RGB: u32 = 0x8581;
    #[classattr]
    const SRC2_ALPHA: u32 = 0x858A;
    #[classattr]
    const SRC2_RGB: u32 = 0x8582;
    #[classattr]
    const SRC_ALPHA: u32 = 0x0302;
    #[classattr]
    const SRC_ALPHA_SATURATE: u32 = 0x0308;
    #[classattr]
    const SRC_COLOR: u32 = 0x0300;
    #[classattr]
    const SRGB: u32 = 0x8C40;
    #[classattr]
    const SRGB8: u32 = 0x8C41;
    #[classattr]
    const SRGB8_ALPHA8: u32 = 0x8C43;
    #[classattr]
    const SRGB_ALPHA: u32 = 0x8C42;
    #[classattr]
    const STACK_OVERFLOW: u32 = 0x0503;
    #[classattr]
    const STACK_OVERFLOW_KHR: u32 = 0x0503;
    #[classattr]
    const STACK_UNDERFLOW: u32 = 0x0504;
    #[classattr]
    const STACK_UNDERFLOW_KHR: u32 = 0x0504;
    #[classattr]
    const STATIC_COPY: u32 = 0x88E6;
    #[classattr]
    const STATIC_DRAW: u32 = 0x88E4;
    #[classattr]
    const STATIC_READ: u32 = 0x88E5;
    #[classattr]
    const STENCIL: u32 = 0x1802;
    #[classattr]
    const STENCIL_ATTACHMENT: u32 = 0x8D20;
    #[classattr]
    const STENCIL_BACK_FAIL: u32 = 0x8801;
    #[classattr]
    const STENCIL_BACK_FUNC: u32 = 0x8800;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
    #[classattr]
    const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
    #[classattr]
    const STENCIL_BACK_REF: u32 = 0x8CA3;
    #[classattr]
    const STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
    #[classattr]
    const STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
    #[classattr]
    const STENCIL_BITS: u32 = 0x0D57;
    #[classattr]
    const STENCIL_BUFFER_BIT: u32 = 0x00000400;
    #[classattr]
    const STENCIL_CLEAR_VALUE: u32 = 0x0B91;
    #[classattr]
    const STENCIL_FAIL: u32 = 0x0B94;
    #[classattr]
    const STENCIL_FUNC: u32 = 0x0B92;
    #[classattr]
    const STENCIL_INDEX: u32 = 0x1901;
    #[classattr]
    const STENCIL_INDEX1: u32 = 0x8D46;
    #[classattr]
    const STENCIL_INDEX16: u32 = 0x8D49;
    #[classattr]
    const STENCIL_INDEX4: u32 = 0x8D47;
    #[classattr]
    const STENCIL_INDEX8: u32 = 0x8D48;
    #[classattr]
    const STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
    #[classattr]
    const STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
    #[classattr]
    const STENCIL_REF: u32 = 0x0B97;
    #[classattr]
    const STENCIL_TEST: u32 = 0x0B90;
    #[classattr]
    const STENCIL_VALUE_MASK: u32 = 0x0B93;
    #[classattr]
    const STENCIL_WRITEMASK: u32 = 0x0B98;
    #[classattr]
    const STEREO: u32 = 0x0C33;
    #[classattr]
    const STORAGE_CACHED_APPLE: u32 = 0x85BE;
    #[classattr]
    const STORAGE_PRIVATE_APPLE: u32 = 0x85BD;
    #[classattr]
    const STORAGE_SHARED_APPLE: u32 = 0x85BF;
    #[classattr]
    const STREAM_COPY: u32 = 0x88E2;
    #[classattr]
    const STREAM_DRAW: u32 = 0x88E0;
    #[classattr]
    const STREAM_READ: u32 = 0x88E1;
    #[classattr]
    const SUBPIXEL_BITS: u32 = 0x0D50;
    #[classattr]
    const SUBTRACT: u32 = 0x84E7;
    #[classattr]
    const SYNC_CONDITION: u32 = 0x9113;
    #[classattr]
    const SYNC_FENCE: u32 = 0x9116;
    #[classattr]
    const SYNC_FLAGS: u32 = 0x9115;
    #[classattr]
    const SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
    #[classattr]
    const SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
    #[classattr]
    const SYNC_STATUS: u32 = 0x9114;
    #[classattr]
    const T: u32 = 0x2001;
    #[classattr]
    const T2F_C3F_V3F: u32 = 0x2A2A;
    #[classattr]
    const T2F_C4F_N3F_V3F: u32 = 0x2A2C;
    #[classattr]
    const T2F_C4UB_V3F: u32 = 0x2A29;
    #[classattr]
    const T2F_N3F_V3F: u32 = 0x2A2B;
    #[classattr]
    const T2F_V3F: u32 = 0x2A27;
    #[classattr]
    const T4F_C4F_N3F_V4F: u32 = 0x2A2D;
    #[classattr]
    const T4F_V4F: u32 = 0x2A28;
    #[classattr]
    const TEXTURE: u32 = 0x1702;
    #[classattr]
    const TEXTURE0: u32 = 0x84C0;
    #[classattr]
    const TEXTURE1: u32 = 0x84C1;
    #[classattr]
    const TEXTURE10: u32 = 0x84CA;
    #[classattr]
    const TEXTURE11: u32 = 0x84CB;
    #[classattr]
    const TEXTURE12: u32 = 0x84CC;
    #[classattr]
    const TEXTURE13: u32 = 0x84CD;
    #[classattr]
    const TEXTURE14: u32 = 0x84CE;
    #[classattr]
    const TEXTURE15: u32 = 0x84CF;
    #[classattr]
    const TEXTURE16: u32 = 0x84D0;
    #[classattr]
    const TEXTURE17: u32 = 0x84D1;
    #[classattr]
    const TEXTURE18: u32 = 0x84D2;
    #[classattr]
    const TEXTURE19: u32 = 0x84D3;
    #[classattr]
    const TEXTURE2: u32 = 0x84C2;
    #[classattr]
    const TEXTURE20: u32 = 0x84D4;
    #[classattr]
    const TEXTURE21: u32 = 0x84D5;
    #[classattr]
    const TEXTURE22: u32 = 0x84D6;
    #[classattr]
    const TEXTURE23: u32 = 0x84D7;
    #[classattr]
    const TEXTURE24: u32 = 0x84D8;
    #[classattr]
    const TEXTURE25: u32 = 0x84D9;
    #[classattr]
    const TEXTURE26: u32 = 0x84DA;
    #[classattr]
    const TEXTURE27: u32 = 0x84DB;
    #[classattr]
    const TEXTURE28: u32 = 0x84DC;
    #[classattr]
    const TEXTURE29: u32 = 0x84DD;
    #[classattr]
    const TEXTURE3: u32 = 0x84C3;
    #[classattr]
    const TEXTURE30: u32 = 0x84DE;
    #[classattr]
    const TEXTURE31: u32 = 0x84DF;
    #[classattr]
    const TEXTURE4: u32 = 0x84C4;
    #[classattr]
    const TEXTURE5: u32 = 0x84C5;
    #[classattr]
    const TEXTURE6: u32 = 0x84C6;
    #[classattr]
    const TEXTURE7: u32 = 0x84C7;
    #[classattr]
    const TEXTURE8: u32 = 0x84C8;
    #[classattr]
    const TEXTURE9: u32 = 0x84C9;
    #[classattr]
    const TEXTURE_1D: u32 = 0x0DE0;
    #[classattr]
    const TEXTURE_1D_ARRAY: u32 = 0x8C18;
    #[classattr]
    const TEXTURE_2D: u32 = 0x0DE1;
    #[classattr]
    const TEXTURE_2D_ARRAY: u32 = 0x8C1A;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
    #[classattr]
    const TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
    #[classattr]
    const TEXTURE_3D: u32 = 0x806F;
    #[classattr]
    const TEXTURE_ALPHA_SIZE: u32 = 0x805F;
    #[classattr]
    const TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
    #[classattr]
    const TEXTURE_BASE_LEVEL: u32 = 0x813C;
    #[classattr]
    const TEXTURE_BINDING_1D: u32 = 0x8068;
    #[classattr]
    const TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
    #[classattr]
    const TEXTURE_BINDING_2D: u32 = 0x8069;
    #[classattr]
    const TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
    #[classattr]
    const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
    #[classattr]
    const TEXTURE_BINDING_3D: u32 = 0x806A;
    #[classattr]
    const TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
    #[classattr]
    const TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
    #[classattr]
    const TEXTURE_BINDING_EXTERNAL_OES: u32 = 0x8D67;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BINDING_RECTANGLE_ARB: u32 = 0x84F6;
    #[classattr]
    const TEXTURE_BIT: u32 = 0x00040000;
    #[classattr]
    const TEXTURE_BLUE_SIZE: u32 = 0x805E;
    #[classattr]
    const TEXTURE_BLUE_TYPE: u32 = 0x8C12;
    #[classattr]
    const TEXTURE_BORDER: u32 = 0x1005;
    #[classattr]
    const TEXTURE_BORDER_COLOR: u32 = 0x1004;
    #[classattr]
    const TEXTURE_BUFFER: u32 = 0x8C2A;
    #[classattr]
    const TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
    #[classattr]
    const TEXTURE_COMPARE_FUNC: u32 = 0x884D;
    #[classattr]
    const TEXTURE_COMPARE_MODE: u32 = 0x884C;
    #[classattr]
    const TEXTURE_COMPONENTS: u32 = 0x1003;
    #[classattr]
    const TEXTURE_COMPRESSED: u32 = 0x86A1;
    #[classattr]
    const TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
    #[classattr]
    const TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
    #[classattr]
    const TEXTURE_COORD_ARRAY: u32 = 0x8078;
    #[classattr]
    const TEXTURE_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_POINTER: u32 = 0x8092;
    #[classattr]
    const TEXTURE_COORD_ARRAY_SIZE: u32 = 0x8088;
    #[classattr]
    const TEXTURE_COORD_ARRAY_STRIDE: u32 = 0x808A;
    #[classattr]
    const TEXTURE_COORD_ARRAY_TYPE: u32 = 0x8089;
    #[classattr]
    const TEXTURE_CUBE_MAP: u32 = 0x8513;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
    #[classattr]
    const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
    #[classattr]
    const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
    #[classattr]
    const TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
    #[classattr]
    const TEXTURE_DEPTH: u32 = 0x8071;
    #[classattr]
    const TEXTURE_DEPTH_SIZE: u32 = 0x884A;
    #[classattr]
    const TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
    #[classattr]
    const TEXTURE_ENV: u32 = 0x2300;
    #[classattr]
    const TEXTURE_ENV_COLOR: u32 = 0x2201;
    #[classattr]
    const TEXTURE_ENV_MODE: u32 = 0x2200;
    #[classattr]
    const TEXTURE_EXTERNAL_OES: u32 = 0x8D65;
    #[classattr]
    const TEXTURE_FILTER_CONTROL: u32 = 0x8500;
    #[classattr]
    const TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
    #[classattr]
    const TEXTURE_GEN_MODE: u32 = 0x2500;
    #[classattr]
    const TEXTURE_GEN_Q: u32 = 0x0C63;
    #[classattr]
    const TEXTURE_GEN_R: u32 = 0x0C62;
    #[classattr]
    const TEXTURE_GEN_S: u32 = 0x0C60;
    #[classattr]
    const TEXTURE_GEN_T: u32 = 0x0C61;
    #[classattr]
    const TEXTURE_GREEN_SIZE: u32 = 0x805D;
    #[classattr]
    const TEXTURE_GREEN_TYPE: u32 = 0x8C11;
    #[classattr]
    const TEXTURE_HEIGHT: u32 = 0x1001;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_FORMAT_EXT: u32 = 0x912F;
    #[classattr]
    const TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
    #[classattr]
    const TEXTURE_INTENSITY_SIZE: u32 = 0x8061;
    #[classattr]
    const TEXTURE_INTENSITY_TYPE: u32 = 0x8C15;
    #[classattr]
    const TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
    #[classattr]
    const TEXTURE_LOD_BIAS: u32 = 0x8501;
    #[classattr]
    const TEXTURE_LUMINANCE_SIZE: u32 = 0x8060;
    #[classattr]
    const TEXTURE_LUMINANCE_TYPE: u32 = 0x8C14;
    #[classattr]
    const TEXTURE_MAG_FILTER: u32 = 0x2800;
    #[classattr]
    const TEXTURE_MATRIX: u32 = 0x0BA8;
    #[classattr]
    const TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
    #[classattr]
    const TEXTURE_MAX_LEVEL: u32 = 0x813D;
    #[classattr]
    const TEXTURE_MAX_LOD: u32 = 0x813B;
    #[classattr]
    const TEXTURE_MIN_FILTER: u32 = 0x2801;
    #[classattr]
    const TEXTURE_MIN_LOD: u32 = 0x813A;
    #[classattr]
    const TEXTURE_PRIORITY: u32 = 0x8066;
    #[classattr]
    const TEXTURE_RANGE_LENGTH_APPLE: u32 = 0x85B7;
    #[classattr]
    const TEXTURE_RANGE_POINTER_APPLE: u32 = 0x85B8;
    #[classattr]
    const TEXTURE_RECTANGLE: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RECTANGLE_ARB: u32 = 0x84F5;
    #[classattr]
    const TEXTURE_RED_SIZE: u32 = 0x805C;
    #[classattr]
    const TEXTURE_RED_TYPE: u32 = 0x8C10;
    #[classattr]
    const TEXTURE_RESIDENT: u32 = 0x8067;
    #[classattr]
    const TEXTURE_SAMPLES: u32 = 0x9106;
    #[classattr]
    const TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
    #[classattr]
    const TEXTURE_STACK_DEPTH: u32 = 0x0BA5;
    #[classattr]
    const TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
    #[classattr]
    const TEXTURE_STORAGE_HINT_APPLE: u32 = 0x85BC;
    #[classattr]
    const TEXTURE_SWIZZLE_A: u32 = 0x8E45;
    #[classattr]
    const TEXTURE_SWIZZLE_B: u32 = 0x8E44;
    #[classattr]
    const TEXTURE_SWIZZLE_G: u32 = 0x8E43;
    #[classattr]
    const TEXTURE_SWIZZLE_R: u32 = 0x8E42;
    #[classattr]
    const TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
    #[classattr]
    const TEXTURE_USAGE_ANGLE: u32 = 0x93A2;
    #[classattr]
    const TEXTURE_WIDTH: u32 = 0x1000;
    #[classattr]
    const TEXTURE_WRAP_R: u32 = 0x8072;
    #[classattr]
    const TEXTURE_WRAP_S: u32 = 0x2802;
    #[classattr]
    const TEXTURE_WRAP_T: u32 = 0x2803;
    #[classattr]
    const TIMEOUT_EXPIRED: u32 = 0x911B;
    #[classattr]
    const TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
    #[classattr]
    const TIMESTAMP: u32 = 0x8E28;
    #[classattr]
    const TIMESTAMP_EXT: u32 = 0x8E28;
    #[classattr]
    const TIME_ELAPSED: u32 = 0x88BF;
    #[classattr]
    const TIME_ELAPSED_EXT: u32 = 0x88BF;
    #[classattr]
    const TRANSFORM_BIT: u32 = 0x00001000;
    #[classattr]
    const TRANSFORM_FEEDBACK: u32 = 0x8E22;
    #[classattr]
    const TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
    #[classattr]
    const TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
    #[classattr]
    const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
    #[classattr]
    const TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
    #[classattr]
    const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
    #[classattr]
    const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
    #[classattr]
    const TRANSPOSE_COLOR_MATRIX: u32 = 0x84E6;
    #[classattr]
    const TRANSPOSE_MODELVIEW_MATRIX: u32 = 0x84E3;
    #[classattr]
    const TRANSPOSE_PROJECTION_MATRIX: u32 = 0x84E4;
    #[classattr]
    const TRANSPOSE_TEXTURE_MATRIX: u32 = 0x84E5;
    #[classattr]
    const TRIANGLES: u32 = 0x0004;
    #[classattr]
    const TRIANGLES_ADJACENCY: u32 = 0x000C;
    #[classattr]
    const TRIANGLE_FAN: u32 = 0x0006;
    #[classattr]
    const TRIANGLE_STRIP: u32 = 0x0005;
    #[classattr]
    const TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
    #[classattr]
    const TRUE: u8 = 1;
    #[classattr]
    const UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
    #[classattr]
    const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
    #[classattr]
    const UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
    #[classattr]
    const UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
    #[classattr]
    const UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
    #[classattr]
    const UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
    #[classattr]
    const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
    #[classattr]
    const UNIFORM_BUFFER: u32 = 0x8A11;
    #[classattr]
    const UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
    #[classattr]
    const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
    #[classattr]
    const UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
    #[classattr]
    const UNIFORM_BUFFER_START: u32 = 0x8A29;
    #[classattr]
    const UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
    #[classattr]
    const UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
    #[classattr]
    const UNIFORM_NAME_LENGTH: u32 = 0x8A39;
    #[classattr]
    const UNIFORM_OFFSET: u32 = 0x8A3B;
    #[classattr]
    const UNIFORM_SIZE: u32 = 0x8A38;
    #[classattr]
    const UNIFORM_TYPE: u32 = 0x8A37;
    #[classattr]
    const UNPACK_ALIGNMENT: u32 = 0x0CF5;
    #[classattr]
    const UNPACK_CLIENT_STORAGE_APPLE: u32 = 0x85B2;
    #[classattr]
    const UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
    #[classattr]
    const UNPACK_LSB_FIRST: u32 = 0x0CF1;
    #[classattr]
    const UNPACK_ROW_LENGTH: u32 = 0x0CF2;
    #[classattr]
    const UNPACK_SKIP_IMAGES: u32 = 0x806D;
    #[classattr]
    const UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
    #[classattr]
    const UNPACK_SKIP_ROWS: u32 = 0x0CF3;
    #[classattr]
    const UNPACK_SWAP_BYTES: u32 = 0x0CF0;
    #[classattr]
    const UNSIGNALED: u32 = 0x9118;
    #[classattr]
    const UNSIGNED_BYTE: u32 = 0x1401;
    #[classattr]
    const UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
    #[classattr]
    const UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
    #[classattr]
    const UNSIGNED_INT: u32 = 0x1405;
    #[classattr]
    const UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
    #[classattr]
    const UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
    #[classattr]
    const UNSIGNED_INT_24_8: u32 = 0x84FA;
    #[classattr]
    const UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
    #[classattr]
    const UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
    #[classattr]
    const UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
    #[classattr]
    const UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
    #[classattr]
    const UNSIGNED_INT_VEC2: u32 = 0x8DC6;
    #[classattr]
    const UNSIGNED_INT_VEC3: u32 = 0x8DC7;
    #[classattr]
    const UNSIGNED_INT_VEC4: u32 = 0x8DC8;
    #[classattr]
    const UNSIGNED_NORMALIZED: u32 = 0x8C17;
    #[classattr]
    const UNSIGNED_SHORT: u32 = 0x1403;
    #[classattr]
    const UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
    #[classattr]
    const UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
    #[classattr]
    const UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
    #[classattr]
    const UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
    #[classattr]
    const UPPER_LEFT: u32 = 0x8CA2;
    #[classattr]
    const V2F: u32 = 0x2A20;
    #[classattr]
    const V3F: u32 = 0x2A21;
    #[classattr]
    const VALIDATE_STATUS: u32 = 0x8B83;
    #[classattr]
    const VENDOR: u32 = 0x1F00;
    #[classattr]
    const VERSION: u32 = 0x1F02;
    #[classattr]
    const VERTEX_ARRAY: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_BINDING: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BINDING_APPLE: u32 = 0x85B5;
    #[classattr]
    const VERTEX_ARRAY_BUFFER_BINDING: u32 = 0x8896;
    #[classattr]
    const VERTEX_ARRAY_KHR: u32 = 0x8074;
    #[classattr]
    const VERTEX_ARRAY_POINTER: u32 = 0x808E;
    #[classattr]
    const VERTEX_ARRAY_SIZE: u32 = 0x807A;
    #[classattr]
    const VERTEX_ARRAY_STRIDE: u32 = 0x807C;
    #[classattr]
    const VERTEX_ARRAY_TYPE: u32 = 0x807B;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
    #[classattr]
    const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
    #[classattr]
    const VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
    #[classattr]
    const VERTEX_PROGRAM_TWO_SIDE: u32 = 0x8643;
    #[classattr]
    const VERTEX_SHADER: u32 = 0x8B31;
    #[classattr]
    const VIEWPORT: u32 = 0x0BA2;
    #[classattr]
    const VIEWPORT_BIT: u32 = 0x00000800;
    #[classattr]
    const WAIT_FAILED: u32 = 0x911D;
    #[classattr]
    const WEIGHT_ARRAY_BUFFER_BINDING: u32 = 0x889E;
    #[classattr]
    const WRITE_ONLY: u32 = 0x88B9;
    #[classattr]
    const XOR: u32 = 0x1506;
    #[classattr]
    const ZERO: u32 = 0;
    #[classattr]
    const ZOOM_X: u32 = 0x0D16;
    #[classattr]
    const ZOOM_Y: u32 = 0x0D17;

    fn get_type(&self) -> AzGlTypeEnumWrapper {
        unsafe { mem::transmute(crate::AzGl_getType(mem::transmute(self))) }
    }
    fn buffer_data_untyped(
        &self,
        target: u32,
        size: isize,
        data: AzGlVoidPtrConst,
        usage: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bufferDataUntyped(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(size),
                mem::transmute(data),
                mem::transmute(usage),
            ))
        }
    }
    fn buffer_sub_data_untyped(
        &self,
        target: u32,
        offset: isize,
        size: isize,
        data: AzGlVoidPtrConst,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bufferSubDataUntyped(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(offset),
                mem::transmute(size),
                mem::transmute(data),
            ))
        }
    }
    fn map_buffer(&self, target: u32, access: u32) -> AzGlVoidPtrMut {
        unsafe {
            mem::transmute(crate::AzGl_mapBuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(access),
            ))
        }
    }
    fn map_buffer_range(
        &self,
        target: u32,
        offset: isize,
        length: isize,
        access: u32,
    ) -> AzGlVoidPtrMut {
        unsafe {
            mem::transmute(crate::AzGl_mapBufferRange(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(offset),
                mem::transmute(length),
                mem::transmute(access),
            ))
        }
    }
    fn unmap_buffer(&self, target: u32) -> u8 {
        unsafe {
            mem::transmute(crate::AzGl_unmapBuffer(
                mem::transmute(self),
                mem::transmute(target),
            ))
        }
    }
    fn tex_buffer(&self, target: u32, internal_format: u32, buffer: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texBuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(internal_format),
                mem::transmute(buffer),
            ))
        }
    }
    fn shader_source(&self, shader: u32, strings: AzStringVec) -> () {
        unsafe {
            mem::transmute(crate::AzGl_shaderSource(
                mem::transmute(self),
                mem::transmute(shader),
                mem::transmute(strings),
            ))
        }
    }
    fn read_buffer(&self, mode: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_readBuffer(
                mem::transmute(self),
                mem::transmute(mode),
            ))
        }
    }
    fn read_pixels_into_buffer(
        &self,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
        format: u32,
        pixel_type: u32,
        mut dst_buffer: Vec<u8>,
    ) -> () {
        let dst_buffer = pybytesrefmut_to_vecu8refmut(&mut dst_buffer);
        unsafe {
            mem::transmute(crate::AzGl_readPixelsIntoBuffer(
                mem::transmute(self),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(format),
                mem::transmute(pixel_type),
                mem::transmute(dst_buffer),
            ))
        }
    }
    fn read_pixels(
        &self,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
        format: u32,
        pixel_type: u32,
    ) -> Vec<u8> {
        az_vecu8_to_py_vecu8(unsafe {
            mem::transmute(crate::AzGl_readPixels(
                mem::transmute(self),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(format),
                mem::transmute(pixel_type),
            ))
        })
    }
    fn read_pixels_into_pbo(
        &self,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
        format: u32,
        pixel_type: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_readPixelsIntoPbo(
                mem::transmute(self),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(format),
                mem::transmute(pixel_type),
            ))
        }
    }
    fn sample_coverage(&self, value: f32, invert: bool) -> () {
        unsafe {
            mem::transmute(crate::AzGl_sampleCoverage(
                mem::transmute(self),
                mem::transmute(value),
                mem::transmute(invert),
            ))
        }
    }
    fn polygon_offset(&self, factor: f32, units: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_polygonOffset(
                mem::transmute(self),
                mem::transmute(factor),
                mem::transmute(units),
            ))
        }
    }
    fn pixel_store_i(&self, name: u32, param: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_pixelStoreI(
                mem::transmute(self),
                mem::transmute(name),
                mem::transmute(param),
            ))
        }
    }
    fn gen_buffers(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genBuffers(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn gen_renderbuffers(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genRenderbuffers(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn gen_framebuffers(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genFramebuffers(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn gen_textures(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genTextures(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn gen_vertex_arrays(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genVertexArrays(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn gen_queries(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genQueries(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn begin_query(&self, target: u32, id: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_beginQuery(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(id),
            ))
        }
    }
    fn end_query(&self, target: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_endQuery(
                mem::transmute(self),
                mem::transmute(target),
            ))
        }
    }
    fn query_counter(&self, id: u32, target: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_queryCounter(
                mem::transmute(self),
                mem::transmute(id),
                mem::transmute(target),
            ))
        }
    }
    fn get_query_object_iv(&self, id: u32, pname: u32) -> i32 {
        unsafe {
            mem::transmute(crate::AzGl_getQueryObjectIv(
                mem::transmute(self),
                mem::transmute(id),
                mem::transmute(pname),
            ))
        }
    }
    fn get_query_object_uiv(&self, id: u32, pname: u32) -> u32 {
        unsafe {
            mem::transmute(crate::AzGl_getQueryObjectUiv(
                mem::transmute(self),
                mem::transmute(id),
                mem::transmute(pname),
            ))
        }
    }
    fn get_query_object_i64v(&self, id: u32, pname: u32) -> i64 {
        unsafe {
            mem::transmute(crate::AzGl_getQueryObjectI64V(
                mem::transmute(self),
                mem::transmute(id),
                mem::transmute(pname),
            ))
        }
    }
    fn get_query_object_ui64v(&self, id: u32, pname: u32) -> u64 {
        unsafe {
            mem::transmute(crate::AzGl_getQueryObjectUi64V(
                mem::transmute(self),
                mem::transmute(id),
                mem::transmute(pname),
            ))
        }
    }
    fn delete_queries(&self, queries: Vec<u32>) -> () {
        let queries = pylist_u32_to_rust(&queries);
        unsafe {
            mem::transmute(crate::AzGl_deleteQueries(
                mem::transmute(self),
                mem::transmute(queries),
            ))
        }
    }
    fn delete_vertex_arrays(&self, vertex_arrays: Vec<u32>) -> () {
        let vertex_arrays = pylist_u32_to_rust(&vertex_arrays);
        unsafe {
            mem::transmute(crate::AzGl_deleteVertexArrays(
                mem::transmute(self),
                mem::transmute(vertex_arrays),
            ))
        }
    }
    fn delete_buffers(&self, buffers: Vec<u32>) -> () {
        let buffers = pylist_u32_to_rust(&buffers);
        unsafe {
            mem::transmute(crate::AzGl_deleteBuffers(
                mem::transmute(self),
                mem::transmute(buffers),
            ))
        }
    }
    fn delete_renderbuffers(&self, renderbuffers: Vec<u32>) -> () {
        let renderbuffers = pylist_u32_to_rust(&renderbuffers);
        unsafe {
            mem::transmute(crate::AzGl_deleteRenderbuffers(
                mem::transmute(self),
                mem::transmute(renderbuffers),
            ))
        }
    }
    fn delete_framebuffers(&self, framebuffers: Vec<u32>) -> () {
        let framebuffers = pylist_u32_to_rust(&framebuffers);
        unsafe {
            mem::transmute(crate::AzGl_deleteFramebuffers(
                mem::transmute(self),
                mem::transmute(framebuffers),
            ))
        }
    }
    fn delete_textures(&self, textures: Vec<u32>) -> () {
        let textures = pylist_u32_to_rust(&textures);
        unsafe {
            mem::transmute(crate::AzGl_deleteTextures(
                mem::transmute(self),
                mem::transmute(textures),
            ))
        }
    }
    fn framebuffer_renderbuffer(
        &self,
        target: u32,
        attachment: u32,
        renderbuffertarget: u32,
        renderbuffer: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_framebufferRenderbuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(attachment),
                mem::transmute(renderbuffertarget),
                mem::transmute(renderbuffer),
            ))
        }
    }
    fn renderbuffer_storage(
        &self,
        target: u32,
        internalformat: u32,
        width: i32,
        height: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_renderbufferStorage(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(internalformat),
                mem::transmute(width),
                mem::transmute(height),
            ))
        }
    }
    fn depth_func(&self, func: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_depthFunc(
                mem::transmute(self),
                mem::transmute(func),
            ))
        }
    }
    fn active_texture(&self, texture: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_activeTexture(
                mem::transmute(self),
                mem::transmute(texture),
            ))
        }
    }
    fn attach_shader(&self, program: u32, shader: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_attachShader(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(shader),
            ))
        }
    }
    fn bind_attrib_location(&self, program: u32, index: u32, name: &str) -> () {
        let name = pystring_to_refstr(&name);
        unsafe {
            mem::transmute(crate::AzGl_bindAttribLocation(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(index),
                mem::transmute(name),
            ))
        }
    }
    fn get_uniform_iv(&self, program: u32, location: i32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getUniformIv(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(location),
                mem::transmute(result),
            ))
        }
    }
    fn get_uniform_fv(&self, program: u32, location: i32, mut result: Vec<f32>) -> () {
        let result = pylist_glfoat_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getUniformFv(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(location),
                mem::transmute(result),
            ))
        }
    }
    fn get_uniform_block_index(&self, program: u32, name: &str) -> u32 {
        let name = pystring_to_refstr(&name);
        unsafe {
            mem::transmute(crate::AzGl_getUniformBlockIndex(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(name),
            ))
        }
    }
    fn get_uniform_indices(&self, program: u32, names: Vec<&str>) -> AzGLuintVec {
        let names = vec_string_to_vec_refstr(&names);
        let names = pylist_str_to_rust(&names);
        unsafe {
            mem::transmute(crate::AzGl_getUniformIndices(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(names),
            ))
        }
    }
    fn bind_buffer_base(&self, target: u32, index: u32, buffer: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindBufferBase(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(index),
                mem::transmute(buffer),
            ))
        }
    }
    fn bind_buffer_range(
        &self,
        target: u32,
        index: u32,
        buffer: u32,
        offset: isize,
        size: isize,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindBufferRange(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(index),
                mem::transmute(buffer),
                mem::transmute(offset),
                mem::transmute(size),
            ))
        }
    }
    fn uniform_block_binding(
        &self,
        program: u32,
        uniform_block_index: u32,
        uniform_block_binding: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniformBlockBinding(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(uniform_block_index),
                mem::transmute(uniform_block_binding),
            ))
        }
    }
    fn bind_buffer(&self, target: u32, buffer: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindBuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(buffer),
            ))
        }
    }
    fn bind_vertex_array(&self, vao: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindVertexArray(
                mem::transmute(self),
                mem::transmute(vao),
            ))
        }
    }
    fn bind_renderbuffer(&self, target: u32, renderbuffer: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindRenderbuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(renderbuffer),
            ))
        }
    }
    fn bind_framebuffer(&self, target: u32, framebuffer: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindFramebuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(framebuffer),
            ))
        }
    }
    fn bind_texture(&self, target: u32, texture: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindTexture(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(texture),
            ))
        }
    }
    fn draw_buffers(&self, bufs: AzGLenumVecRef) -> () {
        unsafe {
            mem::transmute(crate::AzGl_drawBuffers(
                mem::transmute(self),
                mem::transmute(bufs),
            ))
        }
    }
    fn tex_image_2d(
        &self,
        target: u32,
        level: i32,
        internal_format: i32,
        width: i32,
        height: i32,
        border: i32,
        format: u32,
        ty: u32,
        opt_data: AzOptionU8VecRefEnumWrapper,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texImage2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(internal_format),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(border),
                mem::transmute(format),
                mem::transmute(ty),
                mem::transmute(opt_data),
            ))
        }
    }
    fn compressed_tex_image_2d(
        &self,
        target: u32,
        level: i32,
        internal_format: u32,
        width: i32,
        height: i32,
        border: i32,
        data: Vec<u8>,
    ) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe {
            mem::transmute(crate::AzGl_compressedTexImage2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(internal_format),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(border),
                mem::transmute(data),
            ))
        }
    }
    fn compressed_tex_sub_image_2d(
        &self,
        target: u32,
        level: i32,
        xoffset: i32,
        yoffset: i32,
        width: i32,
        height: i32,
        format: u32,
        data: Vec<u8>,
    ) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe {
            mem::transmute(crate::AzGl_compressedTexSubImage2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(format),
                mem::transmute(data),
            ))
        }
    }
    fn tex_image_3d(
        &self,
        target: u32,
        level: i32,
        internal_format: i32,
        width: i32,
        height: i32,
        depth: i32,
        border: i32,
        format: u32,
        ty: u32,
        opt_data: AzOptionU8VecRefEnumWrapper,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texImage3D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(internal_format),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(depth),
                mem::transmute(border),
                mem::transmute(format),
                mem::transmute(ty),
                mem::transmute(opt_data),
            ))
        }
    }
    fn copy_tex_image_2d(
        &self,
        target: u32,
        level: i32,
        internal_format: u32,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
        border: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copyTexImage2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(internal_format),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(border),
            ))
        }
    }
    fn copy_tex_sub_image_2d(
        &self,
        target: u32,
        level: i32,
        xoffset: i32,
        yoffset: i32,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copyTexSubImage2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
            ))
        }
    }
    fn copy_tex_sub_image_3d(
        &self,
        target: u32,
        level: i32,
        xoffset: i32,
        yoffset: i32,
        zoffset: i32,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copyTexSubImage3D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(zoffset),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
            ))
        }
    }
    fn tex_sub_image_2d(
        &self,
        target: u32,
        level: i32,
        xoffset: i32,
        yoffset: i32,
        width: i32,
        height: i32,
        format: u32,
        ty: u32,
        data: Vec<u8>,
    ) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe {
            mem::transmute(crate::AzGl_texSubImage2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(format),
                mem::transmute(ty),
                mem::transmute(data),
            ))
        }
    }
    fn tex_sub_image_2d_pbo(
        &self,
        target: u32,
        level: i32,
        xoffset: i32,
        yoffset: i32,
        width: i32,
        height: i32,
        format: u32,
        ty: u32,
        offset: usize,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texSubImage2DPbo(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(format),
                mem::transmute(ty),
                mem::transmute(offset),
            ))
        }
    }
    fn tex_sub_image_3d(
        &self,
        target: u32,
        level: i32,
        xoffset: i32,
        yoffset: i32,
        zoffset: i32,
        width: i32,
        height: i32,
        depth: i32,
        format: u32,
        ty: u32,
        data: Vec<u8>,
    ) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe {
            mem::transmute(crate::AzGl_texSubImage3D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(zoffset),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(depth),
                mem::transmute(format),
                mem::transmute(ty),
                mem::transmute(data),
            ))
        }
    }
    fn tex_sub_image_3d_pbo(
        &self,
        target: u32,
        level: i32,
        xoffset: i32,
        yoffset: i32,
        zoffset: i32,
        width: i32,
        height: i32,
        depth: i32,
        format: u32,
        ty: u32,
        offset: usize,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texSubImage3DPbo(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(zoffset),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(depth),
                mem::transmute(format),
                mem::transmute(ty),
                mem::transmute(offset),
            ))
        }
    }
    fn tex_storage_2d(
        &self,
        target: u32,
        levels: i32,
        internal_format: u32,
        width: i32,
        height: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texStorage2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(levels),
                mem::transmute(internal_format),
                mem::transmute(width),
                mem::transmute(height),
            ))
        }
    }
    fn tex_storage_3d(
        &self,
        target: u32,
        levels: i32,
        internal_format: u32,
        width: i32,
        height: i32,
        depth: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texStorage3D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(levels),
                mem::transmute(internal_format),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(depth),
            ))
        }
    }
    fn get_tex_image_into_buffer(
        &self,
        target: u32,
        level: i32,
        format: u32,
        ty: u32,
        mut output: Vec<u8>,
    ) -> () {
        let output = pybytesrefmut_to_vecu8refmut(&mut output);
        unsafe {
            mem::transmute(crate::AzGl_getTexImageIntoBuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(level),
                mem::transmute(format),
                mem::transmute(ty),
                mem::transmute(output),
            ))
        }
    }
    fn copy_image_sub_data(
        &self,
        src_name: u32,
        src_target: u32,
        src_level: i32,
        src_x: i32,
        src_y: i32,
        src_z: i32,
        dst_name: u32,
        dst_target: u32,
        dst_level: i32,
        dst_x: i32,
        dst_y: i32,
        dst_z: i32,
        src_width: i32,
        src_height: i32,
        src_depth: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copyImageSubData(
                mem::transmute(self),
                mem::transmute(src_name),
                mem::transmute(src_target),
                mem::transmute(src_level),
                mem::transmute(src_x),
                mem::transmute(src_y),
                mem::transmute(src_z),
                mem::transmute(dst_name),
                mem::transmute(dst_target),
                mem::transmute(dst_level),
                mem::transmute(dst_x),
                mem::transmute(dst_y),
                mem::transmute(dst_z),
                mem::transmute(src_width),
                mem::transmute(src_height),
                mem::transmute(src_depth),
            ))
        }
    }
    fn invalidate_framebuffer(&self, target: u32, attachments: AzGLenumVecRef) -> () {
        unsafe {
            mem::transmute(crate::AzGl_invalidateFramebuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(attachments),
            ))
        }
    }
    fn invalidate_sub_framebuffer(
        &self,
        target: u32,
        attachments: AzGLenumVecRef,
        xoffset: i32,
        yoffset: i32,
        width: i32,
        height: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_invalidateSubFramebuffer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(attachments),
                mem::transmute(xoffset),
                mem::transmute(yoffset),
                mem::transmute(width),
                mem::transmute(height),
            ))
        }
    }
    fn get_integer_v(&self, name: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getIntegerV(
                mem::transmute(self),
                mem::transmute(name),
                mem::transmute(result),
            ))
        }
    }
    fn get_integer_64v(&self, name: u32, mut result: Vec<i64>) -> () {
        let result = pylist_i64_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getInteger64V(
                mem::transmute(self),
                mem::transmute(name),
                mem::transmute(result),
            ))
        }
    }
    fn get_integer_iv(&self, name: u32, index: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getIntegerIv(
                mem::transmute(self),
                mem::transmute(name),
                mem::transmute(index),
                mem::transmute(result),
            ))
        }
    }
    fn get_integer_64iv(&self, name: u32, index: u32, mut result: Vec<i64>) -> () {
        let result = pylist_i64_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getInteger64Iv(
                mem::transmute(self),
                mem::transmute(name),
                mem::transmute(index),
                mem::transmute(result),
            ))
        }
    }
    fn get_boolean_v(&self, name: u32, mut result: Vec<u8>) -> () {
        let result = pylist_bool_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getBooleanV(
                mem::transmute(self),
                mem::transmute(name),
                mem::transmute(result),
            ))
        }
    }
    fn get_float_v(&self, name: u32, mut result: Vec<f32>) -> () {
        let result = pylist_glfoat_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getFloatV(
                mem::transmute(self),
                mem::transmute(name),
                mem::transmute(result),
            ))
        }
    }
    fn get_framebuffer_attachment_parameter_iv(
        &self,
        target: u32,
        attachment: u32,
        pname: u32,
    ) -> i32 {
        unsafe {
            mem::transmute(crate::AzGl_getFramebufferAttachmentParameterIv(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(attachment),
                mem::transmute(pname),
            ))
        }
    }
    fn get_renderbuffer_parameter_iv(&self, target: u32, pname: u32) -> i32 {
        unsafe {
            mem::transmute(crate::AzGl_getRenderbufferParameterIv(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(pname),
            ))
        }
    }
    fn get_tex_parameter_iv(&self, target: u32, name: u32) -> i32 {
        unsafe {
            mem::transmute(crate::AzGl_getTexParameterIv(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(name),
            ))
        }
    }
    fn get_tex_parameter_fv(&self, target: u32, name: u32) -> f32 {
        unsafe {
            mem::transmute(crate::AzGl_getTexParameterFv(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(name),
            ))
        }
    }
    fn tex_parameter_i(&self, target: u32, pname: u32, param: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texParameterI(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(pname),
                mem::transmute(param),
            ))
        }
    }
    fn tex_parameter_f(&self, target: u32, pname: u32, param: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_texParameterF(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(pname),
                mem::transmute(param),
            ))
        }
    }
    fn framebuffer_texture_2d(
        &self,
        target: u32,
        attachment: u32,
        textarget: u32,
        texture: u32,
        level: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_framebufferTexture2D(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(attachment),
                mem::transmute(textarget),
                mem::transmute(texture),
                mem::transmute(level),
            ))
        }
    }
    fn framebuffer_texture_layer(
        &self,
        target: u32,
        attachment: u32,
        texture: u32,
        level: i32,
        layer: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_framebufferTextureLayer(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(attachment),
                mem::transmute(texture),
                mem::transmute(level),
                mem::transmute(layer),
            ))
        }
    }
    fn blit_framebuffer(
        &self,
        src_x0: i32,
        src_y0: i32,
        src_x1: i32,
        src_y1: i32,
        dst_x0: i32,
        dst_y0: i32,
        dst_x1: i32,
        dst_y1: i32,
        mask: u32,
        filter: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_blitFramebuffer(
                mem::transmute(self),
                mem::transmute(src_x0),
                mem::transmute(src_y0),
                mem::transmute(src_x1),
                mem::transmute(src_y1),
                mem::transmute(dst_x0),
                mem::transmute(dst_y0),
                mem::transmute(dst_x1),
                mem::transmute(dst_y1),
                mem::transmute(mask),
                mem::transmute(filter),
            ))
        }
    }
    fn vertex_attrib_4f(&self, index: u32, x: f32, y: f32, z: f32, w: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_vertexAttrib4F(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(z),
                mem::transmute(w),
            ))
        }
    }
    fn vertex_attrib_pointer_f32(
        &self,
        index: u32,
        size: i32,
        normalized: bool,
        stride: i32,
        offset: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_vertexAttribPointerF32(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(size),
                mem::transmute(normalized),
                mem::transmute(stride),
                mem::transmute(offset),
            ))
        }
    }
    fn vertex_attrib_pointer(
        &self,
        index: u32,
        size: i32,
        type_: u32,
        normalized: bool,
        stride: i32,
        offset: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_vertexAttribPointer(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(size),
                mem::transmute(type_),
                mem::transmute(normalized),
                mem::transmute(stride),
                mem::transmute(offset),
            ))
        }
    }
    fn vertex_attrib_i_pointer(
        &self,
        index: u32,
        size: i32,
        type_: u32,
        stride: i32,
        offset: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_vertexAttribIPointer(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(size),
                mem::transmute(type_),
                mem::transmute(stride),
                mem::transmute(offset),
            ))
        }
    }
    fn vertex_attrib_divisor(&self, index: u32, divisor: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_vertexAttribDivisor(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(divisor),
            ))
        }
    }
    fn viewport(&self, x: i32, y: i32, width: i32, height: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_viewport(
                mem::transmute(self),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
            ))
        }
    }
    fn scissor(&self, x: i32, y: i32, width: i32, height: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_scissor(
                mem::transmute(self),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
            ))
        }
    }
    fn line_width(&self, width: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_lineWidth(
                mem::transmute(self),
                mem::transmute(width),
            ))
        }
    }
    fn use_program(&self, program: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_useProgram(
                mem::transmute(self),
                mem::transmute(program),
            ))
        }
    }
    fn validate_program(&self, program: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_validateProgram(
                mem::transmute(self),
                mem::transmute(program),
            ))
        }
    }
    fn draw_arrays(&self, mode: u32, first: i32, count: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_drawArrays(
                mem::transmute(self),
                mem::transmute(mode),
                mem::transmute(first),
                mem::transmute(count),
            ))
        }
    }
    fn draw_arrays_instanced(&self, mode: u32, first: i32, count: i32, primcount: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_drawArraysInstanced(
                mem::transmute(self),
                mem::transmute(mode),
                mem::transmute(first),
                mem::transmute(count),
                mem::transmute(primcount),
            ))
        }
    }
    fn draw_elements(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_drawElements(
                mem::transmute(self),
                mem::transmute(mode),
                mem::transmute(count),
                mem::transmute(element_type),
                mem::transmute(indices_offset),
            ))
        }
    }
    fn draw_elements_instanced(
        &self,
        mode: u32,
        count: i32,
        element_type: u32,
        indices_offset: u32,
        primcount: i32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_drawElementsInstanced(
                mem::transmute(self),
                mem::transmute(mode),
                mem::transmute(count),
                mem::transmute(element_type),
                mem::transmute(indices_offset),
                mem::transmute(primcount),
            ))
        }
    }
    fn blend_color(&self, r: f32, g: f32, b: f32, a: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_blendColor(
                mem::transmute(self),
                mem::transmute(r),
                mem::transmute(g),
                mem::transmute(b),
                mem::transmute(a),
            ))
        }
    }
    fn blend_func(&self, sfactor: u32, dfactor: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_blendFunc(
                mem::transmute(self),
                mem::transmute(sfactor),
                mem::transmute(dfactor),
            ))
        }
    }
    fn blend_func_separate(
        &self,
        src_rgb: u32,
        dest_rgb: u32,
        src_alpha: u32,
        dest_alpha: u32,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_blendFuncSeparate(
                mem::transmute(self),
                mem::transmute(src_rgb),
                mem::transmute(dest_rgb),
                mem::transmute(src_alpha),
                mem::transmute(dest_alpha),
            ))
        }
    }
    fn blend_equation(&self, mode: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_blendEquation(
                mem::transmute(self),
                mem::transmute(mode),
            ))
        }
    }
    fn blend_equation_separate(&self, mode_rgb: u32, mode_alpha: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_blendEquationSeparate(
                mem::transmute(self),
                mem::transmute(mode_rgb),
                mem::transmute(mode_alpha),
            ))
        }
    }
    fn color_mask(&self, r: bool, g: bool, b: bool, a: bool) -> () {
        unsafe {
            mem::transmute(crate::AzGl_colorMask(
                mem::transmute(self),
                mem::transmute(r),
                mem::transmute(g),
                mem::transmute(b),
                mem::transmute(a),
            ))
        }
    }
    fn cull_face(&self, mode: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_cullFace(
                mem::transmute(self),
                mem::transmute(mode),
            ))
        }
    }
    fn front_face(&self, mode: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_frontFace(
                mem::transmute(self),
                mem::transmute(mode),
            ))
        }
    }
    fn enable(&self, cap: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_enable(
                mem::transmute(self),
                mem::transmute(cap),
            ))
        }
    }
    fn disable(&self, cap: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_disable(
                mem::transmute(self),
                mem::transmute(cap),
            ))
        }
    }
    fn hint(&self, param_name: u32, param_val: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_hint(
                mem::transmute(self),
                mem::transmute(param_name),
                mem::transmute(param_val),
            ))
        }
    }
    fn is_enabled(&self, cap: u32) -> u8 {
        unsafe {
            mem::transmute(crate::AzGl_isEnabled(
                mem::transmute(self),
                mem::transmute(cap),
            ))
        }
    }
    fn is_shader(&self, shader: u32) -> u8 {
        unsafe {
            mem::transmute(crate::AzGl_isShader(
                mem::transmute(self),
                mem::transmute(shader),
            ))
        }
    }
    fn is_texture(&self, texture: u32) -> u8 {
        unsafe {
            mem::transmute(crate::AzGl_isTexture(
                mem::transmute(self),
                mem::transmute(texture),
            ))
        }
    }
    fn is_framebuffer(&self, framebuffer: u32) -> u8 {
        unsafe {
            mem::transmute(crate::AzGl_isFramebuffer(
                mem::transmute(self),
                mem::transmute(framebuffer),
            ))
        }
    }
    fn is_renderbuffer(&self, renderbuffer: u32) -> u8 {
        unsafe {
            mem::transmute(crate::AzGl_isRenderbuffer(
                mem::transmute(self),
                mem::transmute(renderbuffer),
            ))
        }
    }
    fn check_frame_buffer_status(&self, target: u32) -> u32 {
        unsafe {
            mem::transmute(crate::AzGl_checkFrameBufferStatus(
                mem::transmute(self),
                mem::transmute(target),
            ))
        }
    }
    fn enable_vertex_attrib_array(&self, index: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_enableVertexAttribArray(
                mem::transmute(self),
                mem::transmute(index),
            ))
        }
    }
    fn disable_vertex_attrib_array(&self, index: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_disableVertexAttribArray(
                mem::transmute(self),
                mem::transmute(index),
            ))
        }
    }
    fn uniform_1f(&self, location: i32, v0: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform1F(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
            ))
        }
    }
    fn uniform_1fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe {
            mem::transmute(crate::AzGl_uniform1Fv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_1i(&self, location: i32, v0: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform1I(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
            ))
        }
    }
    fn uniform_1iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform1Iv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_1ui(&self, location: i32, v0: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform1Ui(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
            ))
        }
    }
    fn uniform_2f(&self, location: i32, v0: f32, v1: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform2F(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
                mem::transmute(v1),
            ))
        }
    }
    fn uniform_2fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe {
            mem::transmute(crate::AzGl_uniform2Fv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_2i(&self, location: i32, v0: i32, v1: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform2I(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
                mem::transmute(v1),
            ))
        }
    }
    fn uniform_2iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform2Iv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_2ui(&self, location: i32, v0: u32, v1: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform2Ui(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
                mem::transmute(v1),
            ))
        }
    }
    fn uniform_3f(&self, location: i32, v0: f32, v1: f32, v2: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform3F(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
                mem::transmute(v1),
                mem::transmute(v2),
            ))
        }
    }
    fn uniform_3fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe {
            mem::transmute(crate::AzGl_uniform3Fv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_3i(&self, location: i32, v0: i32, v1: i32, v2: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform3I(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
                mem::transmute(v1),
                mem::transmute(v2),
            ))
        }
    }
    fn uniform_3iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform3Iv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_3ui(&self, location: i32, v0: u32, v1: u32, v2: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform3Ui(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(v0),
                mem::transmute(v1),
                mem::transmute(v2),
            ))
        }
    }
    fn uniform_4f(&self, location: i32, x: f32, y: f32, z: f32, w: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform4F(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(z),
                mem::transmute(w),
            ))
        }
    }
    fn uniform_4i(&self, location: i32, x: i32, y: i32, z: i32, w: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform4I(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(z),
                mem::transmute(w),
            ))
        }
    }
    fn uniform_4iv(&self, location: i32, values: AzI32VecRef) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform4Iv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_4ui(&self, location: i32, x: u32, y: u32, z: u32, w: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_uniform4Ui(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(z),
                mem::transmute(w),
            ))
        }
    }
    fn uniform_4fv(&self, location: i32, values: Vec<f32>) -> () {
        let values = pylist_f32_to_rust(&values);
        unsafe {
            mem::transmute(crate::AzGl_uniform4Fv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(values),
            ))
        }
    }
    fn uniform_matrix_2fv(&self, location: i32, transpose: bool, value: Vec<f32>) -> () {
        let value = pylist_f32_to_rust(&value);
        unsafe {
            mem::transmute(crate::AzGl_uniformMatrix2Fv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(transpose),
                mem::transmute(value),
            ))
        }
    }
    fn uniform_matrix_3fv(&self, location: i32, transpose: bool, value: Vec<f32>) -> () {
        let value = pylist_f32_to_rust(&value);
        unsafe {
            mem::transmute(crate::AzGl_uniformMatrix3Fv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(transpose),
                mem::transmute(value),
            ))
        }
    }
    fn uniform_matrix_4fv(&self, location: i32, transpose: bool, value: Vec<f32>) -> () {
        let value = pylist_f32_to_rust(&value);
        unsafe {
            mem::transmute(crate::AzGl_uniformMatrix4Fv(
                mem::transmute(self),
                mem::transmute(location),
                mem::transmute(transpose),
                mem::transmute(value),
            ))
        }
    }
    fn depth_mask(&self, flag: bool) -> () {
        unsafe {
            mem::transmute(crate::AzGl_depthMask(
                mem::transmute(self),
                mem::transmute(flag),
            ))
        }
    }
    fn depth_range(&self, near: f64, far: f64) -> () {
        unsafe {
            mem::transmute(crate::AzGl_depthRange(
                mem::transmute(self),
                mem::transmute(near),
                mem::transmute(far),
            ))
        }
    }
    fn get_active_attrib(&self, program: u32, index: u32) -> AzGetActiveAttribReturn {
        unsafe {
            mem::transmute(crate::AzGl_getActiveAttrib(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(index),
            ))
        }
    }
    fn get_active_uniform(&self, program: u32, index: u32) -> AzGetActiveUniformReturn {
        unsafe {
            mem::transmute(crate::AzGl_getActiveUniform(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(index),
            ))
        }
    }
    fn get_active_uniforms_iv(&self, program: u32, indices: AzGLuintVec, pname: u32) -> AzGLintVec {
        unsafe {
            mem::transmute(crate::AzGl_getActiveUniformsIv(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(indices),
                mem::transmute(pname),
            ))
        }
    }
    fn get_active_uniform_block_i(&self, program: u32, index: u32, pname: u32) -> i32 {
        unsafe {
            mem::transmute(crate::AzGl_getActiveUniformBlockI(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(index),
                mem::transmute(pname),
            ))
        }
    }
    fn get_active_uniform_block_iv(&self, program: u32, index: u32, pname: u32) -> AzGLintVec {
        unsafe {
            mem::transmute(crate::AzGl_getActiveUniformBlockIv(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(index),
                mem::transmute(pname),
            ))
        }
    }
    fn get_active_uniform_block_name(&self, program: u32, index: u32) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzGl_getActiveUniformBlockName(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(index),
            ))
        })
    }
    fn get_attrib_location(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe {
            mem::transmute(crate::AzGl_getAttribLocation(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(name),
            ))
        }
    }
    fn get_frag_data_location(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe {
            mem::transmute(crate::AzGl_getFragDataLocation(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(name),
            ))
        }
    }
    fn get_uniform_location(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe {
            mem::transmute(crate::AzGl_getUniformLocation(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(name),
            ))
        }
    }
    fn get_program_info_log(&self, program: u32) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzGl_getProgramInfoLog(
                mem::transmute(self),
                mem::transmute(program),
            ))
        })
    }
    fn get_program_iv(&self, program: u32, pname: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getProgramIv(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(pname),
                mem::transmute(result),
            ))
        }
    }
    fn get_program_binary(&self, program: u32) -> AzGetProgramBinaryReturn {
        unsafe {
            mem::transmute(crate::AzGl_getProgramBinary(
                mem::transmute(self),
                mem::transmute(program),
            ))
        }
    }
    fn program_binary(&self, program: u32, format: u32, binary: Vec<u8>) -> () {
        let binary = pybytesref_to_vecu8_ref(&binary);
        unsafe {
            mem::transmute(crate::AzGl_programBinary(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(format),
                mem::transmute(binary),
            ))
        }
    }
    fn program_parameter_i(&self, program: u32, pname: u32, value: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_programParameterI(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(pname),
                mem::transmute(value),
            ))
        }
    }
    fn get_vertex_attrib_iv(&self, index: u32, pname: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getVertexAttribIv(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(pname),
                mem::transmute(result),
            ))
        }
    }
    fn get_vertex_attrib_fv(&self, index: u32, pname: u32, mut result: Vec<f32>) -> () {
        let result = pylist_glfoat_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getVertexAttribFv(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(pname),
                mem::transmute(result),
            ))
        }
    }
    fn get_vertex_attrib_pointer_v(&self, index: u32, pname: u32) -> isize {
        unsafe {
            mem::transmute(crate::AzGl_getVertexAttribPointerV(
                mem::transmute(self),
                mem::transmute(index),
                mem::transmute(pname),
            ))
        }
    }
    fn get_buffer_parameter_iv(&self, target: u32, pname: u32) -> i32 {
        unsafe {
            mem::transmute(crate::AzGl_getBufferParameterIv(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(pname),
            ))
        }
    }
    fn get_shader_info_log(&self, shader: u32) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzGl_getShaderInfoLog(
                mem::transmute(self),
                mem::transmute(shader),
            ))
        })
    }
    fn get_string(&self, which: u32) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzGl_getString(
                mem::transmute(self),
                mem::transmute(which),
            ))
        })
    }
    fn get_string_i(&self, which: u32, index: u32) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzGl_getStringI(
                mem::transmute(self),
                mem::transmute(which),
                mem::transmute(index),
            ))
        })
    }
    fn get_shader_iv(&self, shader: u32, pname: u32, mut result: Vec<i32>) -> () {
        let result = pylist_i32_to_rust(&mut result);
        unsafe {
            mem::transmute(crate::AzGl_getShaderIv(
                mem::transmute(self),
                mem::transmute(shader),
                mem::transmute(pname),
                mem::transmute(result),
            ))
        }
    }
    fn get_shader_precision_format(
        &self,
        shader_type: u32,
        precision_type: u32,
    ) -> AzGlShaderPrecisionFormatReturn {
        unsafe {
            mem::transmute(crate::AzGl_getShaderPrecisionFormat(
                mem::transmute(self),
                mem::transmute(shader_type),
                mem::transmute(precision_type),
            ))
        }
    }
    fn compile_shader(&self, shader: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_compileShader(
                mem::transmute(self),
                mem::transmute(shader),
            ))
        }
    }
    fn create_program(&self) -> u32 {
        unsafe { mem::transmute(crate::AzGl_createProgram(mem::transmute(self))) }
    }
    fn delete_program(&self, program: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_deleteProgram(
                mem::transmute(self),
                mem::transmute(program),
            ))
        }
    }
    fn create_shader(&self, shader_type: u32) -> u32 {
        unsafe {
            mem::transmute(crate::AzGl_createShader(
                mem::transmute(self),
                mem::transmute(shader_type),
            ))
        }
    }
    fn delete_shader(&self, shader: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_deleteShader(
                mem::transmute(self),
                mem::transmute(shader),
            ))
        }
    }
    fn detach_shader(&self, program: u32, shader: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_detachShader(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(shader),
            ))
        }
    }
    fn link_program(&self, program: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_linkProgram(
                mem::transmute(self),
                mem::transmute(program),
            ))
        }
    }
    fn clear_color(&self, r: f32, g: f32, b: f32, a: f32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_clearColor(
                mem::transmute(self),
                mem::transmute(r),
                mem::transmute(g),
                mem::transmute(b),
                mem::transmute(a),
            ))
        }
    }
    fn clear(&self, buffer_mask: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_clear(
                mem::transmute(self),
                mem::transmute(buffer_mask),
            ))
        }
    }
    fn clear_depth(&self, depth: f64) -> () {
        unsafe {
            mem::transmute(crate::AzGl_clearDepth(
                mem::transmute(self),
                mem::transmute(depth),
            ))
        }
    }
    fn clear_stencil(&self, s: i32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_clearStencil(
                mem::transmute(self),
                mem::transmute(s),
            ))
        }
    }
    fn flush(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_flush(mem::transmute(self))) }
    }
    fn finish(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_finish(mem::transmute(self))) }
    }
    fn get_error(&self) -> u32 {
        unsafe { mem::transmute(crate::AzGl_getError(mem::transmute(self))) }
    }
    fn stencil_mask(&self, mask: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_stencilMask(
                mem::transmute(self),
                mem::transmute(mask),
            ))
        }
    }
    fn stencil_mask_separate(&self, face: u32, mask: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_stencilMaskSeparate(
                mem::transmute(self),
                mem::transmute(face),
                mem::transmute(mask),
            ))
        }
    }
    fn stencil_func(&self, func: u32, ref_: i32, mask: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_stencilFunc(
                mem::transmute(self),
                mem::transmute(func),
                mem::transmute(ref_),
                mem::transmute(mask),
            ))
        }
    }
    fn stencil_func_separate(&self, face: u32, func: u32, ref_: i32, mask: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_stencilFuncSeparate(
                mem::transmute(self),
                mem::transmute(face),
                mem::transmute(func),
                mem::transmute(ref_),
                mem::transmute(mask),
            ))
        }
    }
    fn stencil_op(&self, sfail: u32, dpfail: u32, dppass: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_stencilOp(
                mem::transmute(self),
                mem::transmute(sfail),
                mem::transmute(dpfail),
                mem::transmute(dppass),
            ))
        }
    }
    fn stencil_op_separate(&self, face: u32, sfail: u32, dpfail: u32, dppass: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_stencilOpSeparate(
                mem::transmute(self),
                mem::transmute(face),
                mem::transmute(sfail),
                mem::transmute(dpfail),
                mem::transmute(dppass),
            ))
        }
    }
    fn egl_image_target_texture2d_oes(&self, target: u32, image: AzGlVoidPtrConst) -> () {
        unsafe {
            mem::transmute(crate::AzGl_eglImageTargetTexture2DOes(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(image),
            ))
        }
    }
    fn generate_mipmap(&self, target: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_generateMipmap(
                mem::transmute(self),
                mem::transmute(target),
            ))
        }
    }
    fn insert_event_marker_ext(&self, message: &str) -> () {
        let message = pystring_to_refstr(&message);
        unsafe {
            mem::transmute(crate::AzGl_insertEventMarkerExt(
                mem::transmute(self),
                mem::transmute(message),
            ))
        }
    }
    fn push_group_marker_ext(&self, message: &str) -> () {
        let message = pystring_to_refstr(&message);
        unsafe {
            mem::transmute(crate::AzGl_pushGroupMarkerExt(
                mem::transmute(self),
                mem::transmute(message),
            ))
        }
    }
    fn pop_group_marker_ext(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_popGroupMarkerExt(mem::transmute(self))) }
    }
    fn debug_message_insert_khr(
        &self,
        source: u32,
        type_: u32,
        id: u32,
        severity: u32,
        message: &str,
    ) -> () {
        let message = pystring_to_refstr(&message);
        unsafe {
            mem::transmute(crate::AzGl_debugMessageInsertKhr(
                mem::transmute(self),
                mem::transmute(source),
                mem::transmute(type_),
                mem::transmute(id),
                mem::transmute(severity),
                mem::transmute(message),
            ))
        }
    }
    fn push_debug_group_khr(&self, source: u32, id: u32, message: &str) -> () {
        let message = pystring_to_refstr(&message);
        unsafe {
            mem::transmute(crate::AzGl_pushDebugGroupKhr(
                mem::transmute(self),
                mem::transmute(source),
                mem::transmute(id),
                mem::transmute(message),
            ))
        }
    }
    fn pop_debug_group_khr(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_popDebugGroupKhr(mem::transmute(self))) }
    }
    fn fence_sync(&self, condition: u32, flags: u32) -> AzGLsyncPtr {
        unsafe {
            mem::transmute(crate::AzGl_fenceSync(
                mem::transmute(self),
                mem::transmute(condition),
                mem::transmute(flags),
            ))
        }
    }
    fn client_wait_sync(&self, sync: AzGLsyncPtr, flags: u32, timeout: u64) -> u32 {
        unsafe {
            mem::transmute(crate::AzGl_clientWaitSync(
                mem::transmute(self),
                mem::transmute(sync),
                mem::transmute(flags),
                mem::transmute(timeout),
            ))
        }
    }
    fn wait_sync(&self, sync: AzGLsyncPtr, flags: u32, timeout: u64) -> () {
        unsafe {
            mem::transmute(crate::AzGl_waitSync(
                mem::transmute(self),
                mem::transmute(sync),
                mem::transmute(flags),
                mem::transmute(timeout),
            ))
        }
    }
    fn delete_sync(&self, sync: AzGLsyncPtr) -> () {
        unsafe {
            mem::transmute(crate::AzGl_deleteSync(
                mem::transmute(self),
                mem::transmute(sync),
            ))
        }
    }
    fn texture_range_apple(&self, target: u32, data: Vec<u8>) -> () {
        let data = pybytesref_to_vecu8_ref(&data);
        unsafe {
            mem::transmute(crate::AzGl_textureRangeApple(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(data),
            ))
        }
    }
    fn gen_fences_apple(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genFencesApple(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn delete_fences_apple(&self, fences: Vec<u32>) -> () {
        let fences = pylist_u32_to_rust(&fences);
        unsafe {
            mem::transmute(crate::AzGl_deleteFencesApple(
                mem::transmute(self),
                mem::transmute(fences),
            ))
        }
    }
    fn set_fence_apple(&self, fence: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_setFenceApple(
                mem::transmute(self),
                mem::transmute(fence),
            ))
        }
    }
    fn finish_fence_apple(&self, fence: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_finishFenceApple(
                mem::transmute(self),
                mem::transmute(fence),
            ))
        }
    }
    fn test_fence_apple(&self, fence: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_testFenceApple(
                mem::transmute(self),
                mem::transmute(fence),
            ))
        }
    }
    fn test_object_apple(&self, object: u32, name: u32) -> u8 {
        unsafe {
            mem::transmute(crate::AzGl_testObjectApple(
                mem::transmute(self),
                mem::transmute(object),
                mem::transmute(name),
            ))
        }
    }
    fn finish_object_apple(&self, object: u32, name: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_finishObjectApple(
                mem::transmute(self),
                mem::transmute(object),
                mem::transmute(name),
            ))
        }
    }
    fn get_frag_data_index(&self, program: u32, name: &str) -> i32 {
        let name = pystring_to_refstr(&name);
        unsafe {
            mem::transmute(crate::AzGl_getFragDataIndex(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(name),
            ))
        }
    }
    fn blend_barrier_khr(&self) -> () {
        unsafe { mem::transmute(crate::AzGl_blendBarrierKhr(mem::transmute(self))) }
    }
    fn bind_frag_data_location_indexed(
        &self,
        program: u32,
        color_number: u32,
        index: u32,
        name: &str,
    ) -> () {
        let name = pystring_to_refstr(&name);
        unsafe {
            mem::transmute(crate::AzGl_bindFragDataLocationIndexed(
                mem::transmute(self),
                mem::transmute(program),
                mem::transmute(color_number),
                mem::transmute(index),
                mem::transmute(name),
            ))
        }
    }
    fn get_debug_messages(&self) -> AzDebugMessageVec {
        unsafe { mem::transmute(crate::AzGl_getDebugMessages(mem::transmute(self))) }
    }
    fn provoking_vertex_angle(&self, mode: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_provokingVertexAngle(
                mem::transmute(self),
                mem::transmute(mode),
            ))
        }
    }
    fn gen_vertex_arrays_apple(&self, n: i32) -> AzGLuintVec {
        unsafe {
            mem::transmute(crate::AzGl_genVertexArraysApple(
                mem::transmute(self),
                mem::transmute(n),
            ))
        }
    }
    fn bind_vertex_array_apple(&self, vao: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bindVertexArrayApple(
                mem::transmute(self),
                mem::transmute(vao),
            ))
        }
    }
    fn delete_vertex_arrays_apple(&self, vertex_arrays: Vec<u32>) -> () {
        let vertex_arrays = pylist_u32_to_rust(&vertex_arrays);
        unsafe {
            mem::transmute(crate::AzGl_deleteVertexArraysApple(
                mem::transmute(self),
                mem::transmute(vertex_arrays),
            ))
        }
    }
    fn copy_texture_chromium(
        &self,
        source_id: u32,
        source_level: i32,
        dest_target: u32,
        dest_id: u32,
        dest_level: i32,
        internal_format: i32,
        dest_type: u32,
        unpack_flip_y: u8,
        unpack_premultiply_alpha: u8,
        unpack_unmultiply_alpha: u8,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copyTextureChromium(
                mem::transmute(self),
                mem::transmute(source_id),
                mem::transmute(source_level),
                mem::transmute(dest_target),
                mem::transmute(dest_id),
                mem::transmute(dest_level),
                mem::transmute(internal_format),
                mem::transmute(dest_type),
                mem::transmute(unpack_flip_y),
                mem::transmute(unpack_premultiply_alpha),
                mem::transmute(unpack_unmultiply_alpha),
            ))
        }
    }
    fn copy_sub_texture_chromium(
        &self,
        source_id: u32,
        source_level: i32,
        dest_target: u32,
        dest_id: u32,
        dest_level: i32,
        x_offset: i32,
        y_offset: i32,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
        unpack_flip_y: u8,
        unpack_premultiply_alpha: u8,
        unpack_unmultiply_alpha: u8,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copySubTextureChromium(
                mem::transmute(self),
                mem::transmute(source_id),
                mem::transmute(source_level),
                mem::transmute(dest_target),
                mem::transmute(dest_id),
                mem::transmute(dest_level),
                mem::transmute(x_offset),
                mem::transmute(y_offset),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(unpack_flip_y),
                mem::transmute(unpack_premultiply_alpha),
                mem::transmute(unpack_unmultiply_alpha),
            ))
        }
    }
    fn egl_image_target_renderbuffer_storage_oes(
        &self,
        target: u32,
        image: AzGlVoidPtrConst,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_eglImageTargetRenderbufferStorageOes(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(image),
            ))
        }
    }
    fn copy_texture_3d_angle(
        &self,
        source_id: u32,
        source_level: i32,
        dest_target: u32,
        dest_id: u32,
        dest_level: i32,
        internal_format: i32,
        dest_type: u32,
        unpack_flip_y: u8,
        unpack_premultiply_alpha: u8,
        unpack_unmultiply_alpha: u8,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copyTexture3DAngle(
                mem::transmute(self),
                mem::transmute(source_id),
                mem::transmute(source_level),
                mem::transmute(dest_target),
                mem::transmute(dest_id),
                mem::transmute(dest_level),
                mem::transmute(internal_format),
                mem::transmute(dest_type),
                mem::transmute(unpack_flip_y),
                mem::transmute(unpack_premultiply_alpha),
                mem::transmute(unpack_unmultiply_alpha),
            ))
        }
    }
    fn copy_sub_texture_3d_angle(
        &self,
        source_id: u32,
        source_level: i32,
        dest_target: u32,
        dest_id: u32,
        dest_level: i32,
        x_offset: i32,
        y_offset: i32,
        z_offset: i32,
        x: i32,
        y: i32,
        z: i32,
        width: i32,
        height: i32,
        depth: i32,
        unpack_flip_y: u8,
        unpack_premultiply_alpha: u8,
        unpack_unmultiply_alpha: u8,
    ) -> () {
        unsafe {
            mem::transmute(crate::AzGl_copySubTexture3DAngle(
                mem::transmute(self),
                mem::transmute(source_id),
                mem::transmute(source_level),
                mem::transmute(dest_target),
                mem::transmute(dest_id),
                mem::transmute(dest_level),
                mem::transmute(x_offset),
                mem::transmute(y_offset),
                mem::transmute(z_offset),
                mem::transmute(x),
                mem::transmute(y),
                mem::transmute(z),
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(depth),
                mem::transmute(unpack_flip_y),
                mem::transmute(unpack_premultiply_alpha),
                mem::transmute(unpack_unmultiply_alpha),
            ))
        }
    }
    fn buffer_storage(&self, target: u32, size: isize, data: AzGlVoidPtrConst, flags: u32) -> () {
        unsafe {
            mem::transmute(crate::AzGl_bufferStorage(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(size),
                mem::transmute(data),
                mem::transmute(flags),
            ))
        }
    }
    fn flush_mapped_buffer_range(&self, target: u32, offset: isize, length: isize) -> () {
        unsafe {
            mem::transmute(crate::AzGl_flushMappedBufferRange(
                mem::transmute(self),
                mem::transmute(target),
                mem::transmute(offset),
                mem::transmute(length),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGl {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlContextPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlShaderPrecisionFormatReturn {
    #[new]
    fn __new__(_0: i32, _1: i32, _2: i32) -> Self {
        Self { _0, _1, _2 }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGlShaderPrecisionFormatReturn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GlShaderPrecisionFormatReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeTypeEnumWrapper {
    #[classattr]
    fn Float() -> AzVertexAttributeTypeEnumWrapper {
        AzVertexAttributeTypeEnumWrapper {
            inner: AzVertexAttributeType::Float,
        }
    }
    #[classattr]
    fn Double() -> AzVertexAttributeTypeEnumWrapper {
        AzVertexAttributeTypeEnumWrapper {
            inner: AzVertexAttributeType::Double,
        }
    }
    #[classattr]
    fn UnsignedByte() -> AzVertexAttributeTypeEnumWrapper {
        AzVertexAttributeTypeEnumWrapper {
            inner: AzVertexAttributeType::UnsignedByte,
        }
    }
    #[classattr]
    fn UnsignedShort() -> AzVertexAttributeTypeEnumWrapper {
        AzVertexAttributeTypeEnumWrapper {
            inner: AzVertexAttributeType::UnsignedShort,
        }
    }
    #[classattr]
    fn UnsignedInt() -> AzVertexAttributeTypeEnumWrapper {
        AzVertexAttributeTypeEnumWrapper {
            inner: AzVertexAttributeType::UnsignedInt,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttributeType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzVertexAttributeTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzVertexAttribute {
    #[new]
    fn __new__(
        name: AzString,
        layout_location: AzOptionUsizeEnumWrapper,
        attribute_type: AzVertexAttributeTypeEnumWrapper,
        item_count: usize,
    ) -> Self {
        Self {
            name,
            layout_location,
            attribute_type,
            item_count,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttribute {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttribute = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexLayout {
    #[new]
    fn __new__(fields: AzVertexAttributeVec) -> Self {
        Self { fields }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexLayout {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexLayout = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexArrayObject {
    #[new]
    fn new(vertex_layout: AzVertexLayout, vao_id: u32, gl_context: AzGl) -> AzVertexArrayObject {
        unsafe {
            mem::transmute(crate::AzVertexArrayObject_new(
                mem::transmute(vertex_layout),
                mem::transmute(vao_id),
                mem::transmute(gl_context),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexArrayObject {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexArrayObject = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndexBufferFormatEnumWrapper {
    #[classattr]
    fn Points() -> AzIndexBufferFormatEnumWrapper {
        AzIndexBufferFormatEnumWrapper {
            inner: AzIndexBufferFormat::Points,
        }
    }
    #[classattr]
    fn Lines() -> AzIndexBufferFormatEnumWrapper {
        AzIndexBufferFormatEnumWrapper {
            inner: AzIndexBufferFormat::Lines,
        }
    }
    #[classattr]
    fn LineStrip() -> AzIndexBufferFormatEnumWrapper {
        AzIndexBufferFormatEnumWrapper {
            inner: AzIndexBufferFormat::LineStrip,
        }
    }
    #[classattr]
    fn Triangles() -> AzIndexBufferFormatEnumWrapper {
        AzIndexBufferFormatEnumWrapper {
            inner: AzIndexBufferFormat::Triangles,
        }
    }
    #[classattr]
    fn TriangleStrip() -> AzIndexBufferFormatEnumWrapper {
        AzIndexBufferFormatEnumWrapper {
            inner: AzIndexBufferFormat::TriangleStrip,
        }
    }
    #[classattr]
    fn TriangleFan() -> AzIndexBufferFormatEnumWrapper {
        AzIndexBufferFormatEnumWrapper {
            inner: AzIndexBufferFormat::TriangleFan,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIndexBufferFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::IndexBufferFormat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzIndexBufferFormatEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzVertexBuffer {
    #[new]
    fn new(
        vertex_buffer_id: u32,
        vertex_buffer_len: usize,
        vao: AzVertexArrayObject,
        index_buffer_id: u32,
        index_buffer_len: usize,
        index_buffer_format: AzIndexBufferFormatEnumWrapper,
    ) -> AzVertexBuffer {
        unsafe {
            mem::transmute(crate::AzVertexBuffer_new(
                mem::transmute(vertex_buffer_id),
                mem::transmute(vertex_buffer_len),
                mem::transmute(vao),
                mem::transmute(index_buffer_id),
                mem::transmute(index_buffer_len),
                mem::transmute(index_buffer_format),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexBuffer {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexBuffer = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGlTypeEnumWrapper {
    #[classattr]
    fn Gl() -> AzGlTypeEnumWrapper {
        AzGlTypeEnumWrapper {
            inner: AzGlType::Gl,
        }
    }
    #[classattr]
    fn Gles() -> AzGlTypeEnumWrapper {
        AzGlTypeEnumWrapper {
            inner: AzGlType::Gles,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGlTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzGlType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzGlType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzGlTypeEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzDebugMessage {
    #[new]
    fn __new__(message: AzString, source: u32, ty: u32, id: u32, severity: u32) -> Self {
        Self {
            message,
            source,
            ty,
            id,
            severity,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDebugMessage {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzDebugMessage = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzDebugMessage = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecRef {}

#[pyproto]
impl PyObjectProtocol for AzU8VecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::U8VecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecRefMut {}

#[pyproto]
impl PyObjectProtocol for AzU8VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::U8VecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecRef {}

#[pyproto]
impl PyObjectProtocol for AzF32VecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::F32VecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzI32VecRef {}

#[pyproto]
impl PyObjectProtocol for AzI32VecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::I32VecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecRef {}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLuintVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLenumVecRef {}

#[pyproto]
impl PyObjectProtocol for AzGLenumVecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLenumVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecRefMut {}

#[pyproto]
impl PyObjectProtocol for AzGLintVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLintVecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLint64VecRefMut {}

#[pyproto]
impl PyObjectProtocol for AzGLint64VecRefMut {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLint64VecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLbooleanVecRefMut {}

#[pyproto]
impl PyObjectProtocol for AzGLbooleanVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLbooleanVecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLfloatVecRefMut {}

#[pyproto]
impl PyObjectProtocol for AzGLfloatVecRefMut {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLfloatVecRefMut = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstrVecRef {}

#[pyproto]
impl PyObjectProtocol for AzRefstrVecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::RefstrVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRefstr {}

#[pyproto]
impl PyObjectProtocol for AzRefstr {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::Refstr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::Refstr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetProgramBinaryReturn {
    #[new]
    fn __new__(_0: AzU8Vec, _1: u32) -> Self {
        Self { _0, _1 }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGetProgramBinaryReturn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GetProgramBinaryReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveAttribReturn {
    #[new]
    fn __new__(_0: i32, _1: u32, _2: AzString) -> Self {
        Self { _0, _1, _2 }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGetActiveAttribReturn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GetActiveAttribReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLsyncPtr {}

#[pyproto]
impl PyObjectProtocol for AzGLsyncPtr {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLsyncPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetActiveUniformReturn {
    #[new]
    fn __new__(_0: i32, _1: u32, _2: AzString) -> Self {
        Self { _0, _1, _2 }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGetActiveUniformReturn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GetActiveUniformReturn = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTextureFlags {
    #[staticmethod]
    fn default() -> AzTextureFlags {
        unsafe { mem::transmute(crate::AzTextureFlags_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextureFlags {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::TextureFlags = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageRef {
    #[staticmethod]
    fn null_image(
        width: usize,
        height: usize,
        format: AzRawImageFormatEnumWrapper,
        tag: Vec<u8>,
    ) -> AzImageRef {
        let tag = pyvecu8_to_vecu8(&tag);
        unsafe {
            mem::transmute(crate::AzImageRef_nullImage(
                mem::transmute(width),
                mem::transmute(height),
                mem::transmute(format),
                mem::transmute(tag),
            ))
        }
    }
    #[staticmethod]
    fn raw_image(data: AzRawImage) -> Option<AzImageRef> {
        let m: AzOptionImageRef =
            unsafe { mem::transmute(crate::AzImageRef_rawImage(mem::transmute(data))) };
        match m {
            AzOptionImageRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionImageRef::None => None,
        }
    }
    #[staticmethod]
    fn gl_texture(texture: AzTexture) -> AzImageRef {
        unsafe { mem::transmute(crate::AzImageRef_glTexture(mem::transmute(texture))) }
    }
    fn clone_bytes(&self) -> AzImageRef {
        unsafe { mem::transmute(crate::AzImageRef_cloneBytes(mem::transmute(self))) }
    }
    fn is_invalid(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isInvalid(mem::transmute(self))) }
    }
    fn is_gl_texture(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isGlTexture(mem::transmute(self))) }
    }
    fn is_raw_image(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isRawImage(mem::transmute(self))) }
    }
    fn is_callback(&self) -> bool {
        unsafe { mem::transmute(crate::AzImageRef_isCallback(mem::transmute(self))) }
    }
    fn get_raw_image(&self) -> Option<AzRawImage> {
        let m: AzOptionRawImage =
            unsafe { mem::transmute(crate::AzImageRef_getRawImage(mem::transmute(self))) };
        match m {
            AzOptionRawImage::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionRawImage::None => None,
        }
    }
    fn get_hash(&self) -> u64 {
        unsafe { mem::transmute(crate::AzImageRef_getHash(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImageRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::ImageRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImage {
    #[staticmethod]
    fn empty() -> AzRawImage {
        unsafe { mem::transmute(crate::AzRawImage_empty()) }
    }
    #[staticmethod]
    fn allocate_clip_mask(size: AzLayoutSize) -> AzRawImage {
        unsafe { mem::transmute(crate::AzRawImage_allocateClipMask(mem::transmute(size))) }
    }
    #[staticmethod]
    fn decode_image_bytes_any(bytes: Vec<u8>) -> Result<AzRawImage, PyErr> {
        let bytes = pybytesref_to_vecu8_ref(&bytes);
        let m: AzResultRawImageDecodeImageError =
            unsafe { mem::transmute(crate::AzRawImage_decodeImageBytesAny(mem::transmute(bytes))) };
        match m {
            AzResultRawImageDecodeImageError::Ok(o) => Ok(o.into()),
            AzResultRawImageDecodeImageError::Err(e) => Err(e.into()),
        }
    }
    fn draw_clip_mask(&mut self, node: AzSvgNodeEnumWrapper, style: AzSvgStyleEnumWrapper) -> bool {
        unsafe {
            mem::transmute(crate::AzRawImage_drawClipMask(
                mem::transmute(self),
                mem::transmute(node),
                mem::transmute(style),
            ))
        }
    }
    fn encode_bmp(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError =
            unsafe { mem::transmute(crate::AzRawImage_encodeBmp(mem::transmute(self))) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }
    }
    fn encode_png(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError =
            unsafe { mem::transmute(crate::AzRawImage_encodePng(mem::transmute(self))) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }
    }
    fn encode_jpeg(&self, quality: u8) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError = unsafe {
            mem::transmute(crate::AzRawImage_encodeJpeg(
                mem::transmute(self),
                mem::transmute(quality),
            ))
        };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }
    }
    fn encode_tga(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError =
            unsafe { mem::transmute(crate::AzRawImage_encodeTga(mem::transmute(self))) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }
    }
    fn encode_pnm(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError =
            unsafe { mem::transmute(crate::AzRawImage_encodePnm(mem::transmute(self))) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }
    }
    fn encode_gif(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError =
            unsafe { mem::transmute(crate::AzRawImage_encodeGif(mem::transmute(self))) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }
    }
    fn encode_tiff(&self) -> Result<Vec<u8>, PyErr> {
        let m: AzResultU8VecEncodeImageError =
            unsafe { mem::transmute(crate::AzRawImage_encodeTiff(mem::transmute(self))) };
        match m {
            AzResultU8VecEncodeImageError::Ok(o) => Ok(o.into()),
            AzResultU8VecEncodeImageError::Err(e) => Err(e.into()),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImage {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::RawImage = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::RawImage = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzImageMask {
    #[new]
    fn __new__(image: AzImageRef, rect: AzLogicalRect, repeat: bool) -> Self {
        Self {
            image,
            rect,
            repeat,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImageMask {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::ImageMask = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzRawImageFormatEnumWrapper {
    #[classattr]
    fn R8() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::R8,
        }
    }
    #[classattr]
    fn RG8() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::RG8,
        }
    }
    #[classattr]
    fn RGB8() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::RGB8,
        }
    }
    #[classattr]
    fn RGBA8() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::RGBA8,
        }
    }
    #[classattr]
    fn R16() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::R16,
        }
    }
    #[classattr]
    fn RG16() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::RG16,
        }
    }
    #[classattr]
    fn RGB16() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::RGB16,
        }
    }
    #[classattr]
    fn RGBA16() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::RGBA16,
        }
    }
    #[classattr]
    fn BGR8() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::BGR8,
        }
    }
    #[classattr]
    fn BGRA8() -> AzRawImageFormatEnumWrapper {
        AzRawImageFormatEnumWrapper {
            inner: AzRawImageFormat::BGRA8,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImageFormatEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::RawImageFormat = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzRawImageFormatEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzEncodeImageErrorEnumWrapper {
    #[classattr]
    fn EncoderNotAvailable() -> AzEncodeImageErrorEnumWrapper {
        AzEncodeImageErrorEnumWrapper {
            inner: AzEncodeImageError::EncoderNotAvailable,
        }
    }
    #[classattr]
    fn InsufficientMemory() -> AzEncodeImageErrorEnumWrapper {
        AzEncodeImageErrorEnumWrapper {
            inner: AzEncodeImageError::InsufficientMemory,
        }
    }
    #[classattr]
    fn DimensionError() -> AzEncodeImageErrorEnumWrapper {
        AzEncodeImageErrorEnumWrapper {
            inner: AzEncodeImageError::DimensionError,
        }
    }
    #[classattr]
    fn InvalidData() -> AzEncodeImageErrorEnumWrapper {
        AzEncodeImageErrorEnumWrapper {
            inner: AzEncodeImageError::InvalidData,
        }
    }
    #[classattr]
    fn Unknown() -> AzEncodeImageErrorEnumWrapper {
        AzEncodeImageErrorEnumWrapper {
            inner: AzEncodeImageError::Unknown,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::encode::EncodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::encode::EncodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzEncodeImageErrorEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzDecodeImageErrorEnumWrapper {
    #[classattr]
    fn InsufficientMemory() -> AzDecodeImageErrorEnumWrapper {
        AzDecodeImageErrorEnumWrapper {
            inner: AzDecodeImageError::InsufficientMemory,
        }
    }
    #[classattr]
    fn DimensionError() -> AzDecodeImageErrorEnumWrapper {
        AzDecodeImageErrorEnumWrapper {
            inner: AzDecodeImageError::DimensionError,
        }
    }
    #[classattr]
    fn UnsupportedImageFormat() -> AzDecodeImageErrorEnumWrapper {
        AzDecodeImageErrorEnumWrapper {
            inner: AzDecodeImageError::UnsupportedImageFormat,
        }
    }
    #[classattr]
    fn Unknown() -> AzDecodeImageErrorEnumWrapper {
        AzDecodeImageErrorEnumWrapper {
            inner: AzDecodeImageError::Unknown,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::decode::DecodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::decode::DecodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzDecodeImageErrorEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzRawImageDataEnumWrapper {
    #[staticmethod]
    fn U8(v: AzU8Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper {
            inner: AzRawImageData::U8(v),
        }
    }
    #[staticmethod]
    fn U16(v: AzU16Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper {
            inner: AzRawImageData::U16(v),
        }
    }
    #[staticmethod]
    fn F32(v: AzF32Vec) -> AzRawImageDataEnumWrapper {
        AzRawImageDataEnumWrapper {
            inner: AzRawImageData::F32(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzRawImageData;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzRawImageData::U8(v) => Ok(vec!["U8".into_py(py), v.clone().into_py(py)]),
            AzRawImageData::U16(v) => Ok(vec!["U16".into_py(py), v.clone().into_py(py)]),
            AzRawImageData::F32(v) => Ok(vec!["F32".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzRawImageDataEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::RawImageData = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontMetrics {
    #[staticmethod]
    fn zero() -> AzFontMetrics {
        unsafe { mem::transmute(crate::AzFontMetrics_zero()) }
    }
    fn use_typo_metrics(&self) -> bool {
        unsafe { mem::transmute(crate::AzFontMetrics_useTypoMetrics(mem::transmute(self))) }
    }
    fn get_ascender(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getAscender(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_descender(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getDescender(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_line_gap(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getLineGap(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_x_min(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getXMin(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_min(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYMin(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_x_max(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getXMax(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_max(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYMax(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_advance_width_max(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getAdvanceWidthMax(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_min_left_side_bearing(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getMinLeftSideBearing(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_min_right_side_bearing(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getMinRightSideBearing(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_x_max_extent(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getXMaxExtent(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_x_avg_char_width(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getXAvgCharWidth(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_subscript_x_size(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSubscriptXSize(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_subscript_y_size(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSubscriptYSize(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_subscript_x_offset(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSubscriptXOffset(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_subscript_y_offset(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSubscriptYOffset(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_superscript_x_size(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSuperscriptXSize(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_superscript_y_size(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSuperscriptYSize(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_superscript_x_offset(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSuperscriptXOffset(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_superscript_y_offset(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYSuperscriptYOffset(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_strikeout_size(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYStrikeoutSize(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
    fn get_y_strikeout_position(&self, target_font_size: f32) -> f32 {
        unsafe {
            mem::transmute(crate::AzFontMetrics_getYStrikeoutPosition(
                mem::transmute(self),
                mem::transmute(target_font_size),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFontMetrics {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::FontMetrics = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::FontMetrics = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontSource {
    #[new]
    fn __new__(data: AzU8Vec, font_index: u32, parse_glyph_outlines: bool) -> Self {
        Self {
            data,
            font_index,
            parse_glyph_outlines,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFontSource {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::LoadedFontSource = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFontRef {
    #[staticmethod]
    fn parse(source: AzFontSource) -> Option<AzFontRef> {
        let m: AzOptionFontRef =
            unsafe { mem::transmute(crate::AzFontRef_parse(mem::transmute(source))) };
        match m {
            AzOptionFontRef::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFontRef::None => None,
        }
    }
    fn get_bytes(&self) -> Vec<u8> {
        az_vecu8_to_py_vecu8(unsafe {
            mem::transmute(crate::AzFontRef_getBytes(mem::transmute(self)))
        })
    }
    fn get_font_metrics(&self) -> AzFontMetrics {
        unsafe { mem::transmute(crate::AzFontRef_getFontMetrics(mem::transmute(self))) }
    }
    fn shape_text(&self, text: &str, options: AzResolvedTextLayoutOptions) -> AzInlineText {
        let text = pystring_to_refstr(&text);
        unsafe {
            mem::transmute(crate::AzFontRef_shapeText(
                mem::transmute(self),
                mem::transmute(text),
                mem::transmute(options),
            ))
        }
    }
    fn get_hash(&self) -> u64 {
        unsafe { mem::transmute(crate::AzFontRef_getHash(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFontRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::FontRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::FontRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvg {
    #[staticmethod]
    fn from_string(svg_string: String, parse_options: AzSvgParseOptions) -> Result<AzSvg, PyErr> {
        let svg_string = pystring_to_azstring(&svg_string);
        let m: AzResultSvgSvgParseError = unsafe {
            mem::transmute(crate::AzSvg_fromString(
                mem::transmute(svg_string),
                mem::transmute(parse_options),
            ))
        };
        match m {
            AzResultSvgSvgParseError::Ok(o) => Ok(o.into()),
            AzResultSvgSvgParseError::Err(e) => Err(e.into()),
        }
    }
    #[staticmethod]
    fn from_bytes(svg_bytes: Vec<u8>, parse_options: AzSvgParseOptions) -> Result<AzSvg, PyErr> {
        let svg_bytes = pybytesref_to_vecu8_ref(&svg_bytes);
        let m: AzResultSvgSvgParseError = unsafe {
            mem::transmute(crate::AzSvg_fromBytes(
                mem::transmute(svg_bytes),
                mem::transmute(parse_options),
            ))
        };
        match m {
            AzResultSvgSvgParseError::Ok(o) => Ok(o.into()),
            AzResultSvgSvgParseError::Err(e) => Err(e.into()),
        }
    }
    fn get_root(&self) -> AzSvgXmlNode {
        unsafe { mem::transmute(crate::AzSvg_getRoot(mem::transmute(self))) }
    }
    fn render(&self, options: AzSvgRenderOptions) -> Option<AzRawImage> {
        let m: AzOptionRawImage = unsafe {
            mem::transmute(crate::AzSvg_render(
                mem::transmute(self),
                mem::transmute(options),
            ))
        };
        match m {
            AzOptionRawImage::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionRawImage::None => None,
        }
    }
    fn to_string(&self, options: AzSvgStringFormatOptions) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzSvg_toString(
                mem::transmute(self),
                mem::transmute(options),
            ))
        })
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvg {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::Svg = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::Svg = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgXmlNode {
    #[staticmethod]
    fn parse_from(
        svg_bytes: Vec<u8>,
        parse_options: AzSvgParseOptions,
    ) -> Result<AzSvgXmlNode, PyErr> {
        let svg_bytes = pybytesref_to_vecu8_ref(&svg_bytes);
        let m: AzResultSvgXmlNodeSvgParseError = unsafe {
            mem::transmute(crate::AzSvgXmlNode_parseFrom(
                mem::transmute(svg_bytes),
                mem::transmute(parse_options),
            ))
        };
        match m {
            AzResultSvgXmlNodeSvgParseError::Ok(o) => Ok(o.into()),
            AzResultSvgXmlNodeSvgParseError::Err(e) => Err(e.into()),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgXmlNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgXmlNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgXmlNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygon {
    #[new]
    fn __new__(rings: AzSvgPathVec) -> Self {
        Self { rings }
    }

    fn get_bounds(&self) -> AzSvgRect {
        unsafe { mem::transmute(crate::AzSvgMultiPolygon_getBounds(mem::transmute(self))) }
    }
    fn contains_point(
        &self,
        point: AzSvgPoint,
        fill_rule: AzSvgFillRuleEnumWrapper,
        tolerance: f32,
    ) -> bool {
        unsafe {
            mem::transmute(crate::AzSvgMultiPolygon_containsPoint(
                mem::transmute(self),
                mem::transmute(point),
                mem::transmute(fill_rule),
                mem::transmute(tolerance),
            ))
        }
    }
    fn union(&self, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon {
        unsafe {
            mem::transmute(crate::AzSvgMultiPolygon_union(
                mem::transmute(self),
                mem::transmute(other),
            ))
        }
    }
    fn intersection(&self, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon {
        unsafe {
            mem::transmute(crate::AzSvgMultiPolygon_intersection(
                mem::transmute(self),
                mem::transmute(other),
            ))
        }
    }
    fn difference(&self, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon {
        unsafe {
            mem::transmute(crate::AzSvgMultiPolygon_difference(
                mem::transmute(self),
                mem::transmute(other),
            ))
        }
    }
    fn xor(&self, other: AzSvgMultiPolygon) -> AzSvgMultiPolygon {
        unsafe {
            mem::transmute(crate::AzSvgMultiPolygon_xor(
                mem::transmute(self),
                mem::transmute(other),
            ))
        }
    }
    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgMultiPolygon_tessellateFill(
                mem::transmute(self),
                mem::transmute(fill_style),
            ))
        }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgMultiPolygon_tessellateStroke(
                mem::transmute(self),
                mem::transmute(stroke_style),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygon {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgMultiPolygon = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgMultiPolygon = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgNodeEnumWrapper {
    #[staticmethod]
    fn MultiPolygonCollection(v: AzSvgMultiPolygonVec) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper {
            inner: AzSvgNode::MultiPolygonCollection(v),
        }
    }
    #[staticmethod]
    fn MultiPolygon(v: AzSvgMultiPolygon) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper {
            inner: AzSvgNode::MultiPolygon(v),
        }
    }
    #[staticmethod]
    fn MultiShape(v: AzSvgSimpleNodeVec) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper {
            inner: AzSvgNode::MultiShape(v),
        }
    }
    #[staticmethod]
    fn Path(v: AzSvgPath) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper {
            inner: AzSvgNode::Path(v),
        }
    }
    #[staticmethod]
    fn Circle(v: AzSvgCircle) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper {
            inner: AzSvgNode::Circle(v),
        }
    }
    #[staticmethod]
    fn Rect(v: AzSvgRect) -> AzSvgNodeEnumWrapper {
        AzSvgNodeEnumWrapper {
            inner: AzSvgNode::Rect(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgNode;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgNode::MultiPolygonCollection(v) => Ok(vec![
                "MultiPolygonCollection".into_py(py),
                v.clone().into_py(py),
            ]),
            AzSvgNode::MultiPolygon(v) => {
                Ok(vec!["MultiPolygon".into_py(py), v.clone().into_py(py)])
            }
            AzSvgNode::MultiShape(v) => Ok(vec!["MultiShape".into_py(py), v.clone().into_py(py)]),
            AzSvgNode::Path(v) => Ok(vec!["Path".into_py(py), v.clone().into_py(py)]),
            AzSvgNode::Circle(v) => Ok(vec!["Circle".into_py(py), v.clone().into_py(py)]),
            AzSvgNode::Rect(v) => Ok(vec!["Rect".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgNodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgNode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgNode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeEnumWrapper {
    #[staticmethod]
    fn Path(v: AzSvgPath) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper {
            inner: AzSvgSimpleNode::Path(v),
        }
    }
    #[staticmethod]
    fn Circle(v: AzSvgCircle) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper {
            inner: AzSvgSimpleNode::Circle(v),
        }
    }
    #[staticmethod]
    fn Rect(v: AzSvgRect) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper {
            inner: AzSvgSimpleNode::Rect(v),
        }
    }
    #[staticmethod]
    fn CircleHole(v: AzSvgCircle) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper {
            inner: AzSvgSimpleNode::CircleHole(v),
        }
    }
    #[staticmethod]
    fn RectHole(v: AzSvgRect) -> AzSvgSimpleNodeEnumWrapper {
        AzSvgSimpleNodeEnumWrapper {
            inner: AzSvgSimpleNode::RectHole(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgSimpleNode;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgSimpleNode::Path(v) => Ok(vec!["Path".into_py(py), v.clone().into_py(py)]),
            AzSvgSimpleNode::Circle(v) => Ok(vec!["Circle".into_py(py), v.clone().into_py(py)]),
            AzSvgSimpleNode::Rect(v) => Ok(vec!["Rect".into_py(py), v.clone().into_py(py)]),
            AzSvgSimpleNode::CircleHole(v) => {
                Ok(vec!["CircleHole".into_py(py), v.clone().into_py(py)])
            }
            AzSvgSimpleNode::RectHole(v) => Ok(vec!["RectHole".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgSimpleNode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStyledNode {
    #[new]
    fn __new__(geometry: AzSvgNodeEnumWrapper, style: AzSvgStyleEnumWrapper) -> Self {
        Self { geometry, style }
    }

    fn tessellate(&self) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzSvgStyledNode_tessellate(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStyledNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgStyledNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgStyledNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCircle {
    #[new]
    fn __new__(center_x: f32, center_y: f32, radius: f32) -> Self {
        Self {
            center_x,
            center_y,
            radius,
        }
    }

    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgCircle_tessellateFill(
                mem::transmute(self),
                mem::transmute(fill_style),
            ))
        }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgCircle_tessellateStroke(
                mem::transmute(self),
                mem::transmute(stroke_style),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgCircle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgCircle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgCircle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPath {
    #[new]
    fn __new__(items: AzSvgPathElementVec) -> Self {
        Self { items }
    }

    fn is_closed(&self) -> bool {
        unsafe { mem::transmute(crate::AzSvgPath_isClosed(mem::transmute(self))) }
    }
    fn reverse(&mut self) -> () {
        unsafe { mem::transmute(crate::AzSvgPath_reverse(mem::transmute(self))) }
    }
    fn get_start(&self) -> Option<AzSvgPoint> {
        let m: AzOptionSvgPoint =
            unsafe { mem::transmute(crate::AzSvgPath_getStart(mem::transmute(self))) };
        match m {
            AzOptionSvgPoint::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionSvgPoint::None => None,
        }
    }
    fn get_end(&self) -> Option<AzSvgPoint> {
        let m: AzOptionSvgPoint =
            unsafe { mem::transmute(crate::AzSvgPath_getEnd(mem::transmute(self))) };
        match m {
            AzOptionSvgPoint::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionSvgPoint::None => None,
        }
    }
    fn get_bounds(&mut self) -> AzSvgRect {
        unsafe { mem::transmute(crate::AzSvgPath_getBounds(mem::transmute(self))) }
    }
    fn join_with(&mut self, path: AzSvgPath) -> () {
        unsafe {
            mem::transmute(crate::AzSvgPath_joinWith(
                mem::transmute(self),
                mem::transmute(path),
            ))
        }
    }
    fn offset(
        &mut self,
        distance: f32,
        join: AzSvgLineJoinEnumWrapper,
        cap: AzSvgLineCapEnumWrapper,
    ) -> AzSvgPath {
        unsafe {
            mem::transmute(crate::AzSvgPath_offset(
                mem::transmute(self),
                mem::transmute(distance),
                mem::transmute(join),
                mem::transmute(cap),
            ))
        }
    }
    fn bevel(&mut self, distance: f32) -> AzSvgPath {
        unsafe {
            mem::transmute(crate::AzSvgPath_bevel(
                mem::transmute(self),
                mem::transmute(distance),
            ))
        }
    }
    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgPath_tessellateFill(
                mem::transmute(self),
                mem::transmute(fill_style),
            ))
        }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgPath_tessellateStroke(
                mem::transmute(self),
                mem::transmute(stroke_style),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPath {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPath = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPath = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementEnumWrapper {
    #[staticmethod]
    fn Line(v: AzSvgLine) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper {
            inner: AzSvgPathElement::Line(v),
        }
    }
    #[staticmethod]
    fn QuadraticCurve(v: AzSvgQuadraticCurve) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper {
            inner: AzSvgPathElement::QuadraticCurve(v),
        }
    }
    #[staticmethod]
    fn CubicCurve(v: AzSvgCubicCurve) -> AzSvgPathElementEnumWrapper {
        AzSvgPathElementEnumWrapper {
            inner: AzSvgPathElement::CubicCurve(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgPathElement;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElement::Line(v) => Ok(vec!["Line".into_py(py), v.clone().into_py(py)]),
            AzSvgPathElement::QuadraticCurve(v) => {
                Ok(vec!["QuadraticCurve".into_py(py), v.clone().into_py(py)])
            }
            AzSvgPathElement::CubicCurve(v) => {
                Ok(vec!["CubicCurve".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathElement = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPoint {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self { x, y }
    }

    fn distance(&self, other: AzSvgPoint) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgPoint_distance(
                mem::transmute(self),
                mem::transmute(other),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPoint {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPoint = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPoint = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVector {
    #[new]
    fn __new__(x: f64, y: f64) -> Self {
        Self { x, y }
    }

    fn angle_degrees(&self) -> f64 {
        unsafe { mem::transmute(crate::AzSvgVector_angleDegrees(mem::transmute(self))) }
    }
    fn normalize(&self) -> AzSvgVector {
        unsafe { mem::transmute(crate::AzSvgVector_normalize(mem::transmute(self))) }
    }
    fn rotate_90deg_ccw(&self) -> AzSvgVector {
        unsafe { mem::transmute(crate::AzSvgVector_rotate90DegCcw(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgVector {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVector = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVector = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLine {
    #[new]
    fn __new__(start: AzSvgPoint, end: AzSvgPoint) -> Self {
        Self { start, end }
    }

    fn reverse(&mut self) -> () {
        unsafe { mem::transmute(crate::AzSvgLine_reverse(mem::transmute(self))) }
    }
    fn get_start(&self) -> AzSvgPoint {
        unsafe { mem::transmute(crate::AzSvgLine_getStart(mem::transmute(self))) }
    }
    fn get_end(&self) -> AzSvgPoint {
        unsafe { mem::transmute(crate::AzSvgLine_getEnd(mem::transmute(self))) }
    }
    fn get_bounds(&self) -> AzSvgRect {
        unsafe { mem::transmute(crate::AzSvgLine_getBounds(mem::transmute(self))) }
    }
    fn get_length(&self) -> f64 {
        unsafe { mem::transmute(crate::AzSvgLine_getLength(mem::transmute(self))) }
    }
    fn get_t_at_offset(&self, offset: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgLine_getTAtOffset(
                mem::transmute(self),
                mem::transmute(offset),
            ))
        }
    }
    fn get_x_at_t(&self, t: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgLine_getXAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn get_y_at_t(&self, t: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgLine_getYAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn get_tangent_vector_at_t(&self, t: f64) -> AzSvgVector {
        unsafe {
            mem::transmute(crate::AzSvgLine_getTangentVectorAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn intersect(&self, other: AzSvgLine) -> Option<AzSvgPoint> {
        let m: AzOptionSvgPoint = unsafe {
            mem::transmute(crate::AzSvgLine_intersect(
                mem::transmute(self),
                mem::transmute(other),
            ))
        };
        match m {
            AzOptionSvgPoint::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionSvgPoint::None => None,
        }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgLine_tessellateStroke(
                mem::transmute(self),
                mem::transmute(stroke_style),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgLine {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgLine = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgLine = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgQuadraticCurve {
    #[new]
    fn __new__(start: AzSvgPoint, ctrl: AzSvgPoint, end: AzSvgPoint) -> Self {
        Self { start, ctrl, end }
    }

    fn reverse(&mut self) -> () {
        unsafe { mem::transmute(crate::AzSvgQuadraticCurve_reverse(mem::transmute(self))) }
    }
    fn get_start(&self) -> AzSvgPoint {
        unsafe { mem::transmute(crate::AzSvgQuadraticCurve_getStart(mem::transmute(self))) }
    }
    fn get_end(&self) -> AzSvgPoint {
        unsafe { mem::transmute(crate::AzSvgQuadraticCurve_getEnd(mem::transmute(self))) }
    }
    fn get_bounds(&self) -> AzSvgRect {
        unsafe { mem::transmute(crate::AzSvgQuadraticCurve_getBounds(mem::transmute(self))) }
    }
    fn get_length(&self) -> f64 {
        unsafe { mem::transmute(crate::AzSvgQuadraticCurve_getLength(mem::transmute(self))) }
    }
    fn get_t_at_offset(&self, offset: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgQuadraticCurve_getTAtOffset(
                mem::transmute(self),
                mem::transmute(offset),
            ))
        }
    }
    fn get_x_at_t(&self, t: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgQuadraticCurve_getXAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn get_y_at_t(&self, t: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgQuadraticCurve_getYAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn get_tangent_vector_at_t(&self, t: f64) -> AzSvgVector {
        unsafe {
            mem::transmute(crate::AzSvgQuadraticCurve_getTangentVectorAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgQuadraticCurve_tessellateStroke(
                mem::transmute(self),
                mem::transmute(stroke_style),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgQuadraticCurve {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgQuadraticCurve = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgCubicCurve {
    #[new]
    fn __new__(start: AzSvgPoint, ctrl_1: AzSvgPoint, ctrl_2: AzSvgPoint, end: AzSvgPoint) -> Self {
        Self {
            start,
            ctrl_1,
            ctrl_2,
            end,
        }
    }

    fn reverse(&mut self) -> () {
        unsafe { mem::transmute(crate::AzSvgCubicCurve_reverse(mem::transmute(self))) }
    }
    fn get_start(&self) -> AzSvgPoint {
        unsafe { mem::transmute(crate::AzSvgCubicCurve_getStart(mem::transmute(self))) }
    }
    fn get_end(&self) -> AzSvgPoint {
        unsafe { mem::transmute(crate::AzSvgCubicCurve_getEnd(mem::transmute(self))) }
    }
    fn get_bounds(&self) -> AzSvgRect {
        unsafe { mem::transmute(crate::AzSvgCubicCurve_getBounds(mem::transmute(self))) }
    }
    fn get_length(&self) -> f64 {
        unsafe { mem::transmute(crate::AzSvgCubicCurve_getLength(mem::transmute(self))) }
    }
    fn get_t_at_offset(&self, offset: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgCubicCurve_getTAtOffset(
                mem::transmute(self),
                mem::transmute(offset),
            ))
        }
    }
    fn get_x_at_t(&self, t: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgCubicCurve_getXAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn get_y_at_t(&self, t: f64) -> f64 {
        unsafe {
            mem::transmute(crate::AzSvgCubicCurve_getYAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn get_tangent_vector_at_t(&self, t: f64) -> AzSvgVector {
        unsafe {
            mem::transmute(crate::AzSvgCubicCurve_getTangentVectorAtT(
                mem::transmute(self),
                mem::transmute(t),
            ))
        }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgCubicCurve_tessellateStroke(
                mem::transmute(self),
                mem::transmute(stroke_style),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgCubicCurve {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgCubicCurve = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgCubicCurve = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRect {
    #[new]
    fn __new__(
        width: f32,
        height: f32,
        x: f32,
        y: f32,
        radius_top_left: f32,
        radius_top_right: f32,
        radius_bottom_left: f32,
        radius_bottom_right: f32,
    ) -> Self {
        Self {
            width,
            height,
            x,
            y,
            radius_top_left,
            radius_top_right,
            radius_bottom_left,
            radius_bottom_right,
        }
    }

    fn get_center(&self) -> AzSvgPoint {
        unsafe { mem::transmute(crate::AzSvgRect_getCenter(mem::transmute(self))) }
    }
    fn contains_point(&self, point: AzSvgPoint) -> bool {
        unsafe {
            mem::transmute(crate::AzSvgRect_containsPoint(
                mem::transmute(self),
                mem::transmute(point),
            ))
        }
    }
    fn expand(
        &self,
        padding_top: f32,
        padding_bottom: f32,
        padding_left: f32,
        padding_right: f32,
    ) -> AzSvgRect {
        unsafe {
            mem::transmute(crate::AzSvgRect_expand(
                mem::transmute(self),
                mem::transmute(padding_top),
                mem::transmute(padding_bottom),
                mem::transmute(padding_left),
                mem::transmute(padding_right),
            ))
        }
    }
    fn tessellate_fill(&self, fill_style: AzSvgFillStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgRect_tessellateFill(
                mem::transmute(self),
                mem::transmute(fill_style),
            ))
        }
    }
    fn tessellate_stroke(&self, stroke_style: AzSvgStrokeStyle) -> AzTessellatedSvgNode {
        unsafe {
            mem::transmute(crate::AzSvgRect_tessellateStroke(
                mem::transmute(self),
                mem::transmute(stroke_style),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgRect {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgRect = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgRect = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgColoredVertex {
    #[new]
    fn __new__(x: f32, y: f32, z: f32, r: f32, g: f32, b: f32, a: f32) -> Self {
        Self {
            x,
            y,
            z,
            r,
            g,
            b,
            a,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgColoredVertex {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgColoredVertex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgColoredVertex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNode {
    #[staticmethod]
    fn empty() -> AzTessellatedColoredSvgNode {
        unsafe { mem::transmute(crate::AzTessellatedColoredSvgNode_empty()) }
    }
    #[staticmethod]
    fn from_nodes(nodes: AzTessellatedColoredSvgNodeVecRef) -> AzTessellatedColoredSvgNode {
        unsafe {
            mem::transmute(crate::AzTessellatedColoredSvgNode_fromNodes(
                mem::transmute(nodes),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNodeVecRef {}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNodeVecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredGPUSvgNode {}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredGPUSvgNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredGPUSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertex {
    #[new]
    fn __new__(x: f32, y: f32) -> Self {
        Self { x, y }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertex {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVertex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVertex = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNode {
    #[staticmethod]
    fn empty() -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzTessellatedSvgNode_empty()) }
    }
    #[staticmethod]
    fn from_nodes(nodes: AzTessellatedSvgNodeVecRef) -> AzTessellatedSvgNode {
        unsafe { mem::transmute(crate::AzTessellatedSvgNode_fromNodes(mem::transmute(nodes))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVecRef {}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVecRef {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNodeVecRef = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedGPUSvgNode {}

#[pyproto]
impl PyObjectProtocol for AzTessellatedGPUSvgNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedGPUSvgNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseOptions {
    #[staticmethod]
    fn default() -> AzSvgParseOptions {
        unsafe { mem::transmute(crate::AzSvgParseOptions_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgParseOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgParseOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzShapeRenderingEnumWrapper {
    #[classattr]
    fn OptimizeSpeed() -> AzShapeRenderingEnumWrapper {
        AzShapeRenderingEnumWrapper {
            inner: AzShapeRendering::OptimizeSpeed,
        }
    }
    #[classattr]
    fn CrispEdges() -> AzShapeRenderingEnumWrapper {
        AzShapeRenderingEnumWrapper {
            inner: AzShapeRendering::CrispEdges,
        }
    }
    #[classattr]
    fn GeometricPrecision() -> AzShapeRenderingEnumWrapper {
        AzShapeRenderingEnumWrapper {
            inner: AzShapeRendering::GeometricPrecision,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzShapeRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ShapeRendering = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzShapeRenderingEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzTextRenderingEnumWrapper {
    #[classattr]
    fn OptimizeSpeed() -> AzTextRenderingEnumWrapper {
        AzTextRenderingEnumWrapper {
            inner: AzTextRendering::OptimizeSpeed,
        }
    }
    #[classattr]
    fn OptimizeLegibility() -> AzTextRenderingEnumWrapper {
        AzTextRenderingEnumWrapper {
            inner: AzTextRendering::OptimizeLegibility,
        }
    }
    #[classattr]
    fn GeometricPrecision() -> AzTextRenderingEnumWrapper {
        AzTextRenderingEnumWrapper {
            inner: AzTextRendering::GeometricPrecision,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTextRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TextRendering = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzTextRenderingEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzImageRenderingEnumWrapper {
    #[classattr]
    fn OptimizeQuality() -> AzImageRenderingEnumWrapper {
        AzImageRenderingEnumWrapper {
            inner: AzImageRendering::OptimizeQuality,
        }
    }
    #[classattr]
    fn OptimizeSpeed() -> AzImageRenderingEnumWrapper {
        AzImageRenderingEnumWrapper {
            inner: AzImageRendering::OptimizeSpeed,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzImageRenderingEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ImageRendering = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzImageRenderingEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzFontDatabaseEnumWrapper {
    #[classattr]
    fn Empty() -> AzFontDatabaseEnumWrapper {
        AzFontDatabaseEnumWrapper {
            inner: AzFontDatabase::Empty,
        }
    }
    #[classattr]
    fn System() -> AzFontDatabaseEnumWrapper {
        AzFontDatabaseEnumWrapper {
            inner: AzFontDatabase::System,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFontDatabaseEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::FontDatabase = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzFontDatabaseEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzSvgRenderOptions {
    #[staticmethod]
    fn default() -> AzSvgRenderOptions {
        unsafe { mem::transmute(crate::AzSvgRenderOptions_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgRenderOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgRenderOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgRenderOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgRenderTransform {
    #[new]
    fn __new__(sx: f32, kx: f32, ky: f32, sy: f32, tx: f32, ty: f32) -> Self {
        Self {
            sx,
            kx,
            ky,
            sy,
            tx,
            ty,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgRenderTransform {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgRenderTransform = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgRenderTransform = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStringFormatOptions {
    #[new]
    fn __new__(
        use_single_quote: bool,
        indent: AzIndentEnumWrapper,
        attributes_indent: AzIndentEnumWrapper,
    ) -> Self {
        Self {
            use_single_quote,
            indent,
            attributes_indent,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStringFormatOptions {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgXmlOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgXmlOptions = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIndentEnumWrapper {
    #[classattr]
    fn None() -> AzIndentEnumWrapper {
        AzIndentEnumWrapper {
            inner: AzIndent::None,
        }
    }
    #[staticmethod]
    fn Spaces(v: u8) -> AzIndentEnumWrapper {
        AzIndentEnumWrapper {
            inner: AzIndent::Spaces(v),
        }
    }
    #[classattr]
    fn Tabs() -> AzIndentEnumWrapper {
        AzIndentEnumWrapper {
            inner: AzIndent::Tabs,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzIndent;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIndent::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzIndent::Spaces(v) => Ok(vec!["Spaces".into_py(py), v.into_py(py)]),
            AzIndent::Tabs => Ok(vec!["Tabs".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIndentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::Indent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFitToEnumWrapper {
    #[classattr]
    fn Original() -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper {
            inner: AzSvgFitTo::Original,
        }
    }
    #[staticmethod]
    fn Width(v: u32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper {
            inner: AzSvgFitTo::Width(v),
        }
    }
    #[staticmethod]
    fn Height(v: u32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper {
            inner: AzSvgFitTo::Height(v),
        }
    }
    #[staticmethod]
    fn Zoom(v: f32) -> AzSvgFitToEnumWrapper {
        AzSvgFitToEnumWrapper {
            inner: AzSvgFitTo::Zoom(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgFitTo;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgFitTo::Original => Ok(vec!["Original".into_py(py), ().into_py(py)]),
            AzSvgFitTo::Width(v) => Ok(vec!["Width".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Height(v) => Ok(vec!["Height".into_py(py), v.into_py(py)]),
            AzSvgFitTo::Zoom(v) => Ok(vec!["Zoom".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFitToEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgFitTo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStyleEnumWrapper {
    #[staticmethod]
    fn Fill(v: AzSvgFillStyle) -> AzSvgStyleEnumWrapper {
        AzSvgStyleEnumWrapper {
            inner: AzSvgStyle::Fill(v),
        }
    }
    #[staticmethod]
    fn Stroke(v: AzSvgStrokeStyle) -> AzSvgStyleEnumWrapper {
        AzSvgStyleEnumWrapper {
            inner: AzSvgStyle::Stroke(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgStyle;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgStyle::Fill(v) => Ok(vec!["Fill".into_py(py), v.clone().into_py(py)]),
            AzSvgStyle::Stroke(v) => Ok(vec!["Stroke".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStyleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgStyle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgStyle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFillRuleEnumWrapper {
    #[classattr]
    fn Winding() -> AzSvgFillRuleEnumWrapper {
        AzSvgFillRuleEnumWrapper {
            inner: AzSvgFillRule::Winding,
        }
    }
    #[classattr]
    fn EvenOdd() -> AzSvgFillRuleEnumWrapper {
        AzSvgFillRuleEnumWrapper {
            inner: AzSvgFillRule::EvenOdd,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFillRuleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgFillRule = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzSvgFillRuleEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzSvgTransform {
    #[new]
    fn __new__(sx: f32, kx: f32, ky: f32, sy: f32, tx: f32, ty: f32) -> Self {
        Self {
            sx,
            kx,
            ky,
            sy,
            tx,
            ty,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgTransform {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgTransform = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgTransform = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgFillStyle {
    #[staticmethod]
    fn default() -> AzSvgFillStyle {
        unsafe { mem::transmute(crate::AzSvgFillStyle_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgFillStyle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgFillStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgFillStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgStrokeStyle {
    #[staticmethod]
    fn default() -> AzSvgStrokeStyle {
        unsafe { mem::transmute(crate::AzSvgStrokeStyle_default()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgStrokeStyle {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgStrokeStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgStrokeStyle = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgLineJoinEnumWrapper {
    #[classattr]
    fn Miter() -> AzSvgLineJoinEnumWrapper {
        AzSvgLineJoinEnumWrapper {
            inner: AzSvgLineJoin::Miter,
        }
    }
    #[classattr]
    fn MiterClip() -> AzSvgLineJoinEnumWrapper {
        AzSvgLineJoinEnumWrapper {
            inner: AzSvgLineJoin::MiterClip,
        }
    }
    #[classattr]
    fn Round() -> AzSvgLineJoinEnumWrapper {
        AzSvgLineJoinEnumWrapper {
            inner: AzSvgLineJoin::Round,
        }
    }
    #[classattr]
    fn Bevel() -> AzSvgLineJoinEnumWrapper {
        AzSvgLineJoinEnumWrapper {
            inner: AzSvgLineJoin::Bevel,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineJoinEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgLineJoin = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzSvgLineJoinEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzSvgLineCapEnumWrapper {
    #[classattr]
    fn Butt() -> AzSvgLineCapEnumWrapper {
        AzSvgLineCapEnumWrapper {
            inner: AzSvgLineCap::Butt,
        }
    }
    #[classattr]
    fn Square() -> AzSvgLineCapEnumWrapper {
        AzSvgLineCapEnumWrapper {
            inner: AzSvgLineCap::Square,
        }
    }
    #[classattr]
    fn Round() -> AzSvgLineCapEnumWrapper {
        AzSvgLineCapEnumWrapper {
            inner: AzSvgLineCap::Round,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgLineCapEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgLineCap = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzSvgLineCapEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzSvgDashPattern {
    #[new]
    fn __new__(
        offset: f32,
        length_1: f32,
        gap_1: f32,
        length_2: f32,
        gap_2: f32,
        length_3: f32,
        gap_3: f32,
    ) -> Self {
        Self {
            offset,
            length_1,
            gap_1,
            length_2,
            gap_2,
            length_3,
            gap_3,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgDashPattern {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgDashPattern = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgDashPattern = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXml {
    #[staticmethod]
    fn from_str(xml_string: &str) -> Result<AzXml, PyErr> {
        let xml_string = pystring_to_refstr(&xml_string);
        let m: AzResultXmlXmlError =
            unsafe { mem::transmute(crate::AzXml_fromStr(mem::transmute(xml_string))) };
        match m {
            AzResultXmlXmlError::Ok(o) => Ok(o.into()),
            AzResultXmlXmlError::Err(e) => Err(e.into()),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXml {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::Xml = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::Xml = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNode {
    #[new]
    fn __new__(
        tag: AzString,
        attributes: AzStringPairVec,
        children: AzXmlNodeVec,
        text: AzOptionStringEnumWrapper,
    ) -> Self {
        Self {
            tag,
            attributes,
            children,
            text,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlNode {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlNode = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFile {
    #[staticmethod]
    fn open(path: String) -> Option<AzFile> {
        let path = pystring_to_azstring(&path);
        let m: AzOptionFile = unsafe { mem::transmute(crate::AzFile_open(mem::transmute(path))) };
        match m {
            AzOptionFile::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFile::None => None,
        }
    }
    #[staticmethod]
    fn create(path: String) -> Option<AzFile> {
        let path = pystring_to_azstring(&path);
        let m: AzOptionFile = unsafe { mem::transmute(crate::AzFile_create(mem::transmute(path))) };
        match m {
            AzOptionFile::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionFile::None => None,
        }
    }
    fn read_to_string(&mut self) -> Option<String> {
        let m: AzOptionString =
            unsafe { mem::transmute(crate::AzFile_readToString(mem::transmute(self))) };
        match m {
            AzOptionString::Some(s) => Some({
                let s: AzString = unsafe { mem::transmute(s) };
                s.into()
            }),
            AzOptionString::None => None,
        }
    }
    fn read_to_bytes(&mut self) -> Option<Vec<u8>> {
        let m: AzOptionU8Vec =
            unsafe { mem::transmute(crate::AzFile_readToBytes(mem::transmute(self))) };
        match m {
            AzOptionU8Vec::Some(s) => Some({
                let s: AzU8Vec = unsafe { mem::transmute(s) };
                s.into()
            }),
            AzOptionU8Vec::None => None,
        }
    }
    fn write_string(&mut self, bytes: &str) -> bool {
        let bytes = pystring_to_refstr(&bytes);
        unsafe {
            mem::transmute(crate::AzFile_writeString(
                mem::transmute(self),
                mem::transmute(bytes),
            ))
        }
    }
    fn write_bytes(&mut self, bytes: Vec<u8>) -> bool {
        let bytes = pybytesref_to_vecu8_ref(&bytes);
        unsafe {
            mem::transmute(crate::AzFile_writeBytes(
                mem::transmute(self),
                mem::transmute(bytes),
            ))
        }
    }
    fn close(&mut self) -> () {
        unsafe { mem::transmute(crate::AzFile_close(mem::transmute(self))) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFile {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::file::File = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::file::File = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMsgBox {
    #[staticmethod]
    fn ok(icon: AzMsgBoxIconEnumWrapper, title: String, message: String) -> bool {
        let title = pystring_to_azstring(&title);
        let message = pystring_to_azstring(&message);
        unsafe {
            mem::transmute(crate::AzMsgBox_ok(
                mem::transmute(icon),
                mem::transmute(title),
                mem::transmute(message),
            ))
        }
    }
    #[staticmethod]
    fn info(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_info(mem::transmute(message))) }
    }
    #[staticmethod]
    fn warning(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_warning(mem::transmute(message))) }
    }
    #[staticmethod]
    fn error(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_error(mem::transmute(message))) }
    }
    #[staticmethod]
    fn question(message: String) -> bool {
        let message = pystring_to_azstring(&message);
        unsafe { mem::transmute(crate::AzMsgBox_question(mem::transmute(message))) }
    }
    #[staticmethod]
    fn ok_cancel(
        icon: AzMsgBoxIconEnumWrapper,
        title: String,
        message: String,
        default_value: AzMsgBoxOkCancelEnumWrapper,
    ) -> AzMsgBoxOkCancelEnumWrapper {
        let title = pystring_to_azstring(&title);
        let message = pystring_to_azstring(&message);
        unsafe {
            mem::transmute(crate::AzMsgBox_okCancel(
                mem::transmute(icon),
                mem::transmute(title),
                mem::transmute(message),
                mem::transmute(default_value),
            ))
        }
    }
    #[staticmethod]
    fn yes_no(
        icon: AzMsgBoxIconEnumWrapper,
        title: String,
        message: String,
        default_value: AzMsgBoxYesNoEnumWrapper,
    ) -> AzMsgBoxYesNoEnumWrapper {
        let title = pystring_to_azstring(&title);
        let message = pystring_to_azstring(&message);
        unsafe {
            mem::transmute(crate::AzMsgBox_yesNo(
                mem::transmute(icon),
                mem::transmute(title),
                mem::transmute(message),
                mem::transmute(default_value),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBox {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::MsgBox = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMsgBoxIconEnumWrapper {
    #[classattr]
    fn Info() -> AzMsgBoxIconEnumWrapper {
        AzMsgBoxIconEnumWrapper {
            inner: AzMsgBoxIcon::Info,
        }
    }
    #[classattr]
    fn Warning() -> AzMsgBoxIconEnumWrapper {
        AzMsgBoxIconEnumWrapper {
            inner: AzMsgBoxIcon::Warning,
        }
    }
    #[classattr]
    fn Error() -> AzMsgBoxIconEnumWrapper {
        AzMsgBoxIconEnumWrapper {
            inner: AzMsgBoxIcon::Error,
        }
    }
    #[classattr]
    fn Question() -> AzMsgBoxIconEnumWrapper {
        AzMsgBoxIconEnumWrapper {
            inner: AzMsgBoxIcon::Question,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBoxIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::MsgBoxIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzMsgBoxIconEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzMsgBoxYesNoEnumWrapper {
    #[classattr]
    fn Yes() -> AzMsgBoxYesNoEnumWrapper {
        AzMsgBoxYesNoEnumWrapper {
            inner: AzMsgBoxYesNo::Yes,
        }
    }
    #[classattr]
    fn No() -> AzMsgBoxYesNoEnumWrapper {
        AzMsgBoxYesNoEnumWrapper {
            inner: AzMsgBoxYesNo::No,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBoxYesNoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::YesNo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::YesNo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzMsgBoxYesNoEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzMsgBoxOkCancelEnumWrapper {
    #[classattr]
    fn Ok() -> AzMsgBoxOkCancelEnumWrapper {
        AzMsgBoxOkCancelEnumWrapper {
            inner: AzMsgBoxOkCancel::Ok,
        }
    }
    #[classattr]
    fn Cancel() -> AzMsgBoxOkCancelEnumWrapper {
        AzMsgBoxOkCancelEnumWrapper {
            inner: AzMsgBoxOkCancel::Cancel,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMsgBoxOkCancelEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::OkCancel = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::OkCancel = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzMsgBoxOkCancelEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzFileDialog {
    #[staticmethod]
    fn select_file(
        title: String,
        default_path: AzOptionStringEnumWrapper,
        filter_list: AzOptionFileTypeListEnumWrapper,
    ) -> Option<String> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionString = unsafe {
            mem::transmute(crate::AzFileDialog_selectFile(
                mem::transmute(title),
                mem::transmute(default_path),
                mem::transmute(filter_list),
            ))
        };
        match m {
            AzOptionString::Some(s) => Some({
                let s: AzString = unsafe { mem::transmute(s) };
                s.into()
            }),
            AzOptionString::None => None,
        }
    }
    #[staticmethod]
    fn select_multiple_files(
        title: String,
        default_path: AzOptionStringEnumWrapper,
        filter_list: AzOptionFileTypeListEnumWrapper,
    ) -> Option<AzStringVec> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionStringVec = unsafe {
            mem::transmute(crate::AzFileDialog_selectMultipleFiles(
                mem::transmute(title),
                mem::transmute(default_path),
                mem::transmute(filter_list),
            ))
        };
        match m {
            AzOptionStringVec::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionStringVec::None => None,
        }
    }
    #[staticmethod]
    fn select_folder(title: String, default_path: AzOptionStringEnumWrapper) -> Option<String> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionString = unsafe {
            mem::transmute(crate::AzFileDialog_selectFolder(
                mem::transmute(title),
                mem::transmute(default_path),
            ))
        };
        match m {
            AzOptionString::Some(s) => Some({
                let s: AzString = unsafe { mem::transmute(s) };
                s.into()
            }),
            AzOptionString::None => None,
        }
    }
    #[staticmethod]
    fn save_file(title: String, default_path: AzOptionStringEnumWrapper) -> Option<String> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionString = unsafe {
            mem::transmute(crate::AzFileDialog_saveFile(
                mem::transmute(title),
                mem::transmute(default_path),
            ))
        };
        match m {
            AzOptionString::Some(s) => Some({
                let s: AzString = unsafe { mem::transmute(s) };
                s.into()
            }),
            AzOptionString::None => None,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFileDialog {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::FileDialog = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFileTypeList {
    #[new]
    fn __new__(document_types: AzStringVec, document_descriptor: AzString) -> Self {
        Self {
            document_types,
            document_descriptor,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFileTypeList {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::FileTypeList = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzColorPickerDialog {
    #[staticmethod]
    fn open(title: String, default_color: AzOptionColorUEnumWrapper) -> Option<AzColorU> {
        let title = pystring_to_azstring(&title);
        let m: AzOptionColorU = unsafe {
            mem::transmute(crate::AzColorPickerDialog_open(
                mem::transmute(title),
                mem::transmute(default_color),
            ))
        };
        match m {
            AzOptionColorU::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionColorU::None => None,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzColorPickerDialog {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::ColorPickerDialog = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemClipboard {
    #[staticmethod]
    fn new() -> Option<AzSystemClipboard> {
        let m: AzOptionSystemClipboard = unsafe { mem::transmute(crate::AzSystemClipboard_new()) };
        match m {
            AzOptionSystemClipboard::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionSystemClipboard::None => None,
        }
    }
    fn get_string_contents(&self) -> Option<String> {
        let m: AzOptionString = unsafe {
            mem::transmute(crate::AzSystemClipboard_getStringContents(mem::transmute(
                self,
            )))
        };
        match m {
            AzOptionString::Some(s) => Some({
                let s: AzString = unsafe { mem::transmute(s) };
                s.into()
            }),
            AzOptionString::None => None,
        }
    }
    fn set_string_contents(&mut self, contents: String) -> bool {
        let contents = pystring_to_azstring(&contents);
        unsafe {
            mem::transmute(crate::AzSystemClipboard_setStringContents(
                mem::transmute(self),
                mem::transmute(contents),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSystemClipboard {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::app::Clipboard = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::app::Clipboard = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantEnumWrapper {
    #[staticmethod]
    fn System(v: AzInstantPtr) -> AzInstantEnumWrapper {
        AzInstantEnumWrapper {
            inner: AzInstant::System(v),
        }
    }
    #[staticmethod]
    fn Tick(v: AzSystemTick) -> AzInstantEnumWrapper {
        AzInstantEnumWrapper {
            inner: AzInstant::Tick(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInstant;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInstant::System(v) => Ok(vec!["System".into_py(py), v.clone().into_py(py)]),
            AzInstant::Tick(v) => Ok(vec!["Tick".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInstantEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Instant = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtr {}

#[pyproto]
impl PyObjectProtocol for AzInstantPtr {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::AzInstantPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::AzInstantPtr = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrCloneFn {}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrCloneFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::InstantPtrCloneCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInstantPtrDestructorFn {}

#[pyproto]
impl PyObjectProtocol for AzInstantPtrDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::InstantPtrDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTick {
    #[new]
    fn __new__(tick_counter: u64) -> Self {
        Self { tick_counter }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSystemTick {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::SystemTick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::SystemTick = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDurationEnumWrapper {
    #[staticmethod]
    fn System(v: AzSystemTimeDiff) -> AzDurationEnumWrapper {
        AzDurationEnumWrapper {
            inner: AzDuration::System(v),
        }
    }
    #[staticmethod]
    fn Tick(v: AzSystemTickDiff) -> AzDurationEnumWrapper {
        AzDurationEnumWrapper {
            inner: AzDuration::Tick(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzDuration;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDuration::System(v) => Ok(vec!["System".into_py(py), v.clone().into_py(py)]),
            AzDuration::Tick(v) => Ok(vec!["Tick".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Duration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTimeDiff {
    #[new]
    fn __new__(secs: u64, nanos: u32) -> Self {
        Self { secs, nanos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSystemTimeDiff {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::SystemTimeDiff = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSystemTickDiff {
    #[new]
    fn __new__(tick_diff: u64) -> Self {
        Self { tick_diff }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSystemTickDiff {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::SystemTickDiff = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimerId {
    #[new]
    fn __new__(id: usize) -> Self {
        Self { id }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTimerId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::TimerId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::TimerId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTimer {
    fn with_delay(&self, delay: AzDurationEnumWrapper) -> AzTimer {
        unsafe {
            mem::transmute(crate::AzTimer_withDelay(
                mem::transmute(self),
                mem::transmute(delay),
            ))
        }
    }
    fn with_interval(&self, interval: AzDurationEnumWrapper) -> AzTimer {
        unsafe {
            mem::transmute(crate::AzTimer_withInterval(
                mem::transmute(self),
                mem::transmute(interval),
            ))
        }
    }
    fn with_timeout(&self, timeout: AzDurationEnumWrapper) -> AzTimer {
        unsafe {
            mem::transmute(crate::AzTimer_withTimeout(
                mem::transmute(self),
                mem::transmute(timeout),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTimer {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Timer = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Timer = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTerminateTimerEnumWrapper {
    #[classattr]
    fn Terminate() -> AzTerminateTimerEnumWrapper {
        AzTerminateTimerEnumWrapper {
            inner: AzTerminateTimer::Terminate,
        }
    }
    #[classattr]
    fn Continue() -> AzTerminateTimerEnumWrapper {
        AzTerminateTimerEnumWrapper {
            inner: AzTerminateTimer::Continue,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTerminateTimerEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::TerminateTimer = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::TerminateTimer = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __richcmp__(
        &self,
        other: AzTerminateTimerEnumWrapper,
        op: pyo3::class::basic::CompareOp,
    ) -> PyResult<bool> {
        match op {
            pyo3::class::basic::CompareOp::Lt => {
                Ok((self.clone().inner as usize) < (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Le => {
                Ok((self.clone().inner as usize) <= (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Eq => {
                Ok((self.clone().inner as usize) == (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ne => {
                Ok((self.clone().inner as usize) != (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Gt => {
                Ok((self.clone().inner as usize) > (other.clone().inner as usize))
            }
            pyo3::class::basic::CompareOp::Ge => {
                Ok((self.clone().inner as usize) >= (other.clone().inner as usize))
            }
        }
    }
}

#[pymethods]
impl AzThreadId {
    #[new]
    fn __new__(id: usize) -> Self {
        Self { id }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadId {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadId = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThread {}

#[pyproto]
impl PyObjectProtocol for AzThread {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Thread = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::Thread = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSender {
    fn send(&mut self, msg: AzThreadReceiveMsgEnumWrapper) -> bool {
        unsafe {
            mem::transmute(crate::AzThreadSender_send(
                mem::transmute(self),
                mem::transmute(msg),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadSender {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSender = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSender = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiver {
    fn receive(&mut self) -> Option<AzThreadSendMsgEnumWrapper> {
        let m: AzOptionThreadSendMsg =
            unsafe { mem::transmute(crate::AzThreadReceiver_receive(mem::transmute(self))) };
        match m {
            AzOptionThreadSendMsg::Some(s) => Some(unsafe { mem::transmute(s) }),
            AzOptionThreadSendMsg::None => None,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiver {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadReceiver = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadReceiver = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSendMsgEnumWrapper {
    #[classattr]
    fn TerminateThread() -> AzThreadSendMsgEnumWrapper {
        AzThreadSendMsgEnumWrapper {
            inner: AzThreadSendMsg::TerminateThread,
        }
    }
    #[classattr]
    fn Tick() -> AzThreadSendMsgEnumWrapper {
        AzThreadSendMsgEnumWrapper {
            inner: AzThreadSendMsg::Tick,
        }
    }
    #[staticmethod]
    fn Custom(v: AzRefAny) -> AzThreadSendMsgEnumWrapper {
        AzThreadSendMsgEnumWrapper {
            inner: AzThreadSendMsg::Custom(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzThreadSendMsg;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzThreadSendMsg::TerminateThread => {
                Ok(vec!["TerminateThread".into_py(py), ().into_py(py)])
            }
            AzThreadSendMsg::Tick => Ok(vec!["Tick".into_py(py), ().into_py(py)]),
            AzThreadSendMsg::Custom(v) => Ok(vec!["Custom".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadSendMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSendMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSendMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiveMsgEnumWrapper {
    #[staticmethod]
    fn WriteBack(v: AzThreadWriteBackMsg) -> AzThreadReceiveMsgEnumWrapper {
        AzThreadReceiveMsgEnumWrapper {
            inner: AzThreadReceiveMsg::WriteBack(v),
        }
    }
    #[staticmethod]
    fn Update(v: AzUpdateEnumWrapper) -> AzThreadReceiveMsgEnumWrapper {
        AzThreadReceiveMsgEnumWrapper {
            inner: AzThreadReceiveMsg::Update(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzThreadReceiveMsg;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzThreadReceiveMsg::WriteBack(v) => {
                Ok(vec!["WriteBack".into_py(py), v.clone().into_py(py)])
            }
            AzThreadReceiveMsg::Update(v) => Ok(vec![
                "Update".into_py(py),
                {
                    let m: &AzUpdateEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiveMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadReceiveMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadReceiveMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadWriteBackMsg {
    #[new]
    fn __new__(data: AzRefAny, callback: AzWriteBackCallback) -> Self {
        Self { data, callback }
    }
}

#[pyproto]
impl PyObjectProtocol for AzThreadWriteBackMsg {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadWriteBackMsg = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCreateThreadFn {}

#[pyproto]
impl PyObjectProtocol for AzCreateThreadFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::CreateThreadCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::CreateThreadCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGetSystemTimeFn {}

#[pyproto]
impl PyObjectProtocol for AzGetSystemTimeFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::GetSystemTimeCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::GetSystemTimeCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCheckThreadFinishedFn {}

#[pyproto]
impl PyObjectProtocol for AzCheckThreadFinishedFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::CheckThreadFinishedCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLibrarySendThreadMsgFn {}

#[pyproto]
impl PyObjectProtocol for AzLibrarySendThreadMsgFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::LibrarySendThreadMsgCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLibraryReceiveThreadMsgFn {}

#[pyproto]
impl PyObjectProtocol for AzLibraryReceiveThreadMsgFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::LibraryReceiveThreadMsgCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadRecvFn {}

#[pyproto]
impl PyObjectProtocol for AzThreadRecvFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadRecvCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadRecvCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSendFn {}

#[pyproto]
impl PyObjectProtocol for AzThreadSendFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSendCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSendCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadDestructorFn {}

#[pyproto]
impl PyObjectProtocol for AzThreadDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadReceiverDestructorFn {}

#[pyproto]
impl PyObjectProtocol for AzThreadReceiverDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadReceiverDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzThreadSenderDestructorFn {}

#[pyproto]
impl PyObjectProtocol for AzThreadSenderDestructorFn {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::ThreadSenderDestructorCallback = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtValueEnumWrapper {
    #[staticmethod]
    fn Bool(v: bool) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Bool(v),
        }
    }
    #[staticmethod]
    fn Uchar(v: u8) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Uchar(v),
        }
    }
    #[staticmethod]
    fn Schar(v: i8) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Schar(v),
        }
    }
    #[staticmethod]
    fn Ushort(v: u16) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Ushort(v),
        }
    }
    #[staticmethod]
    fn Sshort(v: i16) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Sshort(v),
        }
    }
    #[staticmethod]
    fn Uint(v: u32) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Uint(v),
        }
    }
    #[staticmethod]
    fn Sint(v: i32) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Sint(v),
        }
    }
    #[staticmethod]
    fn Ulong(v: u64) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Ulong(v),
        }
    }
    #[staticmethod]
    fn Slong(v: i64) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Slong(v),
        }
    }
    #[staticmethod]
    fn Isize(v: isize) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Isize(v),
        }
    }
    #[staticmethod]
    fn Usize(v: usize) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Usize(v),
        }
    }
    #[staticmethod]
    fn Float(v: f32) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Float(v),
        }
    }
    #[staticmethod]
    fn Double(v: f64) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Double(v),
        }
    }
    #[staticmethod]
    fn Str(v: AzString) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::Str(v),
        }
    }
    #[staticmethod]
    fn StrVec(v: AzStringVec) -> AzFmtValueEnumWrapper {
        AzFmtValueEnumWrapper {
            inner: AzFmtValue::StrVec(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzFmtValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFmtValue::Bool(v) => Ok(vec!["Bool".into_py(py), v.into_py(py)]),
            AzFmtValue::Uchar(v) => Ok(vec!["Uchar".into_py(py), v.into_py(py)]),
            AzFmtValue::Schar(v) => Ok(vec!["Schar".into_py(py), v.into_py(py)]),
            AzFmtValue::Ushort(v) => Ok(vec!["Ushort".into_py(py), v.into_py(py)]),
            AzFmtValue::Sshort(v) => Ok(vec!["Sshort".into_py(py), v.into_py(py)]),
            AzFmtValue::Uint(v) => Ok(vec!["Uint".into_py(py), v.into_py(py)]),
            AzFmtValue::Sint(v) => Ok(vec!["Sint".into_py(py), v.into_py(py)]),
            AzFmtValue::Ulong(v) => Ok(vec!["Ulong".into_py(py), v.into_py(py)]),
            AzFmtValue::Slong(v) => Ok(vec!["Slong".into_py(py), v.into_py(py)]),
            AzFmtValue::Isize(v) => Ok(vec!["Isize".into_py(py), v.into_py(py)]),
            AzFmtValue::Usize(v) => Ok(vec!["Usize".into_py(py), v.into_py(py)]),
            AzFmtValue::Float(v) => Ok(vec!["Float".into_py(py), v.into_py(py)]),
            AzFmtValue::Double(v) => Ok(vec!["Double".into_py(py), v.into_py(py)]),
            AzFmtValue::Str(v) => Ok(vec!["Str".into_py(py), v.clone().into_py(py)]),
            AzFmtValue::StrVec(v) => Ok(vec!["StrVec".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArg {
    #[new]
    fn __new__(key: AzString, value: AzFmtValueEnumWrapper) -> Self {
        Self { key, value }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtArg {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtArg = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtArg = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzString {
    #[staticmethod]
    fn format(format: String, args: AzFmtArgVec) -> AzString {
        let format = pystring_to_azstring(&format);
        unsafe {
            mem::transmute(crate::AzString_format(
                mem::transmute(format),
                mem::transmute(args),
            ))
        }
    }
    fn trim(&self) -> String {
        az_string_to_py_string(unsafe {
            mem::transmute(crate::AzString_trim(mem::transmute(self)))
        })
    }
}

#[pyproto]
impl PyObjectProtocol for AzString {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AzString = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::AzString = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRowVec {
    /// Creates a new `ListViewRowVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzListViewRow>) -> Self {
        let m: crate::widgets::list_view::ListViewRowVec =
            crate::widgets::list_view::ListViewRowVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the ListViewRow as a Python array
    fn array(&self) -> Vec<AzListViewRow> {
        let m: &crate::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewRowVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewRowVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVec {
    /// Creates a new `StyleFilterEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleFilterEnumWrapper>) -> Self {
        let m: azul_css::StyleFilterVec =
            azul_css::StyleFilterVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyleFilterEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleFilterEnumWrapper> {
        let m: &azul_css::StyleFilterVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRectVec {
    /// Creates a new `LogicalRectVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzLogicalRect>) -> Self {
        let m: azul_core::geom::LogicalRectVec =
            azul_core::geom::LogicalRectVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the LogicalRect as a Python array
    fn array(&self) -> Vec<AzLogicalRect> {
        let m: &azul_core::geom::LogicalRectVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRectVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalRectVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalRectVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMapVec {
    /// Creates a new `NodeTypeIdInfoMapVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeTypeIdInfoMap>) -> Self {
        let m: crate::widgets::node_graph::NodeTypeIdInfoMapVec =
            crate::widgets::node_graph::NodeTypeIdInfoMapVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NodeTypeIdInfoMap as a Python array
    fn array(&self) -> Vec<AzNodeTypeIdInfoMap> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMapVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMapVec {
    /// Creates a new `InputOutputTypeIdInfoMapVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputOutputTypeIdInfoMap>) -> Self {
        let m: crate::widgets::node_graph::InputOutputTypeIdInfoMapVec =
            crate::widgets::node_graph::InputOutputTypeIdInfoMapVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InputOutputTypeIdInfoMap as a Python array
    fn array(&self) -> Vec<AzInputOutputTypeIdInfoMap> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec =
            unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMapVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVec =
            unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMapVec {
    /// Creates a new `NodeIdNodeMapVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeIdNodeMap>) -> Self {
        let m: crate::widgets::node_graph::NodeIdNodeMapVec =
            crate::widgets::node_graph::NodeIdNodeMapVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NodeIdNodeMap as a Python array
    fn array(&self) -> Vec<AzNodeIdNodeMap> {
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMapVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeIdNodeMapVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdVec {
    /// Creates a new `InputOutputTypeIdVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputOutputTypeId>) -> Self {
        let m: crate::widgets::node_graph::InputOutputTypeIdVec =
            crate::widgets::node_graph::InputOutputTypeIdVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InputOutputTypeId as a Python array
    fn array(&self) -> Vec<AzInputOutputTypeId> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldVec {
    /// Creates a new `NodeTypeFieldVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeTypeField>) -> Self {
        let m: crate::widgets::node_graph::NodeTypeFieldVec =
            crate::widgets::node_graph::NodeTypeFieldVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NodeTypeField as a Python array
    fn array(&self) -> Vec<AzNodeTypeField> {
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeFieldVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnectionVec {
    /// Creates a new `InputConnectionVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputConnection>) -> Self {
        let m: crate::widgets::node_graph::InputConnectionVec =
            crate::widgets::node_graph::InputConnectionVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InputConnection as a Python array
    fn array(&self) -> Vec<AzInputConnection> {
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputConnectionVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputConnectionVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndexVec {
    /// Creates a new `OutputNodeAndIndexVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzOutputNodeAndIndex>) -> Self {
        let m: crate::widgets::node_graph::OutputNodeAndIndexVec =
            crate::widgets::node_graph::OutputNodeAndIndexVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the OutputNodeAndIndex as a Python array
    fn array(&self) -> Vec<AzOutputNodeAndIndex> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndexVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnectionVec {
    /// Creates a new `OutputConnectionVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzOutputConnection>) -> Self {
        let m: crate::widgets::node_graph::OutputConnectionVec =
            crate::widgets::node_graph::OutputConnectionVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the OutputConnection as a Python array
    fn array(&self) -> Vec<AzOutputConnection> {
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputConnectionVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputConnectionVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndexVec {
    /// Creates a new `InputNodeAndIndexVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInputNodeAndIndex>) -> Self {
        let m: crate::widgets::node_graph::InputNodeAndIndexVec =
            crate::widgets::node_graph::InputNodeAndIndexVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InputNodeAndIndex as a Python array
    fn array(&self) -> Vec<AzInputNodeAndIndex> {
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndexVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputNodeAndIndexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVec {
    /// Creates a new `AccessibilityStateEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzAccessibilityStateEnumWrapper>) -> Self {
        let m: azul_core::dom::AccessibilityStateVec =
            azul_core::dom::AccessibilityStateVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the AccessibilityStateEnumWrapper as a Python array
    fn array(&self) -> Vec<AzAccessibilityStateEnumWrapper> {
        let m: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityStateVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVec {
    /// Creates a new `MenuItemEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzMenuItemEnumWrapper>) -> Self {
        let m: azul_core::window::MenuItemVec =
            azul_core::window::MenuItemVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the MenuItemEnumWrapper as a Python array
    fn array(&self) -> Vec<AzMenuItemEnumWrapper> {
        let m: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVec {
    /// Creates a new `TessellatedSvgNodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzTessellatedSvgNode>) -> Self {
        let m: azul_core::svg::TessellatedSvgNodeVec =
            azul_core::svg::TessellatedSvgNodeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the TessellatedSvgNode as a Python array
    fn array(&self) -> Vec<AzTessellatedSvgNode> {
        let m: &azul_core::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

    fn as_ref_vec(&self) -> AzTessellatedSvgNodeVecRef {
        unsafe {
            mem::transmute(crate::AzTessellatedSvgNodeVec_asRefVec(mem::transmute(
                self,
            )))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNodeVec {
    /// Creates a new `TessellatedColoredSvgNodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzTessellatedColoredSvgNode>) -> Self {
        let m: azul_core::svg::TessellatedColoredSvgNodeVec =
            azul_core::svg::TessellatedColoredSvgNodeVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the TessellatedColoredSvgNode as a Python array
    fn array(&self) -> Vec<AzTessellatedColoredSvgNode> {
        let m: &azul_core::svg::TessellatedColoredSvgNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }

    fn as_ref_vec(&self) -> AzTessellatedColoredSvgNodeVecRef {
        unsafe {
            mem::transmute(crate::AzTessellatedColoredSvgNodeVec_asRefVec(
                mem::transmute(self),
            ))
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNodeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVec {
    /// Creates a new `StyleFontFamilyEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleFontFamilyEnumWrapper>) -> Self {
        let m: azul_css::StyleFontFamilyVec =
            azul_css::StyleFontFamilyVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyleFontFamilyEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleFontFamilyEnumWrapper> {
        let m: &azul_css::StyleFontFamilyVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamilyVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamilyVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeVec {
    /// Creates a new `XmlNodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzXmlNode>) -> Self {
        let m: azul_core::xml::XmlNodeVec =
            azul_core::xml::XmlNodeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the XmlNode as a Python array
    fn array(&self) -> Vec<AzXmlNode> {
        let m: &azul_core::xml::XmlNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArgVec {
    /// Creates a new `FmtArgVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzFmtArg>) -> Self {
        let m: crate::str::FmtArgVec =
            crate::str::FmtArgVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the FmtArg as a Python array
    fn array(&self) -> Vec<AzFmtArg> {
        let m: &crate::str::FmtArgVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtArgVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtArgVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtArgVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLineVec {
    /// Creates a new `InlineLineVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineLine>) -> Self {
        let m: azul_core::callbacks::InlineLineVec =
            azul_core::callbacks::InlineLineVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InlineLine as a Python array
    fn array(&self) -> Vec<AzInlineLine> {
        let m: &azul_core::callbacks::InlineLineVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineLineVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineLineVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineLineVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordVec {
    /// Creates a new `InlineWordEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineWordEnumWrapper>) -> Self {
        let m: azul_core::callbacks::InlineWordVec =
            azul_core::callbacks::InlineWordVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InlineWordEnumWrapper as a Python array
    fn array(&self) -> Vec<AzInlineWordEnumWrapper> {
        let m: &azul_core::callbacks::InlineWordVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineWordVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineWordVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyphVec {
    /// Creates a new `InlineGlyphVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineGlyph>) -> Self {
        let m: azul_core::callbacks::InlineGlyphVec =
            azul_core::callbacks::InlineGlyphVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InlineGlyph as a Python array
    fn array(&self) -> Vec<AzInlineGlyph> {
        let m: &azul_core::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyphVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineGlyphVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHitVec {
    /// Creates a new `InlineTextHitVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzInlineTextHit>) -> Self {
        let m: azul_core::callbacks::InlineTextHitVec =
            azul_core::callbacks::InlineTextHitVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the InlineTextHit as a Python array
    fn array(&self) -> Vec<AzInlineTextHit> {
        let m: &azul_core::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHitVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextHitVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVec {
    /// Creates a new `MonitorVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzMonitor>) -> Self {
        let m: azul_core::window::MonitorVec =
            azul_core::window::MonitorVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the Monitor as a Python array
    fn array(&self) -> Vec<AzMonitor> {
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMonitorVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MonitorVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVec {
    /// Creates a new `VideoModeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzVideoMode>) -> Self {
        let m: azul_core::window::VideoModeVec =
            azul_core::window::VideoModeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the VideoMode as a Python array
    fn array(&self) -> Vec<AzVideoMode> {
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VideoModeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVec {
    /// Creates a new `DomVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzDom>) -> Self {
        let m: azul_core::dom::DomVec =
            azul_core::dom::DomVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the Dom as a Python array
    fn array(&self) -> Vec<AzDom> {
        let m: &azul_core::dom::DomVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDomVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::DomVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::DomVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVec {
    /// Creates a new `IdOrClassEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzIdOrClassEnumWrapper>) -> Self {
        let m: azul_core::dom::IdOrClassVec =
            azul_core::dom::IdOrClassVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the IdOrClassEnumWrapper as a Python array
    fn array(&self) -> Vec<AzIdOrClassEnumWrapper> {
        let m: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IdOrClassVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVec {
    /// Creates a new `NodeDataInlineCssPropertyEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeDataInlineCssPropertyEnumWrapper>) -> Self {
        let m: azul_core::dom::NodeDataInlineCssPropertyVec =
            azul_core::dom::NodeDataInlineCssPropertyVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NodeDataInlineCssPropertyEnumWrapper as a Python array
    fn array(&self) -> Vec<AzNodeDataInlineCssPropertyEnumWrapper> {
        let m: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataInlineCssPropertyVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVec {
    /// Creates a new `StyleBackgroundContentEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundContentEnumWrapper>) -> Self {
        let m: azul_css::StyleBackgroundContentVec =
            azul_css::StyleBackgroundContentVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyleBackgroundContentEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundContentEnumWrapper> {
        let m: &azul_css::StyleBackgroundContentVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContentVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContentVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVec {
    /// Creates a new `StyleBackgroundPositionVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundPosition>) -> Self {
        let m: azul_css::StyleBackgroundPositionVec =
            azul_css::StyleBackgroundPositionVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyleBackgroundPosition as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundPosition> {
        let m: &azul_css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPositionVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVec {
    /// Creates a new `StyleBackgroundRepeatEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundRepeatEnumWrapper>) -> Self {
        let m: azul_css::StyleBackgroundRepeatVec =
            azul_css::StyleBackgroundRepeatVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyleBackgroundRepeatEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundRepeatEnumWrapper> {
        let m: &azul_css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeatVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVec {
    /// Creates a new `StyleBackgroundSizeEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleBackgroundSizeEnumWrapper>) -> Self {
        let m: azul_css::StyleBackgroundSizeVec =
            azul_css::StyleBackgroundSizeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyleBackgroundSizeEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleBackgroundSizeEnumWrapper> {
        let m: &azul_css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSizeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVec {
    /// Creates a new `StyleTransformEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyleTransformEnumWrapper>) -> Self {
        let m: azul_css::StyleTransformVec =
            azul_css::StyleTransformVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyleTransformEnumWrapper as a Python array
    fn array(&self) -> Vec<AzStyleTransformEnumWrapper> {
        let m: &azul_css::StyleTransformVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyVec {
    /// Creates a new `CssPropertyEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssPropertyEnumWrapper>) -> Self {
        let m: azul_css::CssPropertyVec =
            azul_css::CssPropertyVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the CssPropertyEnumWrapper as a Python array
    fn array(&self) -> Vec<AzCssPropertyEnumWrapper> {
        let m: &azul_css::CssPropertyVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPropertyVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPropertyVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVec {
    /// Creates a new `SvgMultiPolygonVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgMultiPolygon>) -> Self {
        let m: azul_layout::xml::svg::SvgMultiPolygonVec =
            azul_layout::xml::svg::SvgMultiPolygonVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the SvgMultiPolygon as a Python array
    fn array(&self) -> Vec<AzSvgMultiPolygon> {
        let m: &azul_layout::xml::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgMultiPolygonVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeVec {
    /// Creates a new `SvgSimpleNodeEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgSimpleNodeEnumWrapper>) -> Self {
        let m: azul_layout::xml::svg::SvgSimpleNodeVec =
            azul_layout::xml::svg::SvgSimpleNodeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the SvgSimpleNodeEnumWrapper as a Python array
    fn array(&self) -> Vec<AzSvgSimpleNodeEnumWrapper> {
        let m: &azul_layout::xml::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgSimpleNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVec {
    /// Creates a new `SvgPathVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgPath>) -> Self {
        let m: azul_layout::xml::svg::SvgPathVec =
            azul_layout::xml::svg::SvgPathVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the SvgPath as a Python array
    fn array(&self) -> Vec<AzSvgPath> {
        let m: &azul_layout::xml::svg::SvgPathVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVec {
    /// Creates a new `VertexAttributeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzVertexAttribute>) -> Self {
        let m: azul_core::gl::VertexAttributeVec =
            azul_core::gl::VertexAttributeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the VertexAttribute as a Python array
    fn array(&self) -> Vec<AzVertexAttribute> {
        let m: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttributeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVec {
    /// Creates a new `SvgPathElementEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgPathElementEnumWrapper>) -> Self {
        let m: azul_layout::xml::svg::SvgPathElementVec =
            azul_layout::xml::svg::SvgPathElementVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the SvgPathElementEnumWrapper as a Python array
    fn array(&self) -> Vec<AzSvgPathElementEnumWrapper> {
        let m: &azul_layout::xml::svg::SvgPathElementVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathElementVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathElementVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVec {
    /// Creates a new `SvgVertexVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgVertex>) -> Self {
        let m: azul_layout::xml::svg::SvgVertexVec =
            azul_layout::xml::svg::SvgVertexVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the SvgVertex as a Python array
    fn array(&self) -> Vec<AzSvgVertex> {
        let m: &azul_layout::xml::svg::SvgVertexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVertexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVertexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgColoredVertexVec {
    /// Creates a new `SvgColoredVertexVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzSvgColoredVertex>) -> Self {
        let m: azul_layout::xml::svg::SvgColoredVertexVec =
            azul_layout::xml::svg::SvgColoredVertexVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the SvgColoredVertex as a Python array
    fn array(&self) -> Vec<AzSvgColoredVertex> {
        let m: &azul_layout::xml::svg::SvgColoredVertexVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgColoredVertexVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgColoredVertexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgColoredVertexVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32Vec {
    /// Creates a new `U32Vec` from a Python array
    #[new]
    fn __new__(input: Vec<AzU32>) -> Self {
        let m: azul_css::U32Vec = azul_css::U32Vec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the U32 as a Python array
    fn array(&self) -> Vec<AzU32> {
        let m: &azul_css::U32Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU32Vec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U32Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U32Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVec {
    /// Creates a new `XWindowTypeEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzXWindowTypeEnumWrapper>) -> Self {
        let m: azul_core::window::XWindowTypeVec =
            azul_core::window::XWindowTypeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the XWindowTypeEnumWrapper as a Python array
    fn array(&self) -> Vec<AzXWindowTypeEnumWrapper> {
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XWindowTypeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVec {
    /// Creates a new `VirtualKeyCodeEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzVirtualKeyCodeEnumWrapper>) -> Self {
        let m: azul_core::window::VirtualKeyCodeVec =
            azul_core::window::VirtualKeyCodeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the VirtualKeyCodeEnumWrapper as a Python array
    fn array(&self) -> Vec<AzVirtualKeyCodeEnumWrapper> {
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVec {
    /// Creates a new `CascadeInfoVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCascadeInfo>) -> Self {
        let m: azul_core::style::CascadeInfoVec =
            azul_core::style::CascadeInfoVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the CascadeInfo as a Python array
    fn array(&self) -> Vec<AzCascadeInfo> {
        let m: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::style::CascadeInfoVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVec {
    /// Creates a new `ScanCodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzScanCode>) -> Self {
        let m: azul_core::window::ScanCodeVec =
            azul_core::window::ScanCodeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the ScanCode as a Python array
    fn array(&self) -> Vec<AzScanCode> {
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ScanCodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVec {
    /// Creates a new `CssDeclarationEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssDeclarationEnumWrapper>) -> Self {
        let m: azul_css::CssDeclarationVec =
            azul_css::CssDeclarationVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the CssDeclarationEnumWrapper as a Python array
    fn array(&self) -> Vec<AzCssDeclarationEnumWrapper> {
        let m: &azul_css::CssDeclarationVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssDeclarationVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssDeclarationVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVec {
    /// Creates a new `CssPathSelectorEnumWrapperVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssPathSelectorEnumWrapper>) -> Self {
        let m: azul_css::CssPathSelectorVec =
            azul_css::CssPathSelectorVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the CssPathSelectorEnumWrapper as a Python array
    fn array(&self) -> Vec<AzCssPathSelectorEnumWrapper> {
        let m: &azul_css::CssPathSelectorVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathSelectorVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathSelectorVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVec {
    /// Creates a new `StylesheetVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStylesheet>) -> Self {
        let m: azul_css::StylesheetVec =
            azul_css::StylesheetVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the Stylesheet as a Python array
    fn array(&self) -> Vec<AzStylesheet> {
        let m: &azul_css::StylesheetVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StylesheetVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StylesheetVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVec {
    /// Creates a new `CssRuleBlockVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCssRuleBlock>) -> Self {
        let m: azul_css::CssRuleBlockVec =
            azul_css::CssRuleBlockVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the CssRuleBlock as a Python array
    fn array(&self) -> Vec<AzCssRuleBlock> {
        let m: &azul_css::CssRuleBlockVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssRuleBlockVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssRuleBlockVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16Vec {
    /// Creates a new `U16Vec` from a Python array
    #[new]
    fn __new__(input: Vec<AzU16>) -> Self {
        let m: azul_css::U16Vec = azul_css::U16Vec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the U16 as a Python array
    fn array(&self) -> Vec<AzU16> {
        let m: &azul_css::U16Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU16Vec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U16Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U16Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32Vec {
    /// Creates a new `F32Vec` from a Python array
    #[new]
    fn __new__(input: Vec<AzF32>) -> Self {
        let m: azul_css::F32Vec = azul_css::F32Vec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the F32 as a Python array
    fn array(&self) -> Vec<AzF32> {
        let m: &azul_css::F32Vec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzF32Vec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::F32Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::F32Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8Vec {}

#[pyproto]
impl PyObjectProtocol for AzU8Vec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U8Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U8Vec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackDataVec {
    /// Creates a new `CallbackDataVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzCallbackData>) -> Self {
        let m: azul_core::dom::CallbackDataVec =
            azul_core::dom::CallbackDataVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the CallbackData as a Python array
    fn array(&self) -> Vec<AzCallbackData> {
        let m: &azul_core::dom::CallbackDataVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCallbackDataVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::CallbackDataVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::CallbackDataVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDebugMessageVec {
    /// Creates a new `DebugMessageVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzDebugMessage>) -> Self {
        let m: azul_core::gl::AzDebugMessageVec =
            azul_core::gl::AzDebugMessageVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the DebugMessage as a Python array
    fn array(&self) -> Vec<AzDebugMessage> {
        let m: &azul_core::gl::AzDebugMessageVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDebugMessageVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzDebugMessageVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzDebugMessageVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVec {
    /// Creates a new `GLuintVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzGLuint>) -> Self {
        let m: azul_core::gl::GLuintVec =
            azul_core::gl::GLuintVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the GLuint as a Python array
    fn array(&self) -> Vec<AzGLuint> {
        let m: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLuintVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVec {
    /// Creates a new `GLintVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzGLint>) -> Self {
        let m: azul_core::gl::GLintVec =
            azul_core::gl::GLintVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the GLint as a Python array
    fn array(&self) -> Vec<AzGLint> {
        let m: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLintVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLintVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVec {
    /// Creates a new `StringVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzString>) -> Self {
        let m: azul_css::StringVec =
            azul_css::StringVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the String as a Python array
    fn array(&self) -> Vec<AzString> {
        let m: &azul_css::StringVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StringVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StringVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVec {
    /// Creates a new `StringPairVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStringPair>) -> Self {
        let m: azul_core::window::StringPairVec =
            azul_core::window::StringPairVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StringPair as a Python array
    fn array(&self) -> Vec<AzStringPair> {
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringPairVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::StringPairVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVec {
    /// Creates a new `NormalizedLinearColorStopVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNormalizedLinearColorStop>) -> Self {
        let m: azul_css::NormalizedLinearColorStopVec =
            azul_css::NormalizedLinearColorStopVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NormalizedLinearColorStop as a Python array
    fn array(&self) -> Vec<AzNormalizedLinearColorStop> {
        let m: &azul_css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedLinearColorStopVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVec {
    /// Creates a new `NormalizedRadialColorStopVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNormalizedRadialColorStop>) -> Self {
        let m: azul_css::NormalizedRadialColorStopVec =
            azul_css::NormalizedRadialColorStopVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NormalizedRadialColorStop as a Python array
    fn array(&self) -> Vec<AzNormalizedRadialColorStop> {
        let m: &azul_css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedRadialColorStopVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVec {
    /// Creates a new `NodeIdVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeId>) -> Self {
        let m: azul_core::styled_dom::NodeIdVec =
            azul_core::styled_dom::NodeIdVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NodeId as a Python array
    fn array(&self) -> Vec<AzNodeId> {
        let m: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeIdVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVec {
    /// Creates a new `NodeHierarchyItemVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeHierarchyItem>) -> Self {
        let m: azul_core::styled_dom::NodeHierarchyItemVec =
            azul_core::styled_dom::NodeHierarchyItemVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NodeHierarchyItem as a Python array
    fn array(&self) -> Vec<AzNodeHierarchyItem> {
        let m: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItemVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVec {
    /// Creates a new `StyledNodeVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzStyledNode>) -> Self {
        let m: azul_core::styled_dom::StyledNodeVec =
            azul_core::styled_dom::StyledNodeVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the StyledNode as a Python array
    fn array(&self) -> Vec<AzStyledNode> {
        let m: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNodeVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVec {
    /// Creates a new `TagIdToNodeIdMappingVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzTagIdToNodeIdMapping>) -> Self {
        let m: azul_core::styled_dom::TagIdToNodeIdMappingVec =
            azul_core::styled_dom::TagIdToNodeIdMappingVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the TagIdToNodeIdMapping as a Python array
    fn array(&self) -> Vec<AzTagIdToNodeIdMapping> {
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVec {
    /// Creates a new `ParentWithNodeDepthVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzParentWithNodeDepth>) -> Self {
        let m: azul_core::styled_dom::ParentWithNodeDepthVec =
            azul_core::styled_dom::ParentWithNodeDepthVec::from_vec(unsafe {
                mem::transmute(input)
            });
        unsafe { mem::transmute(m) }
    }

    /// Returns the ParentWithNodeDepth as a Python array
    fn array(&self) -> Vec<AzParentWithNodeDepth> {
        let m: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::ParentWithNodeDepthVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVec {
    /// Creates a new `NodeDataVec` from a Python array
    #[new]
    fn __new__(input: Vec<AzNodeData>) -> Self {
        let m: azul_core::dom::NodeDataVec =
            azul_core::dom::NodeDataVec::from_vec(unsafe { mem::transmute(input) });
        unsafe { mem::transmute(m) }
    }

    /// Returns the NodeData as a Python array
    fn array(&self) -> Vec<AzNodeData> {
        let m: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) };
        unsafe { mem::transmute(m.clone().into_library_owned_vec()) }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVec {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataVec = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFontFamilyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper {
            inner: AzStyleFontFamilyVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleFontFamilyVecDestructorEnumWrapper {
        AzStyleFontFamilyVecDestructorEnumWrapper {
            inner: AzStyleFontFamilyVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleFontFamilyVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFontFamilyVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyleFontFamilyVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyleFontFamilyVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFontFamilyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFontFamilyVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzListViewRowVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper {
            inner: AzListViewRowVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzListViewRowVecDestructorEnumWrapper {
        AzListViewRowVecDestructorEnumWrapper {
            inner: AzListViewRowVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzListViewRowVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzListViewRowVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzListViewRowVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzListViewRowVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzListViewRowVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewRowVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::ListViewRowVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleFilterVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper {
            inner: AzStyleFilterVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleFilterVecDestructorEnumWrapper {
        AzStyleFilterVecDestructorEnumWrapper {
            inner: AzStyleFilterVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleFilterVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleFilterVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyleFilterVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyleFilterVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleFilterVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleFilterVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzLogicalRectVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzLogicalRectVecDestructorEnumWrapper {
        AzLogicalRectVecDestructorEnumWrapper {
            inner: AzLogicalRectVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzLogicalRectVecDestructorEnumWrapper {
        AzLogicalRectVecDestructorEnumWrapper {
            inner: AzLogicalRectVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzLogicalRectVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzLogicalRectVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzLogicalRectVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzLogicalRectVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzLogicalRectVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalRectVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::geom::LogicalRectVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
        AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
            inner: AzNodeTypeIdInfoMapVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
        AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
            inner: AzNodeTypeIdInfoMapVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeTypeIdInfoMapVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeIdInfoMapVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNodeTypeIdInfoMapVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNodeTypeIdInfoMapVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeIdInfoMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeIdInfoMapVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
        AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
            inner: AzInputOutputTypeIdInfoMapVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
        AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
            inner: AzInputOutputTypeIdInfoMapVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInputOutputTypeIdInfoMapVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputOutputTypeIdInfoMapVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInputOutputTypeIdInfoMapVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInputOutputTypeIdInfoMapVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdInfoMapVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdNodeMapVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeIdNodeMapVecDestructorEnumWrapper {
        AzNodeIdNodeMapVecDestructorEnumWrapper {
            inner: AzNodeIdNodeMapVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeIdNodeMapVecDestructorEnumWrapper {
        AzNodeIdNodeMapVecDestructorEnumWrapper {
            inner: AzNodeIdNodeMapVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeIdNodeMapVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeIdNodeMapVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNodeIdNodeMapVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNodeIdNodeMapVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdNodeMapVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeIdNodeMapVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputOutputTypeIdVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputOutputTypeIdVecDestructorEnumWrapper {
        AzInputOutputTypeIdVecDestructorEnumWrapper {
            inner: AzInputOutputTypeIdVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInputOutputTypeIdVecDestructorEnumWrapper {
        AzInputOutputTypeIdVecDestructorEnumWrapper {
            inner: AzInputOutputTypeIdVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInputOutputTypeIdVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputOutputTypeIdVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInputOutputTypeIdVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInputOutputTypeIdVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputOutputTypeIdVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputOutputTypeIdVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeTypeFieldVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeTypeFieldVecDestructorEnumWrapper {
        AzNodeTypeFieldVecDestructorEnumWrapper {
            inner: AzNodeTypeFieldVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeTypeFieldVecDestructorEnumWrapper {
        AzNodeTypeFieldVecDestructorEnumWrapper {
            inner: AzNodeTypeFieldVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeTypeFieldVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeTypeFieldVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNodeTypeFieldVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNodeTypeFieldVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeTypeFieldVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeFieldVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::NodeTypeFieldVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputConnectionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputConnectionVecDestructorEnumWrapper {
        AzInputConnectionVecDestructorEnumWrapper {
            inner: AzInputConnectionVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInputConnectionVecDestructorEnumWrapper {
        AzInputConnectionVecDestructorEnumWrapper {
            inner: AzInputConnectionVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInputConnectionVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputConnectionVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInputConnectionVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInputConnectionVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputConnectionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputConnectionVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputConnectionVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputNodeAndIndexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzOutputNodeAndIndexVecDestructorEnumWrapper {
        AzOutputNodeAndIndexVecDestructorEnumWrapper {
            inner: AzOutputNodeAndIndexVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzOutputNodeAndIndexVecDestructorEnumWrapper {
        AzOutputNodeAndIndexVecDestructorEnumWrapper {
            inner: AzOutputNodeAndIndexVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOutputNodeAndIndexVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOutputNodeAndIndexVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzOutputNodeAndIndexVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzOutputNodeAndIndexVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputNodeAndIndexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputNodeAndIndexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOutputConnectionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzOutputConnectionVecDestructorEnumWrapper {
        AzOutputConnectionVecDestructorEnumWrapper {
            inner: AzOutputConnectionVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzOutputConnectionVecDestructorEnumWrapper {
        AzOutputConnectionVecDestructorEnumWrapper {
            inner: AzOutputConnectionVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOutputConnectionVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOutputConnectionVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzOutputConnectionVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzOutputConnectionVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOutputConnectionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputConnectionVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OutputConnectionVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInputNodeAndIndexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInputNodeAndIndexVecDestructorEnumWrapper {
        AzInputNodeAndIndexVecDestructorEnumWrapper {
            inner: AzInputNodeAndIndexVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInputNodeAndIndexVecDestructorEnumWrapper {
        AzInputNodeAndIndexVecDestructorEnumWrapper {
            inner: AzInputNodeAndIndexVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInputNodeAndIndexVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInputNodeAndIndexVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInputNodeAndIndexVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInputNodeAndIndexVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInputNodeAndIndexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::InputNodeAndIndexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzAccessibilityStateVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper {
            inner: AzAccessibilityStateVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzAccessibilityStateVecDestructorEnumWrapper {
        AzAccessibilityStateVecDestructorEnumWrapper {
            inner: AzAccessibilityStateVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzAccessibilityStateVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzAccessibilityStateVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzAccessibilityStateVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzAccessibilityStateVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzAccessibilityStateVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityStateVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::AccessibilityStateVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMenuItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper {
            inner: AzMenuItemVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzMenuItemVecDestructorEnumWrapper {
        AzMenuItemVecDestructorEnumWrapper {
            inner: AzMenuItemVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzMenuItemVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMenuItemVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzMenuItemVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzMenuItemVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMenuItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MenuItemVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedSvgNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTessellatedSvgNodeVecDestructorEnumWrapper {
        AzTessellatedSvgNodeVecDestructorEnumWrapper {
            inner: AzTessellatedSvgNodeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzTessellatedSvgNodeVecDestructorEnumWrapper {
        AzTessellatedSvgNodeVecDestructorEnumWrapper {
            inner: AzTessellatedSvgNodeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzTessellatedSvgNodeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTessellatedSvgNodeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzTessellatedSvgNodeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzTessellatedSvgNodeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedSvgNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedSvgNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
        AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
            inner: AzTessellatedColoredSvgNodeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
        AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
            inner: AzTessellatedColoredSvgNodeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzTessellatedColoredSvgNodeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTessellatedColoredSvgNodeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzTessellatedColoredSvgNodeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzTessellatedColoredSvgNodeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTessellatedColoredSvgNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::TessellatedColoredSvgNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXmlNodeVecDestructorEnumWrapper {
        AzXmlNodeVecDestructorEnumWrapper {
            inner: AzXmlNodeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzXmlNodeVecDestructorEnumWrapper {
        AzXmlNodeVecDestructorEnumWrapper {
            inner: AzXmlNodeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzXmlNodeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlNodeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzXmlNodeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzXmlNodeVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlNodeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlNodeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzFmtArgVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzFmtArgVecDestructorEnumWrapper {
        AzFmtArgVecDestructorEnumWrapper {
            inner: AzFmtArgVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzFmtArgVecDestructorEnumWrapper {
        AzFmtArgVecDestructorEnumWrapper {
            inner: AzFmtArgVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzFmtArgVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzFmtArgVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzFmtArgVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzFmtArgVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzFmtArgVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtArgVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::str::FmtArgVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineLineVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineLineVecDestructorEnumWrapper {
        AzInlineLineVecDestructorEnumWrapper {
            inner: AzInlineLineVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineLineVecDestructorEnumWrapper {
        AzInlineLineVecDestructorEnumWrapper {
            inner: AzInlineLineVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInlineLineVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineLineVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInlineLineVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInlineLineVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineLineVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineLineVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineLineVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineWordVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineWordVecDestructorEnumWrapper {
        AzInlineWordVecDestructorEnumWrapper {
            inner: AzInlineWordVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineWordVecDestructorEnumWrapper {
        AzInlineWordVecDestructorEnumWrapper {
            inner: AzInlineWordVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInlineWordVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineWordVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInlineWordVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInlineWordVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineWordVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineWordVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineWordVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineGlyphVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineGlyphVecDestructorEnumWrapper {
        AzInlineGlyphVecDestructorEnumWrapper {
            inner: AzInlineGlyphVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineGlyphVecDestructorEnumWrapper {
        AzInlineGlyphVecDestructorEnumWrapper {
            inner: AzInlineGlyphVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInlineGlyphVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineGlyphVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInlineGlyphVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInlineGlyphVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineGlyphVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineGlyphVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineGlyphVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInlineTextHitVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzInlineTextHitVecDestructorEnumWrapper {
        AzInlineTextHitVecDestructorEnumWrapper {
            inner: AzInlineTextHitVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzInlineTextHitVecDestructorEnumWrapper {
        AzInlineTextHitVecDestructorEnumWrapper {
            inner: AzInlineTextHitVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzInlineTextHitVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzInlineTextHitVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzInlineTextHitVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzInlineTextHitVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInlineTextHitVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextHitVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::InlineTextHitVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzMonitorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper {
            inner: AzMonitorVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzMonitorVecDestructorEnumWrapper {
        AzMonitorVecDestructorEnumWrapper {
            inner: AzMonitorVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzMonitorVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzMonitorVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzMonitorVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzMonitorVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzMonitorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::MonitorVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVideoModeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper {
            inner: AzVideoModeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzVideoModeVecDestructorEnumWrapper {
        AzVideoModeVecDestructorEnumWrapper {
            inner: AzVideoModeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzVideoModeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVideoModeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzVideoModeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzVideoModeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVideoModeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VideoModeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDomVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper {
            inner: AzDomVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzDomVecDestructorEnumWrapper {
        AzDomVecDestructorEnumWrapper {
            inner: AzDomVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzDomVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDomVecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzDomVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzDomVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDomVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::DomVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzIdOrClassVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper {
            inner: AzIdOrClassVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzIdOrClassVecDestructorEnumWrapper {
        AzIdOrClassVecDestructorEnumWrapper {
            inner: AzIdOrClassVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzIdOrClassVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzIdOrClassVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzIdOrClassVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzIdOrClassVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzIdOrClassVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::IdOrClassVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
            inner: AzNodeDataInlineCssPropertyVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
        AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
            inner: AzNodeDataInlineCssPropertyVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeDataInlineCssPropertyVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataInlineCssPropertyVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNodeDataInlineCssPropertyVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNodeDataInlineCssPropertyVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataInlineCssPropertyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataInlineCssPropertyVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundContentVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper {
            inner: AzStyleBackgroundContentVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundContentVecDestructorEnumWrapper {
        AzStyleBackgroundContentVecDestructorEnumWrapper {
            inner: AzStyleBackgroundContentVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundContentVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundContentVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundContentVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundContentVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundContentVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContentVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundContentVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundPositionVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper {
            inner: AzStyleBackgroundPositionVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundPositionVecDestructorEnumWrapper {
        AzStyleBackgroundPositionVecDestructorEnumWrapper {
            inner: AzStyleBackgroundPositionVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundPositionVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundPositionVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundPositionVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundPositionVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundPositionVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPositionVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundPositionVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper {
            inner: AzStyleBackgroundRepeatVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundRepeatVecDestructorEnumWrapper {
        AzStyleBackgroundRepeatVecDestructorEnumWrapper {
            inner: AzStyleBackgroundRepeatVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundRepeatVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundRepeatVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundRepeatVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundRepeatVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundRepeatVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeatVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundRepeatVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleBackgroundSizeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper {
            inner: AzStyleBackgroundSizeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleBackgroundSizeVecDestructorEnumWrapper {
        AzStyleBackgroundSizeVecDestructorEnumWrapper {
            inner: AzStyleBackgroundSizeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleBackgroundSizeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleBackgroundSizeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundSizeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyleBackgroundSizeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleBackgroundSizeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleBackgroundSizeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyleTransformVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper {
            inner: AzStyleTransformVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyleTransformVecDestructorEnumWrapper {
        AzStyleTransformVecDestructorEnumWrapper {
            inner: AzStyleTransformVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyleTransformVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyleTransformVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyleTransformVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyleTransformVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyleTransformVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StyleTransformVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPropertyVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssPropertyVecDestructorEnumWrapper {
        AzCssPropertyVecDestructorEnumWrapper {
            inner: AzCssPropertyVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzCssPropertyVecDestructorEnumWrapper {
        AzCssPropertyVecDestructorEnumWrapper {
            inner: AzCssPropertyVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssPropertyVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPropertyVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzCssPropertyVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzCssPropertyVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPropertyVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPropertyVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgMultiPolygonVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper {
            inner: AzSvgMultiPolygonVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgMultiPolygonVecDestructorEnumWrapper {
        AzSvgMultiPolygonVecDestructorEnumWrapper {
            inner: AzSvgMultiPolygonVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgMultiPolygonVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgMultiPolygonVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzSvgMultiPolygonVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzSvgMultiPolygonVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgMultiPolygonVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgMultiPolygonVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgMultiPolygonVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgSimpleNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper {
            inner: AzSvgSimpleNodeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgSimpleNodeVecDestructorEnumWrapper {
        AzSvgSimpleNodeVecDestructorEnumWrapper {
            inner: AzSvgSimpleNodeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgSimpleNodeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgSimpleNodeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzSvgSimpleNodeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzSvgSimpleNodeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgSimpleNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgSimpleNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgSimpleNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper {
            inner: AzSvgPathVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgPathVecDestructorEnumWrapper {
        AzSvgPathVecDestructorEnumWrapper {
            inner: AzSvgPathVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgPathVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzSvgPathVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzSvgPathVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVertexAttributeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper {
            inner: AzVertexAttributeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzVertexAttributeVecDestructorEnumWrapper {
        AzVertexAttributeVecDestructorEnumWrapper {
            inner: AzVertexAttributeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzVertexAttributeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVertexAttributeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzVertexAttributeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzVertexAttributeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVertexAttributeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttributeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::VertexAttributeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgPathElementVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper {
            inner: AzSvgPathElementVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgPathElementVecDestructorEnumWrapper {
        AzSvgPathElementVecDestructorEnumWrapper {
            inner: AzSvgPathElementVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgPathElementVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgPathElementVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzSvgPathElementVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzSvgPathElementVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgPathElementVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathElementVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgPathElementVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgVertexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper {
            inner: AzSvgVertexVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgVertexVecDestructorEnumWrapper {
        AzSvgVertexVecDestructorEnumWrapper {
            inner: AzSvgVertexVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgVertexVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgVertexVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzSvgVertexVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzSvgVertexVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgVertexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVertexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgVertexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgColoredVertexVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzSvgColoredVertexVecDestructorEnumWrapper {
        AzSvgColoredVertexVecDestructorEnumWrapper {
            inner: AzSvgColoredVertexVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzSvgColoredVertexVecDestructorEnumWrapper {
        AzSvgColoredVertexVecDestructorEnumWrapper {
            inner: AzSvgColoredVertexVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgColoredVertexVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgColoredVertexVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzSvgColoredVertexVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzSvgColoredVertexVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgColoredVertexVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgColoredVertexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgColoredVertexVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper {
            inner: AzU32VecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzU32VecDestructorEnumWrapper {
        AzU32VecDestructorEnumWrapper {
            inner: AzU32VecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzU32VecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU32VecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzU32VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U32VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U32VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXWindowTypeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper {
            inner: AzXWindowTypeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzXWindowTypeVecDestructorEnumWrapper {
        AzXWindowTypeVecDestructorEnumWrapper {
            inner: AzXWindowTypeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzXWindowTypeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXWindowTypeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzXWindowTypeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzXWindowTypeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXWindowTypeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XWindowTypeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::XWindowTypeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzVirtualKeyCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper {
            inner: AzVirtualKeyCodeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzVirtualKeyCodeVecDestructorEnumWrapper {
        AzVirtualKeyCodeVecDestructorEnumWrapper {
            inner: AzVirtualKeyCodeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzVirtualKeyCodeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzVirtualKeyCodeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzVirtualKeyCodeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzVirtualKeyCodeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzVirtualKeyCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::VirtualKeyCodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCascadeInfoVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper {
            inner: AzCascadeInfoVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzCascadeInfoVecDestructorEnumWrapper {
        AzCascadeInfoVecDestructorEnumWrapper {
            inner: AzCascadeInfoVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCascadeInfoVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCascadeInfoVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzCascadeInfoVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzCascadeInfoVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCascadeInfoVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::style::CascadeInfoVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzScanCodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper {
            inner: AzScanCodeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzScanCodeVecDestructorEnumWrapper {
        AzScanCodeVecDestructorEnumWrapper {
            inner: AzScanCodeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzScanCodeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzScanCodeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzScanCodeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzScanCodeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzScanCodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::ScanCodeVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssDeclarationVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper {
            inner: AzCssDeclarationVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzCssDeclarationVecDestructorEnumWrapper {
        AzCssDeclarationVecDestructorEnumWrapper {
            inner: AzCssDeclarationVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssDeclarationVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssDeclarationVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzCssDeclarationVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzCssDeclarationVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssDeclarationVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssDeclarationVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssPathSelectorVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper {
            inner: AzCssPathSelectorVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzCssPathSelectorVecDestructorEnumWrapper {
        AzCssPathSelectorVecDestructorEnumWrapper {
            inner: AzCssPathSelectorVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssPathSelectorVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssPathSelectorVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzCssPathSelectorVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzCssPathSelectorVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssPathSelectorVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssPathSelectorVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStylesheetVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper {
            inner: AzStylesheetVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStylesheetVecDestructorEnumWrapper {
        AzStylesheetVecDestructorEnumWrapper {
            inner: AzStylesheetVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStylesheetVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStylesheetVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStylesheetVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStylesheetVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStylesheetVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StylesheetVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCssRuleBlockVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper {
            inner: AzCssRuleBlockVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzCssRuleBlockVecDestructorEnumWrapper {
        AzCssRuleBlockVecDestructorEnumWrapper {
            inner: AzCssRuleBlockVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCssRuleBlockVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCssRuleBlockVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzCssRuleBlockVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzCssRuleBlockVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCssRuleBlockVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::CssRuleBlockVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzF32VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper {
            inner: AzF32VecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzF32VecDestructorEnumWrapper {
        AzF32VecDestructorEnumWrapper {
            inner: AzF32VecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzF32VecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzF32VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzF32VecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzF32VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzF32VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::F32VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::F32VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU16VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper {
            inner: AzU16VecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzU16VecDestructorEnumWrapper {
        AzU16VecDestructorEnumWrapper {
            inner: AzU16VecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzU16VecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU16VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU16VecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzU16VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU16VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U16VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U16VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzU8VecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper {
            inner: AzU8VecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzU8VecDestructorEnumWrapper {
        AzU8VecDestructorEnumWrapper {
            inner: AzU8VecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzU8VecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzU8VecDestructor::DefaultRust => Ok(vec!["DefaultRust".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::NoDestructor => Ok(vec!["NoDestructor".into_py(py), ().into_py(py)]),
            AzU8VecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzU8VecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U8VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::U8VecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzCallbackDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzCallbackDataVecDestructorEnumWrapper {
        AzCallbackDataVecDestructorEnumWrapper {
            inner: AzCallbackDataVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzCallbackDataVecDestructorEnumWrapper {
        AzCallbackDataVecDestructorEnumWrapper {
            inner: AzCallbackDataVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzCallbackDataVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzCallbackDataVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzCallbackDataVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzCallbackDataVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzCallbackDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::CallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::CallbackDataVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDebugMessageVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzDebugMessageVecDestructorEnumWrapper {
        AzDebugMessageVecDestructorEnumWrapper {
            inner: AzDebugMessageVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzDebugMessageVecDestructorEnumWrapper {
        AzDebugMessageVecDestructorEnumWrapper {
            inner: AzDebugMessageVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzDebugMessageVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzDebugMessageVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzDebugMessageVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzDebugMessageVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDebugMessageVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::AzDebugMessageVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLuintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper {
            inner: AzGLuintVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzGLuintVecDestructorEnumWrapper {
        AzGLuintVecDestructorEnumWrapper {
            inner: AzGLuintVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzGLuintVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLuintVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzGLuintVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzGLuintVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLuintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLuintVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzGLintVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper {
            inner: AzGLintVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzGLintVecDestructorEnumWrapper {
        AzGLintVecDestructorEnumWrapper {
            inner: AzGLintVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzGLintVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzGLintVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzGLintVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzGLintVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzGLintVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::GLintVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper {
            inner: AzStringVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStringVecDestructorEnumWrapper {
        AzStringVecDestructorEnumWrapper {
            inner: AzStringVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStringVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStringVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStringVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StringVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::StringVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStringPairVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper {
            inner: AzStringPairVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStringPairVecDestructorEnumWrapper {
        AzStringPairVecDestructorEnumWrapper {
            inner: AzStringPairVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStringPairVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStringPairVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStringPairVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStringPairVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStringPairVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::StringPairVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper {
            inner: AzNormalizedLinearColorStopVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNormalizedLinearColorStopVecDestructorEnumWrapper {
        AzNormalizedLinearColorStopVecDestructorEnumWrapper {
            inner: AzNormalizedLinearColorStopVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNormalizedLinearColorStopVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedLinearColorStopVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNormalizedLinearColorStopVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNormalizedLinearColorStopVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedLinearColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedLinearColorStopVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedLinearColorStopVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper {
            inner: AzNormalizedRadialColorStopVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNormalizedRadialColorStopVecDestructorEnumWrapper {
        AzNormalizedRadialColorStopVecDestructorEnumWrapper {
            inner: AzNormalizedRadialColorStopVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNormalizedRadialColorStopVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNormalizedRadialColorStopVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNormalizedRadialColorStopVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNormalizedRadialColorStopVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNormalizedRadialColorStopVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedRadialColorStopVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::NormalizedRadialColorStopVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeIdVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper {
            inner: AzNodeIdVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeIdVecDestructorEnumWrapper {
        AzNodeIdVecDestructorEnumWrapper {
            inner: AzNodeIdVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeIdVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeIdVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNodeIdVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNodeIdVecDestructor::External(v) => Ok(vec!["External".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeIdVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeIdVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeHierarchyItemVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper {
            inner: AzNodeHierarchyItemVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeHierarchyItemVecDestructorEnumWrapper {
        AzNodeHierarchyItemVecDestructorEnumWrapper {
            inner: AzNodeHierarchyItemVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeHierarchyItemVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeHierarchyItemVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNodeHierarchyItemVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNodeHierarchyItemVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeHierarchyItemVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItemVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::NodeHierarchyItemVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzStyledNodeVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper {
            inner: AzStyledNodeVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzStyledNodeVecDestructorEnumWrapper {
        AzStyledNodeVecDestructorEnumWrapper {
            inner: AzStyledNodeVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzStyledNodeVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzStyledNodeVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzStyledNodeVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzStyledNodeVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzStyledNodeVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::StyledNodeVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
            inner: AzTagIdToNodeIdMappingVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
        AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
            inner: AzTagIdToNodeIdMappingVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzTagIdToNodeIdMappingVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzTagIdToNodeIdMappingVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzTagIdToNodeIdMappingVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzTagIdToNodeIdMappingVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzTagIdToNodeIdMappingVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::TagIdToNodeIdMappingVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzParentWithNodeDepthVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper {
            inner: AzParentWithNodeDepthVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzParentWithNodeDepthVecDestructorEnumWrapper {
        AzParentWithNodeDepthVecDestructorEnumWrapper {
            inner: AzParentWithNodeDepthVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzParentWithNodeDepthVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzParentWithNodeDepthVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzParentWithNodeDepthVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzParentWithNodeDepthVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzParentWithNodeDepthVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::ParentWithNodeDepthVecDestructor =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNodeDataVecDestructorEnumWrapper {
    #[classattr]
    fn DefaultRust() -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper {
            inner: AzNodeDataVecDestructor::DefaultRust,
        }
    }
    #[classattr]
    fn NoDestructor() -> AzNodeDataVecDestructorEnumWrapper {
        AzNodeDataVecDestructorEnumWrapper {
            inner: AzNodeDataVecDestructor::NoDestructor,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzNodeDataVecDestructor;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzNodeDataVecDestructor::DefaultRust => {
                Ok(vec!["DefaultRust".into_py(py), ().into_py(py)])
            }
            AzNodeDataVecDestructor::NoDestructor => {
                Ok(vec!["NoDestructor".into_py(py), ().into_py(py)])
            }
            AzNodeDataVecDestructor::External(v) => {
                Ok(vec!["External".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNodeDataVecDestructorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::NodeDataVecDestructor = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSvgPointEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSvgPointEnumWrapper {
        AzOptionSvgPointEnumWrapper {
            inner: AzOptionSvgPoint::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzSvgPoint) -> AzOptionSvgPointEnumWrapper {
        AzOptionSvgPointEnumWrapper {
            inner: AzOptionSvgPoint::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionSvgPoint;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSvgPoint::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSvgPoint::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSvgPointEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionSvgPoint = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionSvgPoint = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStyleTextAlignEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStyleTextAlignEnumWrapper {
        AzOptionStyleTextAlignEnumWrapper {
            inner: AzOptionStyleTextAlign::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzStyleTextAlignEnumWrapper) -> AzOptionStyleTextAlignEnumWrapper {
        AzOptionStyleTextAlignEnumWrapper {
            inner: AzOptionStyleTextAlign::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionStyleTextAlign;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionStyleTextAlign::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionStyleTextAlign::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzStyleTextAlignEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStyleTextAlignEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionStyleTextAlign = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionStyleTextAlign = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnRowClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnRowClickEnumWrapper {
        AzOptionListViewOnRowClickEnumWrapper {
            inner: AzOptionListViewOnRowClick::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzListViewOnRowClick) -> AzOptionListViewOnRowClickEnumWrapper {
        AzOptionListViewOnRowClickEnumWrapper {
            inner: AzOptionListViewOnRowClick::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionListViewOnRowClick;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnRowClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnRowClick::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnRowClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::OptionListViewOnRowClick =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::OptionListViewOnRowClick =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnColumnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnColumnClickEnumWrapper {
        AzOptionListViewOnColumnClickEnumWrapper {
            inner: AzOptionListViewOnColumnClick::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzListViewOnColumnClick) -> AzOptionListViewOnColumnClickEnumWrapper {
        AzOptionListViewOnColumnClickEnumWrapper {
            inner: AzOptionListViewOnColumnClick::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionListViewOnColumnClick;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnColumnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnColumnClick::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnColumnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::OptionListViewOnColumnClick =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::OptionListViewOnColumnClick =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionListViewOnLazyLoadScrollEnumWrapper {
    #[classattr]
    fn None() -> AzOptionListViewOnLazyLoadScrollEnumWrapper {
        AzOptionListViewOnLazyLoadScrollEnumWrapper {
            inner: AzOptionListViewOnLazyLoadScroll::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzListViewOnLazyLoadScroll) -> AzOptionListViewOnLazyLoadScrollEnumWrapper {
        AzOptionListViewOnLazyLoadScrollEnumWrapper {
            inner: AzOptionListViewOnLazyLoadScroll::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionListViewOnLazyLoadScroll;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionListViewOnLazyLoadScroll::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionListViewOnLazyLoadScroll::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionListViewOnLazyLoadScrollEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::OptionListViewOnLazyLoadScroll =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::list_view::OptionListViewOnLazyLoadScroll =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuEnumWrapper {
        AzOptionMenuEnumWrapper {
            inner: AzOptionMenu::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzMenu) -> AzOptionMenuEnumWrapper {
        AzOptionMenuEnumWrapper {
            inner: AzOptionMenu::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionMenu;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenu::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenu::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMenu = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMenu = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPixelValueNoPercentEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPixelValueNoPercentEnumWrapper {
        AzOptionPixelValueNoPercentEnumWrapper {
            inner: AzOptionPixelValueNoPercent::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzPixelValueNoPercent) -> AzOptionPixelValueNoPercentEnumWrapper {
        AzOptionPixelValueNoPercentEnumWrapper {
            inner: AzOptionPixelValueNoPercent::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionPixelValueNoPercent;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPixelValueNoPercent::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPixelValueNoPercent::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPixelValueNoPercentEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionPixelValueNoPercent = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDropDownOnChoiceChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDropDownOnChoiceChangeEnumWrapper {
        AzOptionDropDownOnChoiceChangeEnumWrapper {
            inner: AzOptionDropDownOnChoiceChange::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzDropDownOnChoiceChange) -> AzOptionDropDownOnChoiceChangeEnumWrapper {
        AzOptionDropDownOnChoiceChangeEnumWrapper {
            inner: AzOptionDropDownOnChoiceChange::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionDropDownOnChoiceChange;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDropDownOnChoiceChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDropDownOnChoiceChange::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDropDownOnChoiceChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::OptionDropDownOnChoiceChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::drop_down::OptionDropDownOnChoiceChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionResolvedTextLayoutOptionsEnumWrapper {
    #[classattr]
    fn None() -> AzOptionResolvedTextLayoutOptionsEnumWrapper {
        AzOptionResolvedTextLayoutOptionsEnumWrapper {
            inner: AzOptionResolvedTextLayoutOptions::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzResolvedTextLayoutOptions) -> AzOptionResolvedTextLayoutOptionsEnumWrapper {
        AzOptionResolvedTextLayoutOptionsEnumWrapper {
            inner: AzOptionResolvedTextLayoutOptions::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionResolvedTextLayoutOptions;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionResolvedTextLayoutOptions::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionResolvedTextLayoutOptions::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionResolvedTextLayoutOptionsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::OptionResolvedTextLayoutOptions =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::OptionResolvedTextLayoutOptions =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeAddedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeAddedEnumWrapper {
        AzOptionNodeGraphOnNodeAddedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeAdded::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeAdded) -> AzOptionNodeGraphOnNodeAddedEnumWrapper {
        AzOptionNodeGraphOnNodeAddedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeAdded::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeAdded;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeAdded::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeAdded::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeAddedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeAdded =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeAdded =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeRemovedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeRemovedEnumWrapper {
        AzOptionNodeGraphOnNodeRemovedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeRemoved::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeRemoved) -> AzOptionNodeGraphOnNodeRemovedEnumWrapper {
        AzOptionNodeGraphOnNodeRemovedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeRemoved::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeRemoved;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeRemoved::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeRemoved::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeRemovedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeRemoved =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeRemoved =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
        AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeGraphDragged::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeGraphDragged) -> AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
        AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeGraphDragged::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeGraphDragged;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeGraphDragged::None => {
                Ok(vec!["None".into_py(py), ().into_py(py)])
            }
            AzOptionNodeGraphOnNodeGraphDragged::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeGraphDragged =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeGraphDragged =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeDraggedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeDraggedEnumWrapper {
        AzOptionNodeGraphOnNodeDraggedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeDragged::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeDragged) -> AzOptionNodeGraphOnNodeDraggedEnumWrapper {
        AzOptionNodeGraphOnNodeDraggedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeDragged::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeDragged;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeDragged::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeDragged::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeDraggedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeDragged =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeDragged =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeConnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeConnectedEnumWrapper {
        AzOptionNodeGraphOnNodeConnectedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeConnected::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeConnected) -> AzOptionNodeGraphOnNodeConnectedEnumWrapper {
        AzOptionNodeGraphOnNodeConnectedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeConnected::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeConnected;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeConnected::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeGraphOnNodeConnected::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeConnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeConnected =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeConnected =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
        AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeInputDisconnected::None,
        }
    }
    #[staticmethod]
    fn Some(
        v: AzNodeGraphOnNodeInputDisconnected,
    ) -> AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
        AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeInputDisconnected::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeInputDisconnected;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeInputDisconnected::None => {
                Ok(vec!["None".into_py(py), ().into_py(py)])
            }
            AzOptionNodeGraphOnNodeInputDisconnected::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeInputDisconnected =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeInputDisconnected =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
        AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeOutputDisconnected::None,
        }
    }
    #[staticmethod]
    fn Some(
        v: AzNodeGraphOnNodeOutputDisconnected,
    ) -> AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
        AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeOutputDisconnected::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeOutputDisconnected;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeOutputDisconnected::None => {
                Ok(vec!["None".into_py(py), ().into_py(py)])
            }
            AzOptionNodeGraphOnNodeOutputDisconnected::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeOutputDisconnected =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
        AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeFieldEdited::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNodeGraphOnNodeFieldEdited) -> AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
        AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
            inner: AzOptionNodeGraphOnNodeFieldEdited::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeGraphOnNodeFieldEdited;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeGraphOnNodeFieldEdited::None => {
                Ok(vec!["None".into_py(py), ().into_py(py)])
            }
            AzOptionNodeGraphOnNodeFieldEdited::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeGraphOnNodeFieldEditedEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeFieldEdited =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::node_graph::OptionOnNodeFieldEdited =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorInputOnValueChangeEnumWrapper {
        AzOptionColorInputOnValueChangeEnumWrapper {
            inner: AzOptionColorInputOnValueChange::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzColorInputOnValueChange) -> AzOptionColorInputOnValueChangeEnumWrapper {
        AzOptionColorInputOnValueChangeEnumWrapper {
            inner: AzOptionColorInputOnValueChange::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionColorInputOnValueChange;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorInputOnValueChange::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::OptionColorInputOnValueChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::color_input::OptionColorInputOnValueChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionButtonOnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionButtonOnClickEnumWrapper {
        AzOptionButtonOnClickEnumWrapper {
            inner: AzOptionButtonOnClick::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzButtonOnClick) -> AzOptionButtonOnClickEnumWrapper {
        AzOptionButtonOnClickEnumWrapper {
            inner: AzOptionButtonOnClick::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionButtonOnClick;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionButtonOnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionButtonOnClick::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionButtonOnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::button::OptionButtonOnClick =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::button::OptionButtonOnClick =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTabOnClickEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTabOnClickEnumWrapper {
        AzOptionTabOnClickEnumWrapper {
            inner: AzOptionTabOnClick::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTabOnClick) -> AzOptionTabOnClickEnumWrapper {
        AzOptionTabOnClickEnumWrapper {
            inner: AzOptionTabOnClick::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTabOnClick;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTabOnClick::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTabOnClick::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTabOnClickEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::tabs::OptionTabOnClick = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileInputOnPathChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileInputOnPathChangeEnumWrapper {
        AzOptionFileInputOnPathChangeEnumWrapper {
            inner: AzOptionFileInputOnPathChange::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzFileInputOnPathChange) -> AzOptionFileInputOnPathChangeEnumWrapper {
        AzOptionFileInputOnPathChangeEnumWrapper {
            inner: AzOptionFileInputOnPathChange::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionFileInputOnPathChange;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFileInputOnPathChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFileInputOnPathChange::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileInputOnPathChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::OptionFileInputOnPathChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::file_input::OptionFileInputOnPathChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCheckBoxOnToggleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCheckBoxOnToggleEnumWrapper {
        AzOptionCheckBoxOnToggleEnumWrapper {
            inner: AzOptionCheckBoxOnToggle::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzCheckBoxOnToggle) -> AzOptionCheckBoxOnToggleEnumWrapper {
        AzOptionCheckBoxOnToggleEnumWrapper {
            inner: AzOptionCheckBoxOnToggle::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionCheckBoxOnToggle;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCheckBoxOnToggle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCheckBoxOnToggle::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCheckBoxOnToggleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::OptionCheckBoxOnToggle =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::check_box::OptionCheckBoxOnToggle =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnTextInputEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnTextInputEnumWrapper {
        AzOptionTextInputOnTextInputEnumWrapper {
            inner: AzOptionTextInputOnTextInput::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTextInputOnTextInput) -> AzOptionTextInputOnTextInputEnumWrapper {
        AzOptionTextInputOnTextInputEnumWrapper {
            inner: AzOptionTextInputOnTextInput::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTextInputOnTextInput;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnTextInput::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnTextInput::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnTextInputEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputOnTextInput =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputOnTextInput =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnVirtualKeyDownEnumWrapper {
        AzOptionTextInputOnVirtualKeyDownEnumWrapper {
            inner: AzOptionTextInputOnVirtualKeyDown::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTextInputOnVirtualKeyDown) -> AzOptionTextInputOnVirtualKeyDownEnumWrapper {
        AzOptionTextInputOnVirtualKeyDownEnumWrapper {
            inner: AzOptionTextInputOnVirtualKeyDown::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTextInputOnVirtualKeyDown;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnVirtualKeyDown::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnVirtualKeyDown::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnVirtualKeyDownEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputOnVirtualKeyDown =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputOnFocusLostEnumWrapper {
        AzOptionTextInputOnFocusLostEnumWrapper {
            inner: AzOptionTextInputOnFocusLost::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTextInputOnFocusLost) -> AzOptionTextInputOnFocusLostEnumWrapper {
        AzOptionTextInputOnFocusLostEnumWrapper {
            inner: AzOptionTextInputOnFocusLost::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTextInputOnFocusLost;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputOnFocusLost::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputOnFocusLost =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputOnFocusLost =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextInputSelectionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextInputSelectionEnumWrapper {
        AzOptionTextInputSelectionEnumWrapper {
            inner: AzOptionTextInputSelection::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTextInputSelectionEnumWrapper) -> AzOptionTextInputSelectionEnumWrapper {
        AzOptionTextInputSelectionEnumWrapper {
            inner: AzOptionTextInputSelection::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTextInputSelection;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTextInputSelection::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTextInputSelection::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzTextInputSelectionEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextInputSelectionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputSelection =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::text_input::OptionTextInputSelection =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnFocusLostEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnFocusLostEnumWrapper {
        AzOptionNumberInputOnFocusLostEnumWrapper {
            inner: AzOptionNumberInputOnFocusLost::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNumberInputOnFocusLost) -> AzOptionNumberInputOnFocusLostEnumWrapper {
        AzOptionNumberInputOnFocusLostEnumWrapper {
            inner: AzOptionNumberInputOnFocusLost::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNumberInputOnFocusLost;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnFocusLost::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnFocusLost::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnFocusLostEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::OptionNumberInputOnFocusLost =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::OptionNumberInputOnFocusLost =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNumberInputOnValueChangeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNumberInputOnValueChangeEnumWrapper {
        AzOptionNumberInputOnValueChangeEnumWrapper {
            inner: AzOptionNumberInputOnValueChange::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNumberInputOnValueChange) -> AzOptionNumberInputOnValueChangeEnumWrapper {
        AzOptionNumberInputOnValueChangeEnumWrapper {
            inner: AzOptionNumberInputOnValueChange::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNumberInputOnValueChange;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNumberInputOnValueChange::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNumberInputOnValueChange::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNumberInputOnValueChangeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::OptionNumberInputOnValueChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::widgets::number_input::OptionNumberInputOnValueChange =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuItemIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuItemIconEnumWrapper {
        AzOptionMenuItemIconEnumWrapper {
            inner: AzOptionMenuItemIcon::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzMenuItemIconEnumWrapper) -> AzOptionMenuItemIconEnumWrapper {
        AzOptionMenuItemIconEnumWrapper {
            inner: AzOptionMenuItemIcon::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionMenuItemIcon;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenuItemIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenuItemIcon::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzMenuItemIconEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuItemIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMenuItemIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMenuCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMenuCallbackEnumWrapper {
        AzOptionMenuCallbackEnumWrapper {
            inner: AzOptionMenuCallback::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzMenuCallback) -> AzOptionMenuCallbackEnumWrapper {
        AzOptionMenuCallbackEnumWrapper {
            inner: AzOptionMenuCallback::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionMenuCallback;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMenuCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMenuCallback::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMenuCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMenuCallback = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMenuCallback = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeComboEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeComboEnumWrapper {
        AzOptionVirtualKeyCodeComboEnumWrapper {
            inner: AzOptionVirtualKeyCodeCombo::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzVirtualKeyCodeCombo) -> AzOptionVirtualKeyCodeComboEnumWrapper {
        AzOptionVirtualKeyCodeComboEnumWrapper {
            inner: AzOptionVirtualKeyCodeCombo::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionVirtualKeyCodeCombo;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCodeCombo::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCodeCombo::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeComboEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionVirtualKeyCodeCombo =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionVirtualKeyCodeCombo =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCssPropertyEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCssPropertyEnumWrapper {
        AzOptionCssPropertyEnumWrapper {
            inner: AzOptionCssProperty::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzCssPropertyEnumWrapper) -> AzOptionCssPropertyEnumWrapper {
        AzOptionCssPropertyEnumWrapper {
            inner: AzOptionCssProperty::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionCssProperty;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCssProperty::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCssProperty::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzCssPropertyEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCssPropertyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionCssProperty = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionCssProperty = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPositionInfoEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPositionInfoEnumWrapper {
        AzOptionPositionInfoEnumWrapper {
            inner: AzOptionPositionInfo::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzPositionInfoEnumWrapper) -> AzOptionPositionInfoEnumWrapper {
        AzOptionPositionInfoEnumWrapper {
            inner: AzOptionPositionInfo::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionPositionInfo;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPositionInfo::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPositionInfo::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzPositionInfoEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPositionInfoEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::OptionPositionInfo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::ui_solver::OptionPositionInfo = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTimerIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTimerIdEnumWrapper {
        AzOptionTimerIdEnumWrapper {
            inner: AzOptionTimerId::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTimerId) -> AzOptionTimerIdEnumWrapper {
        AzOptionTimerIdEnumWrapper {
            inner: AzOptionTimerId::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTimerId;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTimerId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTimerId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTimerIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionTimerId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadIdEnumWrapper {
        AzOptionThreadIdEnumWrapper {
            inner: AzOptionThreadId::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzThreadId) -> AzOptionThreadIdEnumWrapper {
        AzOptionThreadIdEnumWrapper {
            inner: AzOptionThreadId::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionThreadId;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionThreadId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionThreadId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI16EnumWrapper {
        AzOptionI16EnumWrapper {
            inner: AzOptionI16::None,
        }
    }
    #[staticmethod]
    fn Some(v: i16) -> AzOptionI16EnumWrapper {
        AzOptionI16EnumWrapper {
            inner: AzOptionI16::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionI16;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionI16 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionI16 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU16EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU16EnumWrapper {
        AzOptionU16EnumWrapper {
            inner: AzOptionU16::None,
        }
    }
    #[staticmethod]
    fn Some(v: u16) -> AzOptionU16EnumWrapper {
        AzOptionU16EnumWrapper {
            inner: AzOptionU16::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionU16;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU16::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU16::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU16EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionU16 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionU16 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionU32EnumWrapper {
        AzOptionU32EnumWrapper {
            inner: AzOptionU32::None,
        }
    }
    #[staticmethod]
    fn Some(v: u32) -> AzOptionU32EnumWrapper {
        AzOptionU32EnumWrapper {
            inner: AzOptionU32::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionU32;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionU32 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionU32 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionImageRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionImageRefEnumWrapper {
        AzOptionImageRefEnumWrapper {
            inner: AzOptionImageRef::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzImageRef) -> AzOptionImageRefEnumWrapper {
        AzOptionImageRefEnumWrapper {
            inner: AzOptionImageRef::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionImageRef;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionImageRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionImageRef::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionImageRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::OptionImageRef = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFontRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFontRefEnumWrapper {
        AzOptionFontRefEnumWrapper {
            inner: AzOptionFontRef::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzFontRef) -> AzOptionFontRefEnumWrapper {
        AzOptionFontRefEnumWrapper {
            inner: AzOptionFontRef::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionFontRef;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFontRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFontRef::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFontRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionFontRef = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionFontRef = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSystemClipboardEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSystemClipboardEnumWrapper {
        AzOptionSystemClipboardEnumWrapper {
            inner: AzOptionSystemClipboard::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzSystemClipboard) -> AzOptionSystemClipboardEnumWrapper {
        AzOptionSystemClipboardEnumWrapper {
            inner: AzOptionSystemClipboard::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionSystemClipboard;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSystemClipboard::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSystemClipboard::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSystemClipboardEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::app::OptionClipboard = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::app::OptionClipboard = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileTypeListEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileTypeListEnumWrapper {
        AzOptionFileTypeListEnumWrapper {
            inner: AzOptionFileTypeList::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzFileTypeList) -> AzOptionFileTypeListEnumWrapper {
        AzOptionFileTypeListEnumWrapper {
            inner: AzOptionFileTypeList::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionFileTypeList;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFileTypeList::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFileTypeList::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileTypeListEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::OptionFileTypeList =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::dialogs::OptionFileTypeList =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowStateEnumWrapper {
        AzOptionWindowStateEnumWrapper {
            inner: AzOptionWindowState::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzWindowState) -> AzOptionWindowStateEnumWrapper {
        AzOptionWindowStateEnumWrapper {
            inner: AzOptionWindowState::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionWindowState;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowState::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWindowState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWindowState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMouseStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMouseStateEnumWrapper {
        AzOptionMouseStateEnumWrapper {
            inner: AzOptionMouseState::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzMouseState) -> AzOptionMouseStateEnumWrapper {
        AzOptionMouseStateEnumWrapper {
            inner: AzOptionMouseState::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionMouseState;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMouseState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMouseState::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMouseStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMouseState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMouseState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionKeyboardStateEnumWrapper {
    #[classattr]
    fn None() -> AzOptionKeyboardStateEnumWrapper {
        AzOptionKeyboardStateEnumWrapper {
            inner: AzOptionKeyboardState::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzKeyboardState) -> AzOptionKeyboardStateEnumWrapper {
        AzOptionKeyboardStateEnumWrapper {
            inner: AzOptionKeyboardState::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionKeyboardState;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionKeyboardState::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionKeyboardState::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionKeyboardStateEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionKeyboardState = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStringVecEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStringVecEnumWrapper {
        AzOptionStringVecEnumWrapper {
            inner: AzOptionStringVec::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzStringVec) -> AzOptionStringVecEnumWrapper {
        AzOptionStringVecEnumWrapper {
            inner: AzOptionStringVec::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionStringVec;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionStringVec::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionStringVec::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStringVecEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionStringVec = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionStringVec = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionFileEnumWrapper {
    #[classattr]
    fn None() -> AzOptionFileEnumWrapper {
        AzOptionFileEnumWrapper {
            inner: AzOptionFile::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzFile) -> AzOptionFileEnumWrapper {
        AzOptionFileEnumWrapper {
            inner: AzOptionFile::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionFile;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionFile::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionFile::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionFileEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::file::OptionFile = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &crate::azul_impl::file::OptionFile = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionGlEnumWrapper {
    #[classattr]
    fn None() -> AzOptionGlEnumWrapper {
        AzOptionGlEnumWrapper {
            inner: AzOptionGl::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzGl) -> AzOptionGlEnumWrapper {
        AzOptionGlEnumWrapper {
            inner: AzOptionGl::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionGl;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionGl::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionGl::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionGlEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionGlContextPtr = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionGlContextPtr = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadReceiveMsgEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadReceiveMsgEnumWrapper {
        AzOptionThreadReceiveMsgEnumWrapper {
            inner: AzOptionThreadReceiveMsg::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzThreadReceiveMsgEnumWrapper) -> AzOptionThreadReceiveMsgEnumWrapper {
        AzOptionThreadReceiveMsgEnumWrapper {
            inner: AzOptionThreadReceiveMsg::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionThreadReceiveMsg;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadReceiveMsg::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadReceiveMsg::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzThreadReceiveMsgEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadReceiveMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionThreadReceiveMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionThreadReceiveMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPercentageValueEnumWrapper {
    #[classattr]
    fn None() -> AzOptionPercentageValueEnumWrapper {
        AzOptionPercentageValueEnumWrapper {
            inner: AzOptionPercentageValue::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzPercentageValue) -> AzOptionPercentageValueEnumWrapper {
        AzOptionPercentageValueEnumWrapper {
            inner: AzOptionPercentageValue::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionPercentageValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPercentageValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPercentageValue::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPercentageValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionPercentageValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionPercentageValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionAngleValueEnumWrapper {
    #[classattr]
    fn None() -> AzOptionAngleValueEnumWrapper {
        AzOptionAngleValueEnumWrapper {
            inner: AzOptionAngleValue::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzAngleValue) -> AzOptionAngleValueEnumWrapper {
        AzOptionAngleValueEnumWrapper {
            inner: AzOptionAngleValue::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionAngleValue;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionAngleValue::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionAngleValue::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionAngleValueEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionAngleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionAngleValue = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRendererOptionsEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRendererOptionsEnumWrapper {
        AzOptionRendererOptionsEnumWrapper {
            inner: AzOptionRendererOptions::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzRendererOptions) -> AzOptionRendererOptionsEnumWrapper {
        AzOptionRendererOptionsEnumWrapper {
            inner: AzOptionRendererOptions::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionRendererOptions;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRendererOptions::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRendererOptions::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRendererOptionsEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionRendererOptions = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCallbackEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCallbackEnumWrapper {
        AzOptionCallbackEnumWrapper {
            inner: AzOptionCallback::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzCallback) -> AzOptionCallbackEnumWrapper {
        AzOptionCallbackEnumWrapper {
            inner: AzOptionCallback::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionCallback;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionCallback::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionCallback::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCallbackEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionCallback = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionThreadSendMsgEnumWrapper {
    #[classattr]
    fn None() -> AzOptionThreadSendMsgEnumWrapper {
        AzOptionThreadSendMsgEnumWrapper {
            inner: AzOptionThreadSendMsg::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzThreadSendMsgEnumWrapper) -> AzOptionThreadSendMsgEnumWrapper {
        AzOptionThreadSendMsgEnumWrapper {
            inner: AzOptionThreadSendMsg::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionThreadSendMsg;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionThreadSendMsg::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionThreadSendMsg::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzThreadSendMsgEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionThreadSendMsgEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionThreadSendMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionThreadSendMsg = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutRectEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutRectEnumWrapper {
        AzOptionLayoutRectEnumWrapper {
            inner: AzOptionLayoutRect::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzLayoutRect) -> AzOptionLayoutRectEnumWrapper {
        AzOptionLayoutRectEnumWrapper {
            inner: AzOptionLayoutRect::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionLayoutRect;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutRect::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutRect::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutRectEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionLayoutRect = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionLayoutRect = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRefAnyEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRefAnyEnumWrapper {
        AzOptionRefAnyEnumWrapper {
            inner: AzOptionRefAny::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzRefAny) -> AzOptionRefAnyEnumWrapper {
        AzOptionRefAnyEnumWrapper {
            inner: AzOptionRefAny::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionRefAny;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRefAny::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRefAny::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRefAnyEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionRefAny = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionRefAny = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionInlineTextEnumWrapper {
    #[classattr]
    fn None() -> AzOptionInlineTextEnumWrapper {
        AzOptionInlineTextEnumWrapper {
            inner: AzOptionInlineText::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzInlineText) -> AzOptionInlineTextEnumWrapper {
        AzOptionInlineTextEnumWrapper {
            inner: AzOptionInlineText::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionInlineText;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionInlineText::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionInlineText::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionInlineTextEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionInlineText = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionInlineText = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutPointEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutPointEnumWrapper {
        AzOptionLayoutPointEnumWrapper {
            inner: AzOptionLayoutPoint::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzLayoutPoint) -> AzOptionLayoutPointEnumWrapper {
        AzOptionLayoutPointEnumWrapper {
            inner: AzOptionLayoutPoint::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionLayoutPoint;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutPoint::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutPoint::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutPointEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionLayoutPoint = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionLayoutPoint = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLayoutSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLayoutSizeEnumWrapper {
        AzOptionLayoutSizeEnumWrapper {
            inner: AzOptionLayoutSize::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzLayoutSize) -> AzOptionLayoutSizeEnumWrapper {
        AzOptionLayoutSizeEnumWrapper {
            inner: AzOptionLayoutSize::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionLayoutSize;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLayoutSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLayoutSize::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLayoutSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionLayoutSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionLayoutSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowThemeEnumWrapper {
        AzOptionWindowThemeEnumWrapper {
            inner: AzOptionWindowTheme::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzWindowThemeEnumWrapper) -> AzOptionWindowThemeEnumWrapper {
        AzOptionWindowThemeEnumWrapper {
            inner: AzOptionWindowTheme::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionWindowTheme;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowTheme::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzWindowThemeEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWindowTheme = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionNodeIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionNodeIdEnumWrapper {
        AzOptionNodeIdEnumWrapper {
            inner: AzOptionNodeId::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzNodeId) -> AzOptionNodeIdEnumWrapper {
        AzOptionNodeIdEnumWrapper {
            inner: AzOptionNodeId::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionNodeId;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionNodeId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionNodeId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionNodeIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::OptionNodeId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::OptionNodeId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDomNodeIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDomNodeIdEnumWrapper {
        AzOptionDomNodeIdEnumWrapper {
            inner: AzOptionDomNodeId::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzDomNodeId) -> AzOptionDomNodeIdEnumWrapper {
        AzOptionDomNodeIdEnumWrapper {
            inner: AzOptionDomNodeId::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionDomNodeId;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDomNodeId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDomNodeId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDomNodeIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionDomNodeId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::callbacks::OptionDomNodeId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionColorUEnumWrapper {
    #[classattr]
    fn None() -> AzOptionColorUEnumWrapper {
        AzOptionColorUEnumWrapper {
            inner: AzOptionColorU::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzColorU) -> AzOptionColorUEnumWrapper {
        AzOptionColorUEnumWrapper {
            inner: AzOptionColorU::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionColorU;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionColorU::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionColorU::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionColorUEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionColorU = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionColorU = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionRawImageEnumWrapper {
    #[classattr]
    fn None() -> AzOptionRawImageEnumWrapper {
        AzOptionRawImageEnumWrapper {
            inner: AzOptionRawImage::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzRawImage) -> AzOptionRawImageEnumWrapper {
        AzOptionRawImageEnumWrapper {
            inner: AzOptionRawImage::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionRawImage;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionRawImage::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionRawImage::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionRawImageEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::OptionRawImage = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionSvgDashPatternEnumWrapper {
    #[classattr]
    fn None() -> AzOptionSvgDashPatternEnumWrapper {
        AzOptionSvgDashPatternEnumWrapper {
            inner: AzOptionSvgDashPattern::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzSvgDashPattern) -> AzOptionSvgDashPatternEnumWrapper {
        AzOptionSvgDashPatternEnumWrapper {
            inner: AzOptionSvgDashPattern::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionSvgDashPattern;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionSvgDashPattern::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionSvgDashPattern::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionSvgDashPatternEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::OptionSvgDashPattern = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWaylandThemeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWaylandThemeEnumWrapper {
        AzOptionWaylandThemeEnumWrapper {
            inner: AzOptionWaylandTheme::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzWaylandTheme) -> AzOptionWaylandThemeEnumWrapper {
        AzOptionWaylandThemeEnumWrapper {
            inner: AzOptionWaylandTheme::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionWaylandTheme;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWaylandTheme::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWaylandTheme::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWaylandThemeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWaylandTheme = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTaskBarIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTaskBarIconEnumWrapper {
        AzOptionTaskBarIconEnumWrapper {
            inner: AzOptionTaskBarIcon::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTaskBarIcon) -> AzOptionTaskBarIconEnumWrapper {
        AzOptionTaskBarIconEnumWrapper {
            inner: AzOptionTaskBarIcon::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTaskBarIcon;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTaskBarIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTaskBarIcon::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTaskBarIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionTaskBarIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionHwndHandleEnumWrapper {
    #[classattr]
    fn None() -> AzOptionHwndHandleEnumWrapper {
        AzOptionHwndHandleEnumWrapper {
            inner: AzOptionHwndHandle::None,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionHwndHandle;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionHwndHandle::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionHwndHandle::Some(v) => Ok(vec!["Some".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionHwndHandleEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionHwndHandle = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalPositionEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalPositionEnumWrapper {
        AzOptionLogicalPositionEnumWrapper {
            inner: AzOptionLogicalPosition::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzLogicalPosition) -> AzOptionLogicalPositionEnumWrapper {
        AzOptionLogicalPositionEnumWrapper {
            inner: AzOptionLogicalPosition::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionLogicalPosition;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalPosition::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalPosition::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalPositionEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionLogicalPosition = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionPhysicalPositionI32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionPhysicalPositionI32EnumWrapper {
        AzOptionPhysicalPositionI32EnumWrapper {
            inner: AzOptionPhysicalPositionI32::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzPhysicalPositionI32) -> AzOptionPhysicalPositionI32EnumWrapper {
        AzOptionPhysicalPositionI32EnumWrapper {
            inner: AzOptionPhysicalPositionI32::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionPhysicalPositionI32;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionPhysicalPositionI32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionPhysicalPositionI32::Some(v) => {
                Ok(vec!["Some".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionPhysicalPositionI32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionPhysicalPositionI32 =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionPhysicalPositionI32 =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionWindowIconEnumWrapper {
    #[classattr]
    fn None() -> AzOptionWindowIconEnumWrapper {
        AzOptionWindowIconEnumWrapper {
            inner: AzOptionWindowIcon::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzWindowIconEnumWrapper) -> AzOptionWindowIconEnumWrapper {
        AzOptionWindowIconEnumWrapper {
            inner: AzOptionWindowIcon::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionWindowIcon;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionWindowIcon::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionWindowIcon::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzWindowIconEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionWindowIconEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionWindowIcon = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionStringEnumWrapper {
    #[classattr]
    fn None() -> AzOptionStringEnumWrapper {
        AzOptionStringEnumWrapper {
            inner: AzOptionString::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzString) -> AzOptionStringEnumWrapper {
        AzOptionStringEnumWrapper {
            inner: AzOptionString::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionString;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionString::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionString::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionStringEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionAzString = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionAzString = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionX11VisualEnumWrapper {
    #[classattr]
    fn None() -> AzOptionX11VisualEnumWrapper {
        AzOptionX11VisualEnumWrapper {
            inner: AzOptionX11Visual::None,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionX11Visual;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionX11Visual::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionX11Visual::Some(v) => Ok(vec!["Some".into_py(py), ().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionX11VisualEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionX11Visual = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionI32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionI32EnumWrapper {
        AzOptionI32EnumWrapper {
            inner: AzOptionI32::None,
        }
    }
    #[staticmethod]
    fn Some(v: i32) -> AzOptionI32EnumWrapper {
        AzOptionI32EnumWrapper {
            inner: AzOptionI32::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionI32;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionI32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionI32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionI32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionI32 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionI32 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionF32EnumWrapper {
    #[classattr]
    fn None() -> AzOptionF32EnumWrapper {
        AzOptionF32EnumWrapper {
            inner: AzOptionF32::None,
        }
    }
    #[staticmethod]
    fn Some(v: f32) -> AzOptionF32EnumWrapper {
        AzOptionF32EnumWrapper {
            inner: AzOptionF32::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionF32;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionF32::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionF32::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionF32EnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionF32 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionF32 = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionMouseCursorTypeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionMouseCursorTypeEnumWrapper {
        AzOptionMouseCursorTypeEnumWrapper {
            inner: AzOptionMouseCursorType::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzMouseCursorTypeEnumWrapper) -> AzOptionMouseCursorTypeEnumWrapper {
        AzOptionMouseCursorTypeEnumWrapper {
            inner: AzOptionMouseCursorType::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionMouseCursorType;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionMouseCursorType::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionMouseCursorType::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzMouseCursorTypeEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionMouseCursorTypeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionMouseCursorType = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionLogicalSizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionLogicalSizeEnumWrapper {
        AzOptionLogicalSizeEnumWrapper {
            inner: AzOptionLogicalSize::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzLogicalSize) -> AzOptionLogicalSizeEnumWrapper {
        AzOptionLogicalSizeEnumWrapper {
            inner: AzOptionLogicalSize::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionLogicalSize;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionLogicalSize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionLogicalSize::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionLogicalSizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionLogicalSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionLogicalSize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionCharEnumWrapper {
    #[classattr]
    fn None() -> AzOptionCharEnumWrapper {
        AzOptionCharEnumWrapper {
            inner: AzOptionChar::None,
        }
    }
    #[staticmethod]
    fn Some(v: u32) -> AzOptionCharEnumWrapper {
        AzOptionCharEnumWrapper {
            inner: AzOptionChar::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionChar;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionChar::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionChar::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionCharEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionChar = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionChar = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionVirtualKeyCodeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionVirtualKeyCodeEnumWrapper {
        AzOptionVirtualKeyCodeEnumWrapper {
            inner: AzOptionVirtualKeyCode::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzVirtualKeyCodeEnumWrapper) -> AzOptionVirtualKeyCodeEnumWrapper {
        AzOptionVirtualKeyCodeEnumWrapper {
            inner: AzOptionVirtualKeyCode::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionVirtualKeyCode;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionVirtualKeyCode::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionVirtualKeyCode::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzVirtualKeyCodeEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionVirtualKeyCodeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::window::OptionVirtualKeyCode = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDomEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDomEnumWrapper {
        AzOptionDomEnumWrapper {
            inner: AzOptionDom::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzDom) -> AzOptionDomEnumWrapper {
        AzOptionDomEnumWrapper {
            inner: AzOptionDom::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionDom;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDom::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDom::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDomEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::OptionDom = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::OptionDom = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTextureEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTextureEnumWrapper {
        AzOptionTextureEnumWrapper {
            inner: AzOptionTexture::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTexture) -> AzOptionTextureEnumWrapper {
        AzOptionTextureEnumWrapper {
            inner: AzOptionTexture::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTexture;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTexture::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTexture::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTextureEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionTexture = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionTexture = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionImageMaskEnumWrapper {
    #[classattr]
    fn None() -> AzOptionImageMaskEnumWrapper {
        AzOptionImageMaskEnumWrapper {
            inner: AzOptionImageMask::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzImageMask) -> AzOptionImageMaskEnumWrapper {
        AzOptionImageMaskEnumWrapper {
            inner: AzOptionImageMask::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionImageMask;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionImageMask::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionImageMask::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionImageMaskEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::OptionImageMask = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::resources::OptionImageMask = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTabIndexEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTabIndexEnumWrapper {
        AzOptionTabIndexEnumWrapper {
            inner: AzOptionTabIndex::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTabIndexEnumWrapper) -> AzOptionTabIndexEnumWrapper {
        AzOptionTabIndexEnumWrapper {
            inner: AzOptionTabIndex::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTabIndex;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTabIndex::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTabIndex::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzTabIndexEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTabIndexEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::dom::OptionTabIndex = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionTagIdEnumWrapper {
    #[classattr]
    fn None() -> AzOptionTagIdEnumWrapper {
        AzOptionTagIdEnumWrapper {
            inner: AzOptionTagId::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzTagId) -> AzOptionTagIdEnumWrapper {
        AzOptionTagIdEnumWrapper {
            inner: AzOptionTagId::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionTagId;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionTagId::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionTagId::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionTagIdEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::OptionTagId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::styled_dom::OptionTagId = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionDurationEnumWrapper {
    #[classattr]
    fn None() -> AzOptionDurationEnumWrapper {
        AzOptionDurationEnumWrapper {
            inner: AzOptionDuration::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzDurationEnumWrapper) -> AzOptionDurationEnumWrapper {
        AzOptionDurationEnumWrapper {
            inner: AzOptionDuration::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionDuration;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionDuration::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionDuration::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzDurationEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionDurationEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionDuration = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionInstantEnumWrapper {
    #[classattr]
    fn None() -> AzOptionInstantEnumWrapper {
        AzOptionInstantEnumWrapper {
            inner: AzOptionInstant::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzInstantEnumWrapper) -> AzOptionInstantEnumWrapper {
        AzOptionInstantEnumWrapper {
            inner: AzOptionInstant::Some(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionInstant;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionInstant::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionInstant::Some(v) => Ok(vec![
                "Some".into_py(py),
                {
                    let m: &AzInstantEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionInstantEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionInstant = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::task::OptionInstant = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionUsizeEnumWrapper {
    #[classattr]
    fn None() -> AzOptionUsizeEnumWrapper {
        AzOptionUsizeEnumWrapper {
            inner: AzOptionUsize::None,
        }
    }
    #[staticmethod]
    fn Some(v: usize) -> AzOptionUsizeEnumWrapper {
        AzOptionUsizeEnumWrapper {
            inner: AzOptionUsize::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionUsize;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionUsize::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionUsize::Some(v) => Ok(vec!["Some".into_py(py), v.into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionUsizeEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionUsize = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU8VecEnumWrapper {
    #[classattr]
    fn None() -> AzOptionU8VecEnumWrapper {
        AzOptionU8VecEnumWrapper {
            inner: AzOptionU8Vec::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzU8Vec) -> AzOptionU8VecEnumWrapper {
        AzOptionU8VecEnumWrapper {
            inner: AzOptionU8Vec::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionU8Vec;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU8Vec::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU8Vec::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU8VecEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionU8Vec = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_css::OptionU8Vec = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzOptionU8VecRefEnumWrapper {
    #[classattr]
    fn None() -> AzOptionU8VecRefEnumWrapper {
        AzOptionU8VecRefEnumWrapper {
            inner: AzOptionU8VecRef::None,
        }
    }
    #[staticmethod]
    fn Some(v: AzU8VecRef) -> AzOptionU8VecRefEnumWrapper {
        AzOptionU8VecRefEnumWrapper {
            inner: AzOptionU8VecRef::Some(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzOptionU8VecRef;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzOptionU8VecRef::None => Ok(vec!["None".into_py(py), ().into_py(py)]),
            AzOptionU8VecRef::Some(v) => Ok(vec!["Some".into_py(py), v.clone().into_py(py)]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzOptionU8VecRefEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::gl::OptionU8VecRef = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultXmlXmlErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzXml) -> AzResultXmlXmlErrorEnumWrapper {
        AzResultXmlXmlErrorEnumWrapper {
            inner: AzResultXmlXmlError::Ok(v),
        }
    }
    #[staticmethod]
    fn Err(v: AzXmlErrorEnumWrapper) -> AzResultXmlXmlErrorEnumWrapper {
        AzResultXmlXmlErrorEnumWrapper {
            inner: AzResultXmlXmlError::Err(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzResultXmlXmlError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultXmlXmlError::Ok(v) => Ok(vec!["Ok".into_py(py), v.clone().into_py(py)]),
            AzResultXmlXmlError::Err(v) => Ok(vec![
                "Err".into_py(py),
                {
                    let m: &AzXmlErrorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultXmlXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::ResultXmlXmlError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultRawImageDecodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzRawImage) -> AzResultRawImageDecodeImageErrorEnumWrapper {
        AzResultRawImageDecodeImageErrorEnumWrapper {
            inner: AzResultRawImageDecodeImageError::Ok(v),
        }
    }
    #[staticmethod]
    fn Err(v: AzDecodeImageErrorEnumWrapper) -> AzResultRawImageDecodeImageErrorEnumWrapper {
        AzResultRawImageDecodeImageErrorEnumWrapper {
            inner: AzResultRawImageDecodeImageError::Err(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzResultRawImageDecodeImageError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultRawImageDecodeImageError::Ok(v) => {
                Ok(vec!["Ok".into_py(py), v.clone().into_py(py)])
            }
            AzResultRawImageDecodeImageError::Err(v) => Ok(vec![
                "Err".into_py(py),
                {
                    let m: &AzDecodeImageErrorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultRawImageDecodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::decode::ResultRawImageDecodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::decode::ResultRawImageDecodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultU8VecEncodeImageErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzU8Vec) -> AzResultU8VecEncodeImageErrorEnumWrapper {
        AzResultU8VecEncodeImageErrorEnumWrapper {
            inner: AzResultU8VecEncodeImageError::Ok(v),
        }
    }
    #[staticmethod]
    fn Err(v: AzEncodeImageErrorEnumWrapper) -> AzResultU8VecEncodeImageErrorEnumWrapper {
        AzResultU8VecEncodeImageErrorEnumWrapper {
            inner: AzResultU8VecEncodeImageError::Err(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzResultU8VecEncodeImageError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultU8VecEncodeImageError::Ok(v) => {
                Ok(vec!["Ok".into_py(py), v.clone().into_py(py)])
            }
            AzResultU8VecEncodeImageError::Err(v) => Ok(vec![
                "Err".into_py(py),
                {
                    let m: &AzEncodeImageErrorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultU8VecEncodeImageErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::encode::ResultU8VecEncodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::image::encode::ResultU8VecEncodeImageError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzSvgXmlNode) -> AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
        AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
            inner: AzResultSvgXmlNodeSvgParseError::Ok(v),
        }
    }
    #[staticmethod]
    fn Err(v: AzSvgParseErrorEnumWrapper) -> AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
        AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
            inner: AzResultSvgXmlNodeSvgParseError::Err(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzResultSvgXmlNodeSvgParseError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultSvgXmlNodeSvgParseError::Ok(v) => {
                Ok(vec!["Ok".into_py(py), v.clone().into_py(py)])
            }
            AzResultSvgXmlNodeSvgParseError::Err(v) => Ok(vec![
                "Err".into_py(py),
                {
                    let m: &AzSvgParseErrorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultSvgXmlNodeSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ResultSvgXmlNodeSvgParseError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ResultSvgXmlNodeSvgParseError =
            unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzResultSvgSvgParseErrorEnumWrapper {
    #[staticmethod]
    fn Ok(v: AzSvg) -> AzResultSvgSvgParseErrorEnumWrapper {
        AzResultSvgSvgParseErrorEnumWrapper {
            inner: AzResultSvgSvgParseError::Ok(v),
        }
    }
    #[staticmethod]
    fn Err(v: AzSvgParseErrorEnumWrapper) -> AzResultSvgSvgParseErrorEnumWrapper {
        AzResultSvgSvgParseErrorEnumWrapper {
            inner: AzResultSvgSvgParseError::Err(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzResultSvgSvgParseError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzResultSvgSvgParseError::Ok(v) => Ok(vec!["Ok".into_py(py), v.clone().into_py(py)]),
            AzResultSvgSvgParseError::Err(v) => Ok(vec![
                "Err".into_py(py),
                {
                    let m: &AzSvgParseErrorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzResultSvgSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::svg::ResultSvgSvgParseError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper {
            inner: AzSvgParseError::NoParserAvailable,
        }
    }
    #[classattr]
    fn ElementsLimitReached() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper {
            inner: AzSvgParseError::ElementsLimitReached,
        }
    }
    #[classattr]
    fn NotAnUtf8Str() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper {
            inner: AzSvgParseError::NotAnUtf8Str,
        }
    }
    #[classattr]
    fn MalformedGZip() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper {
            inner: AzSvgParseError::MalformedGZip,
        }
    }
    #[classattr]
    fn InvalidSize() -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper {
            inner: AzSvgParseError::InvalidSize,
        }
    }
    #[staticmethod]
    fn ParsingFailed(v: AzXmlErrorEnumWrapper) -> AzSvgParseErrorEnumWrapper {
        AzSvgParseErrorEnumWrapper {
            inner: AzSvgParseError::ParsingFailed(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzSvgParseError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzSvgParseError::NoParserAvailable => {
                Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)])
            }
            AzSvgParseError::ElementsLimitReached => {
                Ok(vec!["ElementsLimitReached".into_py(py), ().into_py(py)])
            }
            AzSvgParseError::NotAnUtf8Str => Ok(vec!["NotAnUtf8Str".into_py(py), ().into_py(py)]),
            AzSvgParseError::MalformedGZip => Ok(vec!["MalformedGZip".into_py(py), ().into_py(py)]),
            AzSvgParseError::InvalidSize => Ok(vec!["InvalidSize".into_py(py), ().into_py(py)]),
            AzSvgParseError::ParsingFailed(v) => Ok(vec![
                "ParsingFailed".into_py(py),
                {
                    let m: &AzXmlErrorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgParseError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_layout::xml::svg::SvgParseError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlErrorEnumWrapper {
    #[classattr]
    fn NoParserAvailable() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::NoParserAvailable,
        }
    }
    #[staticmethod]
    fn InvalidXmlPrefixUri(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::InvalidXmlPrefixUri(v),
        }
    }
    #[staticmethod]
    fn UnexpectedXmlUri(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::UnexpectedXmlUri(v),
        }
    }
    #[staticmethod]
    fn UnexpectedXmlnsUri(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::UnexpectedXmlnsUri(v),
        }
    }
    #[staticmethod]
    fn InvalidElementNamePrefix(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::InvalidElementNamePrefix(v),
        }
    }
    #[staticmethod]
    fn DuplicatedNamespace(v: AzDuplicatedNamespaceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::DuplicatedNamespace(v),
        }
    }
    #[staticmethod]
    fn UnknownNamespace(v: AzUnknownNamespaceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::UnknownNamespace(v),
        }
    }
    #[staticmethod]
    fn UnexpectedCloseTag(v: AzUnexpectedCloseTagError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::UnexpectedCloseTag(v),
        }
    }
    #[staticmethod]
    fn UnexpectedEntityCloseTag(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::UnexpectedEntityCloseTag(v),
        }
    }
    #[staticmethod]
    fn UnknownEntityReference(v: AzUnknownEntityReferenceError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::UnknownEntityReference(v),
        }
    }
    #[staticmethod]
    fn MalformedEntityReference(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::MalformedEntityReference(v),
        }
    }
    #[staticmethod]
    fn EntityReferenceLoop(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::EntityReferenceLoop(v),
        }
    }
    #[staticmethod]
    fn InvalidAttributeValue(v: AzSvgParseErrorPosition) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::InvalidAttributeValue(v),
        }
    }
    #[staticmethod]
    fn DuplicatedAttribute(v: AzDuplicatedAttributeError) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::DuplicatedAttribute(v),
        }
    }
    #[classattr]
    fn NoRootNode() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::NoRootNode,
        }
    }
    #[classattr]
    fn SizeLimit() -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::SizeLimit,
        }
    }
    #[staticmethod]
    fn ParserError(v: AzXmlParseErrorEnumWrapper) -> AzXmlErrorEnumWrapper {
        AzXmlErrorEnumWrapper {
            inner: AzXmlError::ParserError(unsafe { mem::transmute(v) }),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzXmlError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlError::NoParserAvailable => {
                Ok(vec!["NoParserAvailable".into_py(py), ().into_py(py)])
            }
            AzXmlError::InvalidXmlPrefixUri(v) => Ok(vec![
                "InvalidXmlPrefixUri".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::UnexpectedXmlUri(v) => {
                Ok(vec!["UnexpectedXmlUri".into_py(py), v.clone().into_py(py)])
            }
            AzXmlError::UnexpectedXmlnsUri(v) => Ok(vec![
                "UnexpectedXmlnsUri".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::InvalidElementNamePrefix(v) => Ok(vec![
                "InvalidElementNamePrefix".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::DuplicatedNamespace(v) => Ok(vec![
                "DuplicatedNamespace".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::UnknownNamespace(v) => {
                Ok(vec!["UnknownNamespace".into_py(py), v.clone().into_py(py)])
            }
            AzXmlError::UnexpectedCloseTag(v) => Ok(vec![
                "UnexpectedCloseTag".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::UnexpectedEntityCloseTag(v) => Ok(vec![
                "UnexpectedEntityCloseTag".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::UnknownEntityReference(v) => Ok(vec![
                "UnknownEntityReference".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::MalformedEntityReference(v) => Ok(vec![
                "MalformedEntityReference".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::EntityReferenceLoop(v) => Ok(vec![
                "EntityReferenceLoop".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::InvalidAttributeValue(v) => Ok(vec![
                "InvalidAttributeValue".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::DuplicatedAttribute(v) => Ok(vec![
                "DuplicatedAttribute".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlError::NoRootNode => Ok(vec!["NoRootNode".into_py(py), ().into_py(py)]),
            AzXmlError::SizeLimit => Ok(vec!["SizeLimit".into_py(py), ().into_py(py)]),
            AzXmlError::ParserError(v) => Ok(vec![
                "ParserError".into_py(py),
                {
                    let m: &AzXmlParseErrorEnumWrapper = unsafe { mem::transmute(v) };
                    m.clone()
                }
                .into_py(py),
            ]),
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedNamespaceError {
    #[new]
    fn __new__(ns: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self { ns, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::DuplicatedNamespaceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownNamespaceError {
    #[new]
    fn __new__(ns: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self { ns, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzUnknownNamespaceError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::UnknownNamespaceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnexpectedCloseTagError {
    #[new]
    fn __new__(expected: AzString, actual: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self {
            expected,
            actual,
            pos,
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzUnexpectedCloseTagError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::UnexpectedCloseTagError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzUnknownEntityReferenceError {
    #[new]
    fn __new__(entity: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self { entity, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzUnknownEntityReferenceError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::UnknownEntityReferenceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzDuplicatedAttributeError {
    #[new]
    fn __new__(attribute: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self { attribute, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzDuplicatedAttributeError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::DuplicatedAttributeError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlParseErrorEnumWrapper {
    #[staticmethod]
    fn InvalidDeclaration(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidDeclaration(v),
        }
    }
    #[staticmethod]
    fn InvalidComment(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidComment(v),
        }
    }
    #[staticmethod]
    fn InvalidPI(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidPI(v),
        }
    }
    #[staticmethod]
    fn InvalidDoctype(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidDoctype(v),
        }
    }
    #[staticmethod]
    fn InvalidEntity(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidEntity(v),
        }
    }
    #[staticmethod]
    fn InvalidElement(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidElement(v),
        }
    }
    #[staticmethod]
    fn InvalidAttribute(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidAttribute(v),
        }
    }
    #[staticmethod]
    fn InvalidCdata(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidCdata(v),
        }
    }
    #[staticmethod]
    fn InvalidCharData(v: AzXmlTextError) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::InvalidCharData(v),
        }
    }
    #[staticmethod]
    fn UnknownToken(v: AzSvgParseErrorPosition) -> AzXmlParseErrorEnumWrapper {
        AzXmlParseErrorEnumWrapper {
            inner: AzXmlParseError::UnknownToken(v),
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzXmlParseError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlParseError::InvalidDeclaration(v) => Ok(vec![
                "InvalidDeclaration".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlParseError::InvalidComment(v) => {
                Ok(vec!["InvalidComment".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::InvalidPI(v) => {
                Ok(vec!["InvalidPI".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::InvalidDoctype(v) => {
                Ok(vec!["InvalidDoctype".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::InvalidEntity(v) => {
                Ok(vec!["InvalidEntity".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::InvalidElement(v) => {
                Ok(vec!["InvalidElement".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::InvalidAttribute(v) => {
                Ok(vec!["InvalidAttribute".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::InvalidCdata(v) => {
                Ok(vec!["InvalidCdata".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::InvalidCharData(v) => {
                Ok(vec!["InvalidCharData".into_py(py), v.clone().into_py(py)])
            }
            AzXmlParseError::UnknownToken(v) => {
                Ok(vec!["UnknownToken".into_py(py), v.clone().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlParseErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlParseError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlTextError {
    #[new]
    fn __new__(stream_error: AzXmlStreamErrorEnumWrapper, pos: AzSvgParseErrorPosition) -> Self {
        Self { stream_error, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlTextError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlTextError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzXmlStreamErrorEnumWrapper {
    #[classattr]
    fn UnexpectedEndOfStream() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::UnexpectedEndOfStream,
        }
    }
    #[classattr]
    fn InvalidName() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidName,
        }
    }
    #[staticmethod]
    fn NonXmlChar(v: AzNonXmlCharError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::NonXmlChar(v),
        }
    }
    #[staticmethod]
    fn InvalidChar(v: AzInvalidCharError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidChar(v),
        }
    }
    #[staticmethod]
    fn InvalidCharMultiple(v: AzInvalidCharMultipleError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidCharMultiple(v),
        }
    }
    #[staticmethod]
    fn InvalidQuote(v: AzInvalidQuoteError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidQuote(v),
        }
    }
    #[staticmethod]
    fn InvalidSpace(v: AzInvalidSpaceError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidSpace(v),
        }
    }
    #[staticmethod]
    fn InvalidString(v: AzInvalidStringError) -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidString(v),
        }
    }
    #[classattr]
    fn InvalidReference() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidReference,
        }
    }
    #[classattr]
    fn InvalidExternalID() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidExternalID,
        }
    }
    #[classattr]
    fn InvalidCommentData() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidCommentData,
        }
    }
    #[classattr]
    fn InvalidCommentEnd() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidCommentEnd,
        }
    }
    #[classattr]
    fn InvalidCharacterData() -> AzXmlStreamErrorEnumWrapper {
        AzXmlStreamErrorEnumWrapper {
            inner: AzXmlStreamError::InvalidCharacterData,
        }
    }

    fn r#match(&self) -> PyResult<Vec<PyObject>> {
        use pyo3::conversion::IntoPy;

        use crate::python::AzXmlStreamError;
        let gil = Python::acquire_gil();
        let py = gil.python();
        match &self.inner {
            AzXmlStreamError::UnexpectedEndOfStream => {
                Ok(vec!["UnexpectedEndOfStream".into_py(py), ().into_py(py)])
            }
            AzXmlStreamError::InvalidName => Ok(vec!["InvalidName".into_py(py), ().into_py(py)]),
            AzXmlStreamError::NonXmlChar(v) => {
                Ok(vec!["NonXmlChar".into_py(py), v.clone().into_py(py)])
            }
            AzXmlStreamError::InvalidChar(v) => {
                Ok(vec!["InvalidChar".into_py(py), v.clone().into_py(py)])
            }
            AzXmlStreamError::InvalidCharMultiple(v) => Ok(vec![
                "InvalidCharMultiple".into_py(py),
                v.clone().into_py(py),
            ]),
            AzXmlStreamError::InvalidQuote(v) => {
                Ok(vec!["InvalidQuote".into_py(py), v.clone().into_py(py)])
            }
            AzXmlStreamError::InvalidSpace(v) => {
                Ok(vec!["InvalidSpace".into_py(py), v.clone().into_py(py)])
            }
            AzXmlStreamError::InvalidString(v) => {
                Ok(vec!["InvalidString".into_py(py), v.clone().into_py(py)])
            }
            AzXmlStreamError::InvalidReference => {
                Ok(vec!["InvalidReference".into_py(py), ().into_py(py)])
            }
            AzXmlStreamError::InvalidExternalID => {
                Ok(vec!["InvalidExternalID".into_py(py), ().into_py(py)])
            }
            AzXmlStreamError::InvalidCommentData => {
                Ok(vec!["InvalidCommentData".into_py(py), ().into_py(py)])
            }
            AzXmlStreamError::InvalidCommentEnd => {
                Ok(vec!["InvalidCommentEnd".into_py(py), ().into_py(py)])
            }
            AzXmlStreamError::InvalidCharacterData => {
                Ok(vec!["InvalidCharacterData".into_py(py), ().into_py(py)])
            }
        }
    }
}

#[pyproto]
impl PyObjectProtocol for AzXmlStreamErrorEnumWrapper {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlStreamError = unsafe { mem::transmute(&self.inner) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzNonXmlCharError {
    #[new]
    fn __new__(ch: u32, pos: AzSvgParseErrorPosition) -> Self {
        Self { ch, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzNonXmlCharError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::NonXmlCharError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharError {
    #[new]
    fn __new__(expected: u8, got: u8, pos: AzSvgParseErrorPosition) -> Self {
        Self { expected, got, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidCharError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidCharMultipleError {
    #[new]
    fn __new__(expected: u8, got: AzU8Vec, pos: AzSvgParseErrorPosition) -> Self {
        Self { expected, got, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInvalidCharMultipleError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidCharMultipleError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidQuoteError {
    #[new]
    fn __new__(got: u8, pos: AzSvgParseErrorPosition) -> Self {
        Self { got, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInvalidQuoteError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidQuoteError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidSpaceError {
    #[new]
    fn __new__(got: u8, pos: AzSvgParseErrorPosition) -> Self {
        Self { got, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInvalidSpaceError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidSpaceError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzInvalidStringError {
    #[new]
    fn __new__(got: AzString, pos: AzSvgParseErrorPosition) -> Self {
        Self { got, pos }
    }
}

#[pyproto]
impl PyObjectProtocol for AzInvalidStringError {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::InvalidStringError = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

#[pymethods]
impl AzSvgParseErrorPosition {
    #[new]
    fn __new__(row: u32, col: u32) -> Self {
        Self { row, col }
    }
}

#[pyproto]
impl PyObjectProtocol for AzSvgParseErrorPosition {
    fn __str__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
    fn __repr__(&self) -> Result<String, PyErr> {
        let m: &azul_core::xml::XmlTextPos = unsafe { mem::transmute(self) };
        Ok(format!("{:#?}", m))
    }
}

impl core::convert::From<AzDecodeImageError> for PyErr {
    fn from(err: AzDecodeImageError) -> PyErr {
        let r: azul_layout::image::decode::DecodeImageError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

impl core::convert::From<AzEncodeImageError> for PyErr {
    fn from(err: AzEncodeImageError) -> PyErr {
        let r: azul_layout::image::encode::EncodeImageError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

impl core::convert::From<AzSvgParseError> for PyErr {
    fn from(err: AzSvgParseError) -> PyErr {
        let r: azul_layout::xml::svg::SvgParseError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

impl core::convert::From<AzXmlError> for PyErr {
    fn from(err: AzXmlError) -> PyErr {
        let r: azul_core::xml::XmlError = unsafe { mem::transmute(err) };
        PyException::new_err(format!("{}", r))
    }
}

#[pymodule]
fn azul(py: Python, m: &PyModule) -> PyResult<()> {
    #[cfg(all(feature = "use_pyo3_logger", not(feature = "use_fern_logger")))]
    {
        let mut filter = log::LevelFilter::Warn;

        if std::env::var("AZUL_PY_LOGLEVEL_ERROR").is_ok() {
            filter = log::LevelFilter::Error;
        }
        if std::env::var("AZUL_PY_LOGLEVEL_WARN").is_ok() {
            filter = log::LevelFilter::Warn;
        }
        if std::env::var("AZUL_PY_LOGLEVEL_INFO").is_ok() {
            filter = log::LevelFilter::Info;
        }
        if std::env::var("AZUL_PY_LOGLEVEL_DEBUG").is_ok() {
            filter = log::LevelFilter::Debug;
        }
        if std::env::var("AZUL_PY_LOGLEVEL_TRACE").is_ok() {
            filter = log::LevelFilter::Trace;
        }
        if std::env::var("AZUL_PY_LOGLEVEL_OFF").is_ok() {
            filter = log::LevelFilter::Off;
        }
    }

    m.add_class::<AzApp>()?;
    m.add_class::<AzAppConfig>()?;
    m.add_class::<AzAppLogLevelEnumWrapper>()?;
    m.add_class::<AzLayoutSolverEnumWrapper>()?;
    m.add_class::<AzSystemCallbacks>()?;

    m.add_class::<AzWindowCreateOptions>()?;
    m.add_class::<AzRendererOptions>()?;
    m.add_class::<AzVsyncEnumWrapper>()?;
    m.add_class::<AzSrgbEnumWrapper>()?;
    m.add_class::<AzHwAccelerationEnumWrapper>()?;
    m.add_class::<AzLayoutPoint>()?;
    m.add_class::<AzLayoutSize>()?;
    m.add_class::<AzLayoutRect>()?;
    m.add_class::<AzRawWindowHandleEnumWrapper>()?;
    m.add_class::<AzIOSHandle>()?;
    m.add_class::<AzMacOSHandle>()?;
    m.add_class::<AzXlibHandle>()?;
    m.add_class::<AzXcbHandle>()?;
    m.add_class::<AzWaylandHandle>()?;
    m.add_class::<AzWindowsHandle>()?;
    m.add_class::<AzWebHandle>()?;
    m.add_class::<AzAndroidHandle>()?;
    m.add_class::<AzXWindowTypeEnumWrapper>()?;
    m.add_class::<AzPhysicalPositionI32>()?;
    m.add_class::<AzPhysicalSizeU32>()?;
    m.add_class::<AzLogicalRect>()?;
    m.add_class::<AzLogicalPosition>()?;
    m.add_class::<AzLogicalSize>()?;
    m.add_class::<AzIconKey>()?;
    m.add_class::<AzSmallWindowIconBytes>()?;
    m.add_class::<AzLargeWindowIconBytes>()?;
    m.add_class::<AzWindowIconEnumWrapper>()?;
    m.add_class::<AzTaskBarIcon>()?;
    m.add_class::<AzVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzAcceleratorKeyEnumWrapper>()?;
    m.add_class::<AzWindowSize>()?;
    m.add_class::<AzWindowFlags>()?;
    m.add_class::<AzWindowFrameEnumWrapper>()?;
    m.add_class::<AzDebugState>()?;
    m.add_class::<AzKeyboardState>()?;
    m.add_class::<AzMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzCursorPositionEnumWrapper>()?;
    m.add_class::<AzMouseState>()?;
    m.add_class::<AzPlatformSpecificOptions>()?;
    m.add_class::<AzWindowsWindowOptions>()?;
    m.add_class::<AzWaylandTheme>()?;
    m.add_class::<AzRendererTypeEnumWrapper>()?;
    m.add_class::<AzStringPair>()?;
    m.add_class::<AzLinuxWindowOptions>()?;
    m.add_class::<AzMacWindowOptions>()?;
    m.add_class::<AzWasmWindowOptions>()?;
    m.add_class::<AzFullScreenModeEnumWrapper>()?;
    m.add_class::<AzWindowThemeEnumWrapper>()?;
    m.add_class::<AzWindowPositionEnumWrapper>()?;
    m.add_class::<AzImePositionEnumWrapper>()?;
    m.add_class::<AzTouchState>()?;
    m.add_class::<AzMonitor>()?;
    m.add_class::<AzVideoMode>()?;
    m.add_class::<AzWindowState>()?;

    m.add_class::<AzLayoutCallbackEnumWrapper>()?;
    m.add_class::<AzMarshaledLayoutCallback>()?;
    m.add_class::<AzMarshaledLayoutCallbackInner>()?;
    m.add_class::<AzLayoutCallbackInner>()?;
    m.add_class::<AzCallback>()?;
    m.add_class::<AzCallbackInfo>()?;
    m.add_class::<AzUpdateImageTypeEnumWrapper>()?;
    m.add_class::<AzUpdateEnumWrapper>()?;
    m.add_class::<AzNodeId>()?;
    m.add_class::<AzDomId>()?;
    m.add_class::<AzDomNodeId>()?;
    m.add_class::<AzPositionInfoEnumWrapper>()?;
    m.add_class::<AzPositionInfoInner>()?;
    m.add_class::<AzHidpiAdjustedBounds>()?;
    m.add_class::<AzInlineText>()?;
    m.add_class::<AzInlineLine>()?;
    m.add_class::<AzInlineWordEnumWrapper>()?;
    m.add_class::<AzInlineTextContents>()?;
    m.add_class::<AzInlineGlyph>()?;
    m.add_class::<AzInlineTextHit>()?;
    m.add_class::<AzFocusTargetEnumWrapper>()?;
    m.add_class::<AzFocusTargetPath>()?;
    m.add_class::<AzScriptTypeEnumWrapper>()?;
    m.add_class::<AzResolvedTextLayoutOptions>()?;
    m.add_class::<AzAnimation>()?;
    m.add_class::<AzAnimationRepeatEnumWrapper>()?;
    m.add_class::<AzAnimationRepeatCountEnumWrapper>()?;
    m.add_class::<AzAnimationEasingEnumWrapper>()?;
    m.add_class::<AzIFrameCallback>()?;
    m.add_class::<AzIFrameCallbackInfo>()?;
    m.add_class::<AzIFrameCallbackReturn>()?;
    m.add_class::<AzRenderImageCallback>()?;
    m.add_class::<AzRenderImageCallbackInfo>()?;
    m.add_class::<AzTimerCallback>()?;
    m.add_class::<AzTimerCallbackInfo>()?;
    m.add_class::<AzTimerCallbackReturn>()?;
    m.add_class::<AzWriteBackCallback>()?;
    m.add_class::<AzThreadCallback>()?;
    m.add_class::<AzRefCount>()?;
    m.add_class::<AzRefAny>()?;
    m.add_class::<AzLayoutCallbackInfo>()?;

    m.add_class::<AzDom>()?;
    m.add_class::<AzIFrameNode>()?;
    m.add_class::<AzCallbackData>()?;
    m.add_class::<AzNodeData>()?;
    m.add_class::<AzNodeTypeEnumWrapper>()?;
    m.add_class::<AzOnEnumWrapper>()?;
    m.add_class::<AzEventFilterEnumWrapper>()?;
    m.add_class::<AzHoverEventFilterEnumWrapper>()?;
    m.add_class::<AzFocusEventFilterEnumWrapper>()?;
    m.add_class::<AzNotEventFilterEnumWrapper>()?;
    m.add_class::<AzWindowEventFilterEnumWrapper>()?;
    m.add_class::<AzComponentEventFilterEnumWrapper>()?;
    m.add_class::<AzApplicationEventFilterEnumWrapper>()?;
    m.add_class::<AzAccessibilityInfo>()?;
    m.add_class::<AzAccessibilityRoleEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateEnumWrapper>()?;
    m.add_class::<AzTabIndexEnumWrapper>()?;
    m.add_class::<AzIdOrClassEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyEnumWrapper>()?;

    m.add_class::<AzMenu>()?;
    m.add_class::<AzContextMenuMouseButtonEnumWrapper>()?;
    m.add_class::<AzMenuPopupPositionEnumWrapper>()?;
    m.add_class::<AzMenuItemEnumWrapper>()?;
    m.add_class::<AzStringMenuItem>()?;
    m.add_class::<AzVirtualKeyCodeCombo>()?;
    m.add_class::<AzMenuCallback>()?;
    m.add_class::<AzMenuItemIconEnumWrapper>()?;
    m.add_class::<AzMenuItemStateEnumWrapper>()?;

    m.add_class::<AzCssRuleBlock>()?;
    m.add_class::<AzCssPath>()?;
    m.add_class::<AzCssPathSelectorEnumWrapper>()?;
    m.add_class::<AzNodeTypeKeyEnumWrapper>()?;
    m.add_class::<AzCssPathPseudoSelectorEnumWrapper>()?;
    m.add_class::<AzCssNthChildSelectorEnumWrapper>()?;
    m.add_class::<AzCssNthChildPattern>()?;
    m.add_class::<AzStylesheet>()?;
    m.add_class::<AzCss>()?;
    m.add_class::<AzCssDeclarationEnumWrapper>()?;
    m.add_class::<AzDynamicCssProperty>()?;
    m.add_class::<AzCssPropertyTypeEnumWrapper>()?;
    m.add_class::<AzAnimationInterpolationFunctionEnumWrapper>()?;
    m.add_class::<AzInterpolateContext>()?;
    m.add_class::<AzColorU>()?;
    m.add_class::<AzSizeMetricEnumWrapper>()?;
    m.add_class::<AzPixelValue>()?;
    m.add_class::<AzPixelValueNoPercent>()?;
    m.add_class::<AzBoxShadowClipModeEnumWrapper>()?;
    m.add_class::<AzStyleBoxShadow>()?;
    m.add_class::<AzStyleMixBlendModeEnumWrapper>()?;
    m.add_class::<AzStyleFilterEnumWrapper>()?;
    m.add_class::<AzStyleBlur>()?;
    m.add_class::<AzStyleColorMatrix>()?;
    m.add_class::<AzStyleFilterOffset>()?;
    m.add_class::<AzStyleCompositeFilterEnumWrapper>()?;
    m.add_class::<AzLayoutAlignContentEnumWrapper>()?;
    m.add_class::<AzLayoutAlignItemsEnumWrapper>()?;
    m.add_class::<AzLayoutBottom>()?;
    m.add_class::<AzLayoutBoxSizingEnumWrapper>()?;
    m.add_class::<AzLayoutFlexDirectionEnumWrapper>()?;
    m.add_class::<AzLayoutDisplayEnumWrapper>()?;
    m.add_class::<AzLayoutFlexGrow>()?;
    m.add_class::<AzLayoutFlexShrink>()?;
    m.add_class::<AzLayoutFloatEnumWrapper>()?;
    m.add_class::<AzLayoutHeight>()?;
    m.add_class::<AzLayoutJustifyContentEnumWrapper>()?;
    m.add_class::<AzLayoutLeft>()?;
    m.add_class::<AzLayoutMarginBottom>()?;
    m.add_class::<AzLayoutMarginLeft>()?;
    m.add_class::<AzLayoutMarginRight>()?;
    m.add_class::<AzLayoutMarginTop>()?;
    m.add_class::<AzLayoutMaxHeight>()?;
    m.add_class::<AzLayoutMaxWidth>()?;
    m.add_class::<AzLayoutMinHeight>()?;
    m.add_class::<AzLayoutMinWidth>()?;
    m.add_class::<AzLayoutPaddingBottom>()?;
    m.add_class::<AzLayoutPaddingLeft>()?;
    m.add_class::<AzLayoutPaddingRight>()?;
    m.add_class::<AzLayoutPaddingTop>()?;
    m.add_class::<AzLayoutPositionEnumWrapper>()?;
    m.add_class::<AzLayoutRight>()?;
    m.add_class::<AzLayoutTop>()?;
    m.add_class::<AzLayoutWidth>()?;
    m.add_class::<AzLayoutFlexWrapEnumWrapper>()?;
    m.add_class::<AzLayoutOverflowEnumWrapper>()?;
    m.add_class::<AzFloatValue>()?;
    m.add_class::<AzPercentageValue>()?;
    m.add_class::<AzAngleMetricEnumWrapper>()?;
    m.add_class::<AzAngleValue>()?;
    m.add_class::<AzNormalizedLinearColorStop>()?;
    m.add_class::<AzNormalizedRadialColorStop>()?;
    m.add_class::<AzDirectionCornerEnumWrapper>()?;
    m.add_class::<AzDirectionCorners>()?;
    m.add_class::<AzDirectionEnumWrapper>()?;
    m.add_class::<AzExtendModeEnumWrapper>()?;
    m.add_class::<AzLinearGradient>()?;
    m.add_class::<AzShapeEnumWrapper>()?;
    m.add_class::<AzRadialGradientSizeEnumWrapper>()?;
    m.add_class::<AzRadialGradient>()?;
    m.add_class::<AzConicGradient>()?;
    m.add_class::<AzStyleBackgroundContentEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionHorizontalEnumWrapper>()?;
    m.add_class::<AzBackgroundPositionVerticalEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPosition>()?;
    m.add_class::<AzStyleBackgroundRepeatEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomColor>()?;
    m.add_class::<AzStyleBorderBottomLeftRadius>()?;
    m.add_class::<AzStyleBorderBottomRightRadius>()?;
    m.add_class::<AzBorderStyleEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomStyle>()?;
    m.add_class::<AzLayoutBorderBottomWidth>()?;
    m.add_class::<AzStyleBorderLeftColor>()?;
    m.add_class::<AzStyleBorderLeftStyle>()?;
    m.add_class::<AzLayoutBorderLeftWidth>()?;
    m.add_class::<AzStyleBorderRightColor>()?;
    m.add_class::<AzStyleBorderRightStyle>()?;
    m.add_class::<AzLayoutBorderRightWidth>()?;
    m.add_class::<AzStyleBorderTopColor>()?;
    m.add_class::<AzStyleBorderTopLeftRadius>()?;
    m.add_class::<AzStyleBorderTopRightRadius>()?;
    m.add_class::<AzStyleBorderTopStyle>()?;
    m.add_class::<AzLayoutBorderTopWidth>()?;
    m.add_class::<AzScrollbarInfo>()?;
    m.add_class::<AzScrollbarStyle>()?;
    m.add_class::<AzStyleCursorEnumWrapper>()?;
    m.add_class::<AzStyleFontFamilyEnumWrapper>()?;
    m.add_class::<AzStyleFontSize>()?;
    m.add_class::<AzStyleLetterSpacing>()?;
    m.add_class::<AzStyleLineHeight>()?;
    m.add_class::<AzStyleTabWidth>()?;
    m.add_class::<AzStyleOpacity>()?;
    m.add_class::<AzStyleTransformOrigin>()?;
    m.add_class::<AzStylePerspectiveOrigin>()?;
    m.add_class::<AzStyleBackfaceVisibilityEnumWrapper>()?;
    m.add_class::<AzStyleTransformEnumWrapper>()?;
    m.add_class::<AzStyleTransformMatrix2D>()?;
    m.add_class::<AzStyleTransformMatrix3D>()?;
    m.add_class::<AzStyleTransformTranslate2D>()?;
    m.add_class::<AzStyleTransformTranslate3D>()?;
    m.add_class::<AzStyleTransformRotate3D>()?;
    m.add_class::<AzStyleTransformScale2D>()?;
    m.add_class::<AzStyleTransformScale3D>()?;
    m.add_class::<AzStyleTransformSkew2D>()?;
    m.add_class::<AzStyleTextAlignEnumWrapper>()?;
    m.add_class::<AzStyleTextColor>()?;
    m.add_class::<AzStyleWordSpacing>()?;
    m.add_class::<AzStyleBoxShadowValueEnumWrapper>()?;
    m.add_class::<AzLayoutAlignContentValueEnumWrapper>()?;
    m.add_class::<AzLayoutAlignItemsValueEnumWrapper>()?;
    m.add_class::<AzLayoutBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutBoxSizingValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexDirectionValueEnumWrapper>()?;
    m.add_class::<AzLayoutDisplayValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexGrowValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexShrinkValueEnumWrapper>()?;
    m.add_class::<AzLayoutFloatValueEnumWrapper>()?;
    m.add_class::<AzLayoutHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutJustifyContentValueEnumWrapper>()?;
    m.add_class::<AzLayoutLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMarginTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutMaxHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMaxWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutMinHeightValueEnumWrapper>()?;
    m.add_class::<AzLayoutMinWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingBottomValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingLeftValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutPaddingTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutPositionValueEnumWrapper>()?;
    m.add_class::<AzLayoutRightValueEnumWrapper>()?;
    m.add_class::<AzLayoutTopValueEnumWrapper>()?;
    m.add_class::<AzLayoutWidthValueEnumWrapper>()?;
    m.add_class::<AzLayoutFlexWrapValueEnumWrapper>()?;
    m.add_class::<AzLayoutOverflowValueEnumWrapper>()?;
    m.add_class::<AzScrollbarStyleValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundContentVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPositionVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundRepeatVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeVecValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomLeftRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomRightRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderBottomStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderBottomWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderLeftColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderLeftStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderLeftWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderRightColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderRightStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderRightWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopColorValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopLeftRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopRightRadiusValueEnumWrapper>()?;
    m.add_class::<AzStyleBorderTopStyleValueEnumWrapper>()?;
    m.add_class::<AzLayoutBorderTopWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleCursorValueEnumWrapper>()?;
    m.add_class::<AzStyleFontFamilyVecValueEnumWrapper>()?;
    m.add_class::<AzStyleFontSizeValueEnumWrapper>()?;
    m.add_class::<AzStyleLetterSpacingValueEnumWrapper>()?;
    m.add_class::<AzStyleLineHeightValueEnumWrapper>()?;
    m.add_class::<AzStyleTabWidthValueEnumWrapper>()?;
    m.add_class::<AzStyleTextAlignValueEnumWrapper>()?;
    m.add_class::<AzStyleTextColorValueEnumWrapper>()?;
    m.add_class::<AzStyleWordSpacingValueEnumWrapper>()?;
    m.add_class::<AzStyleOpacityValueEnumWrapper>()?;
    m.add_class::<AzStyleTransformVecValueEnumWrapper>()?;
    m.add_class::<AzStyleTransformOriginValueEnumWrapper>()?;
    m.add_class::<AzStylePerspectiveOriginValueEnumWrapper>()?;
    m.add_class::<AzStyleBackfaceVisibilityValueEnumWrapper>()?;
    m.add_class::<AzStyleMixBlendModeValueEnumWrapper>()?;
    m.add_class::<AzStyleFilterVecValueEnumWrapper>()?;
    m.add_class::<AzCssPropertyEnumWrapper>()?;

    m.add_class::<AzRibbon>()?;
    m.add_class::<AzRibbonOnTabClickedCallback>()?;
    m.add_class::<AzButton>()?;
    m.add_class::<AzButtonOnClick>()?;
    m.add_class::<AzFileInput>()?;
    m.add_class::<AzFileInputStateWrapper>()?;
    m.add_class::<AzFileInputState>()?;
    m.add_class::<AzFileInputOnPathChange>()?;
    m.add_class::<AzFileInputOnPathChangeCallback>()?;
    m.add_class::<AzCheckBox>()?;
    m.add_class::<AzCheckBoxStateWrapper>()?;
    m.add_class::<AzCheckBoxOnToggle>()?;
    m.add_class::<AzCheckBoxOnToggleCallback>()?;
    m.add_class::<AzCheckBoxState>()?;
    m.add_class::<AzLabel>()?;
    m.add_class::<AzColorInput>()?;
    m.add_class::<AzColorInputStateWrapper>()?;
    m.add_class::<AzColorInputState>()?;
    m.add_class::<AzColorInputOnValueChange>()?;
    m.add_class::<AzColorInputOnValueChangeCallback>()?;
    m.add_class::<AzTextInput>()?;
    m.add_class::<AzTextInputStateWrapper>()?;
    m.add_class::<AzTextInputState>()?;
    m.add_class::<AzTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzTextInputSelectionRange>()?;
    m.add_class::<AzTextInputOnTextInput>()?;
    m.add_class::<AzTextInputOnTextInputCallback>()?;
    m.add_class::<AzTextInputOnVirtualKeyDown>()?;
    m.add_class::<AzTextInputOnVirtualKeyDownCallback>()?;
    m.add_class::<AzTextInputOnFocusLost>()?;
    m.add_class::<AzTextInputOnFocusLostCallback>()?;
    m.add_class::<AzOnTextInputReturn>()?;
    m.add_class::<AzTextInputValidEnumWrapper>()?;
    m.add_class::<AzNumberInput>()?;
    m.add_class::<AzNumberInputStateWrapper>()?;
    m.add_class::<AzNumberInputState>()?;
    m.add_class::<AzNumberInputOnValueChange>()?;
    m.add_class::<AzNumberInputOnValueChangeCallback>()?;
    m.add_class::<AzNumberInputOnFocusLost>()?;
    m.add_class::<AzNumberInputOnFocusLostCallback>()?;
    m.add_class::<AzProgressBar>()?;
    m.add_class::<AzProgressBarState>()?;
    m.add_class::<AzTabHeader>()?;
    m.add_class::<AzTabHeaderState>()?;
    m.add_class::<AzTabContent>()?;
    m.add_class::<AzTabOnClick>()?;
    m.add_class::<AzTabOnClickCallback>()?;
    m.add_class::<AzFrame>()?;
    m.add_class::<AzNodeGraph>()?;
    m.add_class::<AzNodeTypeIdInfoMap>()?;
    m.add_class::<AzInputOutputTypeIdInfoMap>()?;
    m.add_class::<AzNodeIdNodeMap>()?;
    m.add_class::<AzNodeGraphStyleEnumWrapper>()?;
    m.add_class::<AzNodeGraphCallbacks>()?;
    m.add_class::<AzNodeGraphOnNodeAddedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeAdded>()?;
    m.add_class::<AzNodeGraphOnNodeRemovedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeRemoved>()?;
    m.add_class::<AzNodeGraphOnNodeGraphDraggedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeGraphDragged>()?;
    m.add_class::<AzNodeGraphOnNodeDraggedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeDragged>()?;
    m.add_class::<AzNodeGraphOnNodeConnectedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeConnected>()?;
    m.add_class::<AzNodeGraphOnNodeInputDisconnectedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeInputDisconnected>()?;
    m.add_class::<AzNodeGraphOnNodeOutputDisconnectedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeOutputDisconnected>()?;
    m.add_class::<AzNodeGraphOnNodeFieldEditedCallback>()?;
    m.add_class::<AzNodeGraphOnNodeFieldEdited>()?;
    m.add_class::<AzInputOutputTypeId>()?;
    m.add_class::<AzNodeTypeId>()?;
    m.add_class::<AzNodeGraphNodeId>()?;
    m.add_class::<AzNode>()?;
    m.add_class::<AzNodeTypeField>()?;
    m.add_class::<AzNodeTypeFieldValueEnumWrapper>()?;
    m.add_class::<AzInputConnection>()?;
    m.add_class::<AzOutputNodeAndIndex>()?;
    m.add_class::<AzOutputConnection>()?;
    m.add_class::<AzInputNodeAndIndex>()?;
    m.add_class::<AzNodeTypeInfo>()?;
    m.add_class::<AzInputOutputInfo>()?;
    m.add_class::<AzNodePosition>()?;
    m.add_class::<AzGraphDragAmount>()?;
    m.add_class::<AzNodeDragAmount>()?;
    m.add_class::<AzListView>()?;
    m.add_class::<AzListViewRow>()?;
    m.add_class::<AzListViewState>()?;
    m.add_class::<AzListViewOnLazyLoadScrollCallback>()?;
    m.add_class::<AzListViewOnLazyLoadScroll>()?;
    m.add_class::<AzListViewOnColumnClickCallback>()?;
    m.add_class::<AzListViewOnColumnClick>()?;
    m.add_class::<AzListViewOnRowClickCallback>()?;
    m.add_class::<AzListViewOnRowClick>()?;
    m.add_class::<AzTreeView>()?;
    m.add_class::<AzDropDown>()?;
    m.add_class::<AzDropDownOnChoiceChangeCallback>()?;
    m.add_class::<AzDropDownOnChoiceChange>()?;

    m.add_class::<AzNodeHierarchyItem>()?;
    m.add_class::<AzCascadeInfo>()?;
    m.add_class::<AzCssPropertySourceEnumWrapper>()?;
    m.add_class::<AzStyledNodeState>()?;
    m.add_class::<AzStyledNode>()?;
    m.add_class::<AzTagId>()?;
    m.add_class::<AzTagIdToNodeIdMapping>()?;
    m.add_class::<AzParentWithNodeDepth>()?;
    m.add_class::<AzCssPropertyCache>()?;
    m.add_class::<AzStyledDom>()?;

    m.add_class::<AzTexture>()?;
    m.add_class::<AzGlVoidPtrConst>()?;
    m.add_class::<AzGlVoidPtrMut>()?;
    m.add_class::<AzGl>()?;
    m.add_class::<AzGlShaderPrecisionFormatReturn>()?;
    m.add_class::<AzVertexAttributeTypeEnumWrapper>()?;
    m.add_class::<AzVertexAttribute>()?;
    m.add_class::<AzVertexLayout>()?;
    m.add_class::<AzVertexArrayObject>()?;
    m.add_class::<AzIndexBufferFormatEnumWrapper>()?;
    m.add_class::<AzVertexBuffer>()?;
    m.add_class::<AzGlTypeEnumWrapper>()?;
    m.add_class::<AzDebugMessage>()?;
    m.add_class::<AzU8VecRef>()?;
    m.add_class::<AzU8VecRefMut>()?;
    m.add_class::<AzF32VecRef>()?;
    m.add_class::<AzI32VecRef>()?;
    m.add_class::<AzGLuintVecRef>()?;
    m.add_class::<AzGLenumVecRef>()?;
    m.add_class::<AzGLintVecRefMut>()?;
    m.add_class::<AzGLint64VecRefMut>()?;
    m.add_class::<AzGLbooleanVecRefMut>()?;
    m.add_class::<AzGLfloatVecRefMut>()?;
    m.add_class::<AzRefstrVecRef>()?;
    m.add_class::<AzRefstr>()?;
    m.add_class::<AzGetProgramBinaryReturn>()?;
    m.add_class::<AzGetActiveAttribReturn>()?;
    m.add_class::<AzGLsyncPtr>()?;
    m.add_class::<AzGetActiveUniformReturn>()?;
    m.add_class::<AzTextureFlags>()?;

    m.add_class::<AzImageRef>()?;
    m.add_class::<AzRawImage>()?;
    m.add_class::<AzImageMask>()?;
    m.add_class::<AzRawImageFormatEnumWrapper>()?;
    m.add_class::<AzEncodeImageErrorEnumWrapper>()?;
    m.add_class::<AzDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzRawImageDataEnumWrapper>()?;

    m.add_class::<AzFontMetrics>()?;
    m.add_class::<AzFontSource>()?;
    m.add_class::<AzFontRef>()?;

    m.add_class::<AzSvg>()?;
    m.add_class::<AzSvgXmlNode>()?;
    m.add_class::<AzSvgMultiPolygon>()?;
    m.add_class::<AzSvgNodeEnumWrapper>()?;
    m.add_class::<AzSvgSimpleNodeEnumWrapper>()?;
    m.add_class::<AzSvgStyledNode>()?;
    m.add_class::<AzSvgCircle>()?;
    m.add_class::<AzSvgPath>()?;
    m.add_class::<AzSvgPathElementEnumWrapper>()?;
    m.add_class::<AzSvgPoint>()?;
    m.add_class::<AzSvgVector>()?;
    m.add_class::<AzSvgLine>()?;
    m.add_class::<AzSvgQuadraticCurve>()?;
    m.add_class::<AzSvgCubicCurve>()?;
    m.add_class::<AzSvgRect>()?;
    m.add_class::<AzSvgColoredVertex>()?;
    m.add_class::<AzTessellatedColoredSvgNode>()?;
    m.add_class::<AzTessellatedColoredSvgNodeVecRef>()?;
    m.add_class::<AzTessellatedColoredGPUSvgNode>()?;
    m.add_class::<AzSvgVertex>()?;
    m.add_class::<AzTessellatedSvgNode>()?;
    m.add_class::<AzTessellatedSvgNodeVecRef>()?;
    m.add_class::<AzTessellatedGPUSvgNode>()?;
    m.add_class::<AzSvgParseOptions>()?;
    m.add_class::<AzShapeRenderingEnumWrapper>()?;
    m.add_class::<AzTextRenderingEnumWrapper>()?;
    m.add_class::<AzImageRenderingEnumWrapper>()?;
    m.add_class::<AzFontDatabaseEnumWrapper>()?;
    m.add_class::<AzSvgRenderOptions>()?;
    m.add_class::<AzSvgRenderTransform>()?;
    m.add_class::<AzSvgStringFormatOptions>()?;
    m.add_class::<AzIndentEnumWrapper>()?;
    m.add_class::<AzSvgFitToEnumWrapper>()?;
    m.add_class::<AzSvgStyleEnumWrapper>()?;
    m.add_class::<AzSvgFillRuleEnumWrapper>()?;
    m.add_class::<AzSvgTransform>()?;
    m.add_class::<AzSvgFillStyle>()?;
    m.add_class::<AzSvgStrokeStyle>()?;
    m.add_class::<AzSvgLineJoinEnumWrapper>()?;
    m.add_class::<AzSvgLineCapEnumWrapper>()?;
    m.add_class::<AzSvgDashPattern>()?;

    m.add_class::<AzXml>()?;
    m.add_class::<AzXmlNode>()?;

    m.add_class::<AzFile>()?;

    m.add_class::<AzMsgBox>()?;
    m.add_class::<AzMsgBoxIconEnumWrapper>()?;
    m.add_class::<AzMsgBoxYesNoEnumWrapper>()?;
    m.add_class::<AzMsgBoxOkCancelEnumWrapper>()?;
    m.add_class::<AzFileDialog>()?;
    m.add_class::<AzFileTypeList>()?;
    m.add_class::<AzColorPickerDialog>()?;

    m.add_class::<AzSystemClipboard>()?;

    m.add_class::<AzInstantEnumWrapper>()?;
    m.add_class::<AzInstantPtr>()?;
    m.add_class::<AzInstantPtrCloneFn>()?;
    m.add_class::<AzInstantPtrDestructorFn>()?;
    m.add_class::<AzSystemTick>()?;
    m.add_class::<AzDurationEnumWrapper>()?;
    m.add_class::<AzSystemTimeDiff>()?;
    m.add_class::<AzSystemTickDiff>()?;

    m.add_class::<AzTimerId>()?;
    m.add_class::<AzTimer>()?;
    m.add_class::<AzTerminateTimerEnumWrapper>()?;
    m.add_class::<AzThreadId>()?;
    m.add_class::<AzThread>()?;
    m.add_class::<AzThreadSender>()?;
    m.add_class::<AzThreadReceiver>()?;
    m.add_class::<AzThreadSendMsgEnumWrapper>()?;
    m.add_class::<AzThreadReceiveMsgEnumWrapper>()?;
    m.add_class::<AzThreadWriteBackMsg>()?;
    m.add_class::<AzCreateThreadFn>()?;
    m.add_class::<AzGetSystemTimeFn>()?;
    m.add_class::<AzCheckThreadFinishedFn>()?;
    m.add_class::<AzLibrarySendThreadMsgFn>()?;
    m.add_class::<AzLibraryReceiveThreadMsgFn>()?;
    m.add_class::<AzThreadRecvFn>()?;
    m.add_class::<AzThreadSendFn>()?;
    m.add_class::<AzThreadDestructorFn>()?;
    m.add_class::<AzThreadReceiverDestructorFn>()?;
    m.add_class::<AzThreadSenderDestructorFn>()?;

    m.add_class::<AzFmtValueEnumWrapper>()?;
    m.add_class::<AzFmtArg>()?;
    m.add_class::<AzString>()?;

    m.add_class::<AzListViewRowVec>()?;
    m.add_class::<AzStyleFilterVec>()?;
    m.add_class::<AzLogicalRectVec>()?;
    m.add_class::<AzNodeTypeIdInfoMapVec>()?;
    m.add_class::<AzInputOutputTypeIdInfoMapVec>()?;
    m.add_class::<AzNodeIdNodeMapVec>()?;
    m.add_class::<AzInputOutputTypeIdVec>()?;
    m.add_class::<AzNodeTypeFieldVec>()?;
    m.add_class::<AzInputConnectionVec>()?;
    m.add_class::<AzOutputNodeAndIndexVec>()?;
    m.add_class::<AzOutputConnectionVec>()?;
    m.add_class::<AzInputNodeAndIndexVec>()?;
    m.add_class::<AzAccessibilityStateVec>()?;
    m.add_class::<AzMenuItemVec>()?;
    m.add_class::<AzTessellatedSvgNodeVec>()?;
    m.add_class::<AzTessellatedColoredSvgNodeVec>()?;
    m.add_class::<AzStyleFontFamilyVec>()?;
    m.add_class::<AzXmlNodeVec>()?;
    m.add_class::<AzFmtArgVec>()?;
    m.add_class::<AzInlineLineVec>()?;
    m.add_class::<AzInlineWordVec>()?;
    m.add_class::<AzInlineGlyphVec>()?;
    m.add_class::<AzInlineTextHitVec>()?;
    m.add_class::<AzMonitorVec>()?;
    m.add_class::<AzVideoModeVec>()?;
    m.add_class::<AzDomVec>()?;
    m.add_class::<AzIdOrClassVec>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVec>()?;
    m.add_class::<AzStyleBackgroundContentVec>()?;
    m.add_class::<AzStyleBackgroundPositionVec>()?;
    m.add_class::<AzStyleBackgroundRepeatVec>()?;
    m.add_class::<AzStyleBackgroundSizeVec>()?;
    m.add_class::<AzStyleTransformVec>()?;
    m.add_class::<AzCssPropertyVec>()?;
    m.add_class::<AzSvgMultiPolygonVec>()?;
    m.add_class::<AzSvgSimpleNodeVec>()?;
    m.add_class::<AzSvgPathVec>()?;
    m.add_class::<AzVertexAttributeVec>()?;
    m.add_class::<AzSvgPathElementVec>()?;
    m.add_class::<AzSvgVertexVec>()?;
    m.add_class::<AzSvgColoredVertexVec>()?;
    m.add_class::<AzU32Vec>()?;
    m.add_class::<AzXWindowTypeVec>()?;
    m.add_class::<AzVirtualKeyCodeVec>()?;
    m.add_class::<AzCascadeInfoVec>()?;
    m.add_class::<AzScanCodeVec>()?;
    m.add_class::<AzCssDeclarationVec>()?;
    m.add_class::<AzCssPathSelectorVec>()?;
    m.add_class::<AzStylesheetVec>()?;
    m.add_class::<AzCssRuleBlockVec>()?;
    m.add_class::<AzU16Vec>()?;
    m.add_class::<AzF32Vec>()?;
    m.add_class::<AzU8Vec>()?;
    m.add_class::<AzCallbackDataVec>()?;
    m.add_class::<AzDebugMessageVec>()?;
    m.add_class::<AzGLuintVec>()?;
    m.add_class::<AzGLintVec>()?;
    m.add_class::<AzStringVec>()?;
    m.add_class::<AzStringPairVec>()?;
    m.add_class::<AzNormalizedLinearColorStopVec>()?;
    m.add_class::<AzNormalizedRadialColorStopVec>()?;
    m.add_class::<AzNodeIdVec>()?;
    m.add_class::<AzNodeHierarchyItemVec>()?;
    m.add_class::<AzStyledNodeVec>()?;
    m.add_class::<AzTagIdToNodeIdMappingVec>()?;
    m.add_class::<AzParentWithNodeDepthVec>()?;
    m.add_class::<AzNodeDataVec>()?;
    m.add_class::<AzStyleFontFamilyVecDestructorEnumWrapper>()?;
    m.add_class::<AzListViewRowVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleFilterVecDestructorEnumWrapper>()?;
    m.add_class::<AzLogicalRectVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeTypeIdInfoMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputOutputTypeIdInfoMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeIdNodeMapVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputOutputTypeIdVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeTypeFieldVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputConnectionVecDestructorEnumWrapper>()?;
    m.add_class::<AzOutputNodeAndIndexVecDestructorEnumWrapper>()?;
    m.add_class::<AzOutputConnectionVecDestructorEnumWrapper>()?;
    m.add_class::<AzInputNodeAndIndexVecDestructorEnumWrapper>()?;
    m.add_class::<AzAccessibilityStateVecDestructorEnumWrapper>()?;
    m.add_class::<AzMenuItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzTessellatedSvgNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzTessellatedColoredSvgNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzXmlNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzFmtArgVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineLineVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineWordVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineGlyphVecDestructorEnumWrapper>()?;
    m.add_class::<AzInlineTextHitVecDestructorEnumWrapper>()?;
    m.add_class::<AzMonitorVecDestructorEnumWrapper>()?;
    m.add_class::<AzVideoModeVecDestructorEnumWrapper>()?;
    m.add_class::<AzDomVecDestructorEnumWrapper>()?;
    m.add_class::<AzIdOrClassVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataInlineCssPropertyVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundContentVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundPositionVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundRepeatVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleBackgroundSizeVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyleTransformVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssPropertyVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgMultiPolygonVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgSimpleNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgPathVecDestructorEnumWrapper>()?;
    m.add_class::<AzVertexAttributeVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgPathElementVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgVertexVecDestructorEnumWrapper>()?;
    m.add_class::<AzSvgColoredVertexVecDestructorEnumWrapper>()?;
    m.add_class::<AzU32VecDestructorEnumWrapper>()?;
    m.add_class::<AzXWindowTypeVecDestructorEnumWrapper>()?;
    m.add_class::<AzVirtualKeyCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzCascadeInfoVecDestructorEnumWrapper>()?;
    m.add_class::<AzScanCodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssDeclarationVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssPathSelectorVecDestructorEnumWrapper>()?;
    m.add_class::<AzStylesheetVecDestructorEnumWrapper>()?;
    m.add_class::<AzCssRuleBlockVecDestructorEnumWrapper>()?;
    m.add_class::<AzF32VecDestructorEnumWrapper>()?;
    m.add_class::<AzU16VecDestructorEnumWrapper>()?;
    m.add_class::<AzU8VecDestructorEnumWrapper>()?;
    m.add_class::<AzCallbackDataVecDestructorEnumWrapper>()?;
    m.add_class::<AzDebugMessageVecDestructorEnumWrapper>()?;
    m.add_class::<AzGLuintVecDestructorEnumWrapper>()?;
    m.add_class::<AzGLintVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringVecDestructorEnumWrapper>()?;
    m.add_class::<AzStringPairVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedLinearColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzNormalizedRadialColorStopVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeIdVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeHierarchyItemVecDestructorEnumWrapper>()?;
    m.add_class::<AzStyledNodeVecDestructorEnumWrapper>()?;
    m.add_class::<AzTagIdToNodeIdMappingVecDestructorEnumWrapper>()?;
    m.add_class::<AzParentWithNodeDepthVecDestructorEnumWrapper>()?;
    m.add_class::<AzNodeDataVecDestructorEnumWrapper>()?;

    m.add_class::<AzOptionSvgPointEnumWrapper>()?;
    m.add_class::<AzOptionStyleTextAlignEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnRowClickEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnColumnClickEnumWrapper>()?;
    m.add_class::<AzOptionListViewOnLazyLoadScrollEnumWrapper>()?;
    m.add_class::<AzOptionMenuEnumWrapper>()?;
    m.add_class::<AzOptionPixelValueNoPercentEnumWrapper>()?;
    m.add_class::<AzOptionDropDownOnChoiceChangeEnumWrapper>()?;
    m.add_class::<AzOptionResolvedTextLayoutOptionsEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeAddedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeRemovedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeGraphDraggedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeDraggedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeConnectedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeInputDisconnectedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeOutputDisconnectedEnumWrapper>()?;
    m.add_class::<AzOptionNodeGraphOnNodeFieldEditedEnumWrapper>()?;
    m.add_class::<AzOptionColorInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionButtonOnClickEnumWrapper>()?;
    m.add_class::<AzOptionTabOnClickEnumWrapper>()?;
    m.add_class::<AzOptionFileInputOnPathChangeEnumWrapper>()?;
    m.add_class::<AzOptionCheckBoxOnToggleEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnTextInputEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnVirtualKeyDownEnumWrapper>()?;
    m.add_class::<AzOptionTextInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionTextInputSelectionEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnFocusLostEnumWrapper>()?;
    m.add_class::<AzOptionNumberInputOnValueChangeEnumWrapper>()?;
    m.add_class::<AzOptionMenuItemIconEnumWrapper>()?;
    m.add_class::<AzOptionMenuCallbackEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeComboEnumWrapper>()?;
    m.add_class::<AzOptionCssPropertyEnumWrapper>()?;
    m.add_class::<AzOptionPositionInfoEnumWrapper>()?;
    m.add_class::<AzOptionTimerIdEnumWrapper>()?;
    m.add_class::<AzOptionThreadIdEnumWrapper>()?;
    m.add_class::<AzOptionI16EnumWrapper>()?;
    m.add_class::<AzOptionU16EnumWrapper>()?;
    m.add_class::<AzOptionU32EnumWrapper>()?;
    m.add_class::<AzOptionImageRefEnumWrapper>()?;
    m.add_class::<AzOptionFontRefEnumWrapper>()?;
    m.add_class::<AzOptionSystemClipboardEnumWrapper>()?;
    m.add_class::<AzOptionFileTypeListEnumWrapper>()?;
    m.add_class::<AzOptionWindowStateEnumWrapper>()?;
    m.add_class::<AzOptionMouseStateEnumWrapper>()?;
    m.add_class::<AzOptionKeyboardStateEnumWrapper>()?;
    m.add_class::<AzOptionStringVecEnumWrapper>()?;
    m.add_class::<AzOptionFileEnumWrapper>()?;
    m.add_class::<AzOptionGlEnumWrapper>()?;
    m.add_class::<AzOptionThreadReceiveMsgEnumWrapper>()?;
    m.add_class::<AzOptionPercentageValueEnumWrapper>()?;
    m.add_class::<AzOptionAngleValueEnumWrapper>()?;
    m.add_class::<AzOptionRendererOptionsEnumWrapper>()?;
    m.add_class::<AzOptionCallbackEnumWrapper>()?;
    m.add_class::<AzOptionThreadSendMsgEnumWrapper>()?;
    m.add_class::<AzOptionLayoutRectEnumWrapper>()?;
    m.add_class::<AzOptionRefAnyEnumWrapper>()?;
    m.add_class::<AzOptionInlineTextEnumWrapper>()?;
    m.add_class::<AzOptionLayoutPointEnumWrapper>()?;
    m.add_class::<AzOptionLayoutSizeEnumWrapper>()?;
    m.add_class::<AzOptionWindowThemeEnumWrapper>()?;
    m.add_class::<AzOptionNodeIdEnumWrapper>()?;
    m.add_class::<AzOptionDomNodeIdEnumWrapper>()?;
    m.add_class::<AzOptionColorUEnumWrapper>()?;
    m.add_class::<AzOptionRawImageEnumWrapper>()?;
    m.add_class::<AzOptionSvgDashPatternEnumWrapper>()?;
    m.add_class::<AzOptionWaylandThemeEnumWrapper>()?;
    m.add_class::<AzOptionTaskBarIconEnumWrapper>()?;
    m.add_class::<AzOptionHwndHandleEnumWrapper>()?;
    m.add_class::<AzOptionLogicalPositionEnumWrapper>()?;
    m.add_class::<AzOptionPhysicalPositionI32EnumWrapper>()?;
    m.add_class::<AzOptionWindowIconEnumWrapper>()?;
    m.add_class::<AzOptionStringEnumWrapper>()?;
    m.add_class::<AzOptionX11VisualEnumWrapper>()?;
    m.add_class::<AzOptionI32EnumWrapper>()?;
    m.add_class::<AzOptionF32EnumWrapper>()?;
    m.add_class::<AzOptionMouseCursorTypeEnumWrapper>()?;
    m.add_class::<AzOptionLogicalSizeEnumWrapper>()?;
    m.add_class::<AzOptionCharEnumWrapper>()?;
    m.add_class::<AzOptionVirtualKeyCodeEnumWrapper>()?;
    m.add_class::<AzOptionDomEnumWrapper>()?;
    m.add_class::<AzOptionTextureEnumWrapper>()?;
    m.add_class::<AzOptionImageMaskEnumWrapper>()?;
    m.add_class::<AzOptionTabIndexEnumWrapper>()?;
    m.add_class::<AzOptionTagIdEnumWrapper>()?;
    m.add_class::<AzOptionDurationEnumWrapper>()?;
    m.add_class::<AzOptionInstantEnumWrapper>()?;
    m.add_class::<AzOptionUsizeEnumWrapper>()?;
    m.add_class::<AzOptionU8VecEnumWrapper>()?;
    m.add_class::<AzOptionU8VecRefEnumWrapper>()?;

    m.add_class::<AzResultXmlXmlErrorEnumWrapper>()?;
    m.add_class::<AzResultRawImageDecodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultU8VecEncodeImageErrorEnumWrapper>()?;
    m.add_class::<AzResultSvgXmlNodeSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzResultSvgSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzSvgParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlErrorEnumWrapper>()?;
    m.add_class::<AzDuplicatedNamespaceError>()?;
    m.add_class::<AzUnknownNamespaceError>()?;
    m.add_class::<AzUnexpectedCloseTagError>()?;
    m.add_class::<AzUnknownEntityReferenceError>()?;
    m.add_class::<AzDuplicatedAttributeError>()?;
    m.add_class::<AzXmlParseErrorEnumWrapper>()?;
    m.add_class::<AzXmlTextError>()?;
    m.add_class::<AzXmlStreamErrorEnumWrapper>()?;
    m.add_class::<AzNonXmlCharError>()?;
    m.add_class::<AzInvalidCharError>()?;
    m.add_class::<AzInvalidCharMultipleError>()?;
    m.add_class::<AzInvalidQuoteError>()?;
    m.add_class::<AzInvalidSpaceError>()?;
    m.add_class::<AzInvalidStringError>()?;
    m.add_class::<AzSvgParseErrorPosition>()?;

    Ok(())
}
