# Azul ContentEditable Full Architectural Analysis
# Generated: 2026-01-28T20:23:16.838375
# Purpose: Debug multiple contenteditable and layout bugs

## BUGS TO FIX (Priority Order)

### MAJOR BUGS:

1. **Text Input Not Working**
   - Clicking on contenteditable positions cursor (green cursor visible)
   - Typing 'f' multiple times produces: `[record_text_input] ERROR: No focused node!`
   - The contenteditable div should be focusable
   - Need to understand how focus works when `<div tabindex=0>` is parent of contenteditable
   - Focus should be set on click, not just cursor position

2. **Line Wrapping When It Shouldn't**
   - ContentEditable wraps lines but shouldn't in this case
   - Should horizontally overflow and be horizontally scrollable
   - Related to `white-space` CSS property handling

3. **Scroll Into View**
   - When typing, cursor should scroll into view
   - Cannot test until text input works

### MINOR BUGS:

4. **Scrollbar Visibility (auto mode)**
   - Scrollbar shows at 100% even though nothing to scroll
   - `overflow: auto` should hide scrollbar when content fits
   - Also affects size reservation (auto shouldn't reserve space if not scrollable)

5. **Scrollbar Track Width**
   - Track width calculated wrong
   - Should be "100% - button sizes on each side"

6. **Scrollbar Position**
   - Scrollbar in wrong position/size
   - Should use "inner" box (directly below text), not outer box

7. **Border Position**
   - Light grey 1px border around content is mispositioned
   - Border and content with padding should NEVER be visually detached

8. **Font Resolution**
   - "d" character shows as box (missing glyph)
   - Wrong font being used
   - Need to debug rust-fontconfig and text3 font resolution

---

## CHAT SUMMARY (Context from debugging session)

### Investigation Timeline:
1. User reported clicking positions cursor but typing doesn't work
2. Found `insertText:replacementRange:` never called - added `interpretKeyEvents` to `keyDown`
3. Still getting "blip" sound - fixed `selectedRange()` to return `{location: 0, length: 0}` not `NSNotFound`
4. No blip but still no text - NSTextInputClient not triggering with objc2
5. Workaround: Direct text input in `handle_key_down` for printable characters
6. Still "No focused node" error - clicking sets cursor but not focus
7. Found: `is_contenteditable` check only checked IFC root node
8. Fix attempt: Walk up DOM tree to find `contenteditable` attribute on ancestor
9. STILL NOT WORKING - "No focused node" error persists

### Key Files Modified:
- `dll/src/desktop/shell2/macos/mod.rs` - keyDown, selectedRange, insert_text
- `dll/src/desktop/shell2/macos/events.rs` - handle_key_down direct text input
- `layout/src/window.rs` - contenteditable ancestor detection
- `layout/src/text3/edit.rs` - CursorAffinity handling

### Architecture Understanding:
- IFC root node is the TEXT node, not the DIV with contenteditable
- `contenteditable` attribute is on parent DIV
- Focus manager and cursor manager are separate
- macOS uses NSTextInputClient protocol via objc2 bindings

---

## SCREENSHOT

The screenshot shows:

- "Click here and type..." text with wrong font
- Scrollbar visible at 100% (shouldn't be visible)
- Light grey border visually detached from content
- Font rendering issue with "d" character

---

## CURRENT GIT DIFF (Uncommitted Changes)

```diff
diff --git a/dll/src/desktop/shell2/common/event_v2.rs b/dll/src/desktop/shell2/common/event_v2.rs
index 49911bb9..e6b95f64 100644
--- a/dll/src/desktop/shell2/common/event_v2.rs
+++ b/dll/src/desktop/shell2/common/event_v2.rs
@@ -2919,6 +2919,14 @@ pub trait PlatformWindowV2 {
                 if !dirty_nodes.is_empty() {
                     println!("[process_callback_result_v2] Applied text changeset, {} dirty nodes", dirty_nodes.len());
                     event_result = event_result.max(ProcessEventResult::ShouldReRenderCurrentWindow);
+                    
+                    // CRITICAL FIX: Scroll cursor into view after text edit
+                    // Without this, typing at the end of a long text doesn't scroll
+                    // the view to keep the cursor visible.
+                    layout_window.scroll_selection_into_view(
+                        azul_layout::window::SelectionScrollType::Cursor,
+                        azul_layout::window::ScrollMode::Instant,
+                    );
                 }
             }
         }
diff --git a/dll/src/desktop/shell2/macos/events.rs b/dll/src/desktop/shell2/macos/events.rs
index c0d1260c..d40ffeba 100644
--- a/dll/src/desktop/shell2/macos/events.rs
+++ b/dll/src/desktop/shell2/macos/events.rs
@@ -373,11 +373,20 @@ impl MacOSWindow {
         // Update keyboard state with keycode
         self.update_keyboard_state(key_code, modifiers, true);
 
-        // Record text input if character is available
+        // Handle text input for printable characters
+        // On macOS, interpretKeyEvents SHOULD trigger insertText: via NSTextInputClient,
+        // but there seems to be an issue with protocol conformance in objc2.
+        // So we handle printable characters directly here.
+        // Control characters and modified keys (Cmd+X, Ctrl+C, etc.) are NOT inserted as text.
         if let Some(ch) = character {
-            if let Some(layout_window) = self.get_layout_window_mut() {
+            let is_control_char = ch.is_control();
+            let has_cmd = modifiers.contains(objc2_app_kit::NSEventModifierFlags::Command);
+            let has_ctrl = modifiers.contains(objc2_app_kit::NSEventModifierFlags::Control);
+            
+            // Only insert text for normal printable characters without Cmd/Ctrl
+            if !is_control_char && !has_cmd && !has_ctrl {
                 let text_input = ch.to_string();
-                layout_window.record_text_input(&text_input);
+                self.handle_text_input(&text_input);
             }
         }
 
@@ -410,19 +419,64 @@ impl MacOSWindow {
     /// This is the proper way to handle text input on macOS, as it respects
     /// the IME composition system for non-ASCII characters (accents, CJK, etc.)
     pub fn handle_text_input(&mut self, text: &str) {
+        use crate::desktop::shell2::common::event_v2::{CallbackTarget, HitTestNode};
+        use azul_core::events::ProcessEventResult;
+        
         // Save previous state BEFORE making changes
         self.previous_window_state = Some(self.current_window_state.clone());
 
-        // Record text input - V2 system will detect TextInput event from state diff
-        if let Some(layout_window) = self.get_layout_window_mut() {
-            layout_window.record_text_input(text);
+        // Record text input - this returns a map of nodes that need TextInput event dispatched
+        let affected_nodes = if let Some(layout_window) = self.get_layout_window_mut() {
+            layout_window.record_text_input(text)
+        } else {
+            return; // No layout window, nothing to do
+        };
+
+        if affected_nodes.is_empty() {
+            println!("[handle_text_input] No affected nodes returned from record_text_input");
+            return;
+        }
+
+        // Manually process the generated text input event.
+        // We do NOT call process_window_events_recursive_v2() here, because that function
+        // is for discovering events from state diffs. Here, we already know the exact event.
+        let mut overall_result = ProcessEventResult::DoNothing;
+        
+        for (dom_node_id, (event_filters, _needs_relayout)) in affected_nodes {
+            // Convert DomNodeId to CallbackTarget
+            if let Some(node_id) = dom_node_id.node.into_crate_internal() {
+                let callback_target = CallbackTarget::Node(HitTestNode {
+                    dom_id: dom_node_id.dom.inner as u64,
+                    node_id: node_id.index() as u64,
+                });
+                
+                // Invoke callbacks for each event filter (typically OnTextInput)
+                for event_filter in &event_filters {
+                    println!("[handle_text_input] Invoking callback for {:?}", event_filter);
+                    let callback_results = self.invoke_callbacks_v2(callback_target.clone(), event_filter.clone());
+                    
+                    // Process each callback result
+                    for callback_result in &callback_results {
+                        let process_result = self.process_callback_result_v2(callback_result);
+                        overall_result = overall_result.max(process_result);
+                    }
+                }
+            }
         }
 
-        // Process V2 events
-        let _ = self.process_window_events_recursive_v2(0);
+        // Apply text changeset after callbacks
+        if let Some(layout_window) = self.get_layout_window_mut() {
+            let dirty_nodes = layout_window.apply_text_changeset();
+            if !dirty_nodes.is_empty() {
+                println!("[handle_text_input] Applied text changeset, {} dirty nodes", dirty_nodes.len());
+                overall_result = overall_result.max(ProcessEventResult::ShouldReRenderCurrentWindow);
+            }
+        }
 
         // Request redraw if needed
-        self.frame_needs_regeneration = true;
+        if overall_result >= ProcessEventResult::ShouldReRenderCurrentWindow {
+            self.frame_needs_regeneration = true;
+        }
     }
 
     /// Process a flags changed event (modifier keys).
diff --git a/dll/src/desktop/shell2/macos/mod.rs b/dll/src/desktop/shell2/macos/mod.rs
index cb6f3ada..4fca8619 100644
--- a/dll/src/desktop/shell2/macos/mod.rs
+++ b/dll/src/desktop/shell2/macos/mod.rs
@@ -291,7 +291,12 @@ define_class!(
 
         #[unsafe(method(keyDown:))]
         fn key_down(&self, event: &NSEvent) {
-            // Forward to MacOSWindow for handling
+            // CRITICAL: Call interpretKeyEvents to trigger NSTextInputClient insertText:
+            unsafe {
+                let events = objc2_foundation::NSArray::from_slice(&[event]);
+                self.interpretKeyEvents(&events);
+            }
+            // Forward to MacOSWindow for non-text keys
             if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                 unsafe {
                     use crate::desktop::shell2::macos::events::EventProcessResult;
@@ -541,9 +546,11 @@ define_class!(
 
         #[unsafe(method(selectedRange))]
         fn selected_range(&self) -> NSRange {
-            // Return NSNotFound to indicate no selection
+            // CRITICAL: Return a valid cursor position (location 0, length 0 = cursor at position 0)
+            // Returning NSNotFound (usize::MAX) tells macOS there's no insertion point,
+            // and it will NOT call insertText:replacementRange:
             NSRange {
-                location: usize::MAX,
+                location: 0,
                 length: 0,
             }
         }
@@ -555,6 +562,7 @@ define_class!(
             _selected_range: NSRange,
             _replacement_range: NSRange,
         ) {
+            println!("[GLView::setMarkedText] Called");
             // Phase 2: OnCompositionStart callback - sync IME position
             if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                 unsafe {
@@ -566,6 +574,7 @@ define_class!(
 
         #[unsafe(method(unmarkText))]
         fn unmark_text(&self) {
+            println!("[GLView::unmarkText] Called");
             // Called when IME composition is finished
         }
 
@@ -586,10 +595,15 @@ define_class!(
 
         #[unsafe(method(insertText:replacementRange:))]
         fn insert_text(&self, string: &NSObject, _replacement_range: NSRange) {
+            println!("[GLView::insert_text] Called!");
+            
             // Get the back-pointer to our MacOSWindow
             let window_ptr = match self.get_window_ptr() {
                 Some(ptr) => ptr,
-                None => return,
+                None => {
+                    println!("[GLView::insert_text] ERROR: No window pointer!");
+                    return;
+                }
             };
 
             // SAFETY: We trust that the window pointer is valid.
@@ -597,7 +611,10 @@ define_class!(
                 let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                 if let Some(ns_string) = string.downcast_ref::<NSString>() {
                     let text = ns_string.to_string();
+                    println!("[GLView::insert_text] Inserting text: '{}'", text);
                     macos_window.handle_text_input(&text);
+                } else {
+                    println!("[GLView::insert_text] ERROR: Could not downcast to NSString");
                 }
             }
         }
@@ -820,7 +837,12 @@ define_class!(
 
         #[unsafe(method(keyDown:))]
         fn key_down(&self, event: &NSEvent) {
-            // Forward to MacOSWindow for handling
+            // CRITICAL: Call interpretKeyEvents to trigger NSTextInputClient insertText:
+            unsafe {
+                let events = objc2_foundation::NSArray::from_slice(&[event]);
+                self.interpretKeyEvents(&events);
+            }
+            // Forward to MacOSWindow for non-text keys
             if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                 unsafe {
                     use crate::desktop::shell2::macos::events::EventProcessResult;
@@ -1066,8 +1088,11 @@ define_class!(
 
         #[unsafe(method(selectedRange))]
         fn selected_range(&self) -> NSRange {
+            // CRITICAL: Return a valid cursor position (location 0, length 0 = cursor at position 0)
+            // Returning NSNotFound (usize::MAX) tells macOS there's no insertion point,
+            // and it will NOT call insertText:replacementRange:
             NSRange {
-                location: usize::MAX,
+                location: 0,
                 length: 0,
             }
         }
@@ -1108,10 +1133,15 @@ define_class!(
 
         #[unsafe(method(insertText:replacementRange:))]
         fn insert_text(&self, string: &NSObject, _replacement_range: NSRange) {
+            println!("[CPUView::insert_text] Called!");
+            
             // Get the back-pointer to our MacOSWindow
             let window_ptr = match self.get_window_ptr() {
                 Some(ptr) => ptr,
-                None => return,
+                None => {
+                    println!("[CPUView::insert_text] ERROR: No window pointer!");
+                    return;
+                }
             };
 
             // SAFETY: We trust that the window pointer is valid.
@@ -1119,7 +1149,10 @@ define_class!(
                 let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                 if let Some(ns_string) = string.downcast_ref::<NSString>() {
                     let text = ns_string.to_string();
+                    println!("[CPUView::insert_text] Inserting text: '{}'", text);
                     macos_window.handle_text_input(&text);
+                } else {
+                    println!("[CPUView::insert_text] ERROR: Could not downcast to NSString");
                 }
             }
         }
diff --git a/layout/src/text3/edit.rs b/layout/src/text3/edit.rs
index ed13e9f3..b0c34dda 100644
--- a/layout/src/text3/edit.rs
+++ b/layout/src/text3/edit.rs
@@ -157,16 +157,45 @@ pub fn delete_range(
 }
 
 /// Inserts text at a cursor position.
+/// 
+/// The cursor's affinity determines the exact insertion point:
+/// - `Leading`: Insert at the start of the referenced cluster (start_byte_in_run)
+/// - `Trailing`: Insert at the end of the referenced cluster (after the grapheme)
 pub fn insert_text(
     content: &mut Vec<InlineContent>,
     cursor: &TextCursor,
     text_to_insert: &str,
 ) -> (Vec<InlineContent>, TextCursor) {
+    use unicode_segmentation::UnicodeSegmentation;
+    
     let mut new_content = content.clone();
     let run_idx = cursor.cluster_id.source_run as usize;
-    let byte_offset = cursor.cluster_id.start_byte_in_run as usize;
+    let cluster_start_byte = cursor.cluster_id.start_byte_in_run as usize;
 
     if let Some(InlineContent::Text(run)) = new_content.get_mut(run_idx) {
+        // Calculate the actual insertion byte offset based on affinity
+        let byte_offset = match cursor.affinity {
+            CursorAffinity::Leading => {
+                // Insert at the start of the cluster
+                cluster_start_byte
+            },
+            CursorAffinity::Trailing => {
+                // Insert at the end of the cluster - find the next grapheme boundary
+                // We need to find where this grapheme cluster ends
+                if cluster_start_byte >= run.text.len() {
+                    // Cursor is at/past end of run - insert at end
+                    run.text.len()
+                } else {
+                    // Find the grapheme that starts at cluster_start_byte and get its end
+                    run.text[cluster_start_byte..]
+                        .grapheme_indices(true)
+                        .next()
+                        .map(|(_, grapheme)| cluster_start_byte + grapheme.len())
+                        .unwrap_or(run.text.len())
+                }
+            },
+        };
+        
         if byte_offset <= run.text.len() {
             run.text.insert_str(byte_offset, text_to_insert);
 
@@ -186,6 +215,10 @@ pub fn insert_text(
 }
 
 /// Deletes one grapheme cluster backward from the cursor.
+/// 
+/// The cursor's affinity determines the actual cursor position:
+/// - `Leading`: Cursor is at start of cluster, delete the previous grapheme
+/// - `Trailing`: Cursor is at end of cluster, delete the current grapheme
 pub fn delete_backward(
     content: &mut Vec<InlineContent>,
     cursor: &TextCursor,
@@ -193,9 +226,26 @@ pub fn delete_backward(
     use unicode_segmentation::UnicodeSegmentation;
     let mut new_content = content.clone();
     let run_idx = cursor.cluster_id.source_run as usize;
-    let byte_offset = cursor.cluster_id.start_byte_in_run as usize;
+    let cluster_start_byte = cursor.cluster_id.start_byte_in_run as usize;
 
     if let Some(InlineContent::Text(run)) = new_content.get_mut(run_idx) {
+        // Calculate the actual cursor byte offset based on affinity
+        let byte_offset = match cursor.affinity {
+            CursorAffinity::Leading => cluster_start_byte,
+            CursorAffinity::Trailing => {
+                // Cursor is at end of cluster - find the next grapheme boundary
+                if cluster_start_byte >= run.text.len() {
+                    run.text.len()
+                } else {
+                    run.text[cluster_start_byte..]
+                        .grapheme_indices(true)
+                        .next()
+                        .map(|(_, grapheme)| cluster_start_byte + grapheme.len())
+                        .unwrap_or(run.text.len())
+                }
+            },
+        };
+        
         if byte_offset > 0 {
             let prev_grapheme_start = run.text[..byte_offset]
                 .grapheme_indices(true)
@@ -242,6 +292,10 @@ pub fn delete_backward(
 }
 
 /// Deletes one grapheme cluster forward from the cursor.
+/// 
+/// The cursor's affinity determines the actual cursor position:
+/// - `Leading`: Cursor is at start of cluster, delete the current grapheme
+/// - `Trailing`: Cursor is at end of cluster, delete the next grapheme
 pub fn delete_forward(
     content: &mut Vec<InlineContent>,
     cursor: &TextCursor,
@@ -249,9 +303,26 @@ pub fn delete_forward(
     use unicode_segmentation::UnicodeSegmentation;
     let mut new_content = content.clone();
     let run_idx = cursor.cluster_id.source_run as usize;
-    let byte_offset = cursor.cluster_id.start_byte_in_run as usize;
+    let cluster_start_byte = cursor.cluster_id.start_byte_in_run as usize;
 
     if let Some(InlineContent::Text(run)) = new_content.get_mut(run_idx) {
+        // Calculate the actual cursor byte offset based on affinity
+        let byte_offset = match cursor.affinity {
+            CursorAffinity::Leading => cluster_start_byte,
+            CursorAffinity::Trailing => {
+                // Cursor is at end of cluster - find the next grapheme boundary
+                if cluster_start_byte >= run.text.len() {
+                    run.text.len()
+                } else {
+                    run.text[cluster_start_byte..]
+                        .grapheme_indices(true)
+                        .next()
+                        .map(|(_, grapheme)| cluster_start_byte + grapheme.len())
+                        .unwrap_or(run.text.len())
+                }
+            },
+        };
+        
         if byte_offset < run.text.len() {
             let next_grapheme_end = run.text[byte_offset..]
                 .grapheme_indices(true)
@@ -259,8 +330,15 @@ pub fn delete_forward(
                 .map_or(run.text.len(), |(i, _)| byte_offset + i);
             run.text.drain(byte_offset..next_grapheme_end);
 
-            // Cursor position doesn't change
-            return (new_content, *cursor);
+            // Cursor position stays at the same byte offset but with Leading affinity
+            let new_cursor = TextCursor {
+                cluster_id: GraphemeClusterId {
+                    source_run: run_idx as u32,
+                    start_byte_in_run: byte_offset as u32,
+                },
+                affinity: CursorAffinity::Leading,
+            };
+            return (new_content, new_cursor);
         } else if run_idx < content.len() - 1 {
             // Handle deleting across run boundaries (merge with next run)
             if let Some(InlineContent::Text(next_run)) = content.get(run_idx + 1).cloned() {
diff --git a/layout/src/window.rs b/layout/src/window.rs
index 0016befd..d300cc18 100644
--- a/layout/src/window.rs
+++ b/layout/src/window.rs
@@ -5482,10 +5482,22 @@ impl LayoutWindow {
     /// Returns InlineContent vector if the node has text.
     ///
     /// # Implementation Note
-    /// This function currently reconstructs InlineContent from the styled DOM.
-    /// A future optimization would be to cache the InlineContent during layout
-    /// and retrieve it directly from the text cache.
+    /// This function FIRST checks `dirty_text_nodes` for optimistic state (edits not yet
+    /// committed to StyledDom), then falls back to the StyledDom. This is critical for
+    /// correct text input handling - without this, each keystroke would read stale state.
     pub fn get_text_before_textinput(&self, dom_id: DomId, node_id: NodeId) -> Vec<InlineContent> {
+        // CRITICAL FIX: Check dirty_text_nodes first!
+        // If the node has been edited since last full layout, its most up-to-date
+        // content is in dirty_text_nodes, NOT in the StyledDom.
+        // Without this check, every keystroke reads the ORIGINAL text instead of
+        // the accumulated edits, causing bugs like double-input and wrong node affected.
+        if let Some(dirty_node) = self.dirty_text_nodes.get(&(dom_id, node_id)) {
+            #[cfg(feature = "std")]
+            eprintln!("[get_text_before_textinput] Using dirty_text_nodes content for ({:?}, {:?})", dom_id, node_id);
+            return dirty_node.content.clone();
+        }
+
+        // Fallback to committed state from StyledDom
         // Get the layout result for this DOM
         let layout_result = match self.layout_results.get(&dom_id) {
             Some(lr) => lr,
@@ -6486,6 +6498,61 @@ impl LayoutWindow {
         
         self.selection_manager.set_selection(dom_id, state);
 
+        // CRITICAL FIX 1: Set focus on the clicked node
+        // Without this, clicking on a contenteditable element shows a cursor but
+        // text input doesn't work because record_text_input() checks focus_manager.get_focused_node()
+        // and returns early if there's no focus.
+        //
+        // Check if the node OR ANY ANCESTOR is contenteditable before setting focus
+        // The contenteditable attribute is typically on a parent div, not on the IFC root or text node
+        let is_contenteditable = self.layout_results.get(&dom_id)
+            .map(|lr| {
+                let node_hierarchy = lr.styled_dom.node_hierarchy.as_container();
+                let node_data = lr.styled_dom.node_data.as_ref();
+                
+                // Walk up the DOM tree to check if any ancestor has contenteditable
+                let mut current_node = Some(ifc_root_node_id);
+                while let Some(node_id) = current_node {
+                    if let Some(styled_node) = node_data.get(node_id.index()) {
+                        let has_contenteditable = styled_node.attributes.as_ref().iter().any(|attr| {
+                            matches!(attr, azul_core::dom::AttributeType::ContentEditable(_))
+                        });
+                        if has_contenteditable {
+                            #[cfg(feature = "std")]
+                            eprintln!("[DEBUG] Found contenteditable on node {:?}", node_id);
+                            return true;
+                        }
+                    }
+                    // Move to parent
+                    current_node = node_hierarchy.get(node_id).and_then(|h| h.parent_id());
+                }
+                false
+            })
+            .unwrap_or(false);
+        
+        // W3C conformance: contenteditable elements are implicitly focusable
+        if is_contenteditable {
+            self.focus_manager.set_focused_node(Some(dom_node_id));
+            #[cfg(feature = "std")]
+            eprintln!("[DEBUG] Set focus on contenteditable node {:?}", ifc_root_node_id);
+        }
+
+        // CRITICAL FIX 2: Initialize the CursorManager with the clicked position
+        // Without this, clicking on a contenteditable element sets focus (blue outline)
+        // but the text cursor doesn't appear because CursorManager is never told where to draw it.
+        let now = azul_core::task::Instant::now();
+        self.cursor_manager.move_cursor_to(
+            final_range.start.clone(),
+            dom_id,
+            ifc_root_node_id,
+        );
+        // Reset the blink timer so the cursor is immediately visible
+        self.cursor_manager.reset_blink_on_input(now);
+        self.cursor_manager.set_blink_timer_active(true);
+        
+        #[cfg(feature = "std")]
+        eprintln!("[DEBUG] Initialized cursor at {:?} for node {:?}", final_range.start, ifc_root_node_id);
+
         // Return the affected node for dirty tracking
         Some(vec![dom_node_id])
     }
diff --git a/tests/e2e/contenteditable.c b/tests/e2e/contenteditable.c
index c76d5ba4..3e9e6b7d 100644
--- a/tests/e2e/contenteditable.c
+++ b/tests/e2e/contenteditable.c
@@ -53,39 +53,10 @@ AzUpdate on_text_input(AzRefAny data, AzCallbackInfo info) {
         return AzUpdate_DoNothing;
     }
     
-    // Get the text changeset from the callback info
-    AzOptionPendingTextEdit changeset = AzCallbackInfo_getTextChangeset(&info);
-    
-    if (changeset.Some.tag == AzOptionPendingTextEdit_Tag_Some) {
-        AzPendingTextEdit* edit = &changeset.Some.payload;
-        
-        // Print the changeset for debugging
-        printf("[TextInput] Changeset received:\n");
-        printf("  inserted_text: '%.*s'\n", 
-               (int)edit->inserted_text.vec.len, 
-               (const char*)edit->inserted_text.vec.ptr);
-        printf("  old_text: '%.*s' (len=%zu)\n", 
-               (int)(edit->old_text.vec.len > 50 ? 50 : edit->old_text.vec.len),
-               (const char*)edit->old_text.vec.ptr,
-               edit->old_text.vec.len);
-        
-        // Append the inserted text to our data model
-        // For single-line, we just append to the existing text
-        size_t current_len = strlen(ref.ptr->single_line_text);
-        size_t insert_len = edit->inserted_text.vec.len;
-        
-        if (current_len + insert_len < sizeof(ref.ptr->single_line_text) - 1) {
-            memcpy(ref.ptr->single_line_text + current_len, 
-                   edit->inserted_text.vec.ptr, 
-                   insert_len);
-            ref.ptr->single_line_text[current_len + insert_len] = '\0';
-            printf("  Updated single_line_text: '%s'\n", ref.ptr->single_line_text);
-        }
-        
-        ref.ptr->text_change_count++;
-    } else {
-        printf("[TextInput] No changeset available\n");
-    }
+    // Just count the text input event - the framework handles the actual text update
+    // The contenteditable system uses its internal state for visual updates
+    ref.ptr->text_change_count++;
+    printf("[TextInput] Event received (count: %d)\n", ref.ptr->text_change_count);
     
     ContentEditableDataRefMut_delete(&ref);
     

```

---

## RECENT COMMITS (Last 10 with diffs)

```
f5ddf8b3 Add plan for full text input implementation and architecture
diff --git a/scripts/TEXT_INPUT_IMPLEMENTATION_PLAN_V3.md b/scripts/TEXT_INPUT_IMPLEMENTATION_PLAN_V3.md
new file mode 100644
index 00000000..f7116344
--- /dev/null
+++ b/scripts/TEXT_INPUT_IMPLEMENTATION_PLAN_V3.md
@@ -0,0 +1,920 @@
+# Text Input Implementation Plan V3
+
+## Executive Summary
+
+This document provides the definitive implementation plan for Azul's text input system. The key architectural insight is the **dual-path layout system**:
+
+1. **Initial Layout** → Runs on `StyledDom` (committed state from `layout()` callback)
+2. **Relayout** → Runs on `LayoutCache` (respects quick edits, handles text node resizing)
+
+This separation enables:
+- Instant visual feedback during typing (no callback latency)
+- Proper layout shift handling when text causes reflow
+- Clean separation between "optimistic" and "committed" state
+- Support for complex multi-node editing
+
+---
+
+## Part 1: Architectural Overview
+
+### 1.1 The Two Layout Paths
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                         INITIAL LAYOUT PATH                              │
+│                                                                          │
+│   User Data Model ──► layout() callback ──► StyledDom ──► LayoutCache   │
+│        (RefAny)           (pure fn)         (committed)    (visual)      │
+│                                                                          │
+│   Triggered by: Update::RefreshDom, window resize, first render          │
+└─────────────────────────────────────────────────────────────────────────┘
+
+┌─────────────────────────────────────────────────────────────────────────┐
+│                          RELAYOUT PATH                                   │
+│                                                                          │
+│   LayoutCache ──► detect dirty nodes ──► partial relayout ──► repaint   │
+│   (with edits)      (text changed)        (text only)         (fast)     │
+│                                                                          │
+│   Triggered by: Text input, cursor movement, selection change            │
+└─────────────────────────────────────────────────────────────────────────┘
+```
+
+### 1.2 Key Data Flow
+
+```
+User types 'a' 
+    │
+    ▼
+┌──────────────────────────────────────────────────────────────────┐
+│ 1. Platform layer receives keypress (macOS: NSTextInputClient)  │
+└──────────────────────────────────────────────────────────────────┘
+    │
+    ▼
+┌──────────────────────────────────────────────────────────────────┐
+│ 2. TextInputManager.record_input() creates PendingTextEdit      │
+│    - Records: inserted_text="a", old_text, node                  │
+│    - Does NOT modify any caches yet                              │
+└──────────────────────────────────────────────────────────────────┘
+    │
+    ▼
+┌──────────────────────────────────────────────────────────────────┐
+│ 3. Synthetic 'Input' event generated for contenteditable node   │
+└──────────────────────────────────────────────────────────────────┘
+    │
+    ▼
+┌──────────────────────────────────────────────────────────────────┐
+│ 4. User's On::TextInput callback fires                          │
+│    - Can call info.get_text_changeset() to inspect              │
+│    - Can call info.prevent_default() to cancel                  │
+│    - Updates their data model (RefAny)                          │
+│    - Returns Update::DoNothing (fast) or Update::RefreshDom     │
+└──────────────────────────────────────────────────────────────────┘
+    │
+    ▼
+┌──────────────────────────────────────────────────────────────────┐
+│ 5. If NOT prevented: apply_text_changeset()                     │
+│    - Calls text3::edit::edit_text() to compute new content      │
+│    - Calls update_text_cache_after_edit() for visual update     │
+│    - Updates cursor position                                     │
+│    - Marks node as dirty for relayout                           │
+└──────────────────────────────────────────────────────────────────┘
+    │
+    ▼
+┌──────────────────────────────────────────────────────────────────┐
+│ 6. Relayout runs on dirty nodes                                 │
+│    - Reads from LayoutCache (with edits), NOT StyledDom         │
+│    - Handles text node resizing                                  │
+│    - Propagates layout shifts to ancestors if needed            │
+└──────────────────────────────────────────────────────────────────┘
+    │
+    ▼
+┌──────────────────────────────────────────────────────────────────┐
+│ 7. Display list regenerated, repaint triggered                  │
+└──────────────────────────────────────────────────────────────────┘
+```
+
+---
+
+## Part 2: Data Structures
+
+### 2.1 New Fields in LayoutWindow
+
+```rust
+// In layout/src/window.rs
+
+pub struct LayoutWindow {
+    // ... existing fields ...
+    
+    /// Cache of text layout constraints for each IFC root node.
+    /// Used to perform consistent optimistic updates.
+    pub text_constraints_cache: TextConstraintsCache,
+    
+    /// Tracks which nodes have been edited since last full layout.
+    /// Key: (DomId, NodeId of IFC root)
+    /// Value: The edited Vec<InlineContent> that should be used for relayout
+    pub dirty_text_nodes: BTreeMap<(DomId, NodeId), DirtyTextNode>,
+}
+
+#[derive(Debug, Clone)]
+pub struct TextConstraintsCache {
+    /// Constraints used for each IFC during initial layout
+    pub constraints: BTreeMap<(DomId, NodeId), UnifiedConstraints>,
+}
+
+#[derive(Debug, Clone)]
+pub struct DirtyTextNode {
+    /// The new inline content (text + images) after editing
+    pub content: Vec<InlineContent>,
+    /// The new cursor position after editing
+    pub cursor: Option<TextCursor>,
+    /// Whether this edit requires ancestor relayout (e.g., text grew taller)
+    pub needs_ancestor_relayout: bool,
+}
+```
+
+### 2.2 UnifiedConstraints (Already Exists, Needs Caching)
+
+```rust
+// In layout/src/text3/cache.rs
+
+#[derive(Debug, Clone)]
+pub struct UnifiedConstraints {
+    pub available_width: AvailableSpace,
+    pub text_align: StyleTextAlign,
+    pub direction: Option<BidiDirection>,
+    pub writing_mode: WritingMode,
+    pub line_height: LineHeight,
+    pub word_break: WordBreak,
+    pub overflow_wrap: OverflowWrap,
+    pub white_space: WhiteSpace,
+    pub text_indent: f32,
+    pub letter_spacing: f32,
+    pub word_spacing: f32,
+    // ... etc
+}
+```
+
+### 2.3 Enhanced PendingTextEdit
+
+```rust
+// In layout/src/managers/text_input.rs
+
+#[derive(Debug, Clone)]
+pub struct PendingTextEdit {
+    /// The IFC root node being edited
+    pub node: DomNodeId,
+    /// The text that was inserted (can be empty for deletions)
+    pub inserted_text: String,
+    /// The old Vec<InlineContent> before the edit
+    pub old_content: Vec<InlineContent>,
+    /// The new Vec<InlineContent> after the edit (computed by text3::edit)
+    pub new_content: Option<Vec<InlineContent>>,
+    /// The new cursor position after the edit
+    pub new_cursor: Option<TextCursor>,
+    /// Source of the edit
+    pub source: TextInputSource,
+}
+```
+
+---
+
+## Part 3: Event Handling Flow
+
+### 3.1 Platform Layer → TextInputManager
+
+**File:** `dll/src/desktop/shell2/macos/text_input.rs` (and Windows/Linux equivalents)
+
+```rust
+// When user types a character:
+
+fn insert_text(&mut self, string: &str) {
+    let layout_window = self.get_layout_window_mut();
+    
+    // 1. Find the focused contenteditable node
+    let focused_node = layout_window.focus_manager.get_focused_node();
+    let Some(node_id) = focused_node else { return };
+    
+    // 2. Get current content from cache (NOT StyledDom!)
+    let old_content = layout_window.get_current_inline_content(node_id);
+    
+    // 3. Record the input (Phase 1 - just record, don't apply)
+    layout_window.text_input_manager.record_input(
+        node_id,
+        string.to_string(),
+        old_content,
+        TextInputSource::Keyboard,
+    );
+    
+    // 4. Generate synthetic Input event
+    layout_window.pending_events.push(SyntheticEvent::new(
+        EventType::Input,
+        EventSource::User,
+        node_id,
+        Instant::now(),
+        EventData::None,
+    ));
+}
+```
+
+### 3.2 Event Dispatch → User Callback
+
+**File:** `dll/src/desktop/shell2/common/event_v2.rs`
+
+```rust
+fn process_input_event(
+    &mut self,
+    event: &SyntheticEvent,
+    layout_window: &mut LayoutWindow,
+) -> ProcessedCallbackResult {
+    // 1. Find callbacks registered for On::TextInput on this node
+    let callbacks = layout_window.get_callbacks_for_event(event);
+    
+    // 2. Invoke each callback
+    let mut result = ProcessedCallbackResult::default();
+    for callback_data in callbacks {
+        let callback_info = CallbackInfo::new(layout_window, event);
+        
+        // User callback can:
+        // - info.get_text_changeset() to see what's being inserted
+        // - info.prevent_default() to cancel the edit
+        // - Modify their RefAny data model
+        let update = (callback_data.callback.cb)(
+            callback_data.refany.clone(),
+            callback_info,
+        );
+        
+        result.update.max_self(update);
+    }
+    
+    // 3. Check if prevented
+    if result.changes.contains(&CallbackChange::PreventDefault) {
+        layout_window.text_input_manager.clear_changeset();
+        return result;
+    }
+    
+    // 4. Apply the changeset (Phase 2)
+    layout_window.apply_text_changeset();
+    
+    result
+}
+```
+
+### 3.3 Applying the Changeset
+
+**File:** `layout/src/window.rs`
+
+```rust
+pub fn apply_text_changeset(&mut self) {
+    let Some(changeset) = self.text_input_manager.pending_changeset.take() else {
+        return;
+    };
+    
+    let dom_id = changeset.node.dom;
+    let node_id = changeset.node.node.into_crate_internal().unwrap();
+    
+    // 1. Get current cursor position
+    let current_cursor = self.cursor_manager.get_cursor();
+    
+    // 2. Get the old content (from cache if dirty, else from original layout)
+    let old_content = self.get_current_inline_content_internal(dom_id, node_id);
+    
+    // 3. Compute the edit using text3::edit
+    let edit_result = crate::text3::edit::edit_text(
+        &old_content,
+        &changeset.inserted_text,
+        current_cursor,
+        self.selection_manager.get_selection(dom_id),
+    );
+    
+    let Some((new_content, new_selections)) = edit_result else {
+        return;
+    };
+    
+    // 4. Update the visual cache (optimistic update)
+    self.update_text_cache_after_edit(dom_id, node_id, new_content.clone());
+    
+    // 5. Update cursor position
+    if let Some(new_cursor) = new_selections.cursor {
+        let now = Instant::now();
+        self.cursor_manager.set_cursor_with_time(
+            Some(new_cursor),
+            Some(CursorLocation { dom_id, node_id }),
+            now,
+        );
+    }
+    
+    // 6. Mark node as dirty for relayout
+    self.dirty_text_nodes.insert((dom_id, node_id), DirtyTextNode {
+        content: new_content,
+        cursor: new_selections.cursor,
+        needs_ancestor_relayout: false, // Will be determined during relayout
+    });
+    
+    // 7. Schedule relayout
+    self.needs_relayout = true;
+}
+```
+
+---
+
+## Part 4: The Dual Layout System
+
+### 4.1 Initial Layout (StyledDom Path)
+
+**File:** `layout/src/solver3/mod.rs`
+
+```rust
+/// Full layout pass - reads from StyledDom
+/// Called on: first render, Update::RefreshDom, window resize
+pub fn layout_document(
+    styled_dom: &StyledDom,
+    constraints: &LayoutConstraints,
+    font_manager: &mut FontManager,
+    // ... other params
+) -> LayoutTree {
+    // Clear dirty nodes - we're rebuilding from committed state
+    // The dirty_text_nodes map should be cleared by caller
+    
+    // Traverse StyledDom and build layout tree
+    for node in styled_dom.nodes() {
+        match node.node_type {
+            NodeType::Text(ref text) => {
+                // Convert text to InlineContent
+                let inline_content = text_to_inline_content(text, node.style);
+                // Layout the text
+                let layout = layout_inline_formatting_context(inline_content, ...);
+                // Cache the constraints for later relayout
+                ctx.text_constraints_cache.insert((dom_id, node_id), constraints);
+            }
+            // ... other node types
+        }
+    }
+}
+```
+
+### 4.2 Relayout (LayoutCache Path)
+
+**File:** `layout/src/window.rs`
+
+```rust
+/// Partial relayout - respects dirty text nodes
+/// Called on: text input, when needs_relayout is true
+pub fn relayout_dirty_nodes(&mut self) {
+    if !self.needs_relayout || self.dirty_text_nodes.is_empty() {
+        return;
+    }
+    
+    for ((dom_id, node_id), dirty_node) in self.dirty_text_nodes.iter() {
+        // 1. Get cached constraints
+        let Some(constraints) = self.text_constraints_cache.constraints.get(&(*dom_id, *node_id)) else {
+            continue;
+        };
+        
+        // 2. Re-run lightweight text layout
+        let new_layout = self.relayout_text_node(*dom_id, *node_id, &dirty_node.content, constraints);
+        
+        let Some(new_layout) = new_layout else {
+            continue;
+        };
+        
+        // 3. Check if size changed (needs ancestor relayout)
+        let old_size = self.get_node_size(*dom_id, *node_id);
+        let new_size = new_layout.bounds().size();
+        
+        if old_size.height != new_size.height || old_size.width != new_size.width {
+            // Text node changed size - need to propagate layout shift
+            self.propagate_layout_shift(*dom_id, *node_id, old_size, new_size);
+        }
+        
+        // 4. Update the cache
+        self.update_layout_cache(*dom_id, *node_id, new_layout);
+    }
+    
+    self.needs_relayout = false;
+    self.needs_display_list_update = true;
+}
+
+fn relayout_text_node(
+    &self,
+    dom_id: DomId,
+    node_id: NodeId,
+    content: &[InlineContent],
+    constraints: &UnifiedConstraints,
+) -> Option<UnifiedLayout> {
+    use crate::text3::cache::{
+        create_logical_items, reorder_logical_items, 
+        shape_visual_items, perform_fragment_layout, BreakCursor
+    };
+    
+    // Stage 1: Create logical items from InlineContent
+    let logical_items = create_logical_items(content, &[], &mut None);
+    
+    // Stage 2: Bidi reordering
+    let base_direction = constraints.direction.unwrap_or(BidiDirection::Ltr);
+    let visual_items = reorder_logical_items(&logical_items, base_direction, &mut None)?;
+    
+    // Stage 3: Shape text (resolve fonts, create glyphs)
+    let loaded_fonts = self.font_manager.get_loaded_fonts();
+    let shaped_items = shape_visual_items(
+        &visual_items,
+        self.font_manager.get_font_chain_cache(),
+        &self.font_manager.fc_cache,
+        &loaded_fonts,
+        &mut None,
+    )?;
+    
+    // Stage 4: Fragment layout (line breaking, positioning)
+    let mut cursor = BreakCursor::new(&shaped_items);
+    perform_fragment_layout(&mut cursor, &logical_items, constraints, &mut None, &loaded_fonts).ok()
+}
+```
+
+### 4.3 Layout Shift Propagation
+
+```rust
+fn propagate_layout_shift(
+    &mut self,
+    dom_id: DomId,
+    node_id: NodeId,
+    old_size: LogicalSize,
+    new_size: LogicalSize,
+) {
+    // When a text node changes size, ancestors may need relayout
+    // This is the "layout shift" that can cascade up the tree
+    
+    let height_delta = new_size.height - old_size.height;
+    let width_delta = new_size.width - old_size.width;
+    
+    if height_delta.abs() < 0.001 && width_delta.abs() < 0.001 {
+        return; // No significant change
+    }
+    
+    // For now: mark that we need full relayout for this DOM
+    // Future optimization: incremental ancestor relayout
+    self.needs_full_relayout.insert(dom_id);
+}
+```
+
+---
+
+## Part 5: Cursor and Selection
+
+### 5.1 Cursor Click Positioning
+
+**File:** `layout/src/text3/selection.rs`
+
+```rust
+use azul_core::geom::LogicalPosition;
+use azul_core::selection::{TextCursor, CursorAffinity, GraphemeClusterId};
+use crate::text3::cache::{UnifiedLayout, PositionedItem, ShapedItem};
+use std::collections::BTreeMap;
+
+/// Maps a click position to a TextCursor within a UnifiedLayout.
+/// The `point` must be relative to the layout's container origin.
+pub fn hit_test_text_at_point(
+    layout: &UnifiedLayout,
+    point: LogicalPosition,
+) -> Option<TextCursor> {
+    if layout.items.is_empty() {
+        // Empty contenteditable - cursor at beginning
+        return Some(TextCursor {
+            cluster_id: GraphemeClusterId::default(),
+            affinity: CursorAffinity::Leading,
+        });
+    }
+    
+    // Step 1: Find the line closest to the Y coordinate
+    let mut line_bounds: BTreeMap<usize, (f32, f32)> = BTreeMap::new();
+    for item in &layout.items {
+        let bounds = item.item.bounds();
+        let entry = line_bounds.entry(item.line_index).or_insert((f32::MAX, f32::MIN));
+        entry.0 = entry.0.min(item.position.y);
+        entry.1 = entry.1.max(item.position.y + bounds.height);
+    }
+    
+    let closest_line = line_bounds.iter()
+        .min_by(|(_, (a_min, a_max)), (_, (b_min, b_max))| {
+            let a_center = (a_min + a_max) / 2.0;
+            let b_center = (b_min + b_max) / 2.0;
+            (point.y - a_center).abs().partial_cmp(&(point.y - b_center).abs()).unwrap()
+        })
+        .map(|(idx, _)| *idx)
+        .unwrap_or(0);
+    
+    // Step 2: Find the closest cluster on that line
+    let clusters_on_line: Vec<_> = layout.items.iter()
+        .filter(|item| item.line_index == closest_line)
+        .filter(|item| item.item.as_cluster().is_some())
+        .collect();
+    
+    if clusters_on_line.is_empty() {
+        // Empty line - find previous line's last cluster
+        return layout.items.iter().rev()
+            .filter(|item| item.line_index < closest_line)
+            .find_map(|item| item.item.as_cluster().map(|c| TextCursor {
+                cluster_id: c.source_cluster_id,
+                affinity: CursorAffinity::Trailing,
+            }));
+    }
+    
+    let closest_cluster = clusters_on_line.iter()
+        .min_by(|a, b| {
+            let a_dist = horizontal_distance(point.x, a);
+            let b_dist = horizontal_distance(point.x, b);
+            a_dist.partial_cmp(&b_dist).unwrap()
+        })?;
+    
+    let cluster = closest_cluster.item.as_cluster()?;
+    
+    // Step 3: Determine affinity (leading vs trailing half)
+    let cluster_mid_x = closest_cluster.position.x + cluster.advance / 2.0;
+    let affinity = if point.x < cluster_mid_x {
+        CursorAffinity::Leading
+    } else {
+        CursorAffinity::Trailing
+    };
+    
+    Some(TextCursor {
+        cluster_id: cluster.source_cluster_id,
+        affinity,
+    })
+}
+
+fn horizontal_distance(x: f32, item: &PositionedItem) -> f32 {
+    let bounds = item.item.bounds();
+    let left = item.position.x;
+    let right = left + bounds.width;
+    
+    if x < left {
+        left - x
+    } else if x > right {
+        x - right
+    } else {
+        0.0
+    }
+}
+```
+
+### 5.2 Focus Transfer
+
+**File:** `layout/src/window.rs`
+
+```rust
+/// Handles focus change for cursor blinking
+/// Returns the action the platform should take for the blink timer
+pub fn handle_focus_change_for_cursor_blink(
+    &mut self,
+    old_focus: Option<DomNodeId>,
+    new_focus: Option<DomNodeId>,
+) -> CursorBlinkTimerAction {
+    // Clear old cursor if focus was on a contenteditable
+    if let Some(old_node) = old_focus {
+        if self.is_node_contenteditable(old_node) {
+            self.cursor_manager.clear();
+        }
+    }
+    
+    // Initialize new cursor if focus is on a contenteditable
+    if let Some(new_node) = new_focus {
+        if self.is_node_contenteditable(new_node) {
+            // Set flag for deferred initialization (will be overridden by click)
+            self.focus_manager.set_pending_contenteditable_focus(
+                new_node.dom,
+                new_node.node.into_crate_internal().unwrap(),
+            );
+            return CursorBlinkTimerAction::Start;
+        }
+    }
+    
+    CursorBlinkTimerAction::Stop
+}
+
+/// Called after layout pass to finalize deferred focus changes
+pub fn finalize_pending_focus_changes(&mut self) {
+    if let Some((dom_id, node_id)) = self.focus_manager.take_pending_contenteditable_focus() {
+        // Get the layout for this node
+        if let Some(layout) = self.get_inline_layout_for_node(dom_id, node_id) {
+            // Place cursor at end of text
+            let cursor = get_cursor_at_end(&layout);
+            let now = Instant::now();
+            self.cursor_manager.set_cursor_with_time(
+                Some(cursor),
+                Some(CursorLocation { dom_id, node_id }),
+                now,
+            );
+        }
+    }
+}
+```
+
+---
+
+## Part 6: Callback Info API
+
+### 6.1 Text Changeset Access
+
+**File:** `layout/src/callbacks.rs`
+
+```rust
+impl CallbackInfo {
+    /// Get the pending text changeset for the current Input event.
+    /// Returns None if this is not a text input event.
+    pub fn get_text_changeset(&self) -> Option<&PendingTextEdit> {
+        self.get_layout_window()
+            .text_input_manager
+            .get_pending_changeset()
+    }
+    
+    /// Prevent the default text input behavior.
+    /// The typed character will not be inserted.
+    pub fn prevent_default(&mut self) {
+        self.push_change(CallbackChange::PreventDefault);
+    }
+    
+    /// Override the text that will be inserted.
+    /// Useful for input filtering or transformation.
+    pub fn set_text_changeset(&mut self, new_text: String) {
+        self.push_change(CallbackChange::SetInsertedText { text: new_text });
+    }
+    
+    /// Change the text of a node (for TextInput widget pattern)
+    pub fn change_node_text(&mut self, node_id: DomNodeId, new_text: AzString) {
+        self.push_change(CallbackChange::ChangeNodeText { node_id, text: new_text });
+    }
+}
+```
+
+### 6.2 TextInput Widget Pattern (Reference)
+
+**File:** `layout/src/widgets/text_input.rs`
+
+```rust
+/// The TextInput widget demonstrates the "controlled component" pattern:
+/// 1. Widget has internal state (TextInputStateWrapper)
+/// 2. On text input, callback fires BEFORE visual update
+/// 3. Callback can validate/transform input
+/// 4. If valid, callback updates its internal state
+/// 5. Callback calls info.change_node_text() for visual update
+
+extern "C" fn default_on_text_input(text_input: RefAny, info: CallbackInfo) -> Update {
+    let mut text_input = text_input.downcast_mut::<TextInputStateWrapper>()?;
+    
+    // 1. Get the changeset
+    let changeset = info.get_text_changeset()?;
+    let inserted_text = changeset.inserted_text.clone();
+    
+    if inserted_text.is_empty() {
+        return Update::DoNothing;
+    }
+    
+    // 2. Call user's validation callback if set
+    let validation_result = if let Some(on_text_input) = &text_input.on_text_input {
+        let new_state = compute_new_state(&text_input.inner, &inserted_text);
+        (on_text_input.callback.cb)(on_text_input.refany.clone(), info.clone(), new_state)
+    } else {
+        OnTextInputReturn { update: Update::DoNothing, valid: TextInputValid::Yes }
+    };
+    
+    // 3. If valid, apply the change
+    if validation_result.valid == TextInputValid::Yes {
+        // Update internal state
+        text_input.inner.text.extend(inserted_text.chars().map(|c| c as u32));
+        text_input.inner.cursor_pos += inserted_text.len();
+        
+        // Update visual (for custom TextInput widget)
+        let label_node_id = get_label_node_id(&info);
+        info.change_node_text(label_node_id, text_input.inner.get_text().into());
+    } else {
+        // Prevent the edit
+        info.prevent_default();
+    }
+    
+    validation_result.update
+}
+```
+
+---
+
+## Part 7: Implementation Steps
+
+### Step 1: Add TextConstraintsCache (Day 1)
+
+**Files to modify:**
+- `layout/src/window.rs` - Add `text_constraints_cache` field to `LayoutWindow`
+- `layout/src/solver3/fc.rs` - Cache constraints during IFC layout
+
+```rust
+// In layout/src/window.rs
+impl LayoutWindow {
+    pub fn new(...) -> Self {
+        Self {
+            // ... existing fields
+            text_constraints_cache: TextConstraintsCache::default(),
+            dirty_text_nodes: BTreeMap::new(),
+            needs_relayout: false,
+        }
+    }
+}
+
+// In layout/src/solver3/fc.rs, in layout_inline_formatting_context()
+// After creating constraints:
+if let Some(cache) = ctx.text_constraints_cache.as_mut() {
+    cache.constraints.insert((ctx.dom_id, ifc_root_node_id), constraints.clone());
+}
+```
+
+### Step 2: Implement update_text_cache_after_edit (Day 1-2)
+
+**File:** `layout/src/window.rs`
+
+Replace the TODO stub with the full implementation from Part 4.2.
+
+### Step 3: Add hit_test_text_at_point (Day 2)
+
+**File:** `layout/src/text3/selection.rs`
+
+Add the function from Part 5.1.
+
+### Step 4: Integrate with MouseDown Handler (Day 2-3)
+
+**File:** `dll/src/desktop/shell2/common/event_v2.rs`
+
+```rust
+// In handle_mouse_down or process_mouse_event:
+
+fn handle_mouse_down_for_text(
+    &mut self,
+    position: LogicalPosition,
+    layout_window: &mut LayoutWindow,
+) {
+    // 1. Hit test to find node under cursor
+    let hit_result = layout_window.hit_test_point(position);
+    
+    // 2. Check if it's a contenteditable
+    if let Some(hit_node) = hit_result.deepest_contenteditable() {
+        let dom_id = hit_node.dom;
+        let node_id = hit_node.node.into_crate_internal().unwrap();
+        
+        // 3. Get the inline layout for hit testing
+        if let Some(inline_layout) = layout_window.get_inline_layout_for_node(dom_id, node_id) {
+            // 4. Calculate local position relative to node
+            let node_pos = layout_window.get_node_position(hit_node).unwrap_or_default();
+            let local_pos = LogicalPosition {
+                x: position.x - node_pos.x,
+                y: position.y - node_pos.y,
+            };
+            
+            // 5. Hit test for cursor position
+            if let Some(cursor) = hit_test_text_at_point(&inline_layout, local_pos) {
+                // 6. Set focus
+                let old_focus = layout_window.focus_manager.get_focused_node();
+                layout_window.focus_manager.set_focused_node(Some(hit_node));
+                
+                // 7. Handle focus change (stops old timer, starts new)
+                layout_window.handle_focus_change_for_cursor_blink(old_focus, Some(hit_node));
+                
+                // 8. Set cursor position (overrides deferred init)
+                let now = Instant::now();
+                layout_window.cursor_manager.set_cursor_with_time(
+                    Some(cursor),
+                    Some(CursorLocation { dom_id, node_id }),
+                    now,
+                );
+                
+                // 9. Clear any selection
+                layout_window.selection_manager.clear_text_selection(&dom_id);
+            }
+        }
+    }
+}
+```
+
+### Step 5: Implement relayout_dirty_nodes (Day 3-4)
+
+**File:** `layout/src/window.rs`
+
+Add the function from Part 4.2 and integrate it into the render loop.
+
+### Step 6: Add Event Processing Integration (Day 4)
+
+**File:** `dll/src/desktop/shell2/common/event_v2.rs`
+
+Ensure the Input event triggers the correct flow from Part 3.2.
+
+### Step 7: Testing (Day 5)
+
+Create test cases for:
+1. Single character insertion
+2. Backspace deletion
+3. Multi-character paste
+4. Cursor positioning on click
+5. Focus transfer between inputs
+6. Text that causes layout shift (line wrap)
+
+---
+
+## Part 8: Test Cases
+
+### 8.1 Basic Text Input
+
+```c
+// tests/e2e/contenteditable_basic.c
+
+void test_single_char_input() {
+    // 1. Focus contenteditable
+    // 2. Type 'a'
+    // Expected: 'a' appears, cursor moves right
+    // StyledDom: unchanged
+    // LayoutCache: updated
+}
+
+void test_backspace() {
+    // 1. Focus contenteditable with "hello"
+    // 2. Press Backspace
+    // Expected: 'hell' remains, cursor at end
+}
+
+void test_paste() {
+    // 1. Focus empty contenteditable
+    // 2. Paste "hello world"
+    // Expected: full text appears, cursor at end
+}
+```
+
+### 8.2 Cursor Positioning
+
+```c
+void test_click_positioning() {
+    // 1. Create contenteditable with "hello world"
+    // 2. Click in middle of "world"
+    // Expected: cursor appears between 'o' and 'r'
+}
+
+void test_click_empty_line() {
+    // 1. Create contenteditable with "line1\n\nline3"
+    // 2. Click on empty line 2
+    // Expected: cursor at start of line 2
+}
+```
+
+### 8.3 Focus Transfer
+
+```c
+void test_focus_transfer_click() {
+    // 1. Two contenteditables
+    // 2. Focus first, type "hello"
+    // 3. Click on second
+    // Expected: first cursor gone, second cursor at click position
+}
+
+void test_focus_transfer_tab() {
+    // 1. Two contenteditables
+    // 2. Focus first
+    // 3. Press Tab
+    // Expected: second gets focus, cursor at end of its text
+}
+```
+
+### 8.4 Layout Shift
+
+```c
+void test_line_wrap() {
+    // 1. Create narrow contenteditable (100px wide)
+    // 2. Type long text that wraps to second line
+    // Expected: text wraps, container height increases
+}
+```
+
+---
+
+## Part 9: Known Limitations & Future Work
+
+### Current Scope (V3)
+- Single text node editing
+- Basic cursor positioning
+- Focus transfer
+- Text-only content
+
+### Future Work (V4+)
+- Multi-node selections (bold/italic spans)
+- Inline images from clipboard
+- Undo/redo integration
+- IME composition support
+- Right-to-left text
+- Vertical writing modes
+
+---
+
+## Appendix: Key File Locations
+
+| Component | File | Key Functions |
+|-----------|------|---------------|
+| TextInputManager | `layout/src/managers/text_input.rs` | `record_input()`, `get_pending_changeset()` |
+| CursorManager | `layout/src/managers/cursor.rs` | `set_cursor_with_time()`, `clear()` |
+| FocusManager | `layout/src/managers/focus_cursor.rs` | `set_focused_node()`, `set_pending_contenteditable_focus()` |
+| Window Coordination | `layout/src/window.rs` | `apply_text_changeset()`, `update_text_cache_after_edit()`, `relayout_dirty_nodes()` |
+| Text Editing | `layout/src/text3/edit.rs` | `edit_text()`, `insert_text()`, `delete_range()` |
+| Text Layout | `layout/src/text3/cache.rs` | `perform_fragment_layout()`, `shape_visual_items()` |
+| Event Handling | `dll/src/desktop/shell2/common/event_v2.rs` | `process_input_event()`, `handle_mouse_down_for_text()` |
+| CallbackInfo | `layout/src/callbacks.rs` | `get_text_changeset()`, `prevent_default()` |
+| Display List | `layout/src/solver3/display_list.rs` | Cursor/selection rendering |
90f50a9e Debug contenteditable E2E test with _getTextChangeset
diff --git a/tests/e2e/.gitignore b/tests/e2e/.gitignore
index 761c5b87..d8acac91 100644
--- a/tests/e2e/.gitignore
+++ b/tests/e2e/.gitignore
@@ -14,6 +14,7 @@ focus
 refany_test
 focus_scroll
 focus_scroll_test
+text_area_test
 
 # New test binaries
 text_input
diff --git a/tests/e2e/contenteditable.c b/tests/e2e/contenteditable.c
index e5e2cbe4..c76d5ba4 100644
--- a/tests/e2e/contenteditable.c
+++ b/tests/e2e/contenteditable.c
@@ -53,9 +53,45 @@ AzUpdate on_text_input(AzRefAny data, AzCallbackInfo info) {
         return AzUpdate_DoNothing;
     }
     
-    ref.ptr->text_change_count++;
+    // Get the text changeset from the callback info
+    AzOptionPendingTextEdit changeset = AzCallbackInfo_getTextChangeset(&info);
+    
+    if (changeset.Some.tag == AzOptionPendingTextEdit_Tag_Some) {
+        AzPendingTextEdit* edit = &changeset.Some.payload;
+        
+        // Print the changeset for debugging
+        printf("[TextInput] Changeset received:\n");
+        printf("  inserted_text: '%.*s'\n", 
+               (int)edit->inserted_text.vec.len, 
+               (const char*)edit->inserted_text.vec.ptr);
+        printf("  old_text: '%.*s' (len=%zu)\n", 
+               (int)(edit->old_text.vec.len > 50 ? 50 : edit->old_text.vec.len),
+               (const char*)edit->old_text.vec.ptr,
+               edit->old_text.vec.len);
+        
+        // Append the inserted text to our data model
+        // For single-line, we just append to the existing text
+        size_t current_len = strlen(ref.ptr->single_line_text);
+        size_t insert_len = edit->inserted_text.vec.len;
+        
+        if (current_len + insert_len < sizeof(ref.ptr->single_line_text) - 1) {
+            memcpy(ref.ptr->single_line_text + current_len, 
+                   edit->inserted_text.vec.ptr, 
+                   insert_len);
+            ref.ptr->single_line_text[current_len + insert_len] = '\0';
+            printf("  Updated single_line_text: '%s'\n", ref.ptr->single_line_text);
+        }
+        
+        ref.ptr->text_change_count++;
+    } else {
+        printf("[TextInput] No changeset available\n");
+    }
+    
     ContentEditableDataRefMut_delete(&ref);
-    return AzUpdate_RefreshDom;
+    
+    // Return DoNothing - the text input system handles the visual update internally
+    // RefreshDom would override the internal edit with the old data model state
+    return AzUpdate_DoNothing;
 }
 
 // Callback for key press events
@@ -132,10 +168,9 @@ const char* CSS_STYLE =
     "    background-color: #252525;\n"
     "}\n"
     "\n"
-    "/* Cursor styling */\n"
-    "::cursor {\n"
-    "    width: 3px;\n"
-    "    background-color: #ffffff;\n"
+    "/* Cursor styling - use caret-color for text cursor */\n"
+    ".single-line-input, .multi-line-textarea {\n"
+    "    caret-color: #ffffff;\n"
     "}\n"
     "\n"
     "/* Selection styling */\n"
@@ -162,11 +197,17 @@ AzStyledDom layout(AzRefAny data, AzLayoutCallbackInfo info) {
     AzDom_addChild(&root, label1);
     
     // Single-line contenteditable input
-    AzDom single_input = AzDom_createText(AZ_STR(ref.ptr->single_line_text));
+    // Create a div with text child, set contenteditable on the div
+    AzDom single_input = AzDom_createDiv();
     AzDom_addClass(&single_input, AZ_STR("single-line-input"));
+    AzDom_setContenteditable(&single_input, true);
     AzTabIndex tab_auto = { .Auto = { .tag = AzTabIndex_Tag_Auto } };
     AzDom_setTabIndex(&single_input, tab_auto);
     
+    // Add text as child
+    AzDom single_text = AzDom_createText(AZ_STR(ref.ptr->single_line_text));
+    AzDom_addChild(&single_input, single_text);
+    
     // Add text input callback - use Focus filter for text input
     AzEventFilter text_filter = AzEventFilter_focus(AzFocusEventFilter_TextInput);
     AzDom_addCallback(&single_input, text_filter, AzRefAny_clone(&data), on_text_input);
@@ -179,10 +220,16 @@ AzStyledDom layout(AzRefAny data, AzLayoutCallbackInfo info) {
     AzDom_addChild(&root, label2);
     
     // Multi-line contenteditable textarea
-    AzDom multi_input = AzDom_createText(AZ_STR(ref.ptr->multi_line_text));
+    // Create a div with text child, set contenteditable on the div
+    AzDom multi_input = AzDom_createDiv();
     AzDom_addClass(&multi_input, AZ_STR("multi-line-textarea"));
+    AzDom_setContenteditable(&multi_input, true);
     AzDom_setTabIndex(&multi_input, tab_auto);
     
+    // Add text as child
+    AzDom multi_text = AzDom_createText(AZ_STR(ref.ptr->multi_line_text));
+    AzDom_addChild(&multi_input, multi_text);
+    
     // Add callbacks
     AzDom_addCallback(&multi_input, text_filter, AzRefAny_clone(&data), on_text_input);
     
diff --git a/tests/e2e/test_contenteditable_v2.sh b/tests/e2e/test_contenteditable_v2.sh
new file mode 100755
index 00000000..7a88c3e4
--- /dev/null
+++ b/tests/e2e/test_contenteditable_v2.sh
@@ -0,0 +1,451 @@
+#!/bin/bash
+# ContentEditable E2E Test Suite v2
+#
+# Tests contenteditable text input, cursor blinking, focus, cursor state, and selection
+#
+# Usage: ./test_contenteditable_v2.sh
+#
+# Prerequisites:
+#   1. Build the test: cc contenteditable.c -I../../target/codegen/v2/ -L../../target/release/ -lazul -o contenteditable_test -Wl,-rpath,../../target/release
+#   2. Have jq installed for JSON parsing
+
+set -e
+
+SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
+cd "$SCRIPT_DIR"
+
+DEBUG_PORT=8766
+DEBUG_URL="http://localhost:$DEBUG_PORT/"
+
+# Colors for output
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[0;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
+PASSED=0
+FAILED=0
+WARNINGS=0
+
+echo "================================================"
+echo "ContentEditable E2E Test Suite v2"
+echo "Focus, Cursor, and Blink Timer Tests"
+echo "================================================"
+
+# Build the test executable
+echo -e "${YELLOW}Building contenteditable_test...${NC}"
+cc contenteditable.c -I../../target/codegen/v2/ -L../../target/release/ -lazul -o contenteditable_test -Wl,-rpath,../../target/release 2>&1
+if [ $? -ne 0 ]; then
+    echo -e "${RED}Build failed${NC}"
+    exit 1
+fi
+echo -e "${GREEN}Build successful${NC}"
+
+# Start the test app in background
+echo -e "${YELLOW}Starting contenteditable_test with debug server on port $DEBUG_PORT...${NC}"
+AZUL_DEBUG=$DEBUG_PORT ./contenteditable_test &
+APP_PID=$!
+
+# Give the app time to start and render first frame
+sleep 3
+
+# Function to send debug command
+send_cmd() {
+    curl -s --connect-timeout 2 -X POST "$DEBUG_URL" -d "$1" 2>/dev/null
+}
+
+# Function to check if app is running
+check_app() {
+    if ! kill -0 $APP_PID 2>/dev/null; then
+        echo -e "${RED}App crashed!${NC}"
+        exit 1
+    fi
+}
+
+# Assert function
+assert_eq() {
+    local actual="$1"
+    local expected="$2"
+    local msg="$3"
+    if [ "$actual" = "$expected" ]; then
+        echo -e "${GREEN}PASS: $msg${NC}"
+        ((PASSED++))
+        return 0
+    else
+        echo -e "${RED}FAIL: $msg${NC}"
+        echo -e "${RED}  Expected: $expected${NC}"
+        echo -e "${RED}  Actual: $actual${NC}"
+        ((FAILED++))
+        return 1
+    fi
+}
+
+# Assert not empty
+assert_not_empty() {
+    local value="$1"
+    local msg="$2"
+    if [ -n "$value" ] && [ "$value" != "null" ] && [ "$value" != "none" ]; then
+        echo -e "${GREEN}PASS: $msg (value=$value)${NC}"
+        ((PASSED++))
+        return 0
+    else
+        echo -e "${RED}FAIL: $msg (empty or null)${NC}"
+        ((FAILED++))
+        return 1
+    fi
+}
+
+# Assert boolean true
+assert_true() {
+    local value="$1"
+    local msg="$2"
+    if [ "$value" = "true" ]; then
+        echo -e "${GREEN}PASS: $msg${NC}"
+        ((PASSED++))
+        return 0
+    else
+        echo -e "${RED}FAIL: $msg (got $value, expected true)${NC}"
+        ((FAILED++))
+        return 1
+    fi
+}
+
+# Assert boolean false
+assert_false() {
+    local value="$1"
+    local msg="$2"
+    if [ "$value" = "false" ]; then
+        echo -e "${GREEN}PASS: $msg${NC}"
+        ((PASSED++))
+        return 0
+    else
+        echo -e "${RED}FAIL: $msg (got $value, expected false)${NC}"
+        ((FAILED++))
+        return 1
+    fi
+}
+
+# Warn
+warn() {
+    local msg="$1"
+    echo -e "${YELLOW}WARN: $msg${NC}"
+    ((WARNINGS++))
+}
+
+# Cleanup on exit
+cleanup() {
+    echo -e "\n${YELLOW}Cleaning up...${NC}"
+    kill $APP_PID 2>/dev/null || true
+}
+trap cleanup EXIT
+
+# Wait for debug server to be ready
+echo "Waiting for debug server..."
+for i in {1..20}; do
+    RESULT=$(curl -s --connect-timeout 1 -X POST "$DEBUG_URL" -d '{"op": "get_state"}' 2>/dev/null)
+    if [ -n "$RESULT" ] && echo "$RESULT" | jq -e '.status == "ok"' > /dev/null 2>&1; then
+        echo -e "${GREEN}Debug server ready${NC}"
+        break
+    fi
+    sleep 0.5
+done
+
+# Wait for initial layout and render
+sleep 1
+send_cmd '{"op": "wait_frame"}'
+sleep 0.5
+
+# ============================================================================
+# Test Group 1: Initial State - No Focus
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 1: Initial State ===${NC}"
+
+sleep 0.5
+FOCUS_STATE=$(send_cmd '{"op": "get_focus_state"}')
+echo "DEBUG: Focus state response: $FOCUS_STATE"
+HAS_FOCUS=$(echo "$FOCUS_STATE" | jq -r '.data.value.has_focus // false')
+assert_false "$HAS_FOCUS" "Initial state: no focus"
+
+sleep 0.3
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+echo "DEBUG: Cursor state response: $CURSOR_STATE"
+HAS_CURSOR=$(echo "$CURSOR_STATE" | jq -r '.data.value.has_cursor // false')
+assert_false "$HAS_CURSOR" "Initial state: no cursor"
+
+# ============================================================================
+# Test Group 2: Focus on Contenteditable via Tab
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 2: Focus via Tab ===${NC}"
+
+# Tab to first contenteditable
+echo "Sending Tab key..."
+send_cmd '{"op": "key_down", "key": "Tab"}'
+sleep 0.5
+send_cmd '{"op": "wait_frame"}'
+sleep 0.5
+send_cmd '{"op": "wait_frame"}'
+sleep 0.3
+
+# Check focus state
+FOCUS_STATE=$(send_cmd '{"op": "get_focus_state"}')
+echo "Focus state: $FOCUS_STATE"
+
+HAS_FOCUS=$(echo "$FOCUS_STATE" | jq -r '.data.value.has_focus // false')
+assert_true "$HAS_FOCUS" "After Tab: has focus" || true
+
+IS_CONTENTEDITABLE=$(echo "$FOCUS_STATE" | jq -r '.data.value.focused_node.is_contenteditable // false')
+assert_true "$IS_CONTENTEDITABLE" "Focused node is contenteditable" || true
+
+sleep 0.3
+
+# Check cursor state
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+echo "Cursor state: $CURSOR_STATE"
+
+HAS_CURSOR=$(echo "$CURSOR_STATE" | jq -r '.data.value.has_cursor // false')
+assert_true "$HAS_CURSOR" "After Tab: cursor exists" || true
+
+# Check blink timer is active
+BLINK_TIMER_ACTIVE=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.blink_timer_active')
+if [ "$BLINK_TIMER_ACTIVE" = "true" ]; then
+    echo -e "${GREEN}PASS: Blink timer is active${NC}"
+    ((PASSED++))
+else
+    warn "Blink timer not active (may not be implemented yet)"
+fi
+
+# Check cursor is visible initially
+IS_VISIBLE=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.is_visible')
+assert_true "$IS_VISIBLE" "Cursor is initially visible"
+
+check_app
+
+# ============================================================================
+# Test Group 3: Cursor Position
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 3: Cursor Position ===${NC}"
+
+CURSOR_POS=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.position')
+CURSOR_AFFINITY=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.affinity')
+
+echo "Cursor position: $CURSOR_POS, affinity: $CURSOR_AFFINITY"
+assert_eq "$CURSOR_POS" "0" "Initial cursor at position 0"
+assert_not_empty "$CURSOR_AFFINITY" "Cursor has affinity"
+
+check_app
+
+# ============================================================================
+# Test Group 4: Text Input
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 4: Text Input ===${NC}"
+
+echo "Sending text input 'Hello'..."
+send_cmd '{"op": "text_input", "text": "Hello"}'
+sleep 0.5
+send_cmd '{"op": "wait_frame"}'
+sleep 0.3
+
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+CURSOR_POS=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.position // -1')
+echo "After typing 'Hello', cursor position: $CURSOR_POS"
+assert_eq "$CURSOR_POS" "5" "Cursor moved to position 5 after typing 'Hello'"
+
+# Cursor should be visible after typing (input resets blink)
+IS_VISIBLE=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.is_visible')
+assert_true "$IS_VISIBLE" "Cursor visible after typing"
+
+check_app
+
+# ============================================================================
+# Test Group 5: Arrow Key Navigation
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 5: Arrow Key Navigation ===${NC}"
+
+# Move cursor left
+echo "Pressing Left arrow..."
+send_cmd '{"op": "key_down", "key": "Left"}'
+sleep 0.3
+send_cmd '{"op": "wait_frame"}'
+sleep 0.2
+
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+CURSOR_POS=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.position // -1')
+echo "After Left arrow, cursor position: $CURSOR_POS"
+assert_eq "$CURSOR_POS" "4" "Cursor moved left to position 4"
+
+# Move to beginning (Home)
+echo "Pressing Home key..."
+send_cmd '{"op": "key_down", "key": "Home"}'
+sleep 0.3
+send_cmd '{"op": "wait_frame"}'
+sleep 0.2
+
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+CURSOR_POS=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.position // -1')
+echo "After Home key, cursor position: $CURSOR_POS"
+assert_eq "$CURSOR_POS" "0" "Cursor moved to beginning (position 0)"
+
+check_app
+
+# ============================================================================
+# Test Group 6: Selection State
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 6: Selection State ===${NC}"
+
+# Select All (Ctrl+A)
+echo "Pressing Ctrl+A..."
+send_cmd '{"op": "key_down", "key": "A", "modifiers": {"ctrl": true}}'
+sleep 0.3
+send_cmd '{"op": "wait_frame"}'
+sleep 0.2
+
+SELECTION_STATE=$(send_cmd '{"op": "get_selection_state"}')
+echo "Selection state: $SELECTION_STATE"
+
+HAS_SELECTION=$(echo "$SELECTION_STATE" | jq -r '.data.value.has_selection')
+assert_true "$HAS_SELECTION" "Has selection after Ctrl+A"
+
+# Check selection range
+SELECTION_TYPE=$(echo "$SELECTION_STATE" | jq -r '.data.value.selections[0].ranges[0].selection_type')
+if [ "$SELECTION_TYPE" = "range" ]; then
+    SELECTION_START=$(echo "$SELECTION_STATE" | jq -r '.data.value.selections[0].ranges[0].start')
+    SELECTION_END=$(echo "$SELECTION_STATE" | jq -r '.data.value.selections[0].ranges[0].end')
+    echo "Selection range: $SELECTION_START to $SELECTION_END"
+    assert_eq "$SELECTION_START" "0" "Selection starts at 0"
+    assert_eq "$SELECTION_END" "5" "Selection ends at 5 (Hello = 5 chars)"
+else
+    warn "Expected selection type 'range', got '$SELECTION_TYPE'"
+fi
+
+check_app
+
+# ============================================================================
+# Test Group 7: Cursor Blink Timer (530ms intervals)
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 7: Cursor Blink Timer ===${NC}"
+
+# First, clear selection by pressing Right (or any key)
+send_cmd '{"op": "key_down", "key": "Right"}'
+sleep 0.1
+
+# Wait 600ms (should toggle cursor visibility at ~530ms)
+echo "Waiting 600ms for blink toggle..."
+send_cmd '{"op": "wait", "ms": 600}'
+
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+IS_VISIBLE_AFTER_WAIT=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.is_visible')
+echo "Cursor visibility after 600ms wait: $IS_VISIBLE_AFTER_WAIT"
+
+# We can't strictly assert this because timing may vary, but log it
+if [ "$IS_VISIBLE_AFTER_WAIT" = "false" ]; then
+    echo -e "${GREEN}PASS: Cursor toggled to invisible after blink interval${NC}"
+    ((PASSED++))
+else
+    warn "Cursor still visible after 600ms (blink timer may not be working)"
+fi
+
+# Type to reset blink
+send_cmd '{"op": "text_input", "text": " "}'
+sleep 0.1
+
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+IS_VISIBLE=$(echo "$CURSOR_STATE" | jq -r '.data.value.cursor.is_visible')
+assert_true "$IS_VISIBLE" "Cursor visible after input (blink reset)"
+
+check_app
+
+# ============================================================================
+# Test Group 8: Focus Loss Clears Cursor
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 8: Focus Loss ===${NC}"
+
+# Send Escape to blur (or Tab away)
+send_cmd '{"op": "key_down", "key": "Escape"}'
+sleep 0.2
+send_cmd '{"op": "wait_frame"}'
+
+FOCUS_STATE=$(send_cmd '{"op": "get_focus_state"}')
+HAS_FOCUS=$(echo "$FOCUS_STATE" | jq -r '.data.value.has_focus')
+
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+HAS_CURSOR=$(echo "$CURSOR_STATE" | jq -r '.data.value.has_cursor')
+
+# Note: Escape may or may not clear focus depending on implementation
+echo "After Escape: has_focus=$HAS_FOCUS, has_cursor=$HAS_CURSOR"
+
+if [ "$HAS_FOCUS" = "false" ]; then
+    assert_false "$HAS_CURSOR" "Cursor cleared when focus lost"
+else
+    warn "Escape did not clear focus (may need different blur mechanism)"
+fi
+
+check_app
+
+# ============================================================================
+# Test Group 9: Click to Focus
+# ============================================================================
+echo ""
+echo -e "${BLUE}=== Test Group 9: Click to Focus ===${NC}"
+
+# Click on the single-line input (get its layout first)
+NODE_LAYOUT=$(send_cmd '{"op": "get_node_layout", "selector": ".single-line"}')
+echo "Node layout: $NODE_LAYOUT"
+
+X=$(echo "$NODE_LAYOUT" | jq -r '.data.position.x // 100')
+Y=$(echo "$NODE_LAYOUT" | jq -r '.data.position.y // 100')
+WIDTH=$(echo "$NODE_LAYOUT" | jq -r '.data.size.width // 200')
+HEIGHT=$(echo "$NODE_LAYOUT" | jq -r '.data.size.height // 50')
+
+# Click in the center of the element
+CLICK_X=$(echo "$X + $WIDTH / 2" | bc -l 2>/dev/null || echo "150")
+CLICK_Y=$(echo "$Y + $HEIGHT / 2" | bc -l 2>/dev/null || echo "125")
+
+echo "Clicking at ($CLICK_X, $CLICK_Y)"
+send_cmd "{\"op\": \"click\", \"x\": $CLICK_X, \"y\": $CLICK_Y}"
+sleep 0.2
+send_cmd '{"op": "wait_frame"}'
+
+FOCUS_STATE=$(send_cmd '{"op": "get_focus_state"}')
+HAS_FOCUS=$(echo "$FOCUS_STATE" | jq -r '.data.value.has_focus')
+assert_true "$HAS_FOCUS" "Has focus after click"
+
+CURSOR_STATE=$(send_cmd '{"op": "get_cursor_state"}')
+HAS_CURSOR=$(echo "$CURSOR_STATE" | jq -r '.data.value.has_cursor')
+assert_true "$HAS_CURSOR" "Has cursor after click"
+
+check_app
+
+# ============================================================================
+# Summary
+# ============================================================================
+echo ""
+echo "================================================"
+echo -e "${BLUE}Test Summary${NC}"
+echo "================================================"
+echo -e "Passed:   ${GREEN}$PASSED${NC}"
+echo -e "Failed:   ${RED}$FAILED${NC}"
+echo -e "Warnings: ${YELLOW}$WARNINGS${NC}"
+echo ""
+
+if [ $FAILED -eq 0 ]; then
+    echo -e "${GREEN}All tests passed!${NC}"
+    EXIT_CODE=0
+else
+    echo -e "${RED}Some tests failed.${NC}"
+    EXIT_CODE=1
+fi
+
+echo ""
+echo "The app will close in 2 seconds..."
+sleep 2
+
+exit $EXIT_CODE
2417cb6e Minor compilation fixes
diff --git a/layout/src/managers/scroll_into_view.rs b/layout/src/managers/scroll_into_view.rs
index 03168144..445f260c 100644
--- a/layout/src/managers/scroll_into_view.rs
+++ b/layout/src/managers/scroll_into_view.rs
@@ -118,7 +118,7 @@ pub fn scroll_rect_into_view(
             current_rect,
             ancestor.visible_rect,
             options.block,
-            options.inline,
+            options.inline_axis,
             ancestor.scroll_x,
             ancestor.scroll_y,
         );
diff --git a/layout/src/widgets/text_input.rs b/layout/src/widgets/text_input.rs
index 581f3d22..0aac1192 100644
--- a/layout/src/widgets/text_input.rs
+++ b/layout/src/widgets/text_input.rs
@@ -968,7 +968,7 @@ fn default_on_text_input_inner(mut text_input: RefAny, mut info: CallbackInfo) -
 
     // Get the text changeset (replaces old keyboard_state.current_char API)
     let changeset = info.get_text_changeset()?;
-    let inserted_text = changeset.inserted_text.clone();
+    let inserted_text = changeset.inserted_text.as_str().to_string();
 
     // Early return if no text to insert
     if inserted_text.is_empty() {
74428dd7 Track dirty text nodes and text constraints for relayout
diff --git a/layout/src/solver3/fc.rs b/layout/src/solver3/fc.rs
index a36dedf1..9b61ec3a 100644
--- a/layout/src/solver3/fc.rs
+++ b/layout/src/solver3/fc.rs
@@ -1916,6 +1916,9 @@ fn layout_ifc<T: ParsedFontTrait>(
     let text3_constraints =
         translate_to_text3_constraints(ctx, constraints, ctx.styled_dom, ifc_root_dom_id);
 
+    // Clone constraints for caching (before they're moved into fragments)
+    let cached_constraints = text3_constraints.clone();
+
     debug_info!(
         ctx,
         "[layout_ifc] CALLING text_cache.layout_flow for node {} with {} exclusions",
@@ -2039,10 +2042,11 @@ fn layout_ifc<T: ParsedFontTrait>(
         };
 
         if should_store {
-            node.inline_layout_result = Some(CachedInlineLayout::new(
+            node.inline_layout_result = Some(CachedInlineLayout::new_with_constraints(
                 main_frag.clone(),
                 current_width_type,
                 has_floats,
+                cached_constraints,
             ));
         }
 
diff --git a/layout/src/solver3/layout_tree.rs b/layout/src/solver3/layout_tree.rs
index 7634c403..de287345 100644
--- a/layout/src/solver3/layout_tree.rs
+++ b/layout/src/solver3/layout_tree.rs
@@ -10,6 +10,8 @@ use std::{
     },
 };
 
+use crate::text3::cache::UnifiedConstraints;
+
 /// Global counter for IFC IDs. Resets to 0 when layout() callback is invoked.
 static IFC_ID_COUNTER: AtomicU32 = AtomicU32::new(0);
 
@@ -168,6 +170,9 @@ pub struct CachedInlineLayout {
     /// Whether this layout was computed with float exclusions.
     /// Float-aware layouts should not be overwritten by non-float layouts.
     pub has_floats: bool,
+    /// The full constraints used to compute this layout.
+    /// Used for quick relayout after text edits without rebuilding from CSS.
+    pub constraints: Option<UnifiedConstraints>,
 }
 
 impl CachedInlineLayout {
@@ -181,6 +186,22 @@ impl CachedInlineLayout {
             layout,
             available_width,
             has_floats,
+            constraints: None,
+        }
+    }
+
+    /// Creates a new cached inline layout with full constraints.
+    pub fn new_with_constraints(
+        layout: Arc<UnifiedLayout>,
+        available_width: AvailableSpace,
+        has_floats: bool,
+        constraints: UnifiedConstraints,
+    ) -> Self {
+        Self {
+            layout,
+            available_width,
+            has_floats,
+            constraints: Some(constraints),
         }
     }
 
diff --git a/layout/src/window.rs b/layout/src/window.rs
index e0c26b32..0016befd 100644
--- a/layout/src/window.rs
+++ b/layout/src/window.rs
@@ -257,6 +257,26 @@ pub struct TextConstraintsCache {
     pub constraints: BTreeMap<(DomId, NodeId), UnifiedConstraints>,
 }
 
+impl Default for TextConstraintsCache {
+    fn default() -> Self {
+        Self {
+            constraints: BTreeMap::new(),
+        }
+    }
+}
+
+/// A text node that has been edited since the last full layout.
+/// This allows us to perform lightweight relayout without rebuilding the entire DOM.
+#[derive(Debug, Clone)]
+pub struct DirtyTextNode {
+    /// The new inline content (text + images) after editing
+    pub content: Vec<InlineContent>,
+    /// The new cursor position after editing
+    pub cursor: Option<TextCursor>,
+    /// Whether this edit requires ancestor relayout (e.g., text grew taller)
+    pub needs_ancestor_relayout: bool,
+}
+
 /// Result of applying callback changes
 ///
 /// This struct consolidates all the outputs from `apply_callback_changes()`,
@@ -309,6 +329,9 @@ pub struct CallbackChangeResult {
     /// Hit test update requested at this position (for Debug API)
     /// When set, the shell layer should perform a hit test update before processing events
     pub hit_test_update_requested: Option<LogicalPosition>,
+    /// Text input events triggered by CreateTextInput
+    /// These need to be processed by the recursive event loop to invoke user callbacks
+    pub text_input_triggered: Vec<(azul_core::dom::DomNodeId, Vec<azul_core::events::EventFilter>)>,
 }
 
 /// A window-level layout manager that encapsulates all layout state and caching.
@@ -389,6 +412,10 @@ pub struct LayoutWindow {
     /// Cached text layout constraints for each node
     /// This allows us to re-layout text with the same constraints after edits
     text_constraints_cache: TextConstraintsCache,
+    /// Tracks which nodes have been edited since last full layout.
+    /// Key: (DomId, NodeId of IFC root)
+    /// Value: The edited inline content that should be used for relayout
+    dirty_text_nodes: BTreeMap<(DomId, NodeId), DirtyTextNode>,
     /// Pending IFrame updates from callbacks (processed in next frame)
     /// Map of DomId -> Set of NodeIds that need re-rendering
     pub pending_iframe_updates: BTreeMap<DomId, FastBTreeSet<NodeId>>,
@@ -482,6 +509,7 @@ impl LayoutWindow {
             text_constraints_cache: TextConstraintsCache {
                 constraints: BTreeMap::new(),
             },
+            dirty_text_nodes: BTreeMap::new(),
             pending_iframe_updates: BTreeMap::new(),
             #[cfg(feature = "icu")]
             icu_localizer: IcuLocalizerHandle::default(),
@@ -551,6 +579,7 @@ impl LayoutWindow {
             text_constraints_cache: TextConstraintsCache {
                 constraints: BTreeMap::new(),
             },
+            dirty_text_nodes: BTreeMap::new(),
             pending_iframe_updates: BTreeMap::new(),
             #[cfg(feature = "icu")]
             icu_localizer: IcuLocalizerHandle::default(),
@@ -2253,6 +2282,21 @@ impl LayoutWindow {
                     // Scroll the active text cursor into view
                     self.scroll_active_cursor_into_view(&mut result);
                 }
+                CallbackChange::CreateTextInput { text } => {
+                    // Create a synthetic text input event
+                    // This simulates receiving text input from the OS
+                    println!("[CreateTextInput] Processing text: '{}'", text.as_str());
+                    
+                    // Process the text input - this records the changeset in TextInputManager
+                    let affected_nodes = self.process_text_input(text.as_str());
+                    println!("[CreateTextInput] process_text_input returned {} affected nodes", affected_nodes.len());
+                    
+                    // Mark that we need to trigger text input callbacks
+                    // The affected nodes and their events will be processed by the recursive event loop
+                    for (node, (events, _)) in affected_nodes {
+                        result.text_input_triggered.push((node, events));
+                    }
+                }
             }
         }
 
@@ -3286,6 +3330,7 @@ impl LayoutWindow {
             prevent_default: false,
             hit_test_update_requested: None,
             queued_window_states: Vec::new(),
+            text_input_triggered: Vec::new(),
         };
 
         let mut should_terminate = TerminateTimer::Continue;
@@ -3422,6 +3467,12 @@ impl LayoutWindow {
                 ret.queued_window_states = change_result.queued_window_states;
             }
 
+            // Forward text_input_triggered to shell layer for recursive callback processing
+            if !change_result.text_input_triggered.is_empty() {
+                println!("[run_single_timer] Forwarding {} text_input_triggered events", change_result.text_input_triggered.len());
+                ret.text_input_triggered = change_result.text_input_triggered;
+            }
+
             // Handle focus target outside the timer block so it's available later
             if let Some(ft) = change_result.focus_target {
                 if let Ok(new_focus_node) = crate::managers::focus_cursor::resolve_focus_target(
@@ -3491,6 +3542,7 @@ impl LayoutWindow {
             prevent_default: false,
             hit_test_update_requested: None,
             queued_window_states: Vec::new(),
+            text_input_triggered: Vec::new(),
         };
 
         let mut ret_modified_window_state = current_window_state.clone();
@@ -3766,6 +3818,7 @@ impl LayoutWindow {
             prevent_default: false,
             hit_test_update_requested: None,
             queued_window_states: Vec::new(),
+            text_input_triggered: Vec::new(),
         };
 
         let mut ret_modified_window_state = current_window_state.clone();
@@ -3946,6 +3999,7 @@ impl LayoutWindow {
             prevent_default: false,
             hit_test_update_requested: None,
             queued_window_states: Vec::new(),
+            text_input_triggered: Vec::new(),
         };
 
         let mut ret_modified_window_state = current_window_state.clone();
@@ -5104,39 +5158,58 @@ impl LayoutWindow {
 
         use crate::managers::text_input::TextInputSource;
 
+        println!("[record_text_input] Called with text: '{}'", text_input);
+
         let mut affected_nodes = BTreeMap::new();
 
         if text_input.is_empty() {
+            println!("[record_text_input] Empty text, returning empty");
             return affected_nodes;
         }
 
         // Get focused node
         let focused_node = match self.focus_manager.get_focused_node().copied() {
-            Some(node) => node,
-            None => return affected_nodes, // No focused node
+            Some(node) => {
+                println!("[record_text_input] Focused node: {:?}", node);
+                node
+            },
+            None => {
+                println!("[record_text_input] ERROR: No focused node!");
+                return affected_nodes;
+            }
         };
 
         let node_id = match focused_node.node.into_crate_internal() {
-            Some(id) => id,
-            None => return affected_nodes,
+            Some(id) => {
+                println!("[record_text_input] Node ID: {:?}", id);
+                id
+            },
+            None => {
+                println!("[record_text_input] ERROR: Invalid node ID");
+                return affected_nodes;
+            }
         };
 
         // Get the OLD text before any changes
         let old_inline_content = self.get_text_before_textinput(focused_node.dom, node_id);
         let old_text = self.extract_text_from_inline_content(&old_inline_content);
+        println!("[record_text_input] Old text: '{}' ({} bytes)", old_text, old_text.len());
 
         // Record the changeset in TextInputManager (but DON'T apply changes yet)
+        println!("[record_text_input] Recording input in TextInputManager...");
         self.text_input_manager.record_input(
             focused_node,
             text_input.to_string(),
             old_text,
             TextInputSource::Keyboard, // Assuming keyboard for now
         );
+        println!("[record_text_input] Input recorded successfully");
 
         // Return affected nodes with TextInput event so callbacks can be invoked
         let text_input_event = vec![EventFilter::Focus(FocusEventFilter::TextInput)];
 
         affected_nodes.insert(focused_node, (text_input_event, false)); // false = no re-layout yet
+        println!("[record_text_input] Returning {} affected nodes", affected_nodes.len());
 
         affected_nodes
     }
@@ -5150,26 +5223,41 @@ impl LayoutWindow {
     ///
     /// Returns the nodes that need to be marked dirty for re-layout.
     pub fn apply_text_changeset(&mut self) -> Vec<azul_core::dom::DomNodeId> {
+        println!("[apply_text_changeset] Starting...");
+        
         // Get the changeset from TextInputManager
         let changeset = match self.text_input_manager.get_pending_changeset() {
-            Some(cs) => cs.clone(),
-            None => return Vec::new(), // No changeset to apply
+            Some(cs) => {
+                println!("[apply_text_changeset] Got changeset for node {:?}, inserted='{}', old_len={}", 
+                    cs.node, cs.inserted_text.as_str(), cs.old_text.as_str().len());
+                cs.clone()
+            },
+            None => {
+                println!("[apply_text_changeset] ERROR: No pending changeset!");
+                return Vec::new();
+            }
         };
 
         let node_id = match changeset.node.node.into_crate_internal() {
-            Some(id) => id,
+            Some(id) => {
+                println!("[apply_text_changeset] Node ID: {:?}", id);
+                id
+            },
             None => {
+                println!("[apply_text_changeset] ERROR: Invalid node ID");
                 self.text_input_manager.clear_changeset();
                 return Vec::new();
             }
         };
 
         let dom_id = changeset.node.dom;
+        println!("[apply_text_changeset] DOM ID: {:?}", dom_id);
 
         // Check if node is contenteditable
         let layout_result = match self.layout_results.get(&dom_id) {
             Some(lr) => lr,
             None => {
+                println!("[apply_text_changeset] ERROR: No layout result for DOM {:?}", dom_id);
                 self.text_input_manager.clear_changeset();
                 return Vec::new();
             }
@@ -5183,6 +5271,7 @@ impl LayoutWindow {
         {
             Some(node) => node,
             None => {
+                println!("[apply_text_changeset] ERROR: No styled node at index {}", node_id.index());
                 self.text_input_manager.clear_changeset();
                 return Vec::new();
             }
@@ -5201,11 +5290,15 @@ impl LayoutWindow {
 
         // Get the current inline content from cache
         let content = self.get_text_before_textinput(dom_id, node_id);
+        println!("[apply_text_changeset] Got content, {} inline items", content.len());
 
         // Get current cursor/selection from cursor manager
         let current_selection = if let Some(cursor) = self.cursor_manager.get_cursor() {
+            println!("[apply_text_changeset] Cursor: run={}, byte={}", 
+                cursor.cluster_id.source_run, cursor.cluster_id.start_byte_in_run);
             vec![Selection::Cursor(cursor.clone())]
         } else {
+            println!("[apply_text_changeset] No cursor, creating at position 0");
             // No cursor - create one at start of text
             vec![Selection::Cursor(TextCursor {
                 cluster_id: GraphemeClusterId {
@@ -5243,18 +5336,25 @@ impl LayoutWindow {
 
         // Apply the edit using text3::edit - this is a pure function
         use crate::text3::edit::{edit_text, TextEdit};
-        let text_edit = TextEdit::Insert(changeset.inserted_text.clone());
+        let text_edit = TextEdit::Insert(changeset.inserted_text.as_str().to_string());
+        println!("[apply_text_changeset] Calling edit_text() with Insert('{}')", changeset.inserted_text.as_str());
         let (new_content, new_selections) = edit_text(&content, &current_selection, &text_edit);
+        println!("[apply_text_changeset] edit_text returned {} inline items, {} selections", 
+            new_content.len(), new_selections.len());
 
         // Update the cursor/selection in cursor manager
         // This happens lazily, only when we actually apply the changes
         if let Some(Selection::Cursor(new_cursor)) = new_selections.first() {
+            println!("[apply_text_changeset] Updating cursor to run={}, byte={}", 
+                new_cursor.cluster_id.source_run, new_cursor.cluster_id.start_byte_in_run);
             self.cursor_manager
                 .move_cursor_to(new_cursor.clone(), dom_id, node_id);
         }
 
         // Update the text cache with the new inline content
+        println!("[apply_text_changeset] Calling update_text_cache_after_edit()");
         self.update_text_cache_after_edit(dom_id, node_id, new_content);
+        println!("[apply_text_changeset] Text cache updated successfully");
 
         // Record this operation to the undo/redo manager AFTER successful mutation
 
@@ -5294,7 +5394,7 @@ impl LayoutWindow {
             id: changeset_id,
             target: changeset.node,
             operation: TextOperation::InsertText(TextOpInsertText {
-                text: changeset.inserted_text.clone().into(),
+                text: changeset.inserted_text.clone(),
                 position: old_cursor_pos,
                 new_cursor,
             }),
@@ -5305,9 +5405,12 @@ impl LayoutWindow {
 
         // Clear the changeset now that it's been applied
         self.text_input_manager.clear_changeset();
+        println!("[apply_text_changeset] Changeset cleared");
 
         // Return nodes that need dirty marking
-        self.determine_dirty_text_nodes(dom_id, node_id)
+        let dirty_nodes = self.determine_dirty_text_nodes(dom_id, node_id);
+        println!("[apply_text_changeset] Dirty nodes: {:?}", dirty_nodes);
+        dirty_nodes
     }
 
     /// Determine which nodes need to be marked dirty after a text edit
@@ -5359,7 +5462,13 @@ impl LayoutWindow {
         &mut self,
         text_input: &str,
     ) -> BTreeMap<azul_core::dom::DomNodeId, (Vec<azul_core::events::EventFilter>, bool)> {
-        self.record_text_input(text_input)
+        println!("[process_text_input] Called with text: '{}'", text_input);
+        let result = self.record_text_input(text_input);
+        println!("[process_text_input] record_text_input returned {} affected nodes", result.len());
+        for (node, (filters, has_text)) in &result {
+            println!("[process_text_input]   Node {:?}: {} filters, has_text={}", node, filters.len(), has_text);
+        }
+        result
     }
 
     /// Get the last text changeset (what was changed in the last text input)
@@ -5521,21 +5630,175 @@ impl LayoutWindow {
     ///
     /// This is the ONLY place where we mutate the text cache.
     /// All other functions are pure queries or transformations.
+    ///
+    /// This function:
+    /// 1. Stores the new content in `dirty_text_nodes` for tracking
+    /// 2. Re-runs the text3 layout pipeline (create_logical_items -> reorder -> shape -> fragment)
+    /// 3. Updates the inline_layout_result on the IFC root node in the layout tree
     pub fn update_text_cache_after_edit(
         &mut self,
         dom_id: DomId,
         node_id: NodeId,
         new_inline_content: Vec<InlineContent>,
     ) {
-        // TODO: Update the text cache with the new inline content
-        //
-        // Future implementation should:
-        // 1. Get or create the text cache entry for this node
-        // 2. Clear the existing cache stages (logical, visual, shaped, layout)
-        // 3. Store the new InlineContent
-        // 4. The next layout pass will re-run the 4-stage pipeline
-
-        let _ = (dom_id, node_id, new_inline_content);
+        use crate::solver3::layout_tree::CachedInlineLayout;
+
+        println!("[update_text_cache_after_edit] Starting for DOM {:?}, node {:?}", dom_id, node_id);
+        println!("[update_text_cache_after_edit] New content has {} inline items", new_inline_content.len());
+        for (i, item) in new_inline_content.iter().enumerate() {
+            match item {
+                crate::text3::cache::InlineContent::Text(run) => {
+                    println!("[update_text_cache_after_edit]   Item {}: Text('{}')", i, run.text);
+                }
+                _ => {
+                    println!("[update_text_cache_after_edit]   Item {}: Non-text", i);
+                }
+            }
+        }
+
+        // 1. Store the new content in dirty_text_nodes for tracking
+        let cursor = self.cursor_manager.get_cursor().cloned();
+        self.dirty_text_nodes.insert(
+            (dom_id, node_id),
+            DirtyTextNode {
+                content: new_inline_content.clone(),
+                cursor,
+                needs_ancestor_relayout: false, // Will be set if size changes
+            },
+        );
+        println!("[update_text_cache_after_edit] Stored in dirty_text_nodes");
+
+        // 2. Get the cached constraints from the existing inline layout result
+        // We need to find the IFC root node and extract its constraints
+        let constraints = {
+            let layout_result = match self.layout_results.get(&dom_id) {
+                Some(r) => r,
+                None => {
+                    println!("[update_text_cache_after_edit] ERROR: No layout result for DOM");
+                    return;
+                }
+            };
+            
+            let layout_node = match layout_result.layout_tree.get(node_id.index()) {
+                Some(n) => n,
+                None => {
+                    println!("[update_text_cache_after_edit] ERROR: Node {} not found in layout tree", node_id.index());
+                    return;
+                }
+            };
+            
+            let cached_layout = match &layout_node.inline_layout_result {
+                Some(c) => c,
+                None => {
+                    println!("[update_text_cache_after_edit] ERROR: No inline layout cached for node");
+                    return;
+                }
+            };
+            
+            match &cached_layout.constraints {
+                Some(c) => {
+                    println!("[update_text_cache_after_edit] Got cached constraints");
+                    c.clone()
+                },
+                None => {
+                    println!("[update_text_cache_after_edit] ERROR: No constraints cached");
+                    return;
+                }
+            }
+        };
+
+        // 3. Re-run the text3 layout pipeline
+        println!("[update_text_cache_after_edit] Re-running text3 layout pipeline...");
+        let new_layout = self.relayout_text_node_internal(&new_inline_content, &constraints);
+
+        let Some(new_layout) = new_layout else {
+            println!("[update_text_cache_after_edit] ERROR: relayout_text_node_internal returned None");
+            return;
+        };
+        println!("[update_text_cache_after_edit] Text3 layout complete, {} items", new_layout.items.len());
+
+        // 4. Update the layout cache with the new layout
+        // Find the IFC root node in the layout tree and update its inline_layout_result
+        if let Some(layout_result) = self.layout_results.get_mut(&dom_id) {
+            // Find the node in the layout tree
+            if let Some(layout_node) = layout_result.layout_tree.get_mut(node_id.index()) {
+                // Check if size changed (needs repaint)
+                let old_size = layout_node.used_size;
+                let new_bounds = new_layout.bounds();
+                let new_size = Some(LogicalSize {
+                    width: new_bounds.width,
+                    height: new_bounds.height,
+                });
+                println!("[update_text_cache_after_edit] Old size: {:?}, new size: {:?}", old_size, new_size);
+
+                // Check if we need to propagate layout shift
+                if let (Some(old), Some(new)) = (old_size, new_size) {
+                    if (old.height - new.height).abs() > 0.5 || (old.width - new.width).abs() > 0.5 {
+                        // Mark that ancestor relayout is needed
+                        println!("[update_text_cache_after_edit] Size changed, marking for ancestor relayout");
+                        if let Some(dirty_node) = self.dirty_text_nodes.get_mut(&(dom_id, node_id)) {
+                            dirty_node.needs_ancestor_relayout = true;
+                        }
+                    }
+                }
+
+                // Update the inline layout result with the new layout but preserve constraints
+                layout_node.inline_layout_result = Some(CachedInlineLayout::new_with_constraints(
+                    Arc::new(new_layout),
+                    constraints.available_width,
+                    false, // No floats in quick relayout
+                    constraints,
+                ));
+                println!("[update_text_cache_after_edit] Layout cache updated successfully");
+            } else {
+                println!("[update_text_cache_after_edit] ERROR: Layout node {} not found for update", node_id.index());
+            }
+        } else {
+            println!("[update_text_cache_after_edit] ERROR: Layout result not found for update");
+        }
+    }
+
+    /// Internal helper to re-run the text3 layout pipeline on new content
+    fn relayout_text_node_internal(
+        &self,
+        content: &[InlineContent],
+        constraints: &UnifiedConstraints,
+    ) -> Option<UnifiedLayout> {
+        use crate::text3::cache::{
+            create_logical_items, perform_fragment_layout, reorder_logical_items,
+            shape_visual_items, BidiDirection, BreakCursor,
+        };
+
+        // Stage 1: Create logical items from InlineContent
+        let logical_items = create_logical_items(content, &[], &mut None);
+
+        if logical_items.is_empty() {
+            // Empty text - return empty layout
+            return Some(UnifiedLayout {
+                items: Vec::new(),
+                overflow: crate::text3::cache::OverflowInfo::default(),
+            });
+        }
+
+        // Stage 2: Bidi reordering
+        let base_direction = constraints.direction.unwrap_or(BidiDirection::Ltr);
+        let visual_items = reorder_logical_items(&logical_items, base_direction, &mut None).ok()?;
+
+        // Stage 3: Shape text (resolve fonts, create glyphs)
+        let loaded_fonts = self.font_manager.get_loaded_fonts();
+        let shaped_items = shape_visual_items(
+            &visual_items,
+            self.font_manager.get_font_chain_cache(),
+            &self.font_manager.fc_cache,
+            &loaded_fonts,
+            &mut None,
+        )
+        .ok()?;
+
+        // Stage 4: Fragment layout (line breaking, positioning)
+        let mut cursor = BreakCursor::new(&shaped_items);
+        perform_fragment_layout(&mut cursor, &logical_items, constraints, &mut None, &loaded_fonts)
+            .ok()
     }
 
     /// Helper to get node used_size for accessibility actions
f451c089 Add CallbackInfo::create_text_input to push synthetic text inputs
diff --git a/layout/src/callbacks.rs b/layout/src/callbacks.rs
index ee89c655..6e511376 100644
--- a/layout/src/callbacks.rs
+++ b/layout/src/callbacks.rs
@@ -406,6 +406,20 @@ pub enum CallbackChange {
     /// Scroll the active text cursor into view within its scrollable container
     /// This is automatically triggered after text input or cursor movement
     ScrollActiveCursorIntoView,
+    
+    // Create Text Input Event (for Debug API / Programmatic Text Input)
+    /// Create a synthetic text input event
+    ///
+    /// This simulates receiving text input from the OS. The text input flow will:
+    /// 1. Record the text in TextInputManager (creating a PendingTextEdit)
+    /// 2. Generate synthetic TextInput events
+    /// 3. Invoke user callbacks (which can intercept/reject via preventDefault)
+    /// 4. Apply the changeset if not rejected
+    /// 5. Mark dirty nodes for re-render
+    CreateTextInput {
+        /// The text to insert
+        text: AzString,
+    },
 }
 
 /// Main callback type for UI event handling
@@ -1102,6 +1116,26 @@ impl CallbackInfo {
         self.push_change(CallbackChange::SetTextChangeset { changeset });
     }
 
+    /// Create a synthetic text input event
+    ///
+    /// This simulates receiving text input from the OS. Use this to programmatically
+    /// insert text into contenteditable elements, for example from the debug server
+    /// or from accessibility APIs.
+    ///
+    /// The text input flow will:
+    /// 1. Record the text in TextInputManager (creating a PendingTextEdit)
+    /// 2. Generate synthetic TextInput events
+    /// 3. Invoke user callbacks (which can intercept/reject via preventDefault)
+    /// 4. Apply the changeset if not rejected
+    /// 5. Mark dirty nodes for re-render
+    ///
+    /// # Arguments
+    /// * `text` - The text to insert at the current cursor position
+    pub fn create_text_input(&mut self, text: AzString) {
+        println!("[CallbackInfo::create_text_input] Creating text input: '{}'", text.as_str());
+        self.push_change(CallbackChange::CreateTextInput { text });
+    }
+
     /// Prevent the default text input from being applied
     ///
     /// When called in a TextInput callback, prevents the typed text from being inserted.
@@ -3500,6 +3534,10 @@ pub struct CallCallbacksResult {
     /// Queued window states to apply in sequence (for simulating clicks, etc.)
     /// The shell layer should apply these one at a time, processing events after each.
     pub queued_window_states: Vec<FullWindowState>,
+    /// Text input events triggered by CreateTextInput
+    /// These need to be processed by the recursive event loop to invoke user callbacks
+    /// Format: Vec<(DomNodeId, Vec<EventFilter>)>
+    pub text_input_triggered: Vec<(azul_core::dom::DomNodeId, Vec<azul_core::events::EventFilter>)>,
 }
 
 impl Default for CallCallbacksResult {
@@ -3528,6 +3566,7 @@ impl Default for CallCallbacksResult {
             prevent_default: false,
             hit_test_update_requested: None,
             queued_window_states: Vec::new(),
+            text_input_triggered: Vec::new(),
         }
     }
 }
c96271be Add TextInput-via-API processing in event_v2
diff --git a/dll/src/desktop/shell2/common/event_v2.rs b/dll/src/desktop/shell2/common/event_v2.rs
index df7e7948..49911bb9 100644
--- a/dll/src/desktop/shell2/common/event_v2.rs
+++ b/dll/src/desktop/shell2/common/event_v2.rs
@@ -1279,7 +1279,11 @@ pub trait PlatformWindowV2 {
         // Process text input BEFORE event dispatch
         // If there's a focused contenteditable node and text input occurred,
         // apply the edit using cursor/selection managers and mark nodes dirty
-        let text_input_affected_nodes = if let Some(layout_window) = self.get_layout_window_mut() {
+        //
+        // NOTE: Debug server text input is now handled via CallbackChange::CreateTextInput
+        // which triggers text_input_triggered in CallCallbacksResult, processed in
+        // process_callback_result_v2()
+        let text_input_affected_nodes: BTreeMap<azul_core::dom::DomNodeId, (Vec<azul_core::events::EventFilter>, bool)> = if let Some(_layout_window) = self.get_layout_window_mut() {
             // TODO: Get actual text input from platform (IME, composed chars, etc.)
             // Platform layer needs to provide text_input: &str when available
             // Example integration:
@@ -1287,12 +1291,10 @@ pub trait PlatformWindowV2 {
             // - Windows: WM_CHAR / WM_UNICHAR messages
             // - X11: XIM XLookupString with UTF-8
             // - Wayland: text-input protocol
-            let text_input = ""; // Placeholder
-            layout_window.process_text_input(text_input)
+            BTreeMap::new()
         } else {
             BTreeMap::new()
         };
-
         // TODO: Process accessibility events
         // if let Some(layout_window) = self.get_layout_window_mut() {
         //     layout_window.a11y_manager.record_state_changes(...);
@@ -2867,6 +2869,60 @@ pub trait PlatformWindowV2 {
             self.update_hit_test_at(position);
         }
 
+        // Process text_input_triggered from CreateTextInput
+        // This is how debug server text input flows:
+        // 1. debug_timer_callback calls callback_info.create_text_input(text)
+        // 2. apply_callback_changes processes CreateTextInput
+        // 3. process_text_input() is called, returning affected nodes
+        // 4. text_input_triggered is populated and forwarded here
+        // 5. We trigger recursive event processing to invoke user callbacks
+        if !result.text_input_triggered.is_empty() {
+            println!("[process_callback_result_v2] Processing {} text_input_triggered events", result.text_input_triggered.len());
+            
+            // For each affected node, invoke OnTextInput callbacks
+            // User callbacks can intercept via preventDefault
+            for (dom_node_id, event_filters) in &result.text_input_triggered {
+                println!("[process_callback_result_v2] Node {:?} triggered {} event filters", dom_node_id, event_filters.len());
+                
+                // Convert DomNodeId to CallbackTarget
+                if let Some(node_id) = dom_node_id.node.into_crate_internal() {
+                    let callback_target = CallbackTarget::Node(HitTestNode {
+                        dom_id: dom_node_id.dom.inner as u64,
+                        node_id: node_id.index() as u64,
+                    });
+                    
+                    // Invoke callbacks for each event filter (typically OnTextInput)
+                    for event_filter in event_filters {
+                        println!("[process_callback_result_v2] Invoking callback for {:?}", event_filter);
+                        let callback_results = self.invoke_callbacks_v2(callback_target.clone(), event_filter.clone());
+                        
+                        // Process callback results
+                        for callback_result in &callback_results {
+                            if callback_result.prevent_default {
+                                println!("[process_callback_result_v2] preventDefault called - text input will be rejected");
+                                // TODO: Clear the pending changeset if rejected
+                            }
+                            
+                            // Check if we need to update the screen
+                            if matches!(callback_result.callbacks_update_screen, Update::RefreshDom | Update::RefreshDomAllWindows) {
+                                event_result = event_result.max(ProcessEventResult::ShouldRegenerateDomCurrentWindow);
+                            }
+                        }
+                    }
+                }
+            }
+            
+            // After processing callbacks, apply the text changeset if not rejected
+            // This updates the visual cache
+            if let Some(layout_window) = self.get_layout_window_mut() {
+                let dirty_nodes = layout_window.apply_text_changeset();
+                if !dirty_nodes.is_empty() {
+                    println!("[process_callback_result_v2] Applied text changeset, {} dirty nodes", dirty_nodes.len());
+                    event_result = event_result.max(ProcessEventResult::ShouldReRenderCurrentWindow);
+                }
+            }
+        }
+
         // Process Update screen command
         match result.callbacks_update_screen {
             Update::DoNothing => {}
68d3cbe8 Add TextInput support in debug_server API
diff --git a/dll/src/desktop/shell2/common/debug_server.rs b/dll/src/desktop/shell2/common/debug_server.rs
index 553cd700..ce825483 100644
--- a/dll/src/desktop/shell2/common/debug_server.rs
+++ b/dll/src/desktop/shell2/common/debug_server.rs
@@ -3764,7 +3764,7 @@ fn process_debug_event(
 
             let options = ScrollIntoViewOptions {
                 block: block_align,
-                inline: inline_align,
+                inline_axis: inline_align,
                 behavior: scroll_behavior,
             };
 
@@ -4590,6 +4590,40 @@ fn process_debug_event(
             send_ok(request, None, None);
         }
 
+        DebugEvent::TextInput { text } => {
+            log(
+                LogLevel::Debug,
+                LogCategory::EventLoop,
+                format!("[DEBUG TextInput] Received text input via debug server: '{}'", text),
+                None,
+            );
+            println!("[DEBUG TextInput] ============================================");
+            println!("[DEBUG TextInput] Step 1: Debug server received text: '{}'", text);
+            
+            // Get the focused node - text input only works on focused contenteditable
+            let layout_window = callback_info.get_layout_window();
+            let focused_node = layout_window.focus_manager.get_focused_node();
+            println!("[DEBUG TextInput] Step 2: Focused node: {:?}", focused_node);
+            
+            if focused_node.is_some() {
+                // Use the new create_text_input API which:
+                // 1. Records the changeset in TextInputManager
+                // 2. Triggers text input callbacks via recursive event processing
+                // 3. Applies the changeset if not rejected via preventDefault
+                // 4. Marks dirty nodes for re-render
+                callback_info.create_text_input(text.clone().into());
+                println!("[DEBUG TextInput] Step 3: Called callback_info.create_text_input()");
+                println!("[DEBUG TextInput] NOTE: Text input will be processed recursively");
+                println!("[DEBUG TextInput] NOTE: User callbacks can intercept via OnTextInput");
+                
+                needs_update = true;
+                send_ok(request, None, None);
+            } else {
+                println!("[DEBUG TextInput] ERROR: No focused node - text input requires focus on contenteditable");
+                send_err(request, "No focused node - text input requires focus on contenteditable");
+            }
+            println!("[DEBUG TextInput] ============================================");
+        }
         DebugEvent::GetFocusState => {
             let layout_window = callback_info.get_layout_window();
             let focus_manager = &layout_window.focus_manager;
77cc2f1a inline -> inline_axis to avoid ident clash in C
diff --git a/core/src/events.rs b/core/src/events.rs
index b8429c7e..4107b4e3 100644
--- a/core/src/events.rs
+++ b/core/src/events.rs
@@ -190,7 +190,8 @@ pub struct ScrollIntoViewOptions {
     /// Vertical alignment: start, center, end, nearest (default: nearest)
     pub block: ScrollLogicalPosition,
     /// Horizontal alignment: start, center, end, nearest (default: nearest)
-    pub inline: ScrollLogicalPosition,
+    /// Note: Named `inline_axis` to avoid conflict with C keyword `inline`
+    pub inline_axis: ScrollLogicalPosition,
     /// Animation behavior: auto, instant, smooth (default: auto)
     pub behavior: ScrollIntoViewBehavior,
 }
@@ -200,7 +201,7 @@ impl ScrollIntoViewOptions {
     pub fn nearest() -> Self {
         Self {
             block: ScrollLogicalPosition::Nearest,
-            inline: ScrollLogicalPosition::Nearest,
+            inline_axis: ScrollLogicalPosition::Nearest,
             behavior: ScrollIntoViewBehavior::Auto,
         }
     }
@@ -209,7 +210,7 @@ impl ScrollIntoViewOptions {
     pub fn center() -> Self {
         Self {
             block: ScrollLogicalPosition::Center,
-            inline: ScrollLogicalPosition::Center,
+            inline_axis: ScrollLogicalPosition::Center,
             behavior: ScrollIntoViewBehavior::Auto,
         }
     }
@@ -218,7 +219,7 @@ impl ScrollIntoViewOptions {
     pub fn start() -> Self {
         Self {
             block: ScrollLogicalPosition::Start,
-            inline: ScrollLogicalPosition::Start,
+            inline_axis: ScrollLogicalPosition::Start,
             behavior: ScrollIntoViewBehavior::Auto,
         }
     }
@@ -227,7 +228,7 @@ impl ScrollIntoViewOptions {
     pub fn end() -> Self {
         Self {
             block: ScrollLogicalPosition::End,
-            inline: ScrollLogicalPosition::End,
+            inline_axis: ScrollLogicalPosition::End,
             behavior: ScrollIntoViewBehavior::Auto,
         }
     }
378e4f95 Add PendingTextEdit to public API
diff --git a/api.json b/api.json
index 80a8df76..6e92534a 100644
--- a/api.json
+++ b/api.json
@@ -6438,6 +6438,26 @@
                   "type": "ResultStringString"
                 },
                 "fn_body": "object.take_screenshot_base64(dom_id).into()"
+              },
+              "get_text_changeset": {
+                "doc": [
+                  "Get the current text changeset being processed (if any)",
+                  "",
+                  "This allows callbacks to inspect what text input is about to be applied.",
+                  "Returns None if no text input is currently being processed.",
+                  "",
+                  "Use `set_text_changeset()` to modify the text that will be inserted,",
+                  "and `prevent_default()` to block the text input entirely."
+                ],
+                "fn_args": [
+                  {
+                    "self": "ref"
+                  }
+                ],
+                "returns": {
+                  "type": "OptionPendingTextEdit"
+                },
+                "fn_body": "object.get_text_changeset().into()"
               }
             },
             "repr": "C"
@@ -15024,6 +15044,9 @@
                 "CaretAnimationDuration": {
                   "type": "CaretAnimationDurationValue"
                 },
+                "CaretWidth": {
+                  "type": "CaretWidthValue"
+                },
                 "SelectionBackgroundColor": {
                   "type": "SelectionBackgroundColorValue"
                 },
@@ -26576,6 +26599,7 @@
               {
                 "CaretColor": {},
                 "CaretAnimationDuration": {},
+                "CaretWidth": {},
                 "SelectionBackgroundColor": {},
                 "SelectionColor": {},
                 "SelectionRadius": {},
@@ -27662,6 +27686,61 @@
               }
             ],
             "repr": "C"
+          },
+          "CaretWidthValue": {
+            "external": "azul_css::props::property::CaretWidthValue",
+            "repr": "C",
+            "type_alias": {
+              "target": "CssPropertyValue",
+              "generic_args": [
+                "CaretWidth"
+              ]
+            }
+          },
+          "CaretWidth": {
+            "external": "azul_css::props::style::text::CaretWidth",
+            "custom_impls": [
+              "Default"
+            ],
+            "derive": [
+              "Debug",
+              "Copy",
+              "Clone",
+              "PartialEq",
+              "Eq",
+              "PartialOrd",
+              "Ord",
+              "Hash"
+            ],
+            "struct_fields": [
+              {
+                "inner": {
+                  "type": "PixelValue"
+                }
+              }
+            ],
+            "repr": "C"
+          },
+          "PendingTextEdit": {
+            "external": "azul_layout::managers::text_input::PendingTextEdit",
+            "derive": [
+              "Debug",
+              "Clone"
+            ],
+            "struct_fields": [
+              {
+                "node": {
+                  "type": "DomNodeId"
+                },
+                "inserted_text": {
+                  "type": "String"
+                },
+                "old_text": {
+                  "type": "String"
+                }
+              }
+            ],
+            "repr": "C"
           }
         }
       },
@@ -54361,9 +54440,8 @@
                 "block": {
                   "type": "ScrollLogicalPosition"
                 },
-                "inline_": {
-                  "type": "ScrollLogicalPosition",
-                  "rust_alias": "inline"
+                "inline_axis": {
+                  "type": "ScrollLogicalPosition"
                 },
                 "behavior": {
                   "type": "ScrollIntoViewBehavior"
@@ -54431,6 +54509,25 @@
               }
             },
             "repr": "C"
+          },
+          "OptionPendingTextEdit": {
+            "external": "azul_layout::managers::text_input::OptionPendingTextEdit",
+            "custom_impls": [
+              "From"
+            ],
+            "derive": [
+              "Debug",
+              "Clone"
+            ],
+            "enum_fields": [
+              {
+                "None": {},
+                "Some": {
+                  "type": "PendingTextEdit"
+                }
+              }
+            ],
+            "repr": "C, u8"
           }
         }
       },
diff --git a/layout/src/lib.rs b/layout/src/lib.rs
index 1796d6fa..7650de14 100644
--- a/layout/src/lib.rs
+++ b/layout/src/lib.rs
@@ -183,6 +183,8 @@ pub use solver3::{LayoutContext, LayoutError, Result as LayoutResult3};
 pub use text3::cache::{FontManager, LayoutCache as TextLayoutCache};
 #[cfg(feature = "text_layout")]
 pub use window::{CursorBlinkTimerAction, LayoutWindow, ScrollbarDragState};
+#[cfg(feature = "text_layout")]
+pub use managers::text_input::{PendingTextEdit, OptionPendingTextEdit};
 
 // #[cfg(feature = "text_layout")]
 // pub use solver::{callback_info_shape_text, do_the_layout, do_the_relayout};
diff --git a/layout/src/managers/text_input.rs b/layout/src/managers/text_input.rs
index 3a3468b2..21f11ffb 100644
--- a/layout/src/managers/text_input.rs
+++ b/layout/src/managers/text_input.rs
@@ -40,16 +40,18 @@ use azul_core::{
     selection::TextCursor,
     task::Instant,
 };
+use azul_css::corety::AzString;
 
 /// Information about a pending text edit that hasn't been applied yet
 #[derive(Debug, Clone)]
+#[repr(C)]
 pub struct PendingTextEdit {
     /// The node that was edited
     pub node: DomNodeId,
     /// The text that was inserted
-    pub inserted_text: String,
+    pub inserted_text: AzString,
     /// The old text before the edit (plain text extracted from InlineContent)
-    pub old_text: String,
+    pub old_text: AzString,
 }
 
 impl PendingTextEdit {
@@ -61,15 +63,50 @@ impl PendingTextEdit {
     /// NOTE: Actual text application is handled by apply_text_changeset() in window.rs
     /// which uses text3::edit::insert_text() for proper cursor-based insertion.
     /// This method is for preview/inspection purposes only.
-    pub fn resulting_text(&self, cursor: Option<&TextCursor>) -> String {
+    pub fn resulting_text(&self, cursor: Option<&TextCursor>) -> AzString {
         // For preview: append the inserted text
         // Actual insertion at cursor is done by text3::edit::insert_text()
-        let mut result = self.old_text.clone();
-        result.push_str(&self.inserted_text);
+        let mut result = self.old_text.as_str().to_string();
+        result.push_str(self.inserted_text.as_str());
 
         let _ = cursor; // Preview doesn't need cursor - actual insert does
 
-        result
+        result.into()
+    }
+}
+
+/// C-compatible Option type for PendingTextEdit
+#[derive(Debug, Clone)]
+#[repr(C, u8)]
+pub enum OptionPendingTextEdit {
+    None,
+    Some(PendingTextEdit),
+}
+
+impl OptionPendingTextEdit {
+    pub fn into_option(self) -> Option<PendingTextEdit> {
+        match self {
+            OptionPendingTextEdit::None => None,
+            OptionPendingTextEdit::Some(t) => Some(t),
+        }
+    }
+}
+
+impl From<Option<PendingTextEdit>> for OptionPendingTextEdit {
+    fn from(o: Option<PendingTextEdit>) -> Self {
+        match o {
+            Some(v) => OptionPendingTextEdit::Some(v),
+            None => OptionPendingTextEdit::None,
+        }
+    }
+}
+
+impl<'a> From<Option<&'a PendingTextEdit>> for OptionPendingTextEdit {
+    fn from(o: Option<&'a PendingTextEdit>) -> Self {
+        match o {
+            Some(v) => OptionPendingTextEdit::Some(v.clone()),
+            None => OptionPendingTextEdit::None,
+        }
     }
 }
 
@@ -127,30 +164,42 @@ impl TextInputManager {
         old_text: String,
         source: TextInputSource,
     ) -> DomNodeId {
+        println!("[TextInputManager::record_input] Recording input for node {:?}", node);
+        println!("[TextInputManager::record_input] Inserted text: '{}', old_text len: {}", inserted_text, old_text.len());
+        println!("[TextInputManager::record_input] Source: {:?}", source);
+
         // Clear any previous changeset
         self.pending_changeset = None;
 
         // Store the new changeset
         self.pending_changeset = Some(PendingTextEdit {
             node,
-            inserted_text,
-            old_text,
+            inserted_text: inserted_text.into(),
+            old_text: old_text.into(),
         });
 
         self.input_source = Some(source);
+        println!("[TextInputManager::record_input] Changeset stored successfully");
 
         node
     }
 
     /// Get the pending changeset (if any)
     pub fn get_pending_changeset(&self) -> Option<&PendingTextEdit> {
-        self.pending_changeset.as_ref()
+        let result = self.pending_changeset.as_ref();
+        if result.is_some() {
+            println!("[TextInputManager::get_pending_changeset] Returning pending changeset");
+        } else {
+            println!("[TextInputManager::get_pending_changeset] No pending changeset!");
+        }
+        result
     }
 
     /// Clear the pending changeset
     ///
     /// This is called after applying the changeset or if preventDefault was set.
     pub fn clear_changeset(&mut self) {
+        println!("[TextInputManager::clear_changeset] Clearing changeset");
         self.pending_changeset = None;
         self.input_source = None;
     }
9d30e2e3 feat(css): add -azul-caret-width property and white default caret color
diff --git a/core/src/prop_cache.rs b/core/src/prop_cache.rs
index 285ec06e..0764b94d 100644
--- a/core/src/prop_cache.rs
+++ b/core/src/prop_cache.rs
@@ -188,7 +188,7 @@ use azul_css::{
         layout::{LayoutDisplay, LayoutHeight, LayoutWidth},
         property::{
             BoxDecorationBreakValue, BreakInsideValue, CaretAnimationDurationValue,
-            CaretColorValue, ClipPathValue, ColumnCountValue, ColumnFillValue,
+            CaretColorValue, CaretWidthValue, ClipPathValue, ColumnCountValue, ColumnFillValue,
             ColumnRuleColorValue, ColumnRuleStyleValue, ColumnRuleWidthValue, ColumnSpanValue,
             ColumnWidthValue, ContentValue, CounterIncrementValue, CounterResetValue, CssProperty,
             CssPropertyType, FlowFromValue, FlowIntoValue, LayoutAlignContentValue,
@@ -1955,6 +1955,17 @@ impl CssPropertyCache {
             .and_then(|p| p.as_caret_color())
     }
 
+    // Method for getting -azul-caret-width property
+    pub fn get_caret_width<'a>(
+        &'a self,
+        node_data: &'a NodeData,
+        node_id: &NodeId,
+        node_state: &StyledNodeState,
+    ) -> Option<&'a CaretWidthValue> {
+        self.get_property(node_data, node_id, node_state, &CssPropertyType::CaretWidth)
+            .and_then(|p| p.as_caret_width())
+    }
+
     // Method for getting caret-animation-duration property
     pub fn get_caret_animation_duration<'a>(
         &'a self,
diff --git a/css/src/props/basic/pixel.rs b/css/src/props/basic/pixel.rs
index d41d2ddf..af74d63c 100644
--- a/css/src/props/basic/pixel.rs
+++ b/css/src/props/basic/pixel.rs
@@ -293,6 +293,16 @@ impl crate::css::PrintAsCssValue for PixelValue {
     }
 }
 
+impl crate::format_rust_code::FormatAsRustCode for PixelValue {
+    fn format_as_rust_code(&self, _tabs: usize) -> String {
+        format!(
+            "PixelValue {{ metric: {:?}, number: FloatValue::new({}) }}",
+            self.metric,
+            self.number.get()
+        )
+    }
+}
+
 impl fmt::Debug for PixelValue {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         write!(f, "{}{}", self.number, self.metric)
diff --git a/css/src/props/macros.rs b/css/src/props/macros.rs
index 091c9520..14f064a8 100644
--- a/css/src/props/macros.rs
+++ b/css/src/props/macros.rs
@@ -282,6 +282,7 @@ macro_rules! css_property_from_type {
     ($prop_type:expr, $content_type:ident) => {{
         match $prop_type {
             CssPropertyType::CaretColor => CssProperty::CaretColor(CssPropertyValue::$content_type),
+            CssPropertyType::CaretWidth => CssProperty::CaretWidth(CssPropertyValue::$content_type),
             CssPropertyType::CaretAnimationDuration => {
                 CssProperty::CaretAnimationDuration(CssPropertyValue::$content_type)
             }
diff --git a/css/src/props/property.rs b/css/src/props/property.rs
index 2cd643a2..ba859d76 100644
--- a/css/src/props/property.rs
+++ b/css/src/props/property.rs
@@ -71,7 +71,7 @@ const COMBINED_CSS_PROPERTIES_KEY_MAP: [(CombinedCssPropertyType, &'static str);
     (CombinedCssPropertyType::ColumnRule, "column-rule"),
 ];
 
-const CSS_PROPERTY_KEY_MAP: [(CssPropertyType, &'static str); 148] = [
+const CSS_PROPERTY_KEY_MAP: [(CssPropertyType, &'static str); 149] = [
     (CssPropertyType::Display, "display"),
     (CssPropertyType::Float, "float"),
     (CssPropertyType::BoxSizing, "box-sizing"),
@@ -190,6 +190,7 @@ const CSS_PROPERTY_KEY_MAP: [(CssPropertyType, &'static str); 148] = [
         CssPropertyType::CaretAnimationDuration,
         "caret-animation-duration",
     ),
+    (CssPropertyType::CaretWidth, "-azul-caret-width"),
     (
         CssPropertyType::SelectionBackgroundColor,
         "-azul-selection-background-color",
@@ -253,6 +254,7 @@ const CSS_PROPERTY_KEY_MAP: [(CssPropertyType, &'static str); 148] = [
 // Type aliases for `CssPropertyValue<T>`
 pub type CaretColorValue = CssPropertyValue<CaretColor>;
 pub type CaretAnimationDurationValue = CssPropertyValue<CaretAnimationDuration>;
+pub type CaretWidthValue = CssPropertyValue<CaretWidth>;
 pub type SelectionBackgroundColorValue = CssPropertyValue<SelectionBackgroundColor>;
 pub type SelectionColorValue = CssPropertyValue<SelectionColor>;
 pub type SelectionRadiusValue = CssPropertyValue<SelectionRadius>;
@@ -492,6 +494,7 @@ impl CombinedCssPropertyType {
 pub enum CssProperty {
     CaretColor(CaretColorValue),
     CaretAnimationDuration(CaretAnimationDurationValue),
+    CaretWidth(CaretWidthValue),
     SelectionBackgroundColor(SelectionBackgroundColorValue),
     SelectionColor(SelectionColorValue),
     SelectionRadius(SelectionRadiusValue),
@@ -685,6 +688,7 @@ pub enum CssPropertyCategory {
 pub enum CssPropertyType {
     CaretColor,
     CaretAnimationDuration,
+    CaretWidth,
     SelectionBackgroundColor,
     SelectionColor,
     SelectionRadius,
@@ -875,6 +879,7 @@ impl CssPropertyType {
         match self {
             CssPropertyType::CaretColor => "caret-color",
             CssPropertyType::CaretAnimationDuration => "caret-animation-duration",
+            CssPropertyType::CaretWidth => "-azul-caret-width",
             CssPropertyType::SelectionBackgroundColor => "-azul-selection-background-color",
             CssPropertyType::SelectionColor => "-azul-selection-color",
             CssPropertyType::SelectionRadius => "-azul-selection-radius",
@@ -1200,6 +1205,7 @@ pub enum CssParsingError<'a> {
     Cursor(CursorParseError<'a>),
     CaretColor(CssColorParseError<'a>),
     CaretAnimationDuration(DurationParseError<'a>),
+    CaretWidth(CssPixelValueParseError<'a>),
     SelectionBackgroundColor(CssColorParseError<'a>),
     SelectionColor(CssColorParseError<'a>),
     SelectionRadius(CssPixelValueParseError<'a>),
@@ -1348,6 +1354,7 @@ pub enum CssParsingErrorOwned {
     Cursor(CursorParseErrorOwned),
     CaretColor(CssColorParseErrorOwned),
     CaretAnimationDuration(DurationParseErrorOwned),
+    CaretWidth(CssPixelValueParseErrorOwned),
     SelectionBackgroundColor(CssColorParseErrorOwned),
     SelectionColor(CssColorParseErrorOwned),
     SelectionRadius(CssPixelValueParseErrorOwned),
@@ -1444,6 +1451,7 @@ impl_debug_as_display!(CssParsingError<'a>);
 impl_display! { CssParsingError<'a>, {
     CaretColor(e) => format!("Invalid caret-color: {}", e),
     CaretAnimationDuration(e) => format!("Invalid caret-animation-duration: {}", e),
+    CaretWidth(e) => format!("Invalid -azul-caret-width: {}", e),
     SelectionBackgroundColor(e) => format!("Invalid -azul-selection-background-color: {}", e),
     SelectionColor(e) => format!("Invalid -azul-selection-color: {}", e),
     SelectionRadius(e) => format!("Invalid -azul-selection-radius: {}", e),
@@ -1820,6 +1828,7 @@ impl<'a> CssParsingError<'a> {
     pub fn to_contained(&self) -> CssParsingErrorOwned {
         match self {
             CssParsingError::CaretColor(e) => CssParsingErrorOwned::CaretColor(e.to_contained()),
+            CssParsingError::CaretWidth(e) => CssParsingErrorOwned::CaretWidth(e.to_contained()),
             CssParsingError::CaretAnimationDuration(e) => {
                 CssParsingErrorOwned::CaretAnimationDuration(e.to_contained())
             }
@@ -2034,6 +2043,7 @@ impl CssParsingErrorOwned {
     pub fn to_shared<'a>(&'a self) -> CssParsingError<'a> {
         match self {
             CssParsingErrorOwned::CaretColor(e) => CssParsingError::CaretColor(e.to_shared()),
+            CssParsingErrorOwned::CaretWidth(e) => CssParsingError::CaretWidth(e.to_shared()),
             CssParsingErrorOwned::CaretAnimationDuration(e) => {
                 CssParsingError::CaretAnimationDuration(e.to_shared())
             }
@@ -2253,6 +2263,7 @@ pub fn parse_css_property<'a>(
         "inherit" => CssProperty::inherit(key),
         value => match key {
             CssPropertyType::CaretColor => parse_caret_color(value)?.into(),
+            CssPropertyType::CaretWidth => parse_caret_width(value)?.into(),
             CssPropertyType::CaretAnimationDuration => {
                 parse_caret_animation_duration(value)?.into()
             }
@@ -3258,6 +3269,7 @@ macro_rules! impl_from_css_prop {
 }
 
 impl_from_css_prop!(CaretColor, CssProperty::CaretColor);
+impl_from_css_prop!(CaretWidth, CssProperty::CaretWidth);
 impl_from_css_prop!(CaretAnimationDuration, CssProperty::CaretAnimationDuration);
 impl_from_css_prop!(
     SelectionBackgroundColor,
@@ -3403,6 +3415,7 @@ impl CssProperty {
     pub fn value(&self) -> String {
         match self {
             CssProperty::CaretColor(v) => v.get_css_value_fmt(),
+            CssProperty::CaretWidth(v) => v.get_css_value_fmt(),
             CssProperty::CaretAnimationDuration(v) => v.get_css_value_fmt(),
             CssProperty::SelectionBackgroundColor(v) => v.get_css_value_fmt(),
             CssProperty::SelectionColor(v) => v.get_css_value_fmt(),
@@ -3844,6 +3857,7 @@ impl CssProperty {
     pub const fn get_type(&self) -> CssPropertyType {
         match &self {
             CssProperty::CaretColor(_) => CssPropertyType::CaretColor,
+            CssProperty::CaretWidth(_) => CssPropertyType::CaretWidth,
             CssProperty::CaretAnimationDuration(_) => CssPropertyType::CaretAnimationDuration,
             CssProperty::SelectionBackgroundColor(_) => CssPropertyType::SelectionBackgroundColor,
             CssProperty::SelectionColor(_) => CssPropertyType::SelectionColor,
@@ -4082,6 +4096,9 @@ impl CssProperty {
     pub const fn caret_color(input: CaretColor) -> Self {
         CssProperty::CaretColor(CssPropertyValue::Exact(input))
     }
+    pub const fn caret_width(input: CaretWidth) -> Self {
+        CssProperty::CaretWidth(CssPropertyValue::Exact(input))
+    }
     pub const fn caret_animation_duration(input: CaretAnimationDuration) -> Self {
         CssProperty::CaretAnimationDuration(CssPropertyValue::Exact(input))
     }
@@ -4499,6 +4516,12 @@ impl CssProperty {
             _ => None,
         }
     }
+    pub const fn as_caret_width(&self) -> Option<&CaretWidthValue> {
+        match self {
+            CssProperty::CaretWidth(f) => Some(f),
+            _ => None,
+        }
+    }
     pub const fn as_caret_animation_duration(&self) -> Option<&CaretAnimationDurationValue> {
         match self {
             CssProperty::CaretAnimationDuration(f) => Some(f),
@@ -5297,6 +5320,7 @@ impl CssProperty {
         use self::CssProperty::*;
         match self {
             CaretColor(c) => c.is_initial(),
+            CaretWidth(c) => c.is_initial(),
             CaretAnimationDuration(c) => c.is_initial(),
             SelectionBackgroundColor(c) => c.is_initial(),
             SelectionColor(c) => c.is_initial(),
@@ -5777,6 +5801,10 @@ pub fn format_static_css_prop(prop: &CssProperty, tabs: usize) -> String {
             "CssProperty::CaretColor({})",
             print_css_property_value(p, tabs, "CaretColor")
         ),
+        CssProperty::CaretWidth(p) => format!(
+            "CssProperty::CaretWidth({})",
+            print_css_property_value(p, tabs, "CaretWidth")
+        ),
         CssProperty::CaretAnimationDuration(p) => format!(
             "CssProperty::CaretAnimationDuration({})",
             print_css_property_value(p, tabs, "CaretAnimationDuration")
diff --git a/css/src/props/style/text.rs b/css/src/props/style/text.rs
index 6b3eeac1..9dcd6178 100644
--- a/css/src/props/style/text.rs
+++ b/css/src/props/style/text.rs
@@ -1642,6 +1642,46 @@ pub fn parse_caret_animation_duration(
     parse_duration(input).map(|inner| CaretAnimationDuration { inner })
 }
 
+// --- CaretWidth ---
+
+/// Width of the text cursor (caret) in pixels.
+/// CSS doesn't have a standard property for this, so we use `-azul-caret-width`.
+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[repr(C)]
+pub struct CaretWidth {
+    pub inner: PixelValue,
+}
+
+impl Default for CaretWidth {
+    fn default() -> Self {
+        Self {
+            inner: PixelValue::px(2.0), // Default 2px caret width
+        }
+    }
+}
+
+impl PrintAsCssValue for CaretWidth {
+    fn print_as_css_value(&self) -> String {
+        self.inner.print_as_css_value()
+    }
+}
+
+impl crate::format_rust_code::FormatAsRustCode for CaretWidth {
+    fn format_as_rust_code(&self, _tabs: usize) -> String {
+        format!(
+            "CaretWidth {{ inner: {} }}",
+            self.inner.format_as_rust_code(0)
+        )
+    }
+}
+
+#[cfg(feature = "parser")]
+pub fn parse_caret_width(input: &str) -> Result<CaretWidth, CssPixelValueParseError> {
+    use crate::props::basic::pixel::parse_pixel_value;
+
+    parse_pixel_value(input).map(|inner| CaretWidth { inner })
+}
+
 // --- From implementations for CssProperty ---
 
 impl From<StyleUserSelect> for crate::props::property::CssProperty {
diff --git a/layout/src/solver3/display_list.rs b/layout/src/solver3/display_list.rs
index 91c306a2..33c8374e 100644
--- a/layout/src/solver3/display_list.rs
+++ b/layout/src/solver3/display_list.rs
@@ -1498,6 +1498,10 @@ where
         rect.origin.y += content_box_offset_y;
 
         let style = get_caret_style(self.ctx.styled_dom, Some(dom_id));
+        
+        // Apply caret width from CSS (default is 2px, get_cursor_rect returns 1px)
+        rect.size.width = style.width;
+        
         builder.push_cursor_rect(rect, style.color);
 
         Ok(())
diff --git a/layout/src/solver3/getters.rs b/layout/src/solver3/getters.rs
index 8d563533..35a0901d 100644
--- a/layout/src/solver3/getters.rs
+++ b/layout/src/solver3/getters.rs
@@ -1256,6 +1256,7 @@ pub fn get_selection_style(styled_dom: &StyledDom, node_id: Option<NodeId>) -> S
 #[derive(Debug, Clone, Copy, Default)]
 pub struct CaretStyle {
     pub color: ColorU,
+    pub width: f32,
     pub animation_duration: u32,
 }
 
@@ -1275,12 +1276,20 @@ pub fn get_caret_style(styled_dom: &StyledDom, node_id: Option<NodeId>) -> Caret
         .and_then(|c| c.get_property().cloned())
         .map(|c| c.inner)
         .unwrap_or(ColorU {
-            r: 0,
-            g: 0,
-            b: 0,
-            a: 255, // Black caret by default
+            r: 255,
+            g: 255,
+            b: 255,
+            a: 255, // White caret by default
         });
 
+    let width = styled_dom
+        .css_property_cache
+        .ptr
+        .get_caret_width(node_data, &node_id, node_state)
+        .and_then(|w| w.get_property().cloned())
+        .map(|w| w.inner.to_pixels_internal(0.0, 16.0)) // 16.0 as default em size
+        .unwrap_or(2.0); // 2px width by default
+
     let animation_duration = styled_dom
         .css_property_cache
         .ptr
@@ -1291,6 +1300,7 @@ pub fn get_caret_style(styled_dom: &StyledDom, node_id: Option<NodeId>) -> Caret
 
     CaretStyle {
         color,
+        width,
         animation_duration,
     }
 }

```

---

## OUTPUT LOGS

### examples/c/out.txt
```
UNSUPPORTED (log once): POSSIBLE ISSUE: unit 1 GLD_TEXTURE_INDEX_2D is unloadable and bound to sampler type (Float) - using zero texture because texture unloadable
[DEBUG] process_mouse_click_for_selection: position=(296.8,183.1), time_ms=0
[DEBUG] HoverManager has hit test with 1 doms
[DEBUG] Setting selection on dom_id=DomId { inner: 0 }, node_id=NodeId(1)
[DEBUG] Initialized cursor at TextCursor { cluster_id: GraphemeClusterId { source_run: 0, start_byte_in_run: 21 }, affinity: Trailing } for node NodeId(1)
[DEBUG] handle_mouse_over: dom DomId { inner: 0 } has 2 regular nodes, 0 cursor nodes
[DEBUG] handle_mouse_over: generating TextDragSelection for target DomNodeId { dom: DomId { inner: 0 }, node: Some(NodeId(0)) }
[DEBUG] process_mouse_drag_for_selection: current=(296.9,183.1)
[DEBUG] Found anchor at IFC root NodeId(1), cursor GraphemeClusterId { source_run: 0, start_byte_in_run: 21 }
[DEBUG] Found focus at IFC root NodeId(1), cursor GraphemeClusterId { source_run: 0, start_byte_in_run: 21 }
[DEBUG] Nodes in range: [1], is_forward: true
[DEBUG] Affected IFC roots: [1]
[record_text_input] Called with text: 'f'
[record_text_input] ERROR: No focused node!
[handle_text_input] No affected nodes returned from record_text_input
[record_text_input] Called with text: 'f'
[record_text_input] ERROR: No focused node!
[handle_text_input] No affected nodes returned from record_text_input
[record_text_input] Called with text: 'f'
[record_text_input] ERROR: No focused node!
[handle_text_input] No affected nodes returned from record_text_input
[record_text_input] Called with text: 'f'
[record_text_input] ERROR: No focused node!
[handle_text_input] No affected nodes returned from record_text_input
[record_text_input] Called with text: 'f'
[record_text_input] ERROR: No focused node!
[handle_text_input] No affected nodes returned from record_text_input
[record_text_input] Called with text: 'f'
[record_text_input] ERROR: No focused node!
[handle_text_input] No affected nodes returned from record_text_input
[record_text_input] Called with text: 'f'
[record_text_input] ERROR: No focused node!
[handle_text_input] No affected nodes returned from record_text_input
[DEBUG] process_mouse_click_for_selection: position=(218.1,186.2), time_ms=0
[DEBUG] HoverManager has hit test with 1 doms
[DEBUG] Setting selection on dom_id=DomId { inner: 0 }, node_id=NodeId(1)
[DEBUG] Initialized cursor at TextCursor { cluster_id: GraphemeClusterId { source_run: 0, start_byte_in_run: 20 }, affinity: Leading } for node NodeId(1)
[DEBUG] handle_mouse_over: dom DomId { inner: 0 } has 2 regular nodes, 0 cursor nodes
[DEBUG] handle_mouse_over: generating TextDragSelection for target DomNodeId { dom: DomId { inner: 0 }, node: Some(NodeId(0)) }
[DEBUG] process_mouse_drag_for_selection: current=(218.0,186.2)
[DEBUG] Found anchor at IFC root NodeId(1), cursor GraphemeClusterId { source_run: 0, start_byte_in_run: 20 }
[DEBUG] Found focus at IFC root NodeId(1), cursor GraphemeClusterId { source_run: 0, start_byte_in_run: 20 }
[DEBUG] Nodes in range: [1], is_forward: true
[DEBUG] Affected IFC roots: [1]
[DEBUG] process_mouse_click_for_selection: position=(367.3,194.2), time_ms=0
[DEBUG] HoverManager has hit test with 1 doms
[DEBUG] Setting selection on dom_id=DomId { inner: 0 }, node_id=NodeId(1)
[DEBUG] Initialized cursor at TextCursor { cluster_id: GraphemeClusterId { source_run: 0, start_byte_in_run: 21 }, affinity: Trailing } for node NodeId(1)
Simple ContentEditable Test
===========================
- Single line, no wrap (white-space: nowrap)
- Body scrolls to keep cursor in view
- Green cursor, monospace font

Debug: AZUL_DEBUG=8765
Click on the text and start typing.


```

---

## SOURCE FILES

### TEXT3 MODULE (Text Editing Core)

================================================================================
## FILE: layout/src/text3/cache.rs
## Description: Text editing, cursor, selection
================================================================================
```
use std::{
    any::{Any, TypeId},
    cmp::Ordering,
    collections::{
        hash_map::{DefaultHasher, Entry, HashMap},
        BTreeSet,
    },
    hash::{Hash, Hasher},
    mem::discriminant,
    num::NonZeroUsize,
    sync::{Arc, Mutex},
};

pub use azul_core::selection::{ContentIndex, GraphemeClusterId};
use azul_core::{
    dom::NodeId,
    geom::{LogicalPosition, LogicalRect, LogicalSize},
    resources::ImageRef,
    selection::{CursorAffinity, SelectionRange, TextCursor},
    ui_solver::GlyphInstance,
};
use azul_css::{
    corety::LayoutDebugMessage, props::basic::ColorU, props::style::StyleBackgroundContent,
};
#[cfg(feature = "text_layout_hyphenation")]
use hyphenation::{Hyphenator, Language as HyphenationLanguage, Load, Standard};
use rust_fontconfig::{FcFontCache, FcPattern, FcWeight, FontId, PatternMatch, UnicodeRange};
use unicode_bidi::{BidiInfo, Level, TextSource};
use unicode_segmentation::UnicodeSegmentation;

// Stub type when hyphenation is disabled
#[cfg(not(feature = "text_layout_hyphenation"))]
pub struct Standard;

#[cfg(not(feature = "text_layout_hyphenation"))]
impl Standard {
    /// Stub hyphenate method that returns no breaks
    pub fn hyphenate<'a>(&'a self, _word: &'a str) -> StubHyphenationBreaks {
        StubHyphenationBreaks { breaks: Vec::new() }
    }
}

/// Result of hyphenation (stub when feature is disabled)
#[cfg(not(feature = "text_layout_hyphenation"))]
pub struct StubHyphenationBreaks {
    pub breaks: alloc::vec::Vec<usize>,
}

// Always import Language from script module
use crate::text3::script::{script_to_language, Language, Script};

/// Available space for layout, similar to Taffy's AvailableSpace.
///
/// This type explicitly represents the three possible states for available space:
///
/// - `Definite(f32)`: A specific pixel width is available
/// - `MinContent`: Layout should use minimum content width (shrink-wrap)
/// - `MaxContent`: Layout should use maximum content width (no line breaks unless necessary)
///
/// This is critical for proper handling of intrinsic sizing in Flexbox/Grid
/// where the available space may be indefinite during the measure phase.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AvailableSpace {
    /// A specific amount of space is available (in pixels)
    Definite(f32),
    /// The node should be laid out under a min-content constraint
    MinContent,
    /// The node should be laid out under a max-content constraint  
    MaxContent,
}

impl Default for AvailableSpace {
    fn default() -> Self {
        AvailableSpace::Definite(0.0)
    }
}

impl AvailableSpace {
    /// Returns true if this is a definite (finite, known) amount of space
    pub fn is_definite(&self) -> bool {
        matches!(self, AvailableSpace::Definite(_))
    }

    /// Returns true if this is an indefinite (min-content or max-content) constraint
    pub fn is_indefinite(&self) -> bool {
        !self.is_definite()
    }

    /// Returns the definite value if available, or a fallback for indefinite constraints
    pub fn unwrap_or(self, fallback: f32) -> f32 {
        match self {
            AvailableSpace::Definite(v) => v,
            _ => fallback,
        }
    }

    /// Returns the definite value, or 0.0 for min-content, or f32::MAX for max-content
    pub fn to_f32_for_layout(self) -> f32 {
        match self {
            AvailableSpace::Definite(v) => v,
            AvailableSpace::MinContent => 0.0,
            AvailableSpace::MaxContent => f32::MAX,
        }
    }

    /// Create from an f32 value, recognizing special sentinel values.
    ///
    /// This function provides backwards compatibility with code that uses f32 for constraints:
    /// - `f32::INFINITY` or `f32::MAX` → `MaxContent` (no line wrapping)
    /// - `0.0` → `MinContent` (maximum line wrapping, return longest word width)
    /// - Other values → `Definite(value)`
    ///
    /// Note: Using sentinel values like 0.0 for MinContent is fragile. Prefer using
    /// `AvailableSpace::MinContent` directly when possible.
    pub fn from_f32(value: f32) -> Self {
        if value.is_infinite() || value >= f32::MAX / 2.0 {
            // Treat very large values (including f32::MAX) as MaxContent
            AvailableSpace::MaxContent
        } else if value <= 0.0 {
            // Treat zero or negative as MinContent (shrink-wrap)
            AvailableSpace::MinContent
        } else {
            AvailableSpace::Definite(value)
        }
    }
}

impl Hash for AvailableSpace {
    fn hash<H: Hasher>(&self, state: &mut H) {
        std::mem::discriminant(self).hash(state);
        if let AvailableSpace::Definite(v) = self {
            (v.round() as usize).hash(state);
        }
    }
}

// Re-export traits for backwards compatibility
pub use crate::font_traits::{ParsedFontTrait, ShallowClone};

// --- Core Data Structures for the New Architecture ---

/// Key for caching font chains - based only on CSS properties, not text content
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FontChainKey {
    pub font_families: Vec<String>,
    pub weight: FcWeight,
    pub italic: bool,
    pub oblique: bool,
}

/// Either a FontChainKey (resolved via fontconfig) or a direct FontRef hash.
/// 
/// This enum cleanly separates:
/// - `Chain`: Fonts resolved through fontconfig with fallback support
/// - `Ref`: Direct FontRef that bypasses fontconfig entirely (e.g., embedded icon fonts)
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FontChainKeyOrRef {
    /// Regular font chain resolved via fontconfig
    Chain(FontChainKey),
    /// Direct FontRef identified by pointer address (covers entire Unicode range, no fallbacks)
    Ref(usize),
}

impl FontChainKeyOrRef {
    /// Create from a FontStack enum
    pub fn from_font_stack(font_stack: &FontStack) -> Self {
        match font_stack {
            FontStack::Stack(selectors) => FontChainKeyOrRef::Chain(FontChainKey::from_selectors(selectors)),
            FontStack::Ref(font_ref) => FontChainKeyOrRef::Ref(font_ref.parsed as usize),
        }
    }
    
    /// Returns true if this is a direct FontRef
    pub fn is_ref(&self) -> bool {
        matches!(self, FontChainKeyOrRef::Ref(_))
    }
    
    /// Returns the FontRef pointer if this is a Ref variant
    pub fn as_ref_ptr(&self) -> Option<usize> {
        match self {
            FontChainKeyOrRef::Ref(ptr) => Some(*ptr),
            _ => None,
        }
    }
    
    /// Returns the FontChainKey if this is a Chain variant
    pub fn as_chain(&self) -> Option<&FontChainKey> {
        match self {
            FontChainKeyOrRef::Chain(key) => Some(key),
            _ => None,
        }
    }
}

impl FontChainKey {
    /// Create a FontChainKey from a slice of font selectors
    pub fn from_selectors(font_stack: &[FontSelector]) -> Self {
        let font_families: Vec<String> = font_stack
            .iter()
            .map(|s| s.family.clone())
            .filter(|f| !f.is_empty())
            .collect();

        let font_families = if font_families.is_empty() {
            vec!["serif".to_string()]
        } else {
            font_families
        };

        let weight = font_stack
            .first()
            .map(|s| s.weight)
            .unwrap_or(FcWeight::Normal);
        let is_italic = font_stack
            .first()
            .map(|s| s.style == FontStyle::Italic)
            .unwrap_or(false);
        let is_oblique = font_stack
            .first()
            .map(|s| s.style == FontStyle::Oblique)
            .unwrap_or(false);

        FontChainKey {
            font_families,
            weight,
            italic: is_italic,
            oblique: is_oblique,
        }
    }
}

/// A map of pre-loaded fonts, keyed by FontId (from rust-fontconfig)
///
/// This is passed to the shaper - no font loading happens during shaping
/// The fonts are loaded BEFORE layout based on the font chains and text content.
///
/// Provides both FontId and hash-based lookup for efficient glyph operations.
#[derive(Debug, Clone)]
pub struct LoadedFonts<T> {
    /// Primary storage: FontId -> Font
    pub fonts: HashMap<FontId, T>,
    /// Reverse index: font_hash -> FontId for fast hash-based lookups
    hash_to_id: HashMap<u64, FontId>,
}

impl<T: ParsedFontTrait> LoadedFonts<T> {
    pub fn new() -> Self {
        Self {
            fonts: HashMap::new(),
            hash_to_id: HashMap::new(),
        }
    }

    /// Insert a font with its FontId
    pub fn insert(&mut self, font_id: FontId, font: T) {
        let hash = font.get_hash();
        self.hash_to_id.insert(hash, font_id.clone());
        self.fonts.insert(font_id, font);
    }

    /// Get a font by FontId
    pub fn get(&self, font_id: &FontId) -> Option<&T> {
        self.fonts.get(font_id)
    }

    /// Get a font by its hash
    pub fn get_by_hash(&self, hash: u64) -> Option<&T> {
        self.hash_to_id.get(&hash).and_then(|id| self.fonts.get(id))
    }

    /// Get the FontId for a hash
    pub fn get_font_id_by_hash(&self, hash: u64) -> Option<&FontId> {
        self.hash_to_id.get(&hash)
    }

    /// Check if a FontId is present
    pub fn contains_key(&self, font_id: &FontId) -> bool {
        self.fonts.contains_key(font_id)
    }

    /// Check if a hash is present
    pub fn contains_hash(&self, hash: u64) -> bool {
        self.hash_to_id.contains_key(&hash)
    }

    /// Iterate over all fonts
    pub fn iter(&self) -> impl Iterator<Item = (&FontId, &T)> {
        self.fonts.iter()
    }

    /// Get the number of loaded fonts
    pub fn len(&self) -> usize {
        self.fonts.len()
    }

    /// Check if empty
    pub fn is_empty(&self) -> bool {
        self.fonts.is_empty()
    }
}

impl<T: ParsedFontTrait> Default for LoadedFonts<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: ParsedFontTrait> FromIterator<(FontId, T)> for LoadedFonts<T> {
    fn from_iter<I: IntoIterator<Item = (FontId, T)>>(iter: I) -> Self {
        let mut loaded = LoadedFonts::new();
        for (id, font) in iter {
            loaded.insert(id, font);
        }
        loaded
    }
}

/// Enum that wraps either a fontconfig-resolved font (T) or a direct FontRef.
///
/// This allows the shaping code to handle both fontconfig-resolved fonts
/// and embedded fonts (FontRef) uniformly through the ParsedFontTrait interface.
#[derive(Debug, Clone)]
pub enum FontOrRef<T> {
    /// A font loaded via fontconfig
    Font(T),
    /// A direct FontRef (embedded font, bypasses fontconfig)
    Ref(azul_css::props::basic::FontRef),
}

impl<T: ParsedFontTrait> ShallowClone for FontOrRef<T> {
    fn shallow_clone(&self) -> Self {
        match self {
            FontOrRef::Font(f) => FontOrRef::Font(f.shallow_clone()),
            FontOrRef::Ref(r) => FontOrRef::Ref(r.clone()),
        }
    }
}

impl<T: ParsedFontTrait> ParsedFontTrait for FontOrRef<T> {
    fn shape_text(
        &self,
        text: &str,
        script: Script,
        language: Language,
        direction: BidiDirection,
        style: &StyleProperties,
    ) -> Result<Vec<Glyph>, LayoutError> {
        match self {
            FontOrRef::Font(f) => f.shape_text(text, script, language, direction, style),
            FontOrRef::Ref(r) => r.shape_text(text, script, language, direction, style),
        }
    }

    fn get_hash(&self) -> u64 {
        match self {
            FontOrRef::Font(f) => f.get_hash(),
            FontOrRef::Ref(r) => r.get_hash(),
        }
    }

    fn get_glyph_size(&self, glyph_id: u16, font_size: f32) -> Option<LogicalSize> {
        match self {
            FontOrRef::Font(f) => f.get_glyph_size(glyph_id, font_size),
            FontOrRef::Ref(r) => r.get_glyph_size(glyph_id, font_size),
        }
    }

    fn get_hyphen_glyph_and_advance(&self, font_size: f32) -> Option<(u16, f32)> {
        match self {
            FontOrRef::Font(f) => f.get_hyphen_glyph_and_advance(font_size),
            FontOrRef::Ref(r) => r.get_hyphen_glyph_and_advance(font_size),
        }
    }

    fn get_kashida_glyph_and_advance(&self, font_size: f32) -> Option<(u16, f32)> {
        match self {
            FontOrRef::Font(f) => f.get_kashida_glyph_and_advance(font_size),
            FontOrRef::Ref(r) => r.get_kashida_glyph_and_advance(font_size),
        }
    }

    fn has_glyph(&self, codepoint: u32) -> bool {
        match self {
            FontOrRef::Font(f) => f.has_glyph(codepoint),
            FontOrRef::Ref(r) => r.has_glyph(codepoint),
        }
    }

    fn get_vertical_metrics(&self, glyph_id: u16) -> Option<VerticalMetrics> {
        match self {
            FontOrRef::Font(f) => f.get_vertical_metrics(glyph_id),
            FontOrRef::Ref(r) => r.get_vertical_metrics(glyph_id),
        }
    }

    fn get_font_metrics(&self) -> LayoutFontMetrics {
        match self {
            FontOrRef::Font(f) => f.get_font_metrics(),
            FontOrRef::Ref(r) => r.get_font_metrics(),
        }
    }

    fn num_glyphs(&self) -> u16 {
        match self {
            FontOrRef::Font(f) => f.num_glyphs(),
            FontOrRef::Ref(r) => r.num_glyphs(),
        }
    }
}

#[derive(Debug)]
pub struct FontManager<T> {
    ///  Cache that holds the **file paths** of the fonts (not any font data itself)
    pub fc_cache: Arc<FcFontCache>,
    /// Holds the actual parsed font (usually with the font bytes attached)
    pub parsed_fonts: Mutex<HashMap<FontId, T>>,
    // Cache for font chains - populated by resolve_all_font_chains() before layout
    // This is read-only during layout - no locking needed for reads
    pub font_chain_cache: HashMap<FontChainKey, rust_fontconfig::FontFallbackChain>,
    /// Cache for direct FontRefs (embedded fonts like Material Icons)
    /// These are fonts referenced via FontStack::Ref that bypass fontconfig
    pub embedded_fonts: Mutex<HashMap<u64, azul_css::props::basic::FontRef>>,
}

impl<T: ParsedFontTrait> FontManager<T> {
    pub fn new(fc_cache: FcFontCache) -> Result<Self, LayoutError> {
        Ok(Self {
            fc_cache: Arc::new(fc_cache),
            parsed_fonts: Mutex::new(HashMap::new()),
            font_chain_cache: HashMap::new(), // Populated via set_font_chain_cache()
            embedded_fonts: Mutex::new(HashMap::new()),
        })
    }

    /// Set the font chain cache from externally resolved chains
    ///
    /// This should be called with the result of `resolve_font_chains()` or
    /// `collect_and_resolve_font_chains()` from `solver3::getters`.
    pub fn set_font_chain_cache(
        &mut self,
        chains: HashMap<FontChainKey, rust_fontconfig::FontFallbackChain>,
    ) {
        self.font_chain_cache = chains;
    }

    /// Merge additional font chains into the existing cache
    ///
    /// Useful when processing multiple DOMs that may have different font requirements.
    pub fn merge_font_chain_cache(
        &mut self,
        chains: HashMap<FontChainKey, rust_fontconfig::FontFallbackChain>,
    ) {
        self.font_chain_cache.extend(chains);
    }

    /// Get a reference to the font chain cache
    pub fn get_font_chain_cache(
        &self,
    ) -> &HashMap<FontChainKey, rust_fontconfig::FontFallbackChain> {
        &self.font_chain_cache
    }

    /// Get an embedded font by its hash (used for WebRender registration)
    /// Returns the FontRef if it exists in the embedded_fonts cache.
    pub fn get_embedded_font_by_hash(&self, font_hash: u64) -> Option<azul_css::props::basic::FontRef> {
        let embedded = self.embedded_fonts.lock().unwrap();
        embedded.get(&font_hash).cloned()
    }

    /// Get a parsed font by its hash (used for WebRender registration)
    /// Returns the parsed font if it exists in the parsed_fonts cache.
    pub fn get_font_by_hash(&self, font_hash: u64) -> Option<T> {
        let parsed = self.parsed_fonts.lock().unwrap();
        // Linear search through all cached fonts to find one with matching hash
        for (_, font) in parsed.iter() {
            if font.get_hash() == font_hash {
                return Some(font.clone());
            }
        }
        None
    }

    /// Register an embedded FontRef for later lookup by hash
    /// This is called when using FontStack::Ref during shaping
    pub fn register_embedded_font(&self, font_ref: &azul_css::props::basic::FontRef) {
        let hash = font_ref.get_hash();
        let mut embedded = self.embedded_fonts.lock().unwrap();
        embedded.insert(hash, font_ref.clone());
    }

    /// Get a snapshot of all currently loaded fonts
    ///
    /// This returns a copy of all parsed fonts, which can be passed to the shaper.
    /// No locking is required after this call - the returned HashMap is independent.
    ///
    /// NOTE: This should be called AFTER loading all required fonts for a layout pass.
    pub fn get_loaded_fonts(&self) -> LoadedFonts<T> {
        let parsed = self.parsed_fonts.lock().unwrap();
        parsed
            .iter()
            .map(|(id, font)| (id.clone(), font.shallow_clone()))
            .collect()
    }

    /// Get the set of FontIds that are currently loaded
    ///
    /// This is useful for computing which fonts need to be loaded
    /// (diff with required fonts).
    pub fn get_loaded_font_ids(&self) -> std::collections::HashSet<FontId> {
        let parsed = self.parsed_fonts.lock().unwrap();
        parsed.keys().cloned().collect()
    }

    /// Insert a loaded font into the cache
    ///
    /// Returns the old font if one was already present for this FontId.
    pub fn insert_font(&self, font_id: FontId, font: T) -> Option<T> {
        let mut parsed = self.parsed_fonts.lock().unwrap();
        parsed.insert(font_id, font)
    }

    /// Insert multiple loaded fonts into the cache
    ///
    /// This is more efficient than calling `insert_font` multiple times
    /// because it only acquires the lock once.
    pub fn insert_fonts(&self, fonts: impl IntoIterator<Item = (FontId, T)>) {
        let mut parsed = self.parsed_fonts.lock().unwrap();
        for (font_id, font) in fonts {
            parsed.insert(font_id, font);
        }
    }

    /// Remove a font from the cache
    ///
    /// Returns the removed font if it was present.
    pub fn remove_font(&self, font_id: &FontId) -> Option<T> {
        let mut parsed = self.parsed_fonts.lock().unwrap();
        parsed.remove(font_id)
    }
}

// Error handling
#[derive(Debug, thiserror::Error)]
pub enum LayoutError {
    #[error("Bidi analysis failed: {0}")]
    BidiError(String),
    #[error("Shaping failed: {0}")]
    ShapingError(String),
    #[error("Font not found: {0:?}")]
    FontNotFound(FontSelector),
    #[error("Invalid text input: {0}")]
    InvalidText(String),
    #[error("Hyphenation failed: {0}")]
    HyphenationError(String),
}

/// Text boundary types for cursor movement
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TextBoundary {
    /// Reached top of text (first line)
    Top,
    /// Reached bottom of text (last line)
    Bottom,
    /// Reached start of text (first character)
    Start,
    /// Reached end of text (last character)
    End,
}

/// Error returned when cursor movement hits a boundary
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CursorBoundsError {
    /// The boundary that was hit
    pub boundary: TextBoundary,
    /// The cursor position (unchanged from input)
    pub cursor: TextCursor,
}

/// Unified constraints combining all layout features
///
/// # CSS Inline Layout Module Level 3: Constraint Mapping
///
/// This structure maps CSS properties to layout constraints:
///
/// ## \u00a7 2.1 Layout of Line Boxes
/// - `available_width`: \u26a0\ufe0f CRITICAL - Should equal containing block's inner width
///   * Currently defaults to 0.0 which causes immediate line breaking
///   * Per spec: "logical width of a line box is equal to the inner logical width of its containing
///     block"
/// - `available_height`: For block-axis constraints (max-height)
///
/// ## \u00a7 2.2 Layout Within Line Boxes
/// - `text_align`: \u2705 Horizontal alignment (start, end, center, justify)
/// - `vertical_align`: \u26a0\ufe0f PARTIAL - Only baseline supported, missing:
///   * top, bottom, middle, text-top, text-bottom
///   * <length>, <percentage> values
///   * sub, super positions
/// - `line_height`: \u2705 Distance between baselines
///
/// ## \u00a7 3 Baselines and Alignment Metrics
/// - `text_orientation`: \u2705 For vertical writing (sideways, upright)
/// - `writing_mode`: \u2705 horizontal-tb, vertical-rl, vertical-lr
/// - `direction`: \u2705 ltr, rtl for BiDi
///
/// ## \u00a7 4 Baseline Alignment (vertical-align property)
/// \u26a0\ufe0f INCOMPLETE: Only basic baseline alignment implemented
///
/// ## \u00a7 5 Line Spacing (line-height property)
/// - `line_height`: \u2705 Implemented
/// - \u274c MISSING: line-fit-edge for controlling which edges contribute to line height
///
/// ## \u00a7 6 Trimming Leading (text-box-trim)
/// - \u274c NOT IMPLEMENTED: text-box-trim property
/// - \u274c NOT IMPLEMENTED: text-box-edge property
///
/// ## CSS Text Module Level 3
/// - `text_indent`: \u2705 First line indentation
/// - `text_justify`: \u2705 Justification algorithm (auto, inter-word, inter-character)
/// - `hyphenation`: \u2705 Automatic hyphenation
/// - `hanging_punctuation`: \u2705 Hanging punctuation at line edges
///
/// ## CSS Text Level 4
/// - `text_wrap`: \u2705 balance, pretty, stable
/// - `line_clamp`: \u2705 Max number of lines
///
/// ## CSS Writing Modes Level 4
/// - `text_combine_upright`: \u2705 Tate-chu-yoko for vertical text
///
/// ## CSS Shapes Module
/// - `shape_boundaries`: \u2705 Custom line box shapes
/// - `shape_exclusions`: \u2705 Exclusion areas (float-like behavior)
/// - `exclusion_margin`: \u2705 Margin around exclusions
///
/// ## Multi-column Layout
/// - `columns`: \u2705 Number of columns
/// - `column_gap`: \u2705 Gap between columns
///
/// # Known Issues:
/// 1. [ISSUE] available_width defaults to Definite(0.0) instead of containing block width
/// 2. [ISSUE] vertical_align only supports baseline
/// 3. [TODO] initial-letter (drop caps) not implemented
#[derive(Debug, Clone)]
pub struct UnifiedConstraints {
    // Shape definition
    pub shape_boundaries: Vec<ShapeBoundary>,
    pub shape_exclusions: Vec<ShapeBoundary>,

    // Basic layout - using AvailableSpace for proper indefinite handling
    pub available_width: AvailableSpace,
    pub available_height: Option<f32>,

    // Text layout
    pub writing_mode: Option<WritingMode>,
    // Base direction from CSS, overrides auto-detection
    pub direction: Option<BidiDirection>,
    pub text_orientation: TextOrientation,
    pub text_align: TextAlign,
    pub text_justify: JustifyContent,
    pub line_height: f32,
    pub vertical_align: VerticalAlign,

    // Overflow handling
    pub overflow: OverflowBehavior,
    pub segment_alignment: SegmentAlignment,

    // Advanced features
    pub text_combine_upright: Option<TextCombineUpright>,
    pub exclusion_margin: f32,
    pub hyphenation: bool,
    pub hyphenation_language: Option<Language>,
    pub text_indent: f32,
    pub initial_letter: Option<InitialLetter>,
    pub line_clamp: Option<NonZeroUsize>,

    // text-wrap: balance
    pub text_wrap: TextWrap,
    pub columns: u32,
    pub column_gap: f32,
    pub hanging_punctuation: bool,
}

impl Default for UnifiedConstraints {
    fn default() -> Self {
        Self {
            shape_boundaries: Vec::new(),
            shape_exclusions: Vec::new(),

            // IMPORTANT: This should be set to the containing block's inner width
            // per CSS Inline-3 § 2.1, but defaults to Definite(0.0) which causes immediate line
            // breaking. This value should be passed from the box layout solver (fc.rs)
            // when creating UnifiedConstraints for text layout.
            available_width: AvailableSpace::Definite(0.0),
            available_height: None,
            writing_mode: None,
            direction: None, // Will default to LTR if not specified
            text_orientation: TextOrientation::default(),
            text_align: TextAlign::default(),
            text_justify: JustifyContent::default(),
            line_height: 16.0, // A more sensible default
            vertical_align: VerticalAlign::default(),
            overflow: OverflowBehavior::default(),
            segment_alignment: SegmentAlignment::default(),
            text_combine_upright: None,
            exclusion_margin: 0.0,
            hyphenation: false,
            hyphenation_language: None,
            columns: 1,
            column_gap: 0.0,
            hanging_punctuation: false,
            text_indent: 0.0,
            initial_letter: None,
            line_clamp: None,
            text_wrap: TextWrap::default(),
        }
    }
}

// UnifiedConstraints
impl Hash for UnifiedConstraints {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.shape_boundaries.hash(state);
        self.shape_exclusions.hash(state);
        self.available_width.hash(state);
        self.available_height
            .map(|h| h.round() as usize)
            .hash(state);
        self.writing_mode.hash(state);
        self.direction.hash(state);
        self.text_orientation.hash(state);
        self.text_align.hash(state);
        self.text_justify.hash(state);
        (self.line_height.round() as usize).hash(state);
        self.vertical_align.hash(state);
        self.overflow.hash(state);
        self.text_combine_upright.hash(state);
        (self.exclusion_margin.round() as usize).hash(state);
        self.hyphenation.hash(state);
        self.hyphenation_language.hash(state);
        self.columns.hash(state);
        (self.column_gap.round() as usize).hash(state);
        self.hanging_punctuation.hash(state);
    }
}

impl PartialEq for UnifiedConstraints {
    fn eq(&self, other: &Self) -> bool {
        self.shape_boundaries == other.shape_boundaries
            && self.shape_exclusions == other.shape_exclusions
            && self.available_width == other.available_width
            && match (self.available_height, other.available_height) {
                (None, None) => true,
                (Some(h1), Some(h2)) => round_eq(h1, h2),
                _ => false,
            }
            && self.writing_mode == other.writing_mode
            && self.direction == other.direction
            && self.text_orientation == other.text_orientation
            && self.text_align == other.text_align
            && self.text_justify == other.text_justify
            && round_eq(self.line_height, other.line_height)
            && self.vertical_align == other.vertical_align
            && self.overflow == other.overflow
            && self.text_combine_upright == other.text_combine_upright
            && round_eq(self.exclusion_margin, other.exclusion_margin)
            && self.hyphenation == other.hyphenation
            && self.hyphenation_language == other.hyphenation_language
            && self.columns == other.columns
            && round_eq(self.column_gap, other.column_gap)
            && self.hanging_punctuation == other.hanging_punctuation
    }
}

impl Eq for UnifiedConstraints {}

impl UnifiedConstraints {
    fn direction(&self, fallback: BidiDirection) -> BidiDirection {
        match self.writing_mode {
            Some(s) => s.get_direction().unwrap_or(fallback),
            None => fallback,
        }
    }
    fn is_vertical(&self) -> bool {
        matches!(
            self.writing_mode,
            Some(WritingMode::VerticalRl) | Some(WritingMode::VerticalLr)
        )
    }
}

/// Line constraints with multi-segment support
#[derive(Debug, Clone)]
pub struct LineConstraints {
    pub segments: Vec<LineSegment>,
    pub total_available: f32,
}

impl WritingMode {
    fn get_direction(&self) -> Option<BidiDirection> {
        match self {
            // determined by text content
            WritingMode::HorizontalTb => None,
            WritingMode::VerticalRl => Some(BidiDirection::Rtl),
            WritingMode::VerticalLr => Some(BidiDirection::Ltr),
            WritingMode::SidewaysRl => Some(BidiDirection::Rtl),
            WritingMode::SidewaysLr => Some(BidiDirection::Ltr),
        }
    }
}

// Stage 1: Collection - Styled runs from DOM traversal
#[derive(Debug, Clone, Hash)]
pub struct StyledRun {
    pub text: String,
    pub style: Arc<StyleProperties>,
    /// Byte index in the original logical paragraph text
    pub logical_start_byte: usize,
    /// The DOM NodeId of the Text node this run came from.
    /// None for generated content (e.g., list markers, ::before/::after).
    pub source_node_id: Option<NodeId>,
}

// Stage 2: Bidi Analysis - Visual runs in display order
#[derive(Debug, Clone)]
pub struct VisualRun<'a> {
    pub text_slice: &'a str,
    pub style: Arc<StyleProperties>,
    pub logical_start_byte: usize,
    pub bidi_level: BidiLevel,
    pub script: Script,
    pub language: Language,
}

// Font and styling types

/// A selector for loading fonts from the font cache.
/// Used by FontManager to query fontconfig and load font files.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FontSelector {
    pub family: String,
    pub weight: FcWeight,
    pub style: FontStyle,
    pub unicode_ranges: Vec<UnicodeRange>,
}

impl Default for FontSelector {
    fn default() -> Self {
        Self {
            family: "serif".to_string(),
            weight: FcWeight::Normal,
            style: FontStyle::Normal,
            unicode_ranges: Vec::new(),
        }
    }
}

/// Font stack that can be either a list of font selectors (resolved via fontconfig)
/// or a direct FontRef (bypasses fontconfig entirely).
///
/// When a `FontRef` is used, it bypasses fontconfig resolution entirely
/// and uses the pre-parsed font data directly. This is used for embedded
/// fonts like Material Icons.
#[derive(Debug, Clone)]
pub enum FontStack {
    /// A stack of font selectors to be resolved via fontconfig
    /// First font is primary, rest are fallbacks
    Stack(Vec<FontSelector>),
    /// A direct reference to a pre-parsed font (e.g., embedded icon fonts)
    /// This font covers the entire Unicode range and has no fallbacks.
    Ref(azul_css::props::basic::font::FontRef),
}

impl Default for FontStack {
    fn default() -> Self {
        FontStack::Stack(vec![FontSelector::default()])
    }
}

impl FontStack {
    /// Returns true if this is a direct FontRef
    pub fn is_ref(&self) -> bool {
        matches!(self, FontStack::Ref(_))
    }

    /// Returns the FontRef if this is a Ref variant
    pub fn as_ref(&self) -> Option<&azul_css::props::basic::font::FontRef> {
        match self {
            FontStack::Ref(r) => Some(r),
            _ => None,
        }
    }

    /// Returns the font selectors if this is a Stack variant
    pub fn as_stack(&self) -> Option<&[FontSelector]> {
        match self {
            FontStack::Stack(s) => Some(s),
            _ => None,
        }
    }

    /// Returns the first FontSelector if this is a Stack variant, None if Ref
    pub fn first_selector(&self) -> Option<&FontSelector> {
        match self {
            FontStack::Stack(s) => s.first(),
            FontStack::Ref(_) => None,
        }
    }

    /// Returns the first font family name (for Stack) or a placeholder (for Ref)
    pub fn first_family(&self) -> &str {
        match self {
            FontStack::Stack(s) => s.first().map(|f| f.family.as_str()).unwrap_or("serif"),
            FontStack::Ref(_) => "<embedded-font>",
        }
    }
}

impl PartialEq for FontStack {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (FontStack::Stack(a), FontStack::Stack(b)) => a == b,
            (FontStack::Ref(a), FontStack::Ref(b)) => a.parsed == b.parsed,
            _ => false,
        }
    }
}

impl Eq for FontStack {}

impl Hash for FontStack {
    fn hash<H: Hasher>(&self, state: &mut H) {
        core::mem::discriminant(self).hash(state);
        match self {
            FontStack::Stack(s) => s.hash(state),
            FontStack::Ref(r) => (r.parsed as usize).hash(state),
        }
    }
}

/// A reference to a font for rendering, identified by its hash.
/// This hash corresponds to ParsedFont::hash and is used to look up
/// the actual font data in the renderer's font cache.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FontHash {
    /// The hash of the ParsedFont. 0 means invalid/unknown font.
    pub font_hash: u64,
}

impl FontHash {
    pub fn invalid() -> Self {
        Self { font_hash: 0 }
    }

    pub fn from_hash(font_hash: u64) -> Self {
        Self { font_hash }
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum FontStyle {
    Normal,
    Italic,
    Oblique,
}

/// Defines how text should be aligned when a line contains multiple disjoint segments.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub enum SegmentAlignment {
    /// Align text within the first available segment on the line.
    #[default]
    First,
    /// Align text relative to the total available width of all
    /// segments on the line combined.
    Total,
}

#[derive(Debug, Clone)]
pub struct VerticalMetrics {
    pub advance: f32,
    pub bearing_x: f32,
    pub bearing_y: f32,
    pub origin_y: f32,
}

/// Layout-specific font metrics extracted from FontMetrics
/// Contains only the metrics needed for text layout and rendering
#[derive(Debug, Clone)]
pub struct LayoutFontMetrics {
    pub ascent: f32,
    pub descent: f32,
    pub line_gap: f32,
    pub units_per_em: u16,
}

impl LayoutFontMetrics {
    pub fn baseline_scaled(&self, font_size: f32) -> f32 {
        let scale = font_size / self.units_per_em as f32;
        self.ascent * scale
    }

    /// Convert from full FontMetrics to layout-specific metrics
    pub fn from_font_metrics(metrics: &azul_css::props::basic::FontMetrics) -> Self {
        Self {
            ascent: metrics.ascender as f32,
            descent: metrics.descender as f32,
            line_gap: metrics.line_gap as f32,
            units_per_em: metrics.units_per_em,
        }
    }
}

#[derive(Debug, Clone)]
pub struct LineSegment {
    pub start_x: f32,
    pub width: f32,
    // For choosing best segment when multiple available
    pub priority: u8,
}

#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq, PartialOrd, Ord, Default)]
pub enum TextWrap {
    #[default]
    Wrap,
    Balance,
    NoWrap,
}

// initial-letter
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct InitialLetter {
    /// How many lines tall the initial letter should be.
    pub size: f32,
    /// How many lines the letter should sink into.
    pub sink: u32,
    /// How many characters to apply this styling to.
    pub count: NonZeroUsize,
}

// A type that implements `Hash` must also implement `Eq`.
// Since f32 does not implement `Eq`, we provide a manual implementation.
// This is a marker trait, indicating that `a == b` is a true equivalence
// relation. The derived `PartialEq` already satisfies this.
impl Eq for InitialLetter {}

impl Hash for InitialLetter {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // Per the request, round the f32 to a usize for hashing.
        // This is a lossy conversion; values like 2.3 and 2.4 will produce
        // the same hash value for this field. This is acceptable as long as
        // the `PartialEq` implementation correctly distinguishes them.
        (self.size.round() as usize).hash(state);
        self.sink.hash(state);
        self.count.hash(state);
    }
}

// Path and shape definitions
#[derive(Debug, Clone, PartialOrd)]
pub enum PathSegment {
    MoveTo(Point),
    LineTo(Point),
    CurveTo {
        control1: Point,
        control2: Point,
        end: Point,
    },
    QuadTo {
        control: Point,
        end: Point,
    },
    Arc {
        center: Point,
        radius: f32,
        start_angle: f32,
        end_angle: f32,
    },
    Close,
}

// PathSegment
impl Hash for PathSegment {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // Hash the enum variant's discriminant first to distinguish them
        discriminant(self).hash(state);

        match self {
            PathSegment::MoveTo(p) => p.hash(state),
            PathSegment::LineTo(p) => p.hash(state),
            PathSegment::CurveTo {
                control1,
                control2,
                end,
            } => {
                control1.hash(state);
                control2.hash(state);
                end.hash(state);
            }
            PathSegment::QuadTo { control, end } => {
                control.hash(state);
                end.hash(state);
            }
            PathSegment::Arc {
                center,
                radius,
                start_angle,
                end_angle,
            } => {
                center.hash(state);
                (radius.round() as usize).hash(state);
                (start_angle.round() as usize).hash(state);
                (end_angle.round() as usize).hash(state);
            }
            PathSegment::Close => {} // No data to hash
        }
    }
}

impl PartialEq for PathSegment {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (PathSegment::MoveTo(a), PathSegment::MoveTo(b)) => a == b,
            (PathSegment::LineTo(a), PathSegment::LineTo(b)) => a == b,
            (
                PathSegment::CurveTo {
                    control1: c1a,
                    control2: c2a,
                    end: ea,
                },
                PathSegment::CurveTo {
                    control1: c1b,
                    control2: c2b,
                    end: eb,
                },
            ) => c1a == c1b && c2a == c2b && ea == eb,
            (
                PathSegment::QuadTo {
                    control: ca,
                    end: ea,
                },
                PathSegment::QuadTo {
                    control: cb,
                    end: eb,
                },
            ) => ca == cb && ea == eb,
            (
                PathSegment::Arc {
                    center: ca,
                    radius: ra,
                    start_angle: sa_a,
                    end_angle: ea_a,
                },
                PathSegment::Arc {
                    center: cb,
                    radius: rb,
                    start_angle: sa_b,
                    end_angle: ea_b,
                },
            ) => ca == cb && round_eq(*ra, *rb) && round_eq(*sa_a, *sa_b) && round_eq(*ea_a, *ea_b),
            (PathSegment::Close, PathSegment::Close) => true,
            _ => false, // Variants are different
        }
    }
}

impl Eq for PathSegment {}

// Enhanced content model supporting mixed inline content
#[derive(Debug, Clone, Hash)]
pub enum InlineContent {
    Text(StyledRun),
    Image(InlineImage),
    Shape(InlineShape),
    Space(InlineSpace),
    LineBreak(InlineBreak),
    Tab,
    /// List marker (::marker pseudo-element)
    /// Markers with list-style-position: outside are positioned
    /// in the padding gutter of the list container
    Marker {
        run: StyledRun,
        /// Whether marker is positioned outside (in padding) or inside (inline)
        position_outside: bool,
    },
    // Ruby annotation
    Ruby {
        base: Vec<InlineContent>,
        text: Vec<InlineContent>,
        // Style for the ruby text itself
        style: Arc<StyleProperties>,
    },
}

#[derive(Debug, Clone)]
pub struct InlineImage {
    pub source: ImageSource,
    pub intrinsic_size: Size,
    pub display_size: Option<Size>,
    // How much to shift baseline
    pub baseline_offset: f32,
    pub alignment: VerticalAlign,
    pub object_fit: ObjectFit,
}

impl PartialEq for InlineImage {
    fn eq(&self, other: &Self) -> bool {
        self.baseline_offset.to_bits() == other.baseline_offset.to_bits()
            && self.source == other.source
            && self.intrinsic_size == other.intrinsic_size
            && self.display_size == other.display_size
            && self.alignment == other.alignment
            && self.object_fit == other.object_fit
    }
}

impl Eq for InlineImage {}

impl Hash for InlineImage {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.source.hash(state);
        self.intrinsic_size.hash(state);
        self.display_size.hash(state);
        self.baseline_offset.to_bits().hash(state);
        self.alignment.hash(state);
        self.object_fit.hash(state);
    }
}

impl PartialOrd for InlineImage {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for InlineImage {
    fn cmp(&self, other: &Self) -> Ordering {
        self.source
            .cmp(&other.source)
            .then_with(|| self.intrinsic_size.cmp(&other.intrinsic_size))
            .then_with(|| self.display_size.cmp(&other.display_size))
            .then_with(|| self.baseline_offset.total_cmp(&other.baseline_offset))
            .then_with(|| self.alignment.cmp(&other.alignment))
            .then_with(|| self.object_fit.cmp(&other.object_fit))
    }
}

/// Enhanced glyph with all features
#[derive(Debug, Clone)]
pub struct Glyph {
    // Core glyph data
    pub glyph_id: u16,
    pub codepoint: char,
    /// Hash of the font - use LoadedFonts to look up the actual font when needed
    pub font_hash: u64,
    /// Cached font metrics to avoid font lookup for common operations
    pub font_metrics: LayoutFontMetrics,
    pub style: Arc<StyleProperties>,
    pub source: GlyphSource,

    // Text mapping
    pub logical_byte_index: usize,
    pub logical_byte_len: usize,
    pub content_index: usize,
    pub cluster: u32,

    // Metrics
    pub advance: f32,
    pub kerning: f32,
    pub offset: Point,

    // Vertical text support
    pub vertical_advance: f32,
    pub vertical_origin_y: f32, // from VORG
    pub vertical_bearing: Point,
    pub orientation: GlyphOrientation,

    // Layout properties
    pub script: Script,
    pub bidi_level: BidiLevel,
}

impl Glyph {
    #[inline]
    fn bounds(&self) -> Rect {
        Rect {
            x: 0.0,
            y: 0.0,
            width: self.advance,
            height: self.style.line_height,
        }
    }

    #[inline]
    fn character_class(&self) -> CharacterClass {
        classify_character(self.codepoint as u32)
    }

    #[inline]
    fn is_whitespace(&self) -> bool {
        self.character_class() == CharacterClass::Space
    }

    #[inline]
    fn can_justify(&self) -> bool {
        !self.codepoint.is_whitespace() && self.character_class() != CharacterClass::Combining
    }

    #[inline]
    fn justification_priority(&self) -> u8 {
        get_justification_priority(self.character_class())
    }

    #[inline]
    fn break_opportunity_after(&self) -> bool {
        let is_whitespace = self.codepoint.is_whitespace();
        let is_soft_hyphen = self.codepoint == '\u{00AD}';
        is_whitespace || is_soft_hyphen
    }
}

// Information about text runs after initial analysis
#[derive(Debug, Clone)]
pub struct TextRunInfo<'a> {
    pub text: &'a str,
    pub style: Arc<StyleProperties>,
    pub logical_start: usize,
    pub content_index: usize,
}

#[derive(Debug, Clone)]
pub enum ImageSource {
    /// Direct reference to decoded image (from DOM NodeType::Image)
    Ref(ImageRef),
    /// CSS url reference (from background-image, needs ImageCache lookup)
    Url(String),
    /// Raw image data
    Data(Arc<[u8]>),
    /// SVG source
    Svg(Arc<str>),
    /// Placeholder for layout without actual image
    Placeholder(Size),
}

impl PartialEq for ImageSource {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (ImageSource::Ref(a), ImageSource::Ref(b)) => a.get_hash() == b.get_hash(),
            (ImageSource::Url(a), ImageSource::Url(b)) => a == b,
            (ImageSource::Data(a), ImageSource::Data(b)) => Arc::ptr_eq(a, b),
            (ImageSource::Svg(a), ImageSource::Svg(b)) => Arc::ptr_eq(a, b),
            (ImageSource::Placeholder(a), ImageSource::Placeholder(b)) => {
                a.width.to_bits() == b.width.to_bits() && a.height.to_bits() == b.height.to_bits()
            }
            _ => false,
        }
    }
}

impl Eq for ImageSource {}

impl std::hash::Hash for ImageSource {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        core::mem::discriminant(self).hash(state);
        match self {
            ImageSource::Ref(r) => r.get_hash().hash(state),
            ImageSource::Url(s) => s.hash(state),
            ImageSource::Data(d) => (Arc::as_ptr(d) as *const u8 as usize).hash(state),
            ImageSource::Svg(s) => (Arc::as_ptr(s) as *const u8 as usize).hash(state),
            ImageSource::Placeholder(sz) => {
                sz.width.to_bits().hash(state);
                sz.height.to_bits().hash(state);
            }
        }
    }
}

impl PartialOrd for ImageSource {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for ImageSource {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        fn variant_index(s: &ImageSource) -> u8 {
            match s {
                ImageSource::Ref(_) => 0,
                ImageSource::Url(_) => 1,
                ImageSource::Data(_) => 2,
                ImageSource::Svg(_) => 3,
                ImageSource::Placeholder(_) => 4,
            }
        }
        match (self, other) {
            (ImageSource::Ref(a), ImageSource::Ref(b)) => a.get_hash().cmp(&b.get_hash()),
            (ImageSource::Url(a), ImageSource::Url(b)) => a.cmp(b),
            (ImageSource::Data(a), ImageSource::Data(b)) => {
                (Arc::as_ptr(a) as *const u8 as usize).cmp(&(Arc::as_ptr(b) as *const u8 as usize))
            }
            (ImageSource::Svg(a), ImageSource::Svg(b)) => {
                (Arc::as_ptr(a) as *const u8 as usize).cmp(&(Arc::as_ptr(b) as *const u8 as usize))
            }
            (ImageSource::Placeholder(a), ImageSource::Placeholder(b)) => {
                (a.width.to_bits(), a.height.to_bits())
                    .cmp(&(b.width.to_bits(), b.height.to_bits()))
            }
            // Different variants: compare by variant index
            _ => variant_index(self).cmp(&variant_index(other)),
        }
    }
}

#[derive(Default, Debug, Clone, Copy, PartialEq, PartialOrd)]
pub enum VerticalAlign {
    // Align image baseline with text baseline
    #[default]
    Baseline,
    // Align image bottom with line bottom
    Bottom,
    // Align image top with line top
    Top,
    // Align image middle with text middle
    Middle,
    // Align with tallest text in line
    TextTop,
    // Align with lowest text in line
    TextBottom,
    // Subscript alignment
    Sub,
    // Superscript alignment
    Super,
    // Custom offset from baseline
    Offset(f32),
}

impl std::hash::Hash for VerticalAlign {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        core::mem::discriminant(self).hash(state);
        if let VerticalAlign::Offset(f) = self {
            f.to_bits().hash(state);
        }
    }
}

impl Eq for VerticalAlign {}

impl Ord for VerticalAlign {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap_or(std::cmp::Ordering::Equal)
    }
}

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub enum ObjectFit {
    // Stretch to fit display size
    Fill,
    // Scale to fit within display size
    Contain,
    // Scale to cover display size
    Cover,
    // Use intrinsic size
    None,
    // Like contain but never scale up
    ScaleDown,
}

/// Border information for inline elements (display: inline, inline-block)
///
/// This stores the resolved border properties needed for rendering inline element borders.
/// Unlike block elements which render borders via paint_node_background_and_border(),
/// inline element borders must be rendered per glyph-run to handle line breaks correctly.
#[derive(Debug, Clone, PartialEq)]
pub struct InlineBorderInfo {
    /// Border widths in pixels for each side
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
    pub left: f32,
    /// Border colors for each side
    pub top_color: ColorU,
    pub right_color: ColorU,
    pub bottom_color: ColorU,
    pub left_color: ColorU,
    /// Border radius (if any)
    pub radius: Option<f32>,
}

impl Default for InlineBorderInfo {
    fn default() -> Self {
        Self {
            top: 0.0,
            right: 0.0,
            bottom: 0.0,
            left: 0.0,
            top_color: ColorU::TRANSPARENT,
            right_color: ColorU::TRANSPARENT,
            bottom_color: ColorU::TRANSPARENT,
            left_color: ColorU::TRANSPARENT,
            radius: None,
        }
    }
}

impl InlineBorderInfo {
    /// Returns true if any border has a non-zero width
    pub fn has_border(&self) -> bool {
        self.top > 0.0 || self.right > 0.0 || self.bottom > 0.0 || self.left > 0.0
    }
}

#[derive(Debug, Clone)]
pub struct InlineShape {
    pub shape_def: ShapeDefinition,
    pub fill: Option<ColorU>,
    pub stroke: Option<Stroke>,
    pub baseline_offset: f32,
    /// The NodeId of the element that created this shape
    /// (e.g., inline-block) - this allows us to look up
    /// styling information (background, border) when rendering
    pub source_node_id: Option<azul_core::dom::NodeId>,
}

#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum OverflowBehavior {
    // Content extends outside shape
    Visible,
    // Content is clipped to shape
    Hidden,
    // Scrollable overflow
    Scroll,
    // Browser/system decides
    #[default]
    Auto,
    // Break into next shape/page
    Break,
}

#[derive(Debug, Clone)]
pub struct MeasuredImage {
    pub source: ImageSource,
    pub size: Size,
    pub baseline_offset: f32,
    pub alignment: VerticalAlign,
    pub content_index: usize,
}

#[derive(Debug, Clone)]
pub struct MeasuredShape {
    pub shape_def: ShapeDefinition,
    pub size: Size,
    pub baseline_offset: f32,
    pub content_index: usize,
}

#[derive(Debug, Clone)]
pub struct InlineSpace {
    pub width: f32,
    pub is_breaking: bool, // Can line break here
    pub is_stretchy: bool, // Can be expanded for justification
}

impl PartialEq for InlineSpace {
    fn eq(&self, other: &Self) -> bool {
        self.width.to_bits() == other.width.to_bits()
            && self.is_breaking == other.is_breaking
            && self.is_stretchy == other.is_stretchy
    }
}

impl Eq for InlineSpace {}

impl Hash for InlineSpace {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.width.to_bits().hash(state);
        self.is_breaking.hash(state);
        self.is_stretchy.hash(state);
    }
}

impl PartialOrd for InlineSpace {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for InlineSpace {
    fn cmp(&self, other: &Self) -> Ordering {
        self.width
            .total_cmp(&other.width)
            .then_with(|| self.is_breaking.cmp(&other.is_breaking))
            .then_with(|| self.is_stretchy.cmp(&other.is_stretchy))
    }
}

impl PartialEq for InlineShape {
    fn eq(&self, other: &Self) -> bool {
        self.baseline_offset.to_bits() == other.baseline_offset.to_bits()
            && self.shape_def == other.shape_def
            && self.fill == other.fill
            && self.stroke == other.stroke
            && self.source_node_id == other.source_node_id
    }
}

impl Eq for InlineShape {}

impl Hash for InlineShape {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.shape_def.hash(state);
        self.fill.hash(state);
        self.stroke.hash(state);
        self.baseline_offset.to_bits().hash(state);
        self.source_node_id.hash(state);
    }
}

impl PartialOrd for InlineShape {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(
            self.shape_def
                .partial_cmp(&other.shape_def)?
                .then_with(|| self.fill.cmp(&other.fill))
                .then_with(|| {
                    self.stroke
                        .partial_cmp(&other.stroke)
                        .unwrap_or(Ordering::Equal)
                })
                .then_with(|| self.baseline_offset.total_cmp(&other.baseline_offset))
                .then_with(|| self.source_node_id.cmp(&other.source_node_id)),
        )
    }
}

#[derive(Debug, Default, Clone, Copy)]
pub struct Rect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}

impl PartialEq for Rect {
    fn eq(&self, other: &Self) -> bool {
        round_eq(self.x, other.x)
            && round_eq(self.y, other.y)
            && round_eq(self.width, other.width)
            && round_eq(self.height, other.height)
    }
}
impl Eq for Rect {}

impl Hash for Rect {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // The order in which you hash the fields matters.
        // A consistent order is crucial.
        (self.x.round() as usize).hash(state);
        (self.y.round() as usize).hash(state);
        (self.width.round() as usize).hash(state);
        (self.height.round() as usize).hash(state);
    }
}

#[derive(Debug, Default, Clone, Copy, PartialOrd)]
pub struct Size {
    pub width: f32,
    pub height: f32,
}

impl Ord for Size {
    fn cmp(&self, other: &Self) -> Ordering {
        (self.width.round() as usize)
            .cmp(&(other.width.round() as usize))
            .then_with(|| (self.height.round() as usize).cmp(&(other.height.round() as usize)))
    }
}

// Size
impl Hash for Size {
    fn hash<H: Hasher>(&self, state: &mut H) {
        (self.width.round() as usize).hash(state);
        (self.height.round() as usize).hash(state);
    }
}
impl PartialEq for Size {
    fn eq(&self, other: &Self) -> bool {
        round_eq(self.width, other.width) && round_eq(self.height, other.height)
    }
}
impl Eq for Size {}

impl Size {
    pub const fn zero() -> Self {
        Self::new(0.0, 0.0)
    }
    pub const fn new(width: f32, height: f32) -> Self {
        Self { width, height }
    }
}

#[derive(Debug, Default, Clone, Copy, PartialOrd)]
pub struct Point {
    pub x: f32,
    pub y: f32,
}

// Point
impl Hash for Point {
    fn hash<H: Hasher>(&self, state: &mut H) {
        (self.x.round() as usize).hash(state);
        (self.y.round() as usize).hash(state);
    }
}

impl PartialEq for Point {
    fn eq(&self, other: &Self) -> bool {
        round_eq(self.x, other.x) && round_eq(self.y, other.y)
    }
}

impl Eq for Point {}

#[derive(Debug, Clone, PartialOrd)]
pub enum ShapeDefinition {
    Rectangle {
        size: Size,
        corner_radius: Option<f32>,
    },
    Circle {
        radius: f32,
    },
    Ellipse {
        radii: Size,
    },
    Polygon {
        points: Vec<Point>,
    },
    Path {
        segments: Vec<PathSegment>,
    },
}

// ShapeDefinition
impl Hash for ShapeDefinition {
    fn hash<H: Hasher>(&self, state: &mut H) {
        discriminant(self).hash(state);
        match self {
            ShapeDefinition::Rectangle {
                size,
                corner_radius,
            } => {
                size.hash(state);
                corner_radius.map(|r| r.round() as usize).hash(state);
            }
            ShapeDefinition::Circle { radius } => {
                (radius.round() as usize).hash(state);
            }
            ShapeDefinition::Ellipse { radii } => {
                radii.hash(state);
            }
            ShapeDefinition::Polygon { points } => {
                // Since Point implements Hash, we can hash the Vec directly.
                points.hash(state);
            }
            ShapeDefinition::Path { segments } => {
                // Same for Vec<PathSegment>
                segments.hash(state);
            }
        }
    }
}

impl PartialEq for ShapeDefinition {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                ShapeDefinition::Rectangle {
                    size: s1,
                    corner_radius: r1,
                },
                ShapeDefinition::Rectangle {
                    size: s2,
                    corner_radius: r2,
                },
            ) => {
                s1 == s2
                    && match (r1, r2) {
                        (None, None) => true,
                        (Some(v1), Some(v2)) => round_eq(*v1, *v2),
                        _ => false,
                    }
            }
            (ShapeDefinition::Circle { radius: r1 }, ShapeDefinition::Circle { radius: r2 }) => {
                round_eq(*r1, *r2)
            }
            (ShapeDefinition::Ellipse { radii: r1 }, ShapeDefinition::Ellipse { radii: r2 }) => {
                r1 == r2
            }
            (ShapeDefinition::Polygon { points: p1 }, ShapeDefinition::Polygon { points: p2 }) => {
                p1 == p2
            }
            (ShapeDefinition::Path { segments: s1 }, ShapeDefinition::Path { segments: s2 }) => {
                s1 == s2
            }
            _ => false,
        }
    }
}
impl Eq for ShapeDefinition {}

impl ShapeDefinition {
    /// Calculates the bounding box size for the shape.
    pub fn get_size(&self) -> Size {
        match self {
            // The size is explicitly defined.
            ShapeDefinition::Rectangle { size, .. } => *size,

            // The bounding box of a circle is a square with sides equal to the diameter.
            ShapeDefinition::Circle { radius } => {
                let diameter = radius * 2.0;
                Size::new(diameter, diameter)
            }

            // The bounding box of an ellipse has width and height equal to twice its radii.
            ShapeDefinition::Ellipse { radii } => Size::new(radii.width * 2.0, radii.height * 2.0),

            // For a polygon, we must find the min/max coordinates to get the bounds.
            ShapeDefinition::Polygon { points } => calculate_bounding_box_size(points),

            // For a path, we find the bounding box of all its anchor and control points.
            //
            // NOTE: This is a common and fast approximation. The true bounding box of
            // bezier curves can be slightly smaller than the box containing their control
            // points. For pixel-perfect results, one would need to calculate the
            // curve's extrema.
            ShapeDefinition::Path { segments } => {
                let mut points = Vec::new();
                let mut current_pos = Point { x: 0.0, y: 0.0 };

                for segment in segments {
                    match segment {
                        PathSegment::MoveTo(p) | PathSegment::LineTo(p) => {
                            points.push(*p);
                            current_pos = *p;
                        }
                        PathSegment::QuadTo { control, end } => {
                            points.push(current_pos);
                            points.push(*control);
                            points.push(*end);
                            current_pos = *end;
                        }
                        PathSegment::CurveTo {
                            control1,
                            control2,
                            end,
                        } => {
                            points.push(current_pos);
                            points.push(*control1);
                            points.push(*control2);
                            points.push(*end);
                            current_pos = *end;
                        }
                        PathSegment::Arc {
                            center,
                            radius,
                            start_angle,
                            end_angle,
                        } => {
                            // 1. Calculate and add the arc's start and end points to the list.
                            let start_point = Point {
                                x: center.x + radius * start_angle.cos(),
                                y: center.y + radius * start_angle.sin(),
                            };
                            let end_point = Point {
                                x: center.x + radius * end_angle.cos(),
                                y: center.y + radius * end_angle.sin(),
                            };
                            points.push(start_point);
                            points.push(end_point);

                            // 2. Normalize the angles to handle cases where the arc crosses the
                            //    0-radian line.
                            // This ensures we can iterate forward from a start to an end angle.
                            let mut normalized_end = *end_angle;
                            while normalized_end < *start_angle {
                                normalized_end += 2.0 * std::f32::consts::PI;
                            }

                            // 3. Find the first cardinal point (multiples of PI/2) at or after the
                            //    start angle.
                            let mut check_angle = (*start_angle / std::f32::consts::FRAC_PI_2)
                                .ceil()
                                * std::f32::consts::FRAC_PI_2;

                            // 4. Iterate through all cardinal points that fall within the arc's
                            //    sweep and add them.
                            // These points define the maximum extent of the arc's bounding box.
                            while check_angle < normalized_end {
                                points.push(Point {
                                    x: center.x + radius * check_angle.cos(),
                                    y: center.y + radius * check_angle.sin(),
                                });
                                check_angle += std::f32::consts::FRAC_PI_2;
                            }

                            // 5. The end of the arc is the new current position for subsequent path
                            //    segments.
                            current_pos = end_point;
                        }
                        PathSegment::Close => {
                            // No new points are added for closing the path
                        }
                    }
                }
                calculate_bounding_box_size(&points)
            }
        }
    }
}

/// Helper function to calculate the size of the bounding box enclosing a set of points.
fn calculate_bounding_box_size(points: &[Point]) -> Size {
    if points.is_empty() {
        return Size::zero();
    }

    let mut min_x = f32::MAX;
    let mut max_x = f32::MIN;
    let mut min_y = f32::MAX;
    let mut max_y = f32::MIN;

    for point in points {
        min_x = min_x.min(point.x);
        max_x = max_x.max(point.x);
        min_y = min_y.min(point.y);
        max_y = max_y.max(point.y);
    }

    // Handle case where points might be collinear or a single point
    if min_x > max_x || min_y > max_y {
        return Size::zero();
    }

    Size::new(max_x - min_x, max_y - min_y)
}

#[derive(Debug, Clone, PartialOrd)]
pub struct Stroke {
    pub color: ColorU,
    pub width: f32,
    pub dash_pattern: Option<Vec<f32>>,
}

// Stroke
impl Hash for Stroke {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.color.hash(state);
        (self.width.round() as usize).hash(state);

        // Manual hashing for Option<Vec<f32>>
        match &self.dash_pattern {
            None => 0u8.hash(state), // Hash a discriminant for None
            Some(pattern) => {
                1u8.hash(state); // Hash a discriminant for Some
                pattern.len().hash(state); // Hash the length
                for &val in pattern {
                    (val.round() as usize).hash(state); // Hash each rounded value
                }
            }
        }
    }
}

impl PartialEq for Stroke {
    fn eq(&self, other: &Self) -> bool {
        if self.color != other.color || !round_eq(self.width, other.width) {
            return false;
        }
        match (&self.dash_pattern, &other.dash_pattern) {
            (None, None) => true,
            (Some(p1), Some(p2)) => {
                p1.len() == p2.len() && p1.iter().zip(p2.iter()).all(|(a, b)| round_eq(*a, *b))
            }
            _ => false,
        }
    }
}

impl Eq for Stroke {}

// Helper function to round f32 for comparison
fn round_eq(a: f32, b: f32) -> bool {
    (a.round() as isize) == (b.round() as isize)
}

#[derive(Debug, Clone)]
pub enum ShapeBoundary {
    Rectangle(Rect),
    Circle { center: Point, radius: f32 },
    Ellipse { center: Point, radii: Size },
    Polygon { points: Vec<Point> },
    Path { segments: Vec<PathSegment> },
}

impl ShapeBoundary {
    pub fn inflate(&self, margin: f32) -> Self {
        if margin == 0.0 {
            return self.clone();
        }
        match self {
            Self::Rectangle(rect) => Self::Rectangle(Rect {
                x: rect.x - margin,
                y: rect.y - margin,
                width: (rect.width + margin * 2.0).max(0.0),
                height: (rect.height + margin * 2.0).max(0.0),
            }),
            Self::Circle { center, radius } => Self::Circle {
                center: *center,
                radius: radius + margin,
            },
            // For simplicity, Polygon and Path inflation is not implemented here.
            // A full implementation would require a geometry library to offset the path.
            _ => self.clone(),
        }
    }
}

// ShapeBoundary
impl Hash for ShapeBoundary {
    fn hash<H: Hasher>(&self, state: &mut H) {
        discriminant(self).hash(state);
        match self {
            ShapeBoundary::Rectangle(rect) => rect.hash(state),
            ShapeBoundary::Circle { center, radius } => {
                center.hash(state);
                (radius.round() as usize).hash(state);
            }
            ShapeBoundary::Ellipse { center, radii } => {
                center.hash(state);
                radii.hash(state);
            }
            ShapeBoundary::Polygon { points } => points.hash(state),
            ShapeBoundary::Path { segments } => segments.hash(state),
        }
    }
}
impl PartialEq for ShapeBoundary {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (ShapeBoundary::Rectangle(r1), ShapeBoundary::Rectangle(r2)) => r1 == r2,
            (
                ShapeBoundary::Circle {
                    center: c1,
                    radius: r1,
                },
                ShapeBoundary::Circle {
                    center: c2,
                    radius: r2,
                },
            ) => c1 == c2 && round_eq(*r1, *r2),
            (
                ShapeBoundary::Ellipse {
                    center: c1,
                    radii: r1,
                },
                ShapeBoundary::Ellipse {
                    center: c2,
                    radii: r2,
                },
            ) => c1 == c2 && r1 == r2,
            (ShapeBoundary::Polygon { points: p1 }, ShapeBoundary::Polygon { points: p2 }) => {
                p1 == p2
            }
            (ShapeBoundary::Path { segments: s1 }, ShapeBoundary::Path { segments: s2 }) => {
                s1 == s2
            }
            _ => false,
        }
    }
}
impl Eq for ShapeBoundary {}

impl ShapeBoundary {
    /// Converts a CSS shape (from azul-css) to a layout engine ShapeBoundary
    ///
    /// # Arguments
    /// * `css_shape` - The parsed CSS shape from azul-css
    /// * `reference_box` - The containing box for resolving coordinates (from layout solver)
    ///
    /// # Returns
    /// A ShapeBoundary ready for use in the text layout engine
    pub fn from_css_shape(
        css_shape: &azul_css::shape::CssShape,
        reference_box: Rect,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Self {
        use azul_css::shape::CssShape;

        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "[ShapeBoundary::from_css_shape] Input CSS shape: {:?}",
                css_shape
            )));
            msgs.push(LayoutDebugMessage::info(format!(
                "[ShapeBoundary::from_css_shape] Reference box: {:?}",
                reference_box
            )));
        }

        let result = match css_shape {
            CssShape::Circle(circle) => {
                let center = Point {
                    x: reference_box.x + circle.center.x,
                    y: reference_box.y + circle.center.y,
                };
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[ShapeBoundary::from_css_shape] Circle - CSS center: ({}, {}), radius: {}",
                        circle.center.x, circle.center.y, circle.radius
                    )));
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[ShapeBoundary::from_css_shape] Circle - Absolute center: ({}, {}), \
                         radius: {}",
                        center.x, center.y, circle.radius
                    )));
                }
                ShapeBoundary::Circle {
                    center,
                    radius: circle.radius,
                }
            }

            CssShape::Ellipse(ellipse) => {
                let center = Point {
                    x: reference_box.x + ellipse.center.x,
                    y: reference_box.y + ellipse.center.y,
                };
                let radii = Size {
                    width: ellipse.radius_x,
                    height: ellipse.radius_y,
                };
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[ShapeBoundary::from_css_shape] Ellipse - center: ({}, {}), radii: ({}, \
                         {})",
                        center.x, center.y, radii.width, radii.height
                    )));
                }
                ShapeBoundary::Ellipse { center, radii }
            }

            CssShape::Polygon(polygon) => {
                let points = polygon
                    .points
                    .as_ref()
                    .iter()
                    .map(|pt| Point {
                        x: reference_box.x + pt.x,
                        y: reference_box.y + pt.y,
                    })
                    .collect();
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[ShapeBoundary::from_css_shape] Polygon - {} points",
                        polygon.points.as_ref().len()
                    )));
                }
                ShapeBoundary::Polygon { points }
            }

            CssShape::Inset(inset) => {
                // Inset defines distances from reference box edges
                let x = reference_box.x + inset.inset_left;
                let y = reference_box.y + inset.inset_top;
                let width = reference_box.width - inset.inset_left - inset.inset_right;
                let height = reference_box.height - inset.inset_top - inset.inset_bottom;

                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[ShapeBoundary::from_css_shape] Inset - insets: ({}, {}, {}, {})",
                        inset.inset_top, inset.inset_right, inset.inset_bottom, inset.inset_left
                    )));
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[ShapeBoundary::from_css_shape] Inset - resulting rect: x={}, y={}, \
                         w={}, h={}",
                        x, y, width, height
                    )));
                }

                ShapeBoundary::Rectangle(Rect {
                    x,
                    y,
                    width: width.max(0.0),
                    height: height.max(0.0),
                })
            }

            CssShape::Path(path) => {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(
                        "[ShapeBoundary::from_css_shape] Path - fallback to rectangle".to_string(),
                    ));
                }
                // TODO: Parse SVG path data into PathSegments
                // For now, fall back to rectangle
                ShapeBoundary::Rectangle(reference_box)
            }
        };

        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "[ShapeBoundary::from_css_shape] Result: {:?}",
                result
            )));
        }
        result
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InlineBreak {
    pub break_type: BreakType,
    pub clear: ClearType,
    pub content_index: usize,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum BreakType {
    Soft,   // Preferred break (like <wbr>)
    Hard,   // Forced break (like <br>)
    Page,   // Page break
    Column, // Column break
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum ClearType {
    None,
    Left,
    Right,
    Both,
}

// Complex shape constraints for non-rectangular text flow
#[derive(Debug, Clone)]
pub struct ShapeConstraints {
    pub boundaries: Vec<ShapeBoundary>,
    pub exclusions: Vec<ShapeBoundary>,
    pub writing_mode: WritingMode,
    pub text_align: TextAlign,
    pub line_height: f32,
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Hash, Eq, PartialOrd, Ord)]
pub enum WritingMode {
    #[default]
    HorizontalTb, // horizontal-tb (normal horizontal)
    VerticalRl, // vertical-rl (vertical right-to-left)
    VerticalLr, // vertical-lr (vertical left-to-right)
    SidewaysRl, // sideways-rl (rotated horizontal in vertical context)
    SidewaysLr, // sideways-lr (rotated horizontal in vertical context)
}

impl WritingMode {
    /// Necessary to determine if the glyphs are advancing in a horizontal direction
    pub fn is_advance_horizontal(&self) -> bool {
        matches!(
            self,
            WritingMode::HorizontalTb | WritingMode::SidewaysRl | WritingMode::SidewaysLr
        )
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Hash, Eq, PartialOrd, Ord)]
pub enum JustifyContent {
    #[default]
    None,
    InterWord,      // Expand spaces between words
    InterCharacter, // Expand spaces between all characters (for CJK)
    Distribute,     // Distribute space evenly including start/end
    Kashida,        // Stretch Arabic text using kashidas
}

// Enhanced text alignment with logical directions
#[derive(Debug, Clone, Copy, PartialEq, Default, Hash, Eq, PartialOrd, Ord)]
pub enum TextAlign {
    #[default]
    Left,
    Right,
    Center,
    Justify,
    Start,
    End,        // Logical start/end
    JustifyAll, // Justify including last line
}

// Vertical text orientation for individual characters
#[derive(Debug, Clone, Copy, PartialEq, Default, Eq, PartialOrd, Ord, Hash)]
pub enum TextOrientation {
    #[default]
    Mixed, // Default: upright for scripts, rotated for others
    Upright,  // All characters upright
    Sideways, // All characters rotated 90 degrees
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TextDecoration {
    pub underline: bool,
    pub strikethrough: bool,
    pub overline: bool,
}

impl Default for TextDecoration {
    fn default() -> Self {
        TextDecoration {
            underline: false,
            overline: false,
            strikethrough: false,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq, PartialOrd, Ord, Default)]
pub enum TextTransform {
    #[default]
    None,
    Uppercase,
    Lowercase,
    Capitalize,
}

// Type alias for OpenType feature tags
pub type FourCc = [u8; 4];

// Enum for relative or absolute spacing
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub enum Spacing {
    Px(i32), // Use integer pixels to simplify hashing and equality
    Em(f32),
}

// A type that implements `Hash` must also implement `Eq`.
// Since f32 does not implement `Eq`, we provide a manual implementation.
// The derived `PartialEq` is sufficient for this marker trait.
impl Eq for Spacing {}

impl Hash for Spacing {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // First, hash the enum variant to distinguish between Px and Em.
        discriminant(self).hash(state);
        match self {
            Spacing::Px(val) => val.hash(state),
            // For hashing floats, convert them to their raw bit representation.
            // This ensures that identical float values produce identical hashes.
            Spacing::Em(val) => val.to_bits().hash(state),
        }
    }
}

impl Default for Spacing {
    fn default() -> Self {
        Spacing::Px(0)
    }
}

impl Default for FontHash {
    fn default() -> Self {
        Self::invalid()
    }
}

/// Style properties with vertical text support
#[derive(Debug, Clone, PartialEq)]
pub struct StyleProperties {
    /// Font stack for fallback support (priority order)
    /// Can be either a list of FontSelectors (resolved via fontconfig)
    /// or a direct FontRef (bypasses fontconfig entirely).
    pub font_stack: FontStack,
    pub font_size_px: f32,
    pub color: ColorU,
    /// Background color for inline elements (e.g., `<span style="background-color: yellow">`)
    ///
    /// This is propagated from CSS through the style system and eventually used by
    /// the PDF renderer to draw filled rectangles behind text. The value is `None`
    /// for transparent backgrounds (the default).
    ///
    /// The propagation chain is:
    /// CSS -> `get_style_properties()` -> `StyleProperties` -> `ShapedGlyph` -> `PdfGlyphRun`
    ///
    /// See `PdfGlyphRun::background_color` for how this is used in PDF rendering.
    pub background_color: Option<ColorU>,
    /// Full background content layers (for gradients, images, etc.)
    /// This extends background_color to support CSS gradients on inline elements.
    pub background_content: Vec<StyleBackgroundContent>,
    /// Border information for inline elements
    pub border: Option<InlineBorderInfo>,
    pub letter_spacing: Spacing,
    pub word_spacing: Spacing,

    pub line_height: f32,
    pub text_decoration: TextDecoration,

    // Represents CSS font-feature-settings like `"liga"`, `"smcp=1"`.
    pub font_features: Vec<String>,

    // Variable fonts
    pub font_variations: Vec<(FourCc, f32)>,
    // Multiplier of the space width
    pub tab_size: f32,
    // text-transform
    pub text_transform: TextTransform,
    // Vertical text properties
    pub writing_mode: WritingMode,
    pub text_orientation: TextOrientation,
    // Tate-chu-yoko
    pub text_combine_upright: Option<TextCombineUpright>,

    // Variant handling
    pub font_variant_caps: FontVariantCaps,
    pub font_variant_numeric: FontVariantNumeric,
    pub font_variant_ligatures: FontVariantLigatures,
    pub font_variant_east_asian: FontVariantEastAsian,
}

impl Default for StyleProperties {
    fn default() -> Self {
        const FONT_SIZE: f32 = 16.0;
        const TAB_SIZE: f32 = 8.0;
        Self {
            font_stack: FontStack::default(),
            font_size_px: FONT_SIZE,
            color: ColorU::default(),
            background_color: None,
            background_content: Vec::new(),
            border: None,
            letter_spacing: Spacing::default(), // Px(0)
            word_spacing: Spacing::default(),   // Px(0)
            line_height: FONT_SIZE * 1.2,
            text_decoration: TextDecoration::default(),
            font_features: Vec::new(),
            font_variations: Vec::new(),
            tab_size: TAB_SIZE, // CSS default
            text_transform: TextTransform::default(),
            writing_mode: WritingMode::default(),
            text_orientation: TextOrientation::default(),
            text_combine_upright: None,
            font_variant_caps: FontVariantCaps::default(),
            font_variant_numeric: FontVariantNumeric::default(),
            font_variant_ligatures: FontVariantLigatures::default(),
            font_variant_east_asian: FontVariantEastAsian::default(),
        }
    }
}

impl Hash for StyleProperties {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.font_stack.hash(state);
        self.color.hash(state);
        self.background_color.hash(state);
        self.text_decoration.hash(state);
        self.font_features.hash(state);
        self.writing_mode.hash(state);
        self.text_orientation.hash(state);
        self.text_combine_upright.hash(state);
        self.letter_spacing.hash(state);
        self.word_spacing.hash(state);

        // For f32 fields, round and cast to usize before hashing.
        (self.font_size_px.round() as usize).hash(state);
        (self.line_height.round() as usize).hash(state);
    }
}

#[derive(Debug, Clone, PartialEq, Hash, Eq, PartialOrd, Ord)]
pub enum TextCombineUpright {
    None,
    All,        // Combine all characters in horizontal layout
    Digits(u8), // Combine up to N digits
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GlyphSource {
    /// Glyph generated from a character in the source text.
    Char,
    /// Glyph inserted dynamically by the layout engine (e.g., a hyphen).
    Hyphen,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CharacterClass {
    Space,       // Regular spaces - highest justification priority
    Punctuation, // Can sometimes be adjusted
    Letter,      // Normal letters
    Ideograph,   // CJK characters - can be justified between
    Symbol,      // Symbols, emojis
    Combining,   // Combining marks - never justified
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum GlyphOrientation {
    Horizontal, // Keep horizontal (normal in horizontal text)
    Vertical,   // Rotate to vertical (normal in vertical text)
    Upright,    // Keep upright regardless of writing mode
    Mixed,      // Use script-specific default orientation
}

// Bidi and script detection
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum BidiDirection {
    Ltr,
    Rtl,
}

impl BidiDirection {
    pub fn is_rtl(&self) -> bool {
        matches!(self, BidiDirection::Rtl)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq, PartialOrd, Ord, Default)]
pub enum FontVariantCaps {
    #[default]
    Normal,
    SmallCaps,
    AllSmallCaps,
    PetiteCaps,
    AllPetiteCaps,
    Unicase,
    TitlingCaps,
}

#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq, PartialOrd, Ord, Default)]
pub enum FontVariantNumeric {
    #[default]
    Normal,
    LiningNums,
    OldstyleNums,
    ProportionalNums,
    TabularNums,
    DiagonalFractions,
    StackedFractions,
    Ordinal,
    SlashedZero,
}

#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq, PartialOrd, Ord, Default)]
pub enum FontVariantLigatures {
    #[default]
    Normal,
    None,
    Common,
    NoCommon,
    Discretionary,
    NoDiscretionary,
    Historical,
    NoHistorical,
    Contextual,
    NoContextual,
}

#[derive(Debug, Clone, Copy, PartialEq, Hash, Eq, PartialOrd, Ord, Default)]
pub enum FontVariantEastAsian {
    #[default]
    Normal,
    Jis78,
    Jis83,
    Jis90,
    Jis04,
    Simplified,
    Traditional,
    FullWidth,
    ProportionalWidth,
    Ruby,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BidiLevel(u8);

impl BidiLevel {
    pub fn new(level: u8) -> Self {
        Self(level)
    }
    pub fn is_rtl(&self) -> bool {
        self.0 % 2 == 1
    }
    pub fn level(&self) -> u8 {
        self.0
    }
}

// Add this new struct for style overrides
#[derive(Debug, Clone)]
pub struct StyleOverride {
    /// The specific character this override applies to.
    pub target: ContentIndex,
    /// The style properties to apply.
    /// Any `None` value means "inherit from the base style".
    pub style: PartialStyleProperties,
}

#[derive(Debug, Clone, Default)]
pub struct PartialStyleProperties {
    pub font_stack: Option<FontStack>,
    pub font_size_px: Option<f32>,
    pub color: Option<ColorU>,
    pub letter_spacing: Option<Spacing>,
    pub word_spacing: Option<Spacing>,
    pub line_height: Option<f32>,
    pub text_decoration: Option<TextDecoration>,
    pub font_features: Option<Vec<String>>,
    pub font_variations: Option<Vec<(FourCc, f32)>>,
    pub tab_size: Option<f32>,
    pub text_transform: Option<TextTransform>,
    pub writing_mode: Option<WritingMode>,
    pub text_orientation: Option<TextOrientation>,
    pub text_combine_upright: Option<Option<TextCombineUpright>>,
    pub font_variant_caps: Option<FontVariantCaps>,
    pub font_variant_numeric: Option<FontVariantNumeric>,
    pub font_variant_ligatures: Option<FontVariantLigatures>,
    pub font_variant_east_asian: Option<FontVariantEastAsian>,
}

impl Hash for PartialStyleProperties {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.font_stack.hash(state);
        self.font_size_px.map(|f| f.to_bits()).hash(state);
        self.color.hash(state);
        self.letter_spacing.hash(state);
        self.word_spacing.hash(state);
        self.line_height.map(|f| f.to_bits()).hash(state);
        self.text_decoration.hash(state);
        self.font_features.hash(state);

        // Manual hashing for Vec<(FourCc, f32)>
        self.font_variations.as_ref().map(|v| {
            for (tag, val) in v {
                tag.hash(state);
                val.to_bits().hash(state);
            }
        });

        self.tab_size.map(|f| f.to_bits()).hash(state);
        self.text_transform.hash(state);
        self.writing_mode.hash(state);
        self.text_orientation.hash(state);
        self.text_combine_upright.hash(state);
        self.font_variant_caps.hash(state);
        self.font_variant_numeric.hash(state);
        self.font_variant_ligatures.hash(state);
        self.font_variant_east_asian.hash(state);
    }
}

impl PartialEq for PartialStyleProperties {
    fn eq(&self, other: &Self) -> bool {
        self.font_stack == other.font_stack &&
        self.font_size_px.map(|f| f.to_bits()) == other.font_size_px.map(|f| f.to_bits()) &&
        self.color == other.color &&
        self.letter_spacing == other.letter_spacing &&
        self.word_spacing == other.word_spacing &&
        self.line_height.map(|f| f.to_bits()) == other.line_height.map(|f| f.to_bits()) &&
        self.text_decoration == other.text_decoration &&
        self.font_features == other.font_features &&
        self.font_variations == other.font_variations && // Vec<(FourCc, f32)> is PartialEq
        self.tab_size.map(|f| f.to_bits()) == other.tab_size.map(|f| f.to_bits()) &&
        self.text_transform == other.text_transform &&
        self.writing_mode == other.writing_mode &&
        self.text_orientation == other.text_orientation &&
        self.text_combine_upright == other.text_combine_upright &&
        self.font_variant_caps == other.font_variant_caps &&
        self.font_variant_numeric == other.font_variant_numeric &&
        self.font_variant_ligatures == other.font_variant_ligatures &&
        self.font_variant_east_asian == other.font_variant_east_asian
    }
}

impl Eq for PartialStyleProperties {}

impl StyleProperties {
    fn apply_override(&self, partial: &PartialStyleProperties) -> Self {
        let mut new_style = self.clone();
        if let Some(val) = &partial.font_stack {
            new_style.font_stack = val.clone();
        }
        if let Some(val) = partial.font_size_px {
            new_style.font_size_px = val;
        }
        if let Some(val) = &partial.color {
            new_style.color = val.clone();
        }
        if let Some(val) = partial.letter_spacing {
            new_style.letter_spacing = val;
        }
        if let Some(val) = partial.word_spacing {
            new_style.word_spacing = val;
        }
        if let Some(val) = partial.line_height {
            new_style.line_height = val;
        }
        if let Some(val) = &partial.text_decoration {
            new_style.text_decoration = val.clone();
        }
        if let Some(val) = &partial.font_features {
            new_style.font_features = val.clone();
        }
        if let Some(val) = &partial.font_variations {
            new_style.font_variations = val.clone();
        }
        if let Some(val) = partial.tab_size {
            new_style.tab_size = val;
        }
        if let Some(val) = partial.text_transform {
            new_style.text_transform = val;
        }
        if let Some(val) = partial.writing_mode {
            new_style.writing_mode = val;
        }
        if let Some(val) = partial.text_orientation {
            new_style.text_orientation = val;
        }
        if let Some(val) = &partial.text_combine_upright {
            new_style.text_combine_upright = val.clone();
        }
        if let Some(val) = partial.font_variant_caps {
            new_style.font_variant_caps = val;
        }
        if let Some(val) = partial.font_variant_numeric {
            new_style.font_variant_numeric = val;
        }
        if let Some(val) = partial.font_variant_ligatures {
            new_style.font_variant_ligatures = val;
        }
        if let Some(val) = partial.font_variant_east_asian {
            new_style.font_variant_east_asian = val;
        }
        new_style
    }
}

/// The kind of a glyph, used to distinguish characters from layout-inserted items.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum GlyphKind {
    /// A standard glyph representing one or more characters from the source text.
    Character,
    /// A hyphen glyph inserted by the line breaking algorithm.
    Hyphen,
    /// A `.notdef` glyph, indicating a character that could not be found in any font.
    NotDef,
    /// A Kashida justification glyph, inserted to stretch Arabic text.
    Kashida {
        /// The target width of the kashida.
        width: f32,
    },
}

// --- Stage 1: Logical Representation ---

#[derive(Debug, Clone)]
pub enum LogicalItem {
    Text {
        /// A stable ID pointing back to the original source character.
        source: ContentIndex,
        /// The text of this specific logical item (often a single grapheme cluster).
        text: String,
        style: Arc<StyleProperties>,
        /// If this text is a list marker: whether it should be positioned outside
        /// (in the padding gutter) or inside (inline with content).
        /// None for non-marker content.
        marker_position_outside: Option<bool>,
        /// The DOM NodeId of the Text node this item originated from.
        /// None for generated content (list markers, ::before/::after, etc.)
        source_node_id: Option<NodeId>,
    },
    /// Tate-chu-yoko: Run of text to be laid out horizontally within a vertical context.
    CombinedText {
        source: ContentIndex,
        text: String,
        style: Arc<StyleProperties>,
    },
    Ruby {
        source: ContentIndex,
        // For the stub, we simplify to strings. A full implementation
        // would need to handle Vec<LogicalItem> for both.
        base_text: String,
        ruby_text: String,
        style: Arc<StyleProperties>,
    },
    Object {
        /// A stable ID pointing back to the original source object.
        source: ContentIndex,
        /// The original non-text object.
        content: InlineContent,
    },
    Tab {
        source: ContentIndex,
        style: Arc<StyleProperties>,
    },
    Break {
        source: ContentIndex,
        break_info: InlineBreak,
    },
}

impl Hash for LogicalItem {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        discriminant(self).hash(state);
        match self {
            LogicalItem::Text {
                source,
                text,
                style,
                marker_position_outside,
                source_node_id,
            } => {
                source.hash(state);
                text.hash(state);
                style.as_ref().hash(state); // Hash the content, not the Arc pointer
                marker_position_outside.hash(state);
                source_node_id.hash(state);
            }
            LogicalItem::CombinedText {
                source,
                text,
                style,
            } => {
                source.hash(state);
                text.hash(state);
                style.as_ref().hash(state);
            }
            LogicalItem::Ruby {
                source,
                base_text,
                ruby_text,
                style,
            } => {
                source.hash(state);
                base_text.hash(state);
                ruby_text.hash(state);
                style.as_ref().hash(state);
            }
            LogicalItem::Object { source, content } => {
                source.hash(state);
                content.hash(state);
            }
            LogicalItem::Tab { source, style } => {
                source.hash(state);
                style.as_ref().hash(state);
            }
            LogicalItem::Break { source, break_info } => {
                source.hash(state);
                break_info.hash(state);
            }
        }
    }
}

// --- Stage 2: Visual Representation ---

#[derive(Debug, Clone)]
pub struct VisualItem {
    /// A reference to the logical item this visual item originated from.
    /// A single LogicalItem can be split into multiple VisualItems.
    pub logical_source: LogicalItem,
    /// The Bidi embedding level for this item.
    pub bidi_level: BidiLevel,
    /// The script detected for this run, crucial for shaping.
    pub script: Script,
    /// The text content for this specific visual run.
    pub text: String,
}

// --- Stage 3: Shaped Representation ---

#[derive(Debug, Clone)]
pub enum ShapedItem {
    Cluster(ShapedCluster),
    /// A block of combined text (tate-chu-yoko) that is laid out
    // as a single unbreakable object.
    CombinedBlock {
        source: ContentIndex,
        /// The glyphs to be rendered horizontally within the vertical line.
        glyphs: Vec<ShapedGlyph>,
        bounds: Rect,
        baseline_offset: f32,
    },
    Object {
        source: ContentIndex,
        bounds: Rect,
        baseline_offset: f32,
        // Store original object for rendering
        content: InlineContent,
    },
    Tab {
        source: ContentIndex,
        bounds: Rect,
    },
    Break {
        source: ContentIndex,
        break_info: InlineBreak,
    },
}

impl ShapedItem {
    pub fn as_cluster(&self) -> Option<&ShapedCluster> {
        match self {
            ShapedItem::Cluster(c) => Some(c),
            _ => None,
        }
    }
    /// Returns the bounding box of the item, relative to its own origin.
    ///
    /// The origin of the returned `Rect` is `(0,0)`, representing the top-left corner
    /// of the item's layout space before final positioning. The size represents the
    /// item's total advance (width in horizontal mode) and its line height (ascent + descent).
    pub fn bounds(&self) -> Rect {
        match self {
            ShapedItem::Cluster(cluster) => {
                // The width of a text cluster is its total advance.
                let width = cluster.advance;

                // The height is the sum of its ascent and descent, which defines its line box.
                // We use the existing helper function which correctly calculates this from font
                // metrics.
                let (ascent, descent) = get_item_vertical_metrics(self);
                let height = ascent + descent;

                Rect {
                    x: 0.0,
                    y: 0.0,
                    width,
                    height,
                }
            }
            // For atomic inline items like objects, combined blocks, and tabs,
            // their bounds have already been calculated during the shaping or measurement phase.
            ShapedItem::CombinedBlock { bounds, .. } => *bounds,
            ShapedItem::Object { bounds, .. } => *bounds,
            ShapedItem::Tab { bounds, .. } => *bounds,

            // Breaks are control characters and have no visual geometry.
            ShapedItem::Break { .. } => Rect::default(), // A zero-sized rectangle.
        }
    }
}

/// A group of glyphs that corresponds to one or more source characters (a cluster).
#[derive(Debug, Clone)]
pub struct ShapedCluster {
    /// The original text that this cluster was shaped from.
    /// This is crucial for correct hyphenation.
    pub text: String,
    /// The ID of the grapheme cluster this glyph cluster represents.
    pub source_cluster_id: GraphemeClusterId,
    /// The source `ContentIndex` for mapping back to logical items.
    pub source_content_index: ContentIndex,
    /// The DOM NodeId of the Text node this cluster originated from.
    /// None for generated content (list markers, ::before/::after, etc.)
    pub source_node_id: Option<NodeId>,
    /// The glyphs that make up this cluster.
    pub glyphs: Vec<ShapedGlyph>,
    /// The total advance width (horizontal) or height (vertical) of the cluster.
    pub advance: f32,
    /// The direction of this cluster, inherited from its `VisualItem`.
    pub direction: BidiDirection,
    /// Font style of this cluster
    pub style: Arc<StyleProperties>,
    /// If this cluster is a list marker: whether it should be positioned outside
    /// (in the padding gutter) or inside (inline with content).
    /// None for non-marker content.
    pub marker_position_outside: Option<bool>,
}

/// A single, shaped glyph with its essential metrics.
#[derive(Debug, Clone)]
pub struct ShapedGlyph {
    /// The kind of glyph this is (character, hyphen, etc.).
    pub kind: GlyphKind,
    /// Glyph ID inside of the font
    pub glyph_id: u16,
    /// The byte offset of this glyph's source character(s) within its cluster text.
    pub cluster_offset: u32,
    /// The horizontal advance for this glyph (for horizontal text) - this is the BASE advance
    /// from the font metrics, WITHOUT kerning applied
    pub advance: f32,
    /// The kerning adjustment for this glyph (positive = more space, negative = less space)
    /// This is separate from advance so we can position glyphs absolutely
    pub kerning: f32,
    /// The horizontal offset/bearing for this glyph
    pub offset: Point,
    /// The vertical advance for this glyph (for vertical text).
    pub vertical_advance: f32,
    /// The vertical offset/bearing for this glyph.
    pub vertical_offset: Point,
    pub script: Script,
    pub style: Arc<StyleProperties>,
    /// Hash of the font - use LoadedFonts to look up the actual font when needed
    pub font_hash: u64,
    /// Cached font metrics to avoid font lookup for common operations
    pub font_metrics: LayoutFontMetrics,
}

impl ShapedGlyph {
    pub fn into_glyph_instance<T: ParsedFontTrait>(
        &self,
        writing_mode: WritingMode,
        loaded_fonts: &LoadedFonts<T>,
    ) -> GlyphInstance {
        let size = loaded_fonts
            .get_by_hash(self.font_hash)
            .and_then(|font| font.get_glyph_size(self.glyph_id, self.style.font_size_px))
            .unwrap_or_default();

        let position = if writing_mode.is_advance_horizontal() {
            LogicalPosition {
                x: self.offset.x,
                y: self.offset.y,
            }
        } else {
            LogicalPosition {
                x: self.vertical_offset.x,
                y: self.vertical_offset.y,
            }
        };

        GlyphInstance {
            index: self.glyph_id as u32,
            point: position,
            size,
        }
    }

    /// Convert this ShapedGlyph into a GlyphInstance with an absolute position.
    /// This is used for display list generation where glyphs need their final page coordinates.
    pub fn into_glyph_instance_at<T: ParsedFontTrait>(
        &self,
        writing_mode: WritingMode,
        absolute_position: LogicalPosition,
        loaded_fonts: &LoadedFonts<T>,
    ) -> GlyphInstance {
        let size = loaded_fonts
            .get_by_hash(self.font_hash)
            .and_then(|font| font.get_glyph_size(self.glyph_id, self.style.font_size_px))
            .unwrap_or_default();

        GlyphInstance {
            index: self.glyph_id as u32,
            point: absolute_position,
            size,
        }
    }

    /// Convert this ShapedGlyph into a GlyphInstance with an absolute position.
    /// This version doesn't require fonts - it uses a default size.
    /// Use this when you don't need precise glyph bounds (e.g., display list generation).
    pub fn into_glyph_instance_at_simple(
        &self,
        _writing_mode: WritingMode,
        absolute_position: LogicalPosition,
    ) -> GlyphInstance {
        // Use font metrics to estimate size, or default to zero
        // The actual rendering will use the font directly
        GlyphInstance {
            index: self.glyph_id as u32,
            point: absolute_position,
            size: LogicalSize::default(),
        }
    }
}

// --- Stage 4: Positioned Representation (Final Layout) ---

#[derive(Debug, Clone)]
pub struct PositionedItem {
    pub item: ShapedItem,
    pub position: Point,
    pub line_index: usize,
}

#[derive(Debug, Clone)]
pub struct UnifiedLayout {
    pub items: Vec<PositionedItem>,
    /// Information about content that did not fit.
    pub overflow: OverflowInfo,
}

impl UnifiedLayout {
    /// Calculate the bounding box of all positioned items.
    /// This is computed on-demand rather than cached.
    pub fn bounds(&self) -> Rect {
        if self.items.is_empty() {
            return Rect::default();
        }

        let mut min_x = f32::MAX;
        let mut min_y = f32::MAX;
        let mut max_x = f32::MIN;
        let mut max_y = f32::MIN;

        for item in &self.items {
            let item_x = item.position.x;
            let item_y = item.position.y;

            // Get item dimensions
            let item_bounds = item.item.bounds();
            let item_width = item_bounds.width;
            let item_height = item_bounds.height;

            min_x = min_x.min(item_x);
            min_y = min_y.min(item_y);
            max_x = max_x.max(item_x + item_width);
            max_y = max_y.max(item_y + item_height);
        }

        Rect {
            x: min_x,
            y: min_y,
            width: max_x - min_x,
            height: max_y - min_y,
        }
    }

    pub fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
    pub fn last_baseline(&self) -> Option<f32> {
        self.items
            .iter()
            .rev()
            .find_map(|item| get_baseline_for_item(&item.item))
    }

    /// Takes a point relative to the layout's origin and returns the closest
    /// logical cursor position.
    ///
    /// This is the unified hit-testing implementation. The old `hit_test_to_cursor`
    /// method is deprecated in favor of this one.
    pub fn hittest_cursor(&self, point: LogicalPosition) -> Option<TextCursor> {
        if self.items.is_empty() {
            return None;
        }

        // Find the closest cluster vertically and horizontally
        let mut closest_item_idx = 0;
        let mut closest_distance = f32::MAX;

        for (idx, item) in self.items.iter().enumerate() {
            // Only consider cluster items for cursor placement
            if !matches!(item.item, ShapedItem::Cluster(_)) {
                continue;
            }

            let item_bounds = item.item.bounds();
            let item_center_y = item.position.y + item_bounds.height / 2.0;

            // Distance from click position to item center
            let vertical_distance = (point.y - item_center_y).abs();

            // For horizontal distance, check if we're within the cluster bounds
            let horizontal_distance = if point.x < item.position.x {
                item.position.x - point.x
            } else if point.x > item.position.x + item_bounds.width {
                point.x - (item.position.x + item_bounds.width)
            } else {
                0.0 // Inside the cluster horizontally
            };

            // Combined distance (prioritize vertical proximity)
            let distance = vertical_distance * 2.0 + horizontal_distance;

            if distance < closest_distance {
                closest_distance = distance;
                closest_item_idx = idx;
            }
        }

        // Get the closest cluster
        let closest_item = &self.items[closest_item_idx];
        let cluster = match &closest_item.item {
            ShapedItem::Cluster(c) => c,
            // Objects are treated as a single cluster for selection
            ShapedItem::Object { source, .. } | ShapedItem::CombinedBlock { source, .. } => {
                return Some(TextCursor {
                    cluster_id: GraphemeClusterId {
                        source_run: source.run_index,
                        start_byte_in_run: source.item_index,
                    },
                    affinity: if point.x
                        < closest_item.position.x + (closest_item.item.bounds().width / 2.0)
                    {
                        CursorAffinity::Leading
                    } else {
                        CursorAffinity::Trailing
                    },
                });
            }
            _ => return None,
        };

        // Determine affinity based on which half of the cluster was clicked
        let cluster_mid_x = closest_item.position.x + cluster.advance / 2.0;
        let affinity = if point.x < cluster_mid_x {
            CursorAffinity::Leading
        } else {
            CursorAffinity::Trailing
        };

        Some(TextCursor {
            cluster_id: cluster.source_cluster_id,
            affinity,
        })
    }

    /// Given a logical selection range, returns a vector of visual rectangles
    /// that cover the selected text, in the layout's coordinate space.
    pub fn get_selection_rects(&self, range: &SelectionRange) -> Vec<LogicalRect> {
        // 1. Build a map from the logical cluster ID to the visual PositionedItem for fast lookups.
        let mut cluster_map: HashMap<GraphemeClusterId, &PositionedItem> = HashMap::new();
        for item in &self.items {
            if let Some(cluster) = item.item.as_cluster() {
                cluster_map.insert(cluster.source_cluster_id, item);
            }
        }

        // 2. Normalize the range to ensure start always logically precedes end.
        let (start_cursor, end_cursor) = if range.start.cluster_id > range.end.cluster_id
            || (range.start.cluster_id == range.end.cluster_id
                && range.start.affinity > range.end.affinity)
        {
            (range.end, range.start)
        } else {
            (range.start, range.end)
        };

        // 3. Find the positioned items corresponding to the start and end of the selection.
        let Some(start_item) = cluster_map.get(&start_cursor.cluster_id) else {
            return Vec::new();
        };
        let Some(end_item) = cluster_map.get(&end_cursor.cluster_id) else {
            return Vec::new();
        };

        let mut rects = Vec::new();

        // Helper to get the absolute visual X coordinate of a cursor.
        let get_cursor_x = |item: &PositionedItem, affinity: CursorAffinity| -> f32 {
            match affinity {
                CursorAffinity::Leading => item.position.x,
                CursorAffinity::Trailing => item.position.x + get_item_measure(&item.item, false),
            }
        };

        // Helper to get the visual bounding box of all content on a specific line index.
        let get_line_bounds = |line_index: usize| -> Option<LogicalRect> {
            let items_on_line = self.items.iter().filter(|i| i.line_index == line_index);

            let mut min_x: Option<f32> = None;
            let mut max_x: Option<f32> = None;
            let mut min_y: Option<f32> = None;
            let mut max_y: Option<f32> = None;

            for item in items_on_line {
                // Skip items that don't take up space (like hard breaks)
                let item_bounds = item.item.bounds();
                if item_bounds.width <= 0.0 && item_bounds.height <= 0.0 {
                    continue;
                }

                let item_x_end = item.position.x + item_bounds.width;
                let item_y_end = item.position.y + item_bounds.height;

                min_x = Some(min_x.map_or(item.position.x, |mx| mx.min(item.position.x)));
                max_x = Some(max_x.map_or(item_x_end, |mx| mx.max(item_x_end)));
                min_y = Some(min_y.map_or(item.position.y, |my| my.min(item.position.y)));
                max_y = Some(max_y.map_or(item_y_end, |my| my.max(item_y_end)));
            }

            if let (Some(min_x), Some(max_x), Some(min_y), Some(max_y)) =
                (min_x, max_x, min_y, max_y)
            {
                Some(LogicalRect {
                    origin: LogicalPosition { x: min_x, y: min_y },
                    size: LogicalSize {
                        width: max_x - min_x,
                        height: max_y - min_y,
                    },
                })
            } else {
                None
            }
        };

        // 4. Handle single-line selection.
        if start_item.line_index == end_item.line_index {
            if let Some(line_bounds) = get_line_bounds(start_item.line_index) {
                let start_x = get_cursor_x(start_item, start_cursor.affinity);
                let end_x = get_cursor_x(end_item, end_cursor.affinity);

                // Use min/max and abs to correctly handle selections made from right-to-left.
                rects.push(LogicalRect {
                    origin: LogicalPosition {
                        x: start_x.min(end_x),
                        y: line_bounds.origin.y,
                    },
                    size: LogicalSize {
                        width: (end_x - start_x).abs(),
                        height: line_bounds.size.height,
                    },
                });
            }
        }
        // 5. Handle multi-line selection.
        else {
            // Rectangle for the start line (from cursor to end of line).
            if let Some(start_line_bounds) = get_line_bounds(start_item.line_index) {
                let start_x = get_cursor_x(start_item, start_cursor.affinity);
                let line_end_x = start_line_bounds.origin.x + start_line_bounds.size.width;
                rects.push(LogicalRect {
                    origin: LogicalPosition {
                        x: start_x,
                        y: start_line_bounds.origin.y,
                    },
                    size: LogicalSize {
                        width: line_end_x - start_x,
                        height: start_line_bounds.size.height,
                    },
                });
            }

            // Rectangles for all full lines in between.
            for line_idx in (start_item.line_index + 1)..end_item.line_index {
                if let Some(line_bounds) = get_line_bounds(line_idx) {
                    rects.push(line_bounds);
                }
            }

            // Rectangle for the end line (from start of line to cursor).
            if let Some(end_line_bounds) = get_line_bounds(end_item.line_index) {
                let line_start_x = end_line_bounds.origin.x;
                let end_x = get_cursor_x(end_item, end_cursor.affinity);
                rects.push(LogicalRect {
                    origin: LogicalPosition {
                        x: line_start_x,
                        y: end_line_bounds.origin.y,
                    },
                    size: LogicalSize {
                        width: end_x - line_start_x,
                        height: end_line_bounds.size.height,
                    },
                });
            }
        }

        rects
    }

    /// Calculates the visual rectangle for a cursor at a given logical position.
    pub fn get_cursor_rect(&self, cursor: &TextCursor) -> Option<LogicalRect> {
        // Find the item and glyph corresponding to the cursor's cluster ID.
        for item in &self.items {
            if let ShapedItem::Cluster(cluster) = &item.item {
                if cluster.source_cluster_id == cursor.cluster_id {
                    // This is the correct cluster. Now find the position.
                    let line_height = item.item.bounds().height;
                    let cursor_x = match cursor.affinity {
                        CursorAffinity::Leading => item.position.x,
                        CursorAffinity::Trailing => item.position.x + cluster.advance,
                    };
                    return Some(LogicalRect {
                        origin: LogicalPosition {
                            x: cursor_x,
                            y: item.position.y,
                        },
                        size: LogicalSize {
                            width: 1.0,
                            height: line_height,
                        }, // 1px wide cursor
                    });
                }
            }
        }
        None
    }

    /// Get a cursor at the first cluster (leading edge) in the layout.
    pub fn get_first_cluster_cursor(&self) -> Option<TextCursor> {
        for item in &self.items {
            if let ShapedItem::Cluster(cluster) = &item.item {
                return Some(TextCursor {
                    cluster_id: cluster.source_cluster_id,
                    affinity: CursorAffinity::Leading,
                });
            }
        }
        None
    }

    /// Get a cursor at the last cluster (trailing edge) in the layout.
    pub fn get_last_cluster_cursor(&self) -> Option<TextCursor> {
        for item in self.items.iter().rev() {
            if let ShapedItem::Cluster(cluster) = &item.item {
                return Some(TextCursor {
                    cluster_id: cluster.source_cluster_id,
                    affinity: CursorAffinity::Trailing,
                });
            }
        }
        None
    }

    /// Moves a cursor one visual unit to the left, handling line wrapping and Bidi text.
    pub fn move_cursor_left(
        &self,
        cursor: TextCursor,
        debug: &mut Option<Vec<String>>,
    ) -> TextCursor {
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_left: starting at byte {}, affinity {:?}",
                cursor.cluster_id.start_byte_in_run, cursor.affinity
            ));
        }

        // Find current item
        let current_item_pos = self.items.iter().position(|i| {
            i.item
                .as_cluster()
                .map_or(false, |c| c.source_cluster_id == cursor.cluster_id)
        });

        let Some(current_pos) = current_item_pos else {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_left: cursor not found, staying at byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return cursor;
        };

        // If we're at trailing edge, move to leading edge of same cluster
        if cursor.affinity == CursorAffinity::Trailing {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_left: moving from trailing to leading edge of byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return TextCursor {
                cluster_id: cursor.cluster_id,
                affinity: CursorAffinity::Leading,
            };
        }

        // We're at leading edge, move to previous cluster's trailing edge
        // Search backwards for a cluster on the same line, or any cluster if at line start
        let current_line = self.items[current_pos].line_index;

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_left: at leading edge, current line {}",
                current_line
            ));
        }

        // First, try to find previous item on same line
        for i in (0..current_pos).rev() {
            if let Some(cluster) = self.items[i].item.as_cluster() {
                if self.items[i].line_index == current_line {
                    if let Some(d) = debug {
                        d.push(format!(
                            "[Cursor] move_cursor_left: found previous cluster on same line, byte \
                             {}",
                            cluster.source_cluster_id.start_byte_in_run
                        ));
                    }
                    return TextCursor {
                        cluster_id: cluster.source_cluster_id,
                        affinity: CursorAffinity::Trailing,
                    };
                }
            }
        }

        // If no previous item on same line, try to move to end of previous line
        if current_line > 0 {
            let prev_line = current_line - 1;
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_left: trying previous line {}",
                    prev_line
                ));
            }
            for i in (0..current_pos).rev() {
                if let Some(cluster) = self.items[i].item.as_cluster() {
                    if self.items[i].line_index == prev_line {
                        if let Some(d) = debug {
                            d.push(format!(
                                "[Cursor] move_cursor_left: found cluster on previous line, byte \
                                 {}",
                                cluster.source_cluster_id.start_byte_in_run
                            ));
                        }
                        return TextCursor {
                            cluster_id: cluster.source_cluster_id,
                            affinity: CursorAffinity::Trailing,
                        };
                    }
                }
            }
        }

        // At start of text, can't move further
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_left: at start of text, staying at byte {}",
                cursor.cluster_id.start_byte_in_run
            ));
        }
        cursor
    }

    /// Moves a cursor one visual unit to the right.
    pub fn move_cursor_right(
        &self,
        cursor: TextCursor,
        debug: &mut Option<Vec<String>>,
    ) -> TextCursor {
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_right: starting at byte {}, affinity {:?}",
                cursor.cluster_id.start_byte_in_run, cursor.affinity
            ));
        }

        // Find current item
        let current_item_pos = self.items.iter().position(|i| {
            i.item
                .as_cluster()
                .map_or(false, |c| c.source_cluster_id == cursor.cluster_id)
        });

        let Some(current_pos) = current_item_pos else {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_right: cursor not found, staying at byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return cursor;
        };

        // If we're at leading edge, move to trailing edge of same cluster
        if cursor.affinity == CursorAffinity::Leading {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_right: moving from leading to trailing edge of byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return TextCursor {
                cluster_id: cursor.cluster_id,
                affinity: CursorAffinity::Trailing,
            };
        }

        // We're at trailing edge, move to next cluster's leading edge
        let current_line = self.items[current_pos].line_index;

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_right: at trailing edge, current line {}",
                current_line
            ));
        }

        // First, try to find next item on same line
        for i in (current_pos + 1)..self.items.len() {
            if let Some(cluster) = self.items[i].item.as_cluster() {
                if self.items[i].line_index == current_line {
                    if let Some(d) = debug {
                        d.push(format!(
                            "[Cursor] move_cursor_right: found next cluster on same line, byte {}",
                            cluster.source_cluster_id.start_byte_in_run
                        ));
                    }
                    return TextCursor {
                        cluster_id: cluster.source_cluster_id,
                        affinity: CursorAffinity::Leading,
                    };
                }
            }
        }

        // If no next item on same line, try to move to start of next line
        let next_line = current_line + 1;
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_right: trying next line {}",
                next_line
            ));
        }
        for i in (current_pos + 1)..self.items.len() {
            if let Some(cluster) = self.items[i].item.as_cluster() {
                if self.items[i].line_index == next_line {
                    if let Some(d) = debug {
                        d.push(format!(
                            "[Cursor] move_cursor_right: found cluster on next line, byte {}",
                            cluster.source_cluster_id.start_byte_in_run
                        ));
                    }
                    return TextCursor {
                        cluster_id: cluster.source_cluster_id,
                        affinity: CursorAffinity::Leading,
                    };
                }
            }
        }

        // At end of text, can't move further
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_right: at end of text, staying at byte {}",
                cursor.cluster_id.start_byte_in_run
            ));
        }
        cursor
    }

    /// Moves a cursor up one line, attempting to preserve the horizontal column.
    pub fn move_cursor_up(
        &self,
        cursor: TextCursor,
        goal_x: &mut Option<f32>,
        debug: &mut Option<Vec<String>>,
    ) -> TextCursor {
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_up: from byte {} (affinity {:?})",
                cursor.cluster_id.start_byte_in_run, cursor.affinity
            ));
        }

        let Some(current_item) = self.items.iter().find(|i| {
            i.item
                .as_cluster()
                .map_or(false, |c| c.source_cluster_id == cursor.cluster_id)
        }) else {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_up: cursor not found in items, staying at byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return cursor;
        };

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_up: current line {}, position ({}, {})",
                current_item.line_index, current_item.position.x, current_item.position.y
            ));
        }

        let target_line_idx = current_item.line_index.saturating_sub(1);
        if current_item.line_index == target_line_idx {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_up: already at top line {}, staying put",
                    current_item.line_index
                ));
            }
            return cursor;
        }

        let current_x = goal_x.unwrap_or_else(|| {
            let x = match cursor.affinity {
                CursorAffinity::Leading => current_item.position.x,
                CursorAffinity::Trailing => {
                    current_item.position.x + get_item_measure(&current_item.item, false)
                }
            };
            *goal_x = Some(x);
            x
        });

        // Find the Y coordinate of the middle of the target line
        let target_y = self
            .items
            .iter()
            .find(|i| i.line_index == target_line_idx)
            .map(|i| i.position.y + (i.item.bounds().height / 2.0))
            .unwrap_or(current_item.position.y);

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_up: target line {}, hittesting at ({}, {})",
                target_line_idx, current_x, target_y
            ));
        }

        let result = self
            .hittest_cursor(LogicalPosition {
                x: current_x,
                y: target_y,
            })
            .unwrap_or(cursor);

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_up: result byte {} (affinity {:?})",
                result.cluster_id.start_byte_in_run, result.affinity
            ));
        }

        result
    }

    /// Moves a cursor down one line, attempting to preserve the horizontal column.
    pub fn move_cursor_down(
        &self,
        cursor: TextCursor,
        goal_x: &mut Option<f32>,
        debug: &mut Option<Vec<String>>,
    ) -> TextCursor {
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_down: from byte {} (affinity {:?})",
                cursor.cluster_id.start_byte_in_run, cursor.affinity
            ));
        }

        let Some(current_item) = self.items.iter().find(|i| {
            i.item
                .as_cluster()
                .map_or(false, |c| c.source_cluster_id == cursor.cluster_id)
        }) else {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_down: cursor not found in items, staying at byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return cursor;
        };

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_down: current line {}, position ({}, {})",
                current_item.line_index, current_item.position.x, current_item.position.y
            ));
        }

        let max_line = self.items.iter().map(|i| i.line_index).max().unwrap_or(0);
        let target_line_idx = (current_item.line_index + 1).min(max_line);
        if current_item.line_index == target_line_idx {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_down: already at bottom line {}, staying put",
                    current_item.line_index
                ));
            }
            return cursor;
        }

        let current_x = goal_x.unwrap_or_else(|| {
            let x = match cursor.affinity {
                CursorAffinity::Leading => current_item.position.x,
                CursorAffinity::Trailing => {
                    current_item.position.x + get_item_measure(&current_item.item, false)
                }
            };
            *goal_x = Some(x);
            x
        });

        let target_y = self
            .items
            .iter()
            .find(|i| i.line_index == target_line_idx)
            .map(|i| i.position.y + (i.item.bounds().height / 2.0))
            .unwrap_or(current_item.position.y);

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_down: hit testing at ({}, {})",
                current_x, target_y
            ));
        }

        let result = self
            .hittest_cursor(LogicalPosition {
                x: current_x,
                y: target_y,
            })
            .unwrap_or(cursor);

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_down: result byte {}, affinity {:?}",
                result.cluster_id.start_byte_in_run, result.affinity
            ));
        }

        result
    }

    /// Moves a cursor to the visual start of its current line.
    pub fn move_cursor_to_line_start(
        &self,
        cursor: TextCursor,
        debug: &mut Option<Vec<String>>,
    ) -> TextCursor {
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_to_line_start: starting at byte {}, affinity {:?}",
                cursor.cluster_id.start_byte_in_run, cursor.affinity
            ));
        }

        let Some(current_item) = self.items.iter().find(|i| {
            i.item
                .as_cluster()
                .map_or(false, |c| c.source_cluster_id == cursor.cluster_id)
        }) else {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_to_line_start: cursor not found, staying at byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return cursor;
        };

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_to_line_start: current line {}, position ({}, {})",
                current_item.line_index, current_item.position.x, current_item.position.y
            ));
        }

        let first_item_on_line = self
            .items
            .iter()
            .filter(|i| i.line_index == current_item.line_index)
            .min_by(|a, b| {
                a.position
                    .x
                    .partial_cmp(&b.position.x)
                    .unwrap_or(Ordering::Equal)
            });

        if let Some(item) = first_item_on_line {
            if let ShapedItem::Cluster(c) = &item.item {
                let result = TextCursor {
                    cluster_id: c.source_cluster_id,
                    affinity: CursorAffinity::Leading,
                };
                if let Some(d) = debug {
                    d.push(format!(
                        "[Cursor] move_cursor_to_line_start: result byte {}, affinity {:?}",
                        result.cluster_id.start_byte_in_run, result.affinity
                    ));
                }
                return result;
            }
        }

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_to_line_start: no first item found, staying at byte {}",
                cursor.cluster_id.start_byte_in_run
            ));
        }
        cursor
    }

    /// Moves a cursor to the visual end of its current line.
    pub fn move_cursor_to_line_end(
        &self,
        cursor: TextCursor,
        debug: &mut Option<Vec<String>>,
    ) -> TextCursor {
        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_to_line_end: starting at byte {}, affinity {:?}",
                cursor.cluster_id.start_byte_in_run, cursor.affinity
            ));
        }

        let Some(current_item) = self.items.iter().find(|i| {
            i.item
                .as_cluster()
                .map_or(false, |c| c.source_cluster_id == cursor.cluster_id)
        }) else {
            if let Some(d) = debug {
                d.push(format!(
                    "[Cursor] move_cursor_to_line_end: cursor not found, staying at byte {}",
                    cursor.cluster_id.start_byte_in_run
                ));
            }
            return cursor;
        };

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_to_line_end: current line {}, position ({}, {})",
                current_item.line_index, current_item.position.x, current_item.position.y
            ));
        }

        let last_item_on_line = self
            .items
            .iter()
            .filter(|i| i.line_index == current_item.line_index)
            .max_by(|a, b| {
                a.position
                    .x
                    .partial_cmp(&b.position.x)
                    .unwrap_or(Ordering::Equal)
            });

        if let Some(item) = last_item_on_line {
            if let ShapedItem::Cluster(c) = &item.item {
                let result = TextCursor {
                    cluster_id: c.source_cluster_id,
                    affinity: CursorAffinity::Trailing,
                };
                if let Some(d) = debug {
                    d.push(format!(
                        "[Cursor] move_cursor_to_line_end: result byte {}, affinity {:?}",
                        result.cluster_id.start_byte_in_run, result.affinity
                    ));
                }
                return result;
            }
        }

        if let Some(d) = debug {
            d.push(format!(
                "[Cursor] move_cursor_to_line_end: no last item found, staying at byte {}",
                cursor.cluster_id.start_byte_in_run
            ));
        }
        cursor
    }
}

fn get_baseline_for_item(item: &ShapedItem) -> Option<f32> {
    match item {
        ShapedItem::CombinedBlock {
            baseline_offset, ..
        } => Some(*baseline_offset),
        ShapedItem::Object {
            baseline_offset, ..
        } => Some(*baseline_offset),
        // We have to get the clusters font from the last glyph
        ShapedItem::Cluster(ref cluster) => {
            if let Some(last_glyph) = cluster.glyphs.last() {
                Some(
                    last_glyph
                        .font_metrics
                        .baseline_scaled(last_glyph.style.font_size_px),
                )
            } else {
                None
            }
        }
        ShapedItem::Break { source, break_info } => {
            // Breaks do not contribute to baseline
            None
        }
        ShapedItem::Tab { source, bounds } => {
            // Tabs do not contribute to baseline
            None
        }
    }
}

/// Stores information about content that exceeded the available layout space.
#[derive(Debug, Clone, Default)]
pub struct OverflowInfo {
    /// The items that did not fit within the constraints.
    pub overflow_items: Vec<ShapedItem>,
    /// The total bounds of all content, including overflowing items.
    /// This is useful for `OverflowBehavior::Visible` or `Scroll`.
    pub unclipped_bounds: Rect,
}

impl OverflowInfo {
    pub fn has_overflow(&self) -> bool {
        !self.overflow_items.is_empty()
    }
}

/// Intermediate structure carrying information from the line breaker to the positioner.
#[derive(Debug, Clone)]
pub struct UnifiedLine {
    pub items: Vec<ShapedItem>,
    /// The y-position (for horizontal) or x-position (for vertical) of the line's baseline.
    pub cross_axis_position: f32,
    /// The geometric segments this line must fit into.
    pub constraints: LineConstraints,
    pub is_last: bool,
}

// --- Caching Infrastructure ---

pub type CacheId = u64;

/// Defines a single area for layout, with its own shape and properties.
#[derive(Debug, Clone)]
pub struct LayoutFragment {
    /// A unique identifier for this fragment (e.g., "main-content", "sidebar").
    pub id: String,
    /// The geometric and style constraints for this specific fragment.
    pub constraints: UnifiedConstraints,
}

/// Represents the final layout distributed across multiple fragments.
#[derive(Debug, Clone)]
pub struct FlowLayout {
    /// A map from a fragment's unique ID to the layout it contains.
    pub fragment_layouts: HashMap<String, Arc<UnifiedLayout>>,
    /// Any items that did not fit into the last fragment in the flow chain.
    /// This is useful for pagination or determining if more layout space is needed.
    pub remaining_items: Vec<ShapedItem>,
}

pub struct LayoutCache {
    // Stage 1 Cache: InlineContent -> LogicalItems
    logical_items: HashMap<CacheId, Arc<Vec<LogicalItem>>>,
    // Stage 2 Cache: LogicalItems -> VisualItems
    visual_items: HashMap<CacheId, Arc<Vec<VisualItem>>>,
    // Stage 3 Cache: VisualItems -> ShapedItems (now strongly typed)
    shaped_items: HashMap<CacheId, Arc<Vec<ShapedItem>>>,
    // Stage 4 Cache: ShapedItems + Constraints -> Final Layout (now strongly typed)
    layouts: HashMap<CacheId, Arc<UnifiedLayout>>,
}

impl LayoutCache {
    pub fn new() -> Self {
        Self {
            logical_items: HashMap::new(),
            visual_items: HashMap::new(),
            shaped_items: HashMap::new(),
            layouts: HashMap::new(),
        }
    }

    /// Get a layout from the cache by its ID
    pub fn get_layout(&self, cache_id: &CacheId) -> Option<&Arc<UnifiedLayout>> {
        self.layouts.get(cache_id)
    }

    /// Get all layout cache IDs (for iteration/debugging)
    pub fn get_all_layout_ids(&self) -> Vec<CacheId> {
        self.layouts.keys().copied().collect()
    }
}

impl Default for LayoutCache {
    fn default() -> Self {
        Self::new()
    }
}

/// Key for caching the conversion from `InlineContent` to `LogicalItem`s.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct LogicalItemsKey<'a> {
    pub inline_content_hash: u64, // Pre-hash the content for efficiency
    pub default_font_size: u32,   // Affects space widths
    // Add other relevant properties from constraints if they affect this stage
    pub _marker: std::marker::PhantomData<&'a ()>,
}

/// Key for caching the Bidi reordering stage.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct VisualItemsKey {
    pub logical_items_id: CacheId,
    pub base_direction: BidiDirection,
}

/// Key for caching the shaping stage.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct ShapedItemsKey {
    pub visual_items_id: CacheId,
    pub style_hash: u64, // Represents a hash of all font/style properties
}

impl ShapedItemsKey {
    pub fn new(visual_items_id: CacheId, visual_items: &[VisualItem]) -> Self {
        let style_hash = {
            let mut hasher = DefaultHasher::new();
            for item in visual_items.iter() {
                // Hash the style from the logical source, as this is what determines the font.
                match &item.logical_source {
                    LogicalItem::Text { style, .. } | LogicalItem::CombinedText { style, .. } => {
                        style.as_ref().hash(&mut hasher);
                    }
                    _ => {}
                }
            }
            hasher.finish()
        };

        Self {
            visual_items_id,
            style_hash,
        }
    }
}

/// Key for the final layout stage.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct LayoutKey {
    pub shaped_items_id: CacheId,
    pub constraints: UnifiedConstraints,
}

/// Helper to create a `CacheId` from any `Hash`able type.
fn calculate_id<T: Hash>(item: &T) -> CacheId {
    let mut hasher = DefaultHasher::new();
    item.hash(&mut hasher);
    hasher.finish()
}

// --- Main Layout Pipeline Implementation ---

impl LayoutCache {
    /// New top-level entry point for flowing layout across multiple regions.
    ///
    /// This function orchestrates the entire layout pipeline, but instead of fitting
    /// content into a single set of constraints, it flows the content through an
    /// ordered sequence of `LayoutFragment`s.
    ///
    /// # CSS Inline Layout Module Level 3: Pipeline Implementation
    ///
    /// This implements the inline formatting context with 5 stages:
    ///
    /// ## Stage 1: Logical Analysis (InlineContent -> LogicalItem)
    /// \u2705 IMPLEMENTED: Parses raw content into logical units
    /// - Handles text runs, inline-blocks, replaced elements
    /// - Applies style overrides at character level
    /// - Implements \u00a7 2.2: Content size contribution calculation
    ///
    /// ## Stage 2: BiDi Reordering (LogicalItem -> VisualItem)
    /// \u2705 IMPLEMENTED: Uses CSS 'direction' property per CSS Writing Modes
    /// - Reorders items for right-to-left text (Arabic, Hebrew)
    /// - Respects containing block direction (not auto-detection)
    /// - Conforms to Unicode BiDi Algorithm (UAX #9)
    ///
    /// ## Stage 3: Shaping (VisualItem -> ShapedItem)
    /// \u2705 IMPLEMENTED: Converts text to glyphs
    /// - Uses HarfBuzz for OpenType shaping
    /// - Handles ligatures, kerning, contextual forms
    /// - Caches shaped results for performance
    ///
    /// ## Stage 4: Text Orientation Transformations
    /// \u26a0\ufe0f PARTIAL: Applies text-orientation for vertical text
    /// - Uses constraints from *first* fragment only
    /// - \u274c TODO: Should re-orient if fragments have different writing modes
    ///
    /// ## Stage 5: Flow Loop (ShapedItem -> PositionedItem)
    /// \u2705 IMPLEMENTED: Breaks lines and positions content
    /// - Calls perform_fragment_layout for each fragment
    /// - Uses BreakCursor to flow content across fragments
    /// - Implements \u00a7 5: Line breaking and hyphenation
    ///
    /// # Missing Features from CSS Inline-3:
    /// - \u00a7 3.3: initial-letter (drop caps)
    /// - \u00a7 4: vertical-align (only baseline supported)
    /// - \u00a7 6: text-box-trim (leading trim)
    /// - \u00a7 7: inline-sizing (aspect-ratio for inline-blocks)
    ///
    /// # Arguments
    /// * `content` - The raw `InlineContent` to be laid out.
    /// * `style_overrides` - Character-level style changes.
    /// * `flow_chain` - An ordered slice of `LayoutFragment` defining the regions (e.g., columns,
    ///   pages) that the content should flow through.
    /// * `font_chain_cache` - Pre-resolved font chains (from FontManager.font_chain_cache)
    /// * `fc_cache` - The fontconfig cache for font lookups
    /// * `loaded_fonts` - Pre-loaded fonts, keyed by FontId
    ///
    /// # Returns
    /// A `FlowLayout` struct containing the positioned items for each fragment that
    /// was filled, and any content that did not fit in the final fragment.
    pub fn layout_flow<T: ParsedFontTrait>(
        &mut self,
        content: &[InlineContent],
        style_overrides: &[StyleOverride],
        flow_chain: &[LayoutFragment],
        font_chain_cache: &HashMap<FontChainKey, rust_fontconfig::FontFallbackChain>,
        fc_cache: &FcFontCache,
        loaded_fonts: &LoadedFonts<T>,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<FlowLayout, LayoutError> {
        // --- Stages 1-3: Preparation ---
        // These stages are independent of the final geometry. We perform them once
        // on the entire content block before flowing. Caching is used at each stage.

        // Stage 1: Logical Analysis (InlineContent -> LogicalItem)
        let logical_items_id = calculate_id(&content);
        let logical_items = self
            .logical_items
            .entry(logical_items_id)
            .or_insert_with(|| {
                Arc::new(create_logical_items(
                    content,
                    style_overrides,
                    debug_messages,
                ))
            })
            .clone();

        // Get the first fragment's constraints to extract the CSS direction property.
        // This is used for BiDi reordering in Stage 2.
        let default_constraints = UnifiedConstraints::default();
        let first_constraints = flow_chain
            .first()
            .map(|f| &f.constraints)
            .unwrap_or(&default_constraints);

        // Stage 2: Bidi Reordering (LogicalItem -> VisualItem)
        // Use CSS direction property from constraints instead of auto-detecting from text content.
        // This fixes issues with mixed-direction text (e.g., "Arabic - Latin") where auto-detection
        // would treat the entire paragraph as RTL if the first strong character is Arabic.
        // Per HTML/CSS spec, base direction should come from the 'direction' CSS property,
        // defaulting to LTR if not specified.
        let base_direction = first_constraints.direction.unwrap_or(BidiDirection::Ltr);
        let visual_key = VisualItemsKey {
            logical_items_id,
            base_direction,
        };
        let visual_items_id = calculate_id(&visual_key);
        let visual_items = self
            .visual_items
            .entry(visual_items_id)
            .or_insert_with(|| {
                Arc::new(
                    reorder_logical_items(&logical_items, base_direction, debug_messages).unwrap(),
                )
            })
            .clone();

        // Stage 3: Shaping (VisualItem -> ShapedItem)
        let shaped_key = ShapedItemsKey::new(visual_items_id, &visual_items);
        let shaped_items_id = calculate_id(&shaped_key);
        let shaped_items = match self.shaped_items.get(&shaped_items_id) {
            Some(cached) => cached.clone(),
            None => {
                let items = Arc::new(shape_visual_items(
                    &visual_items,
                    font_chain_cache,
                    fc_cache,
                    loaded_fonts,
                    debug_messages,
                )?);
                self.shaped_items.insert(shaped_items_id, items.clone());
                items
            }
        };

        // --- Stage 4: Apply Vertical Text Transformations ---

        // Note: first_constraints was already extracted above for BiDi reordering (Stage 2).
        // This orients all text based on the constraints of the *first* fragment.
        // A more advanced system could defer orientation until inside the loop if
        // fragments can have different writing modes.
        let oriented_items = apply_text_orientation(shaped_items, first_constraints)?;

        // --- Stage 5: The Flow Loop ---

        let mut fragment_layouts = HashMap::new();
        // The cursor now manages the stream of items for the entire flow.
        let mut cursor = BreakCursor::new(&oriented_items);

        for fragment in flow_chain {
            // Perform layout for this single fragment, consuming items from the cursor.
            let fragment_layout = perform_fragment_layout(
                &mut cursor,
                &logical_items,
                &fragment.constraints,
                debug_messages,
                loaded_fonts,
            )?;

            fragment_layouts.insert(fragment.id.clone(), Arc::new(fragment_layout));
            if cursor.is_done() {
                break; // All content has been laid out.
            }
        }

        Ok(FlowLayout {
            fragment_layouts,
            remaining_items: cursor.drain_remaining(),
        })
    }
}

// --- Stage 1 Implementation ---
pub fn create_logical_items(
    content: &[InlineContent],
    style_overrides: &[StyleOverride],
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Vec<LogicalItem> {
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(
            "\n--- Entering create_logical_items (Refactored) ---".to_string(),
        ));
        msgs.push(LayoutDebugMessage::info(format!(
            "Input content length: {}",
            content.len()
        )));
        msgs.push(LayoutDebugMessage::info(format!(
            "Input overrides length: {}",
            style_overrides.len()
        )));
    }

    let mut items = Vec::new();
    let mut style_cache: HashMap<u64, Arc<StyleProperties>> = HashMap::new();

    // 1. Organize overrides for fast lookup per run.
    let mut run_overrides: HashMap<u32, HashMap<u32, &PartialStyleProperties>> = HashMap::new();
    for override_item in style_overrides {
        run_overrides
            .entry(override_item.target.run_index)
            .or_default()
            .insert(override_item.target.item_index, &override_item.style);
    }

    for (run_idx, inline_item) in content.iter().enumerate() {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "Processing content run #{}",
                run_idx
            )));
        }

        // Extract marker information if this is a marker
        let marker_position_outside = match inline_item {
            InlineContent::Marker {
                position_outside, ..
            } => Some(*position_outside),
            _ => None,
        };

        match inline_item {
            InlineContent::Text(run) | InlineContent::Marker { run, .. } => {
                let text = &run.text;
                if text.is_empty() {
                    if let Some(msgs) = debug_messages {
                        msgs.push(LayoutDebugMessage::info(
                            "  Run is empty, skipping.".to_string(),
                        ));
                    }
                    continue;
                }
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!("  Run text: '{}'", text)));
                }

                let current_run_overrides = run_overrides.get(&(run_idx as u32));
                let mut boundaries = BTreeSet::new();
                boundaries.insert(0);
                boundaries.insert(text.len());

                // --- Stateful Boundary Generation ---
                let mut scan_cursor = 0;
                while scan_cursor < text.len() {
                    let style_at_cursor = if let Some(partial) =
                        current_run_overrides.and_then(|o| o.get(&(scan_cursor as u32)))
                    {
                        // Create a temporary, full style to check its properties
                        run.style.apply_override(partial)
                    } else {
                        (*run.style).clone()
                    };

                    let current_char = text[scan_cursor..].chars().next().unwrap();

                    // Rule 1: Multi-character features take precedence.
                    if let Some(TextCombineUpright::Digits(max_digits)) =
                        style_at_cursor.text_combine_upright
                    {
                        if max_digits > 0 && current_char.is_ascii_digit() {
                            let digit_chunk: String = text[scan_cursor..]
                                .chars()
                                .take(max_digits as usize)
                                .take_while(|c| c.is_ascii_digit())
                                .collect();

                            let end_of_chunk = scan_cursor + digit_chunk.len();
                            boundaries.insert(scan_cursor);
                            boundaries.insert(end_of_chunk);
                            scan_cursor = end_of_chunk; // Jump past the entire sequence
                            continue;
                        }
                    }

                    // Rule 2: If no multi-char feature, check for a normal single-grapheme
                    // override.
                    if current_run_overrides
                        .and_then(|o| o.get(&(scan_cursor as u32)))
                        .is_some()
                    {
                        let grapheme_len = text[scan_cursor..]
                            .graphemes(true)
                            .next()
                            .unwrap_or("")
                            .len();
                        boundaries.insert(scan_cursor);
                        boundaries.insert(scan_cursor + grapheme_len);
                        scan_cursor += grapheme_len;
                        continue;
                    }

                    // Rule 3: No special features or overrides at this point, just advance one
                    // char.
                    scan_cursor += current_char.len_utf8();
                }

                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "  Boundaries: {:?}",
                        boundaries
                    )));
                }

                // --- Chunk Processing ---
                for (start, end) in boundaries.iter().zip(boundaries.iter().skip(1)) {
                    let (start, end) = (*start, *end);
                    if start >= end {
                        continue;
                    }

                    let text_slice = &text[start..end];
                    if let Some(msgs) = debug_messages {
                        msgs.push(LayoutDebugMessage::info(format!(
                            "  Processing chunk from {} to {}: '{}'",
                            start, end, text_slice
                        )));
                    }

                    let style_to_use = if let Some(partial_style) =
                        current_run_overrides.and_then(|o| o.get(&(start as u32)))
                    {
                        if let Some(msgs) = debug_messages {
                            msgs.push(LayoutDebugMessage::info(format!(
                                "  -> Applying override at byte {}",
                                start
                            )));
                        }
                        let mut hasher = DefaultHasher::new();
                        Arc::as_ptr(&run.style).hash(&mut hasher);
                        partial_style.hash(&mut hasher);
                        style_cache
                            .entry(hasher.finish())
                            .or_insert_with(|| Arc::new(run.style.apply_override(partial_style)))
                            .clone()
                    } else {
                        run.style.clone()
                    };

                    let is_combinable_chunk = if let Some(TextCombineUpright::Digits(max_digits)) =
                        &style_to_use.text_combine_upright
                    {
                        *max_digits > 0
                            && !text_slice.is_empty()
                            && text_slice.chars().all(|c| c.is_ascii_digit())
                            && text_slice.chars().count() <= *max_digits as usize
                    } else {
                        false
                    };

                    if is_combinable_chunk {
                        items.push(LogicalItem::CombinedText {
                            source: ContentIndex {
                                run_index: run_idx as u32,
                                item_index: start as u32,
                            },
                            text: text_slice.to_string(),
                            style: style_to_use,
                        });
                    } else {
                        items.push(LogicalItem::Text {
                            source: ContentIndex {
                                run_index: run_idx as u32,
                                item_index: start as u32,
                            },
                            text: text_slice.to_string(),
                            style: style_to_use,
                            marker_position_outside,
                            source_node_id: run.source_node_id,
                        });
                    }
                }
            }
            // Handle explicit line breaks (from white-space: pre or <br>)
            InlineContent::LineBreak(break_info) => {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "  LineBreak: {:?}",
                        break_info
                    )));
                }
                items.push(LogicalItem::Break {
                    source: ContentIndex {
                        run_index: run_idx as u32,
                        item_index: 0,
                    },
                    break_info: break_info.clone(),
                });
            }
            // Other cases (Image, Shape, Space, Tab, Ruby)
            _ => {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(
                        "  Run is not text, creating generic LogicalItem.".to_string(),
                    ));
                }
                items.push(LogicalItem::Object {
                    source: ContentIndex {
                        run_index: run_idx as u32,
                        item_index: 0,
                    },
                    content: inline_item.clone(),
                });
            }
        }
    }
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "--- Exiting create_logical_items, created {} items ---",
            items.len()
        )));
    }
    items
}

// --- Stage 2 Implementation ---

pub fn get_base_direction_from_logical(logical_items: &[LogicalItem]) -> BidiDirection {
    let first_strong = logical_items.iter().find_map(|item| {
        if let LogicalItem::Text { text, .. } = item {
            Some(unicode_bidi::get_base_direction(text.as_str()))
        } else {
            None
        }
    });

    match first_strong {
        Some(unicode_bidi::Direction::Rtl) => BidiDirection::Rtl,
        _ => BidiDirection::Ltr,
    }
}

pub fn reorder_logical_items(
    logical_items: &[LogicalItem],
    base_direction: BidiDirection,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<Vec<VisualItem>, LayoutError> {
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(
            "\n--- Entering reorder_logical_items ---".to_string(),
        ));
        msgs.push(LayoutDebugMessage::info(format!(
            "Input logical items count: {}",
            logical_items.len()
        )));
        msgs.push(LayoutDebugMessage::info(format!(
            "Base direction: {:?}",
            base_direction
        )));
    }

    let mut bidi_str = String::new();
    let mut item_map = Vec::new();
    for (idx, item) in logical_items.iter().enumerate() {
        let text = match item {
            LogicalItem::Text { text, .. } => text.as_str(),
            LogicalItem::CombinedText { text, .. } => text.as_str(),
            _ => "\u{FFFC}",
        };
        let start_byte = bidi_str.len();
        bidi_str.push_str(text);
        for _ in start_byte..bidi_str.len() {
            item_map.push(idx);
        }
    }

    if bidi_str.is_empty() {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(
                "Bidi string is empty, returning.".to_string(),
            ));
        }
        return Ok(Vec::new());
    }
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Constructed bidi string: '{}'",
            bidi_str
        )));
    }

    let bidi_level = if base_direction == BidiDirection::Rtl {
        Some(Level::rtl())
    } else {
        Some(Level::ltr())
    };
    let bidi_info = BidiInfo::new(&bidi_str, bidi_level);
    let para = &bidi_info.paragraphs[0];
    let (levels, visual_runs) = bidi_info.visual_runs(para, para.range.clone());

    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(
            "Bidi visual runs generated:".to_string(),
        ));
        for (i, run_range) in visual_runs.iter().enumerate() {
            let level = levels[run_range.start].number();
            let slice = &bidi_str[run_range.start..run_range.end];
            msgs.push(LayoutDebugMessage::info(format!(
                "  Run {}: range={:?}, level={}, text='{}'",
                i, run_range, level, slice
            )));
        }
    }

    let mut visual_items = Vec::new();
    for run_range in visual_runs {
        let bidi_level = BidiLevel::new(levels[run_range.start].number());
        let mut sub_run_start = run_range.start;

        for i in (run_range.start + 1)..run_range.end {
            if item_map[i] != item_map[sub_run_start] {
                let logical_idx = item_map[sub_run_start];
                let logical_item = &logical_items[logical_idx];
                let text_slice = &bidi_str[sub_run_start..i];
                visual_items.push(VisualItem {
                    logical_source: logical_item.clone(),
                    bidi_level,
                    script: crate::text3::script::detect_script(text_slice)
                        .unwrap_or(Script::Latin),
                    text: text_slice.to_string(),
                });
                sub_run_start = i;
            }
        }

        let logical_idx = item_map[sub_run_start];
        let logical_item = &logical_items[logical_idx];
        let text_slice = &bidi_str[sub_run_start..run_range.end];
        visual_items.push(VisualItem {
            logical_source: logical_item.clone(),
            bidi_level,
            script: crate::text3::script::detect_script(text_slice).unwrap_or(Script::Latin),
            text: text_slice.to_string(),
        });
    }

    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(
            "Final visual items produced:".to_string(),
        ));
        for (i, item) in visual_items.iter().enumerate() {
            msgs.push(LayoutDebugMessage::info(format!(
                "  Item {}: level={}, text='{}'",
                i,
                item.bidi_level.level(),
                item.text
            )));
        }
        msgs.push(LayoutDebugMessage::info(
            "--- Exiting reorder_logical_items ---".to_string(),
        ));
    }
    Ok(visual_items)
}

// --- Stage 3 Implementation ---

/// Shape visual items into ShapedItems using pre-loaded fonts.
///
/// This function does NOT load any fonts - all fonts must be pre-loaded and passed in.
/// If a required font is not in `loaded_fonts`, the text will be skipped with a warning.
pub fn shape_visual_items<T: ParsedFontTrait>(
    visual_items: &[VisualItem],
    font_chain_cache: &HashMap<FontChainKey, rust_fontconfig::FontFallbackChain>,
    fc_cache: &FcFontCache,
    loaded_fonts: &LoadedFonts<T>,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> Result<Vec<ShapedItem>, LayoutError> {
    let mut shaped = Vec::new();

    for item in visual_items {
        match &item.logical_source {
            LogicalItem::Text {
                style,
                source,
                marker_position_outside,
                source_node_id,
                ..
            } => {
                let direction = if item.bidi_level.is_rtl() {
                    BidiDirection::Rtl
                } else {
                    BidiDirection::Ltr
                };

                let language = script_to_language(item.script, &item.text);

                // Shape text using either FontRef directly or fontconfig-resolved font
                let shaped_clusters_result: Result<Vec<ShapedCluster>, LayoutError> = match &style.font_stack {
                    FontStack::Ref(font_ref) => {
                        // For FontRef, use the font directly without fontconfig
                        if let Some(msgs) = debug_messages {
                            msgs.push(LayoutDebugMessage::info(format!(
                                "[TextLayout] Using direct FontRef for text: '{}'",
                                item.text.chars().take(30).collect::<String>()
                            )));
                        }
                        shape_text_correctly(
                            &item.text,
                            item.script,
                            language,
                            direction,
                            font_ref,
                            style,
                            *source,
                            *source_node_id,
                        )
                    }
                    FontStack::Stack(selectors) => {
                        // Build FontChainKey and resolve through fontconfig
                        let cache_key = FontChainKey::from_selectors(selectors);

                        // Look up pre-resolved font chain
                        let font_chain = match font_chain_cache.get(&cache_key) {
                            Some(chain) => chain,
                            None => {
                                if let Some(msgs) = debug_messages {
                                    msgs.push(LayoutDebugMessage::warning(format!(
                                        "[TextLayout] Font chain not pre-resolved for {:?} - text will \
                                         not be rendered",
                                        cache_key.font_families
                                    )));
                                }
                                continue;
                            }
                        };

                        // Use the font chain to resolve which font to use for the first character
                        let first_char = item.text.chars().next().unwrap_or('A');
                        let font_id = match font_chain.resolve_char(fc_cache, first_char) {
                            Some((id, _css_source)) => id,
                            None => {
                                if let Some(msgs) = debug_messages {
                                    msgs.push(LayoutDebugMessage::warning(format!(
                                        "[TextLayout] No font in chain can render character '{}' \
                                         (U+{:04X})",
                                        first_char, first_char as u32
                                    )));
                                }
                                continue;
                            }
                        };

                        // Look up the pre-loaded font
                        match loaded_fonts.get(&font_id) {
                            Some(font) => {
                                shape_text_correctly(
                                    &item.text,
                                    item.script,
                                    language,
                                    direction,
                                    font,
                                    style,
                                    *source,
                                    *source_node_id,
                                )
                            }
                            None => {
                                if let Some(msgs) = debug_messages {
                                    let truncated_text = item.text.chars().take(50).collect::<String>();
                                    let display_text = if item.text.chars().count() > 50 {
                                        format!("{}...", truncated_text)
                                    } else {
                                        truncated_text
                                    };

                                    msgs.push(LayoutDebugMessage::warning(format!(
                                        "[TextLayout] Font {:?} not pre-loaded for text: '{}'",
                                        font_id, display_text
                                    )));
                                }
                                continue;
                            }
                        }
                    }
                };

                let mut shaped_clusters = shaped_clusters_result?;

                // Set marker flag on all clusters if this is a marker
                if let Some(is_outside) = marker_position_outside {
                    for cluster in &mut shaped_clusters {
                        cluster.marker_position_outside = Some(*is_outside);
                    }
                }

                shaped.extend(shaped_clusters.into_iter().map(ShapedItem::Cluster));
            }
            LogicalItem::Tab { source, style } => {
                // TODO: To get the space width accurately, we would need to shape
                // a space character with the current font.
                // For now, we approximate it as a fraction of the font size.
                let space_advance = style.font_size_px * 0.33;
                let tab_width = style.tab_size * space_advance;
                shaped.push(ShapedItem::Tab {
                    source: *source,
                    bounds: Rect {
                        x: 0.0,
                        y: 0.0,
                        width: tab_width,
                        height: 0.0,
                    },
                });
            }
            LogicalItem::Ruby {
                source,
                base_text,
                ruby_text,
                style,
            } => {
                // TODO: Implement Ruby layout. This is a major feature.
                // 1. Recursively call layout for the `base_text` to get its size.
                // 2. Recursively call layout for the `ruby_text` (with a smaller font from
                //    `style`).
                // 3. Position the ruby text bounds above/beside the base text bounds.
                // 4. Create a single `ShapedItem::Object` or `ShapedItem::CombinedBlock` that
                //    represents the combined metric bounds of the group, which will be used for
                //    line breaking and positioning on the main line.
                // For now, create a placeholder object.
                let placeholder_width = base_text.chars().count() as f32 * style.font_size_px * 0.6;
                shaped.push(ShapedItem::Object {
                    source: *source,
                    bounds: Rect {
                        x: 0.0,
                        y: 0.0,
                        width: placeholder_width,
                        height: style.line_height * 1.5,
                    },
                    baseline_offset: 0.0,
                    content: InlineContent::Text(StyledRun {
                        text: base_text.clone(),
                        style: style.clone(),
                        logical_start_byte: 0,
                        source_node_id: None, // Ruby text is generated, not from DOM
                    }),
                });
            }
            LogicalItem::CombinedText {
                style,
                source,
                text,
            } => {
                let language = script_to_language(item.script, &item.text);

                // Shape CombinedText using either FontRef directly or fontconfig-resolved font
                let glyphs: Vec<Glyph> = match &style.font_stack {
                    FontStack::Ref(font_ref) => {
                        // For FontRef, use the font directly without fontconfig
                        if let Some(msgs) = debug_messages {
                            msgs.push(LayoutDebugMessage::info(format!(
                                "[TextLayout] Using direct FontRef for CombinedText: '{}'",
                                text.chars().take(30).collect::<String>()
                            )));
                        }
                        font_ref.shape_text(
                            text,
                            item.script,
                            language,
                            BidiDirection::Ltr,
                            style.as_ref(),
                        )?
                    }
                    FontStack::Stack(selectors) => {
                        // Build FontChainKey and resolve through fontconfig
                        let cache_key = FontChainKey::from_selectors(selectors);

                        let font_chain = match font_chain_cache.get(&cache_key) {
                            Some(chain) => chain,
                            None => {
                                if let Some(msgs) = debug_messages {
                                    msgs.push(LayoutDebugMessage::warning(format!(
                                        "[TextLayout] Font chain not pre-resolved for CombinedText {:?}",
                                        cache_key.font_families
                                    )));
                                }
                                continue;
                            }
                        };

                        let first_char = text.chars().next().unwrap_or('A');
                        let font_id = match font_chain.resolve_char(fc_cache, first_char) {
                            Some((id, _)) => id,
                            None => {
                                if let Some(msgs) = debug_messages {
                                    msgs.push(LayoutDebugMessage::warning(format!(
                                        "[TextLayout] No font for CombinedText char '{}'",
                                        first_char
                                    )));
                                }
                                continue;
                            }
                        };

                        match loaded_fonts.get(&font_id) {
                            Some(font) => {
                                font.shape_text(
                                    text,
                                    item.script,
                                    language,
                                    BidiDirection::Ltr,
                                    style.as_ref(),
                                )?
                            }
                            None => {
                                if let Some(msgs) = debug_messages {
                                    msgs.push(LayoutDebugMessage::warning(format!(
                                        "[TextLayout] Font {:?} not pre-loaded for CombinedText",
                                        font_id
                                    )));
                                }
                                continue;
                            }
                        }
                    }
                };

                let shaped_glyphs = glyphs
                    .into_iter()
                    .map(|g| ShapedGlyph {
                        kind: GlyphKind::Character,
                        glyph_id: g.glyph_id,
                        script: g.script,
                        font_hash: g.font_hash,
                        font_metrics: g.font_metrics,
                        style: g.style,
                        cluster_offset: 0,
                        advance: g.advance,
                        kerning: g.kerning,
                        offset: g.offset,
                        vertical_advance: g.vertical_advance,
                        vertical_offset: g.vertical_bearing,
                    })
                    .collect::<Vec<_>>();

                let total_width: f32 = shaped_glyphs.iter().map(|g| g.advance + g.kerning).sum();
                let bounds = Rect {
                    x: 0.0,
                    y: 0.0,
                    width: total_width,
                    height: style.line_height,
                };

                shaped.push(ShapedItem::CombinedBlock {
                    source: *source,
                    glyphs: shaped_glyphs,
                    bounds,
                    baseline_offset: 0.0,
                });
            }
            LogicalItem::Object {
                content, source, ..
            } => {
                let (bounds, baseline) = measure_inline_object(content)?;
                shaped.push(ShapedItem::Object {
                    source: *source,
                    bounds,
                    baseline_offset: baseline,
                    content: content.clone(),
                });
            }
            LogicalItem::Break { source, break_info } => {
                shaped.push(ShapedItem::Break {
                    source: *source,
                    break_info: break_info.clone(),
                });
            }
        }
    }
    Ok(shaped)
}

/// Helper to check if a cluster contains only hanging punctuation.
fn is_hanging_punctuation(item: &ShapedItem) -> bool {
    if let ShapedItem::Cluster(c) = item {
        if c.glyphs.len() == 1 {
            match c.text.as_str() {
                "." | "," | ":" | ";" => true,
                _ => false,
            }
        } else {
            false
        }
    } else {
        false
    }
}

fn shape_text_correctly<T: ParsedFontTrait>(
    text: &str,
    script: Script,
    language: crate::text3::script::Language,
    direction: BidiDirection,
    font: &T, // Changed from &Arc<T>
    style: &Arc<StyleProperties>,
    source_index: ContentIndex,
    source_node_id: Option<NodeId>,
) -> Result<Vec<ShapedCluster>, LayoutError> {
    let glyphs = font.shape_text(text, script, language, direction, style.as_ref())?;

    if glyphs.is_empty() {
        return Ok(Vec::new());
    }

    let mut clusters = Vec::new();

    // Group glyphs by cluster ID from the shaper.
    let mut current_cluster_glyphs = Vec::new();
    let mut cluster_id = glyphs[0].cluster;
    let mut cluster_start_byte_in_text = glyphs[0].logical_byte_index;

    for glyph in glyphs {
        if glyph.cluster != cluster_id {
            // Finalize previous cluster
            let advance = current_cluster_glyphs
                .iter()
                .map(|g: &Glyph| g.advance)
                .sum();

            // Safely extract cluster text - handle cases where byte indices may be out of order
            // (can happen with RTL text or complex GSUB reordering)
            let (start, end) = if cluster_start_byte_in_text <= glyph.logical_byte_index {
                (cluster_start_byte_in_text, glyph.logical_byte_index)
            } else {
                (glyph.logical_byte_index, cluster_start_byte_in_text)
            };
            let cluster_text = text.get(start..end).unwrap_or("");

            clusters.push(ShapedCluster {
                text: cluster_text.to_string(), // Store original text for hyphenation
                source_cluster_id: GraphemeClusterId {
                    source_run: source_index.run_index,
                    start_byte_in_run: cluster_id,
                },
                source_content_index: source_index,
                source_node_id,
                glyphs: current_cluster_glyphs
                    .iter()
                    .map(|g| {
                        let source_char = text
                            .get(g.logical_byte_index..)
                            .and_then(|s| s.chars().next())
                            .unwrap_or('\u{FFFD}');
                        // Calculate cluster_offset safely
                        let cluster_offset = if g.logical_byte_index >= cluster_start_byte_in_text {
                            (g.logical_byte_index - cluster_start_byte_in_text) as u32
                        } else {
                            0
                        };
                        ShapedGlyph {
                            kind: if g.glyph_id == 0 {
                                GlyphKind::NotDef
                            } else {
                                GlyphKind::Character
                            },
                            glyph_id: g.glyph_id,
                            script: g.script,
                            font_hash: g.font_hash,
                            font_metrics: g.font_metrics.clone(),
                            style: g.style.clone(),
                            cluster_offset,
                            advance: g.advance,
                            kerning: g.kerning,
                            vertical_advance: g.vertical_advance,
                            vertical_offset: g.vertical_bearing,
                            offset: g.offset,
                        }
                    })
                    .collect(),
                advance,
                direction,
                style: style.clone(),
                marker_position_outside: None,
            });
            current_cluster_glyphs.clear();
            cluster_id = glyph.cluster;
            cluster_start_byte_in_text = glyph.logical_byte_index;
        }
        current_cluster_glyphs.push(glyph);
    }

    // Finalize the last cluster
    if !current_cluster_glyphs.is_empty() {
        let advance = current_cluster_glyphs
            .iter()
            .map(|g: &Glyph| g.advance)
            .sum();
        let cluster_text = text.get(cluster_start_byte_in_text..).unwrap_or("");
        clusters.push(ShapedCluster {
            text: cluster_text.to_string(), // Store original text
            source_cluster_id: GraphemeClusterId {
                source_run: source_index.run_index,
                start_byte_in_run: cluster_id,
            },
            source_content_index: source_index,
            source_node_id,
            glyphs: current_cluster_glyphs
                .iter()
                .map(|g| {
                    let source_char = text
                        .get(g.logical_byte_index..)
                        .and_then(|s| s.chars().next())
                        .unwrap_or('\u{FFFD}');
                    // Calculate cluster_offset safely
                    let cluster_offset = if g.logical_byte_index >= cluster_start_byte_in_text {
                        (g.logical_byte_index - cluster_start_byte_in_text) as u32
                    } else {
                        0
                    };
                    ShapedGlyph {
                        kind: if g.glyph_id == 0 {
                            GlyphKind::NotDef
                        } else {
                            GlyphKind::Character
                        },
                        glyph_id: g.glyph_id,
                        font_hash: g.font_hash,
                        font_metrics: g.font_metrics.clone(),
                        style: g.style.clone(),
                        script: g.script,
                        vertical_advance: g.vertical_advance,
                        vertical_offset: g.vertical_bearing,
                        cluster_offset,
                        advance: g.advance,
                        kerning: g.kerning,
                        offset: g.offset,
                    }
                })
                .collect(),
            advance,
            direction,
            style: style.clone(),
            marker_position_outside: None,
        });
    }

    Ok(clusters)
}

/// Measures a non-text object, returning its bounds and baseline offset.
fn measure_inline_object(item: &InlineContent) -> Result<(Rect, f32), LayoutError> {
    match item {
        InlineContent::Image(img) => {
            let size = img.display_size.unwrap_or(img.intrinsic_size);
            Ok((
                Rect {
                    x: 0.0,
                    y: 0.0,
                    width: size.width,
                    height: size.height,
                },
                img.baseline_offset,
            ))
        }
        InlineContent::Shape(shape) => Ok({
            let size = shape.shape_def.get_size();
            (
                Rect {
                    x: 0.0,
                    y: 0.0,
                    width: size.width,
                    height: size.height,
                },
                shape.baseline_offset,
            )
        }),
        InlineContent::Space(space) => Ok((
            Rect {
                x: 0.0,
                y: 0.0,
                width: space.width,
                height: 0.0,
            },
            0.0,
        )),
        InlineContent::Marker { .. } => {
            // Markers are treated as text content, not measurable objects
            Err(LayoutError::InvalidText(
                "Marker is text content, not a measurable object".into(),
            ))
        }
        _ => Err(LayoutError::InvalidText("Not a measurable object".into())),
    }
}

// --- Stage 4 Implementation: Vertical Text ---

/// Applies orientation and vertical metrics to glyphs if the writing mode is vertical.
fn apply_text_orientation(
    items: Arc<Vec<ShapedItem>>,
    constraints: &UnifiedConstraints,
) -> Result<Arc<Vec<ShapedItem>>, LayoutError> {
    if !constraints.is_vertical() {
        return Ok(items);
    }

    let mut oriented_items = Vec::with_capacity(items.len());
    let writing_mode = constraints.writing_mode.unwrap_or_default();

    for item in items.iter() {
        match item {
            ShapedItem::Cluster(cluster) => {
                let mut new_cluster = cluster.clone();
                let mut total_vertical_advance = 0.0;

                for glyph in &mut new_cluster.glyphs {
                    // Use the vertical metrics already computed during shaping
                    // If they're zero, use fallback values
                    if glyph.vertical_advance > 0.0 {
                        total_vertical_advance += glyph.vertical_advance;
                    } else {
                        // Fallback: use line height for vertical advance
                        let fallback_advance = cluster.style.line_height;
                        glyph.vertical_advance = fallback_advance;
                        // Center the glyph horizontally as a fallback
                        glyph.vertical_offset = Point {
                            x: -glyph.advance / 2.0,
                            y: 0.0,
                        };
                        total_vertical_advance += fallback_advance;
                    }
                }
                // The cluster's `advance` now represents vertical advance.
                new_cluster.advance = total_vertical_advance;
                oriented_items.push(ShapedItem::Cluster(new_cluster));
            }
            // Non-text objects also need their advance axis swapped.
            ShapedItem::Object {
                source,
                bounds,
                baseline_offset,
                content,
            } => {
                let mut new_bounds = *bounds;
                std::mem::swap(&mut new_bounds.width, &mut new_bounds.height);
                oriented_items.push(ShapedItem::Object {
                    source: *source,
                    bounds: new_bounds,
                    baseline_offset: *baseline_offset,
                    content: content.clone(),
                });
            }
            _ => oriented_items.push(item.clone()),
        }
    }

    Ok(Arc::new(oriented_items))
}

// --- Stage 5 & 6 Implementation: Combined Layout Pass ---
// This section replaces the previous simple line breaking and positioning logic.

/// Gets the ascent (distance from baseline to top) and descent (distance from baseline to bottom)
/// for a single item.
pub fn get_item_vertical_metrics(item: &ShapedItem) -> (f32, f32) {
    // (ascent, descent)
    match item {
        ShapedItem::Cluster(c) => {
            if c.glyphs.is_empty() {
                // For an empty text cluster, use the line height from its style as a fallback.
                return (c.style.line_height, 0.0);
            }
            // CORRECTED: Iterate through ALL glyphs in the cluster to find the true max
            // ascent/descent.
            c.glyphs
                .iter()
                .fold((0.0f32, 0.0f32), |(max_asc, max_desc), glyph| {
                    let metrics = &glyph.font_metrics;
                    if metrics.units_per_em == 0 {
                        return (max_asc, max_desc);
                    }
                    let scale = glyph.style.font_size_px / metrics.units_per_em as f32;
                    let item_asc = metrics.ascent * scale;
                    // Descent in OpenType is typically negative, so we negate it to get a positive
                    // distance.
                    let item_desc = (-metrics.descent * scale).max(0.0);
                    (max_asc.max(item_asc), max_desc.max(item_desc))
                })
        }
        ShapedItem::Object {
            bounds,
            baseline_offset,
            ..
        } => {
            // Per analysis, `baseline_offset` is the distance from the bottom.
            let ascent = bounds.height - *baseline_offset;
            let descent = *baseline_offset;
            (ascent.max(0.0), descent.max(0.0))
        }
        ShapedItem::CombinedBlock {
            bounds,
            baseline_offset,
            ..
        } => {
            // CORRECTED: Treat baseline_offset consistently as distance from the bottom (descent).
            let ascent = bounds.height - *baseline_offset;
            let descent = *baseline_offset;
            (ascent.max(0.0), descent.max(0.0))
        }
        _ => (0.0, 0.0), // Breaks and other non-visible items don't affect line height.
    }
}

/// Calculates the maximum ascent and descent for an entire line of items.
/// This determines the "line box" used for vertical alignment.
fn calculate_line_metrics(items: &[ShapedItem]) -> (f32, f32) {
    // (max_ascent, max_descent)
    items
        .iter()
        .fold((0.0f32, 0.0f32), |(max_asc, max_desc), item| {
            let (item_asc, item_desc) = get_item_vertical_metrics(item);
            (max_asc.max(item_asc), max_desc.max(item_desc))
        })
}

/// Performs layout for a single fragment, consuming items from a `BreakCursor`.
///
/// This function contains the core line-breaking and positioning logic, but is
/// designed to operate on a portion of a larger content stream and within the
/// constraints of a single geometric area (a fragment).
///
/// The loop terminates when either the fragment is filled (e.g., runs out of
/// vertical space) or the content stream managed by the `cursor` is exhausted.
///
/// # CSS Inline Layout Module Level 3 Implementation
///
/// This function implements the inline formatting context as described in:
/// https://www.w3.org/TR/css-inline-3/#inline-formatting-context
///
/// ## § 2.1 Layout of Line Boxes
/// "In general, the line-left edge of a line box touches the line-left edge of its
/// containing block and the line-right edge touches the line-right edge of its
/// containing block, and thus the logical width of a line box is equal to the inner
/// logical width of its containing block."
///
/// [ISSUE] available_width should be set to the containing block's inner width,
/// but is currently defaulting to 0.0 in UnifiedConstraints::default().
/// This causes premature line breaking.
///
/// ## § 2.2 Layout Within Line Boxes
/// The layout process follows these steps:
/// 1. Baseline Alignment: All inline-level boxes are aligned by their baselines
/// 2. Content Size Contribution: Calculate layout bounds for each box
/// 3. Line Box Sizing: Size line box to fit aligned layout bounds
/// 4. Content Positioning: Position boxes within the line box
///
/// ## Missing Features:
/// - § 3 Baselines and Alignment Metrics: Only basic baseline alignment implemented
/// - § 4 Baseline Alignment: vertical-align property not fully supported
/// - § 5 Line Spacing: line-height implemented, but line-fit-edge missing
/// - § 6 Trimming Leading: text-box-trim not implemented
pub fn perform_fragment_layout<T: ParsedFontTrait>(
    cursor: &mut BreakCursor,
    logical_items: &[LogicalItem],
    fragment_constraints: &UnifiedConstraints,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    fonts: &LoadedFonts<T>,
) -> Result<UnifiedLayout, LayoutError> {
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(
            "\n--- Entering perform_fragment_layout ---".to_string(),
        ));
        msgs.push(LayoutDebugMessage::info(format!(
            "Constraints: available_width={:?}, available_height={:?}, columns={}, text_wrap={:?}",
            fragment_constraints.available_width,
            fragment_constraints.available_height,
            fragment_constraints.columns,
            fragment_constraints.text_wrap
        )));
    }

    // For TextWrap::Balance, use Knuth-Plass algorithm for optimal line breaking
    // This produces more visually balanced lines at the cost of more computation
    if fragment_constraints.text_wrap == TextWrap::Balance {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(
                "Using Knuth-Plass algorithm for text-wrap: balance".to_string(),
            ));
        }

        // Get the shaped items from the cursor
        let shaped_items: Vec<ShapedItem> = cursor.drain_remaining();

        let hyphenator = if fragment_constraints.hyphenation {
            fragment_constraints
                .hyphenation_language
                .and_then(|lang| get_hyphenator(lang).ok())
        } else {
            None
        };

        // Use the Knuth-Plass algorithm for optimal line breaking
        return crate::text3::knuth_plass::kp_layout(
            &shaped_items,
            logical_items,
            fragment_constraints,
            hyphenator.as_ref(),
            fonts,
        );
    }

    let hyphenator = if fragment_constraints.hyphenation {
        fragment_constraints
            .hyphenation_language
            .and_then(|lang| get_hyphenator(lang).ok())
    } else {
        None
    };

    let mut positioned_items = Vec::new();
    let mut layout_bounds = Rect::default();

    let num_columns = fragment_constraints.columns.max(1);
    let total_column_gap = fragment_constraints.column_gap * (num_columns - 1) as f32;

    // CSS Inline Layout § 2.1: "the logical width of a line box is equal to the inner
    // logical width of its containing block"
    //
    // Handle the different available space modes:
    // - Definite(width): Use the specified width for column calculation
    // - MinContent: Use 0.0 to force line breaks at every opportunity
    // - MaxContent: Use a large value to allow content to expand naturally
    let column_width = match fragment_constraints.available_width {
        AvailableSpace::Definite(width) => (width - total_column_gap) / num_columns as f32,
        AvailableSpace::MinContent => {
            // Min-content: effectively 0 width forces immediate line breaks
            0.0
        }
        AvailableSpace::MaxContent => {
            // Max-content: very large width allows content to expand
            // Using f32::MAX / 2.0 to avoid overflow issues
            f32::MAX / 2.0
        }
    };
    let mut current_column = 0;
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Column width calculated: {}",
            column_width
        )));
    }

    // Use the CSS direction from constraints instead of auto-detecting from text
    // This ensures that mixed-direction text (e.g., "مرحبا - Hello") uses the
    // correct paragraph-level direction for alignment purposes
    let base_direction = fragment_constraints.direction.unwrap_or(BidiDirection::Ltr);

    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "[PFLayout] Base direction: {:?} (from CSS), Text align: {:?}",
            base_direction, fragment_constraints.text_align
        )));
    }

    'column_loop: while current_column < num_columns {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "\n-- Starting Column {} --",
                current_column
            )));
        }
        let column_start_x =
            (column_width + fragment_constraints.column_gap) * current_column as f32;
        let mut line_top_y = 0.0;
        let mut line_index = 0;
        let mut empty_segment_count = 0; // Failsafe counter for infinite loops
        const MAX_EMPTY_SEGMENTS: usize = 1000; // Maximum allowed consecutive empty segments

        while !cursor.is_done() {
            if let Some(max_height) = fragment_constraints.available_height {
                if line_top_y >= max_height {
                    if let Some(msgs) = debug_messages {
                        msgs.push(LayoutDebugMessage::info(format!(
                            "  Column full (pen {} >= height {}), breaking to next column.",
                            line_top_y, max_height
                        )));
                    }
                    break;
                }
            }

            if let Some(clamp) = fragment_constraints.line_clamp {
                if line_index >= clamp.get() {
                    break;
                }
            }

            // Create constraints specific to the current column for the line breaker.
            let mut column_constraints = fragment_constraints.clone();
            column_constraints.available_width = AvailableSpace::Definite(column_width);
            let line_constraints = get_line_constraints(
                line_top_y,
                fragment_constraints.line_height,
                &column_constraints,
                debug_messages,
            );

            if line_constraints.segments.is_empty() {
                empty_segment_count += 1;
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "  No available segments at y={}, skipping to next line. (empty count: \
                         {}/{})",
                        line_top_y, empty_segment_count, MAX_EMPTY_SEGMENTS
                    )));
                }

                // Failsafe: If we've skipped too many lines without content, break out
                if empty_segment_count >= MAX_EMPTY_SEGMENTS {
                    if let Some(msgs) = debug_messages {
                        msgs.push(LayoutDebugMessage::warning(format!(
                            "  [WARN] Reached maximum empty segment count ({}). Breaking to \
                             prevent infinite loop.",
                            MAX_EMPTY_SEGMENTS
                        )));
                        msgs.push(LayoutDebugMessage::warning(
                            "  This likely means the shape constraints are too restrictive or \
                             positioned incorrectly."
                                .to_string(),
                        ));
                        msgs.push(LayoutDebugMessage::warning(format!(
                            "  Current y={}, shape boundaries might be outside this range.",
                            line_top_y
                        )));
                    }
                    break;
                }

                // Additional check: If we have shapes and are far beyond the expected height,
                // also break to avoid infinite loops
                if !fragment_constraints.shape_boundaries.is_empty() && empty_segment_count > 50 {
                    // Calculate maximum shape height
                    let max_shape_y: f32 = fragment_constraints
                        .shape_boundaries
                        .iter()
                        .map(|shape| {
                            match shape {
                                ShapeBoundary::Circle { center, radius } => center.y + radius,
                                ShapeBoundary::Ellipse { center, radii } => center.y + radii.height,
                                ShapeBoundary::Polygon { points } => {
                                    points.iter().map(|p| p.y).fold(0.0, f32::max)
                                }
                                ShapeBoundary::Rectangle(rect) => rect.y + rect.height,
                                ShapeBoundary::Path { .. } => f32::MAX, // Can't determine for path
                            }
                        })
                        .fold(0.0, f32::max);

                    if line_top_y > max_shape_y + 100.0 {
                        if let Some(msgs) = debug_messages {
                            msgs.push(LayoutDebugMessage::info(format!(
                                "  [INFO] Current y={} is far beyond maximum shape extent y={}. \
                                 Breaking layout.",
                                line_top_y, max_shape_y
                            )));
                            msgs.push(LayoutDebugMessage::info(
                                "  Shape boundaries exist but no segments available - text cannot \
                                 fit in shape."
                                    .to_string(),
                            ));
                        }
                        break;
                    }
                }

                line_top_y += fragment_constraints.line_height;
                continue;
            }

            // Reset counter when we find valid segments
            empty_segment_count = 0;

            // CSS Text Module Level 3 § 5 Line Breaking and Word Boundaries
            // https://www.w3.org/TR/css-text-3/#line-breaking
            // "When an inline box exceeds the logical width of a line box, it is split
            // into several fragments, which are partitioned across multiple line boxes."
            let (mut line_items, was_hyphenated) =
                break_one_line(cursor, &line_constraints, false, hyphenator.as_ref(), fonts);
            if line_items.is_empty() {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(
                        "  Break returned no items. Ending column.".to_string(),
                    ));
                }
                break;
            }

            let line_text_before_rev: String = line_items
                .iter()
                .filter_map(|i| i.as_cluster())
                .map(|c| c.text.as_str())
                .collect();
            if let Some(msgs) = debug_messages {
                msgs.push(LayoutDebugMessage::info(format!(
                    // FIX: The log message was misleading. Items are in visual order.
                    "[PFLayout] Line items from breaker (visual order): [{}]",
                    line_text_before_rev
                )));
            }

            let (mut line_pos_items, line_height) = position_one_line(
                line_items,
                &line_constraints,
                line_top_y,
                line_index,
                fragment_constraints.text_align,
                base_direction,
                cursor.is_done() && !was_hyphenated,
                fragment_constraints,
                debug_messages,
                fonts,
            );

            for item in &mut line_pos_items {
                item.position.x += column_start_x;
            }

            line_top_y += line_height.max(fragment_constraints.line_height);
            line_index += 1;
            positioned_items.extend(line_pos_items);
        }
        current_column += 1;
    }

    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "--- Exiting perform_fragment_layout, positioned {} items ---",
            positioned_items.len()
        )));
    }

    let layout = UnifiedLayout {
        items: positioned_items,
        overflow: OverflowInfo::default(),
    };

    // Calculate bounds on demand via the bounds() method
    let calculated_bounds = layout.bounds();
    
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "--- Calculated bounds: width={}, height={} ---",
            calculated_bounds.width, calculated_bounds.height
        )));
    }

    Ok(layout)
}

/// Breaks a single line of items to fit within the given geometric constraints,
/// handling multi-segment lines and hyphenation.
/// Break a single line from the current cursor position.
///
/// # CSS Text Module Level 3 \u00a7 5 Line Breaking and Word Boundaries
/// https://www.w3.org/TR/css-text-3/#line-breaking
///
/// Implements the line breaking algorithm:
/// 1. "When an inline box exceeds the logical width of a line box, it is split into several
///    fragments, which are partitioned across multiple line boxes."
///
/// ## \u2705 Implemented Features:
/// - **Break Opportunities**: Identifies word boundaries and break points
/// - **Soft Wraps**: Wraps at spaces between words
/// - **Hard Breaks**: Handles explicit line breaks (\\n)
/// - **Overflow**: If a word is too long, places it anyway to avoid infinite loop
/// - **Hyphenation**: Tries to break long words at hyphenation points (\u00a7 5.4)
///
/// ## \u26a0\ufe0f Known Issues:
/// - If `line_constraints.total_available` is 0.0 (from `available_width: 0.0` bug), every word
///   will overflow, causing single-word lines
/// - This is the symptom visible in the PDF: "List items break extremely early"
///
/// ## \u00a7 5.2 Breaking Rules for Letters
/// \u2705 IMPLEMENTED: Uses Unicode line breaking algorithm
/// - Relies on UAX #14 for break opportunities
/// - Respects non-breaking spaces and zero-width joiners
///
/// ## \u00a7 5.3 Breaking Rules for Punctuation
/// \u26a0\ufe0f PARTIAL: Basic punctuation handling
/// - \u274c TODO: hanging-punctuation is declared in UnifiedConstraints but not used here
/// - \u274c TODO: Should implement punctuation trimming at line edges
///
/// ## \u00a7 5.4 Hyphenation
/// \u2705 IMPLEMENTED: Automatic hyphenation with hyphenator library
/// - Tries to hyphenate words that overflow
/// - Inserts hyphen glyph at break point
/// - Carries remainder to next line
///
/// ## \u00a7 5.5 Overflow Wrapping
/// \u2705 IMPLEMENTED: Emergency breaking
/// - If line is empty and word doesn't fit, forces at least one item
/// - Prevents infinite loop
/// - This is "overflow-wrap: break-word" behavior
///
/// # Missing Features:
/// - \u274c word-break property (normal, break-all, keep-all)
/// - \u274c line-break property (auto, loose, normal, strict, anywhere)
/// - \u274c overflow-wrap: anywhere vs break-word distinction
/// - \u274c white-space: break-spaces handling
pub fn break_one_line<T: ParsedFontTrait>(
    cursor: &mut BreakCursor,
    line_constraints: &LineConstraints,
    is_vertical: bool,
    hyphenator: Option<&Standard>,
    fonts: &LoadedFonts<T>,
) -> (Vec<ShapedItem>, bool) {
    let mut line_items = Vec::new();
    let mut current_width = 0.0;

    if cursor.is_done() {
        return (Vec::new(), false);
    }

    // CSS Text Module Level 3 § 4.1.1: At the beginning of a line, white space
    // is collapsed away. Skip leading whitespace at line start.
    // https://www.w3.org/TR/css-text-3/#white-space-phase-2
    while !cursor.is_done() {
        let next_unit = cursor.peek_next_unit();
        if next_unit.is_empty() {
            break;
        }
        // Check if the first item is whitespace-only
        if next_unit.len() == 1 && is_word_separator(&next_unit[0]) {
            // Skip this whitespace at line start
            cursor.consume(1);
        } else {
            break;
        }
    }

    loop {
        // 1. Identify the next unbreakable unit (word) or break opportunity.
        let next_unit = cursor.peek_next_unit();
        if next_unit.is_empty() {
            break; // End of content
        }

        // Handle hard breaks immediately.
        if let Some(ShapedItem::Break { .. }) = next_unit.first() {
            line_items.push(next_unit[0].clone());
            cursor.consume(1);
            return (line_items, false);
        }

        let unit_width: f32 = next_unit
            .iter()
            .map(|item| get_item_measure(item, is_vertical))
            .sum();
        let available_width = line_constraints.total_available - current_width;

        // 2. Can the whole unit fit on the current line?
        if unit_width <= available_width {
            line_items.extend_from_slice(&next_unit);
            current_width += unit_width;
            cursor.consume(next_unit.len());
        } else {
            // 3. The unit overflows. Can we hyphenate it?
            if let Some(hyphenator) = hyphenator {
                // We only try to hyphenate if the unit is a word (not a space).
                if !is_break_opportunity(next_unit.last().unwrap()) {
                    if let Some(hyphenation_result) = try_hyphenate_word_cluster(
                        &next_unit,
                        available_width,
                        is_vertical,
                        hyphenator,
                        fonts,
                    ) {
                        line_items.extend(hyphenation_result.line_part);
                        // Consume the original full word from the cursor.
                        cursor.consume(next_unit.len());
                        // Put the remainder back for the next line.
                        cursor.partial_remainder = hyphenation_result.remainder_part;
                        return (line_items, true);
                    }
                }
            }

            // 4. Cannot hyphenate or fit. The line is finished.
            // If the line is empty, we must force at least one item to avoid an infinite loop.
            if line_items.is_empty() {
                line_items.push(next_unit[0].clone());
                cursor.consume(1);
            }
            break;
        }
    }

    (line_items, false)
}

/// Represents a single valid hyphenation point within a word.
#[derive(Clone)]
pub struct HyphenationBreak {
    /// The number of characters from the original word string included on the line.
    pub char_len_on_line: usize,
    /// The total advance width of the line part + the hyphen.
    pub width_on_line: f32,
    /// The cluster(s) that will remain on the current line.
    pub line_part: Vec<ShapedItem>,
    /// The cluster that represents the hyphen character itself.
    pub hyphen_item: ShapedItem,
    /// The cluster(s) that will be carried over to the next line.
    /// CRITICAL FIX: Changed from ShapedItem to Vec<ShapedItem>
    pub remainder_part: Vec<ShapedItem>,
}

/// A "word" is defined as a sequence of one or more adjacent ShapedClusters.
pub fn find_all_hyphenation_breaks<T: ParsedFontTrait>(
    word_clusters: &[ShapedCluster],
    hyphenator: &Standard,
    is_vertical: bool, // Pass this in to use correct metrics
    fonts: &LoadedFonts<T>,
) -> Option<Vec<HyphenationBreak>> {
    if word_clusters.is_empty() {
        return None;
    }

    // --- 1. Concatenate the TRUE text and build a robust map ---
    let mut word_string = String::new();
    let mut char_map = Vec::new();
    let mut current_width = 0.0;

    for (cluster_idx, cluster) in word_clusters.iter().enumerate() {
        for (char_byte_offset, _ch) in cluster.text.char_indices() {
            let glyph_idx = cluster
                .glyphs
                .iter()
                .rposition(|g| g.cluster_offset as usize <= char_byte_offset)
                .unwrap_or(0);
            let glyph = &cluster.glyphs[glyph_idx];

            let num_chars_in_glyph = cluster.text[glyph.cluster_offset as usize..]
                .chars()
                .count();
            let advance_per_char = if is_vertical {
                glyph.vertical_advance
            } else {
                glyph.advance
            } / (num_chars_in_glyph as f32).max(1.0);

            current_width += advance_per_char;
            char_map.push((cluster_idx, glyph_idx, current_width));
        }
        word_string.push_str(&cluster.text);
    }

    // --- 2. Get hyphenation opportunities ---
    let opportunities = hyphenator.hyphenate(&word_string);
    if opportunities.breaks.is_empty() {
        return None;
    }

    let last_cluster = word_clusters.last().unwrap();
    let last_glyph = last_cluster.glyphs.last().unwrap();
    let style = last_cluster.style.clone();

    // Look up font from hash
    let font = fonts.get_by_hash(last_glyph.font_hash)?;
    let (hyphen_glyph_id, hyphen_advance) =
        font.get_hyphen_glyph_and_advance(style.font_size_px)?;

    let mut possible_breaks = Vec::new();

    // --- 3. Generate a HyphenationBreak for each valid opportunity ---
    for &break_char_idx in &opportunities.breaks {
        // The break is *before* the character at this index.
        // So the last character on the line is at `break_char_idx - 1`.
        if break_char_idx == 0 || break_char_idx > char_map.len() {
            continue;
        }

        let (_, _, width_at_break) = char_map[break_char_idx - 1];

        // The line part is all clusters *before* the break index.
        let line_part: Vec<ShapedItem> = word_clusters[..break_char_idx]
            .iter()
            .map(|c| ShapedItem::Cluster(c.clone()))
            .collect();

        // The remainder is all clusters *from* the break index onward.
        let remainder_part: Vec<ShapedItem> = word_clusters[break_char_idx..]
            .iter()
            .map(|c| ShapedItem::Cluster(c.clone()))
            .collect();

        let hyphen_item = ShapedItem::Cluster(ShapedCluster {
            text: "-".to_string(),
            source_cluster_id: GraphemeClusterId {
                source_run: u32::MAX,
                start_byte_in_run: u32::MAX,
            },
            source_content_index: ContentIndex {
                run_index: u32::MAX,
                item_index: u32::MAX,
            },
            source_node_id: None, // Hyphen is generated, not from DOM
            glyphs: vec![ShapedGlyph {
                kind: GlyphKind::Hyphen,
                glyph_id: hyphen_glyph_id,
                font_hash: last_glyph.font_hash,
                font_metrics: last_glyph.font_metrics.clone(),
                cluster_offset: 0,
                script: Script::Latin,
                advance: hyphen_advance,
                kerning: 0.0,
                offset: Point::default(),
                style: style.clone(),
                vertical_advance: hyphen_advance,
                vertical_offset: Point::default(),
            }],
            advance: hyphen_advance,
            direction: BidiDirection::Ltr,
            style: style.clone(),
            marker_position_outside: None,
        });

        possible_breaks.push(HyphenationBreak {
            char_len_on_line: break_char_idx,
            width_on_line: width_at_break + hyphen_advance,
            line_part,
            hyphen_item,
            remainder_part,
        });
    }

    Some(possible_breaks)
}

/// Tries to find a hyphenation point within a word, returning the line part and remainder.
fn try_hyphenate_word_cluster<T: ParsedFontTrait>(
    word_items: &[ShapedItem],
    remaining_width: f32,
    is_vertical: bool,
    hyphenator: &Standard,
    fonts: &LoadedFonts<T>,
) -> Option<HyphenationResult> {
    let word_clusters: Vec<ShapedCluster> = word_items
        .iter()
        .filter_map(|item| item.as_cluster().cloned())
        .collect();

    if word_clusters.is_empty() {
        return None;
    }

    let all_breaks = find_all_hyphenation_breaks(&word_clusters, hyphenator, is_vertical, fonts)?;

    if let Some(best_break) = all_breaks
        .into_iter()
        .rfind(|b| b.width_on_line <= remaining_width)
    {
        let mut line_part = best_break.line_part;
        line_part.push(best_break.hyphen_item);

        return Some(HyphenationResult {
            line_part,
            remainder_part: best_break.remainder_part,
        });
    }

    None
}

/// Positions a single line of items, handling alignment and justification within segments.
///
/// This function is architecturally critical for cache safety. It does not mutate the
/// `advance` or `bounds` of the input `ShapedItem`s. Instead, it applies justification
/// spacing by adjusting the drawing pen's position (`main_axis_pen`).
///
/// # Returns
/// A tuple containing the `Vec` of positioned items and the calculated height of the line box.
/// Position items on a single line after breaking.
///
/// # CSS Inline Layout Module Level 3 \u00a7 2.2 Layout Within Line Boxes
/// https://www.w3.org/TR/css-inline-3/#layout-within-line-boxes
///
/// Implements the positioning algorithm:
/// 1. "All inline-level boxes are aligned by their baselines"
/// 2. "Calculate layout bounds for each inline box"
/// 3. "Size the line box to fit the aligned layout bounds"
/// 4. "Position all inline boxes within the line box"
///
/// ## \u2705 Implemented Features:
///
/// ### \u00a7 4 Baseline Alignment (vertical-align)
/// \u26a0\ufe0f PARTIAL IMPLEMENTATION:
/// - \u2705 `baseline`: Aligns box baseline with parent baseline (default)
/// - \u2705 `top`: Aligns top of box with top of line box
/// - \u2705 `middle`: Centers box within line box
/// - \u2705 `bottom`: Aligns bottom of box with bottom of line box
/// - \u274c MISSING: `text-top`, `text-bottom`, `sub`, `super`
/// - \u274c MISSING: `<length>`, `<percentage>` values for custom offset
///
/// ### \u00a7 2.2.1 Text Alignment (text-align)
/// \u2705 IMPLEMENTED:
/// - `left`, `right`, `center`: Physical alignment
/// - `start`, `end`: Logical alignment (respects direction: ltr/rtl)
/// - `justify`: Distributes space between words/characters
/// - `justify-all`: Justifies last line too
///
/// ### \u00a7 7.3 Text Justification (text-justify)
/// \u2705 IMPLEMENTED:
/// - `inter-word`: Adds space between words
/// - `inter-character`: Adds space between characters
/// - `kashida`: Arabic kashida elongation
/// - \u274c MISSING: `distribute` (CJK justification)
///
/// ### CSS Text \u00a7 8.1 Text Indentation (text-indent)
/// \u2705 IMPLEMENTED: First line indentation
///
/// ### CSS Text \u00a7 4.1 Word Spacing (word-spacing)
/// \u2705 IMPLEMENTED: Additional space between words
///
/// ### CSS Text \u00a7 4.2 Letter Spacing (letter-spacing)
/// \u2705 IMPLEMENTED: Additional space between characters
///
/// ## Segment-Aware Layout:
/// \u2705 Handles CSS Shapes and multi-column layouts
/// - Breaks line into segments (for shape boundaries)
/// - Calculates justification per segment
/// - Applies alignment within each segment's bounds
///
/// ## Known Issues:
/// - \u26a0\ufe0f If segment.width is infinite (from intrinsic sizing), sets alignment_offset=0 to
///   avoid infinite positioning. This is correct for measurement but documented for clarity.
/// - The function assumes `line_index == 0` means first line for text-indent. A more robust system
///   would track paragraph boundaries.
///
/// # Missing Features:
/// - \u274c \u00a7 6 Trimming Leading (text-box-trim, text-box-edge)
/// - \u274c \u00a7 3.3 Initial Letters (drop caps)
/// - \u274c Full vertical-align support (sub, super, lengths, percentages)
/// - \u274c white-space: break-spaces alignment behavior
pub fn position_one_line<T: ParsedFontTrait>(
    line_items: Vec<ShapedItem>,
    line_constraints: &LineConstraints,
    line_top_y: f32,
    line_index: usize,
    text_align: TextAlign,
    base_direction: BidiDirection,
    is_last_line: bool,
    constraints: &UnifiedConstraints,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    fonts: &LoadedFonts<T>,
) -> (Vec<PositionedItem>, f32) {
    let line_text: String = line_items
        .iter()
        .filter_map(|i| i.as_cluster())
        .map(|c| c.text.as_str())
        .collect();
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "\n--- Entering position_one_line for line: [{}] ---",
            line_text
        )));
    }
    // NEW: Resolve the final physical alignment here, inside the function.
    let physical_align = match (text_align, base_direction) {
        (TextAlign::Start, BidiDirection::Ltr) => TextAlign::Left,
        (TextAlign::Start, BidiDirection::Rtl) => TextAlign::Right,
        (TextAlign::End, BidiDirection::Ltr) => TextAlign::Right,
        (TextAlign::End, BidiDirection::Rtl) => TextAlign::Left,
        // Physical alignments are returned as-is, regardless of direction.
        (other, _) => other,
    };
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "[Pos1Line] Physical align: {:?}",
            physical_align
        )));
    }

    if line_items.is_empty() {
        return (Vec::new(), 0.0);
    }
    let mut positioned = Vec::new();
    let is_vertical = constraints.is_vertical();

    // The line box is calculated once for all items on the line, regardless of segment.
    let (line_ascent, line_descent) = calculate_line_metrics(&line_items);
    let line_box_height = line_ascent + line_descent;

    // The baseline for the entire line is determined by its tallest item.
    let line_baseline_y = line_top_y + line_ascent;

    // --- Segment-Aware Positioning ---
    let mut item_cursor = 0;
    let is_first_line_of_para = line_index == 0; // Simplified assumption

    for (segment_idx, segment) in line_constraints.segments.iter().enumerate() {
        if item_cursor >= line_items.len() {
            break;
        }

        // 1. Collect all items that fit into the current segment.
        let mut segment_items = Vec::new();
        let mut current_segment_width = 0.0;
        while item_cursor < line_items.len() {
            let item = &line_items[item_cursor];
            let item_measure = get_item_measure(item, is_vertical);
            // Put at least one item in the segment to avoid getting stuck.
            if current_segment_width + item_measure > segment.width && !segment_items.is_empty() {
                break;
            }
            segment_items.push(item.clone());
            current_segment_width += item_measure;
            item_cursor += 1;
        }

        if segment_items.is_empty() {
            continue;
        }

        // 2. Calculate justification spacing *for this segment only*.
        let (extra_word_spacing, extra_char_spacing) = if constraints.text_justify
            != JustifyContent::None
            && (!is_last_line || constraints.text_align == TextAlign::JustifyAll)
            && constraints.text_justify != JustifyContent::Kashida
        {
            let segment_line_constraints = LineConstraints {
                segments: vec![segment.clone()],
                total_available: segment.width,
            };
            calculate_justification_spacing(
                &segment_items,
                &segment_line_constraints,
                constraints.text_justify,
                is_vertical,
            )
        } else {
            (0.0, 0.0)
        };

        // Kashida justification needs to be segment-aware if used.
        let justified_segment_items = if constraints.text_justify == JustifyContent::Kashida
            && (!is_last_line || constraints.text_align == TextAlign::JustifyAll)
        {
            let segment_line_constraints = LineConstraints {
                segments: vec![segment.clone()],
                total_available: segment.width,
            };
            justify_kashida_and_rebuild(
                segment_items,
                &segment_line_constraints,
                is_vertical,
                debug_messages,
                fonts,
            )
        } else {
            segment_items
        };

        // Recalculate width in case kashida changed the item list
        let final_segment_width: f32 = justified_segment_items
            .iter()
            .map(|item| get_item_measure(item, is_vertical))
            .sum();

        // 3. Calculate alignment offset *within this segment*.
        let remaining_space = segment.width - final_segment_width;

        // Handle MaxContent/indefinite width: when available_width is MaxContent (for intrinsic
        // sizing), segment.width will be f32::MAX / 2.0. Alignment calculations would
        // produce huge offsets. In this case, treat as left-aligned (offset = 0) since
        // we're measuring natural content width. We check for both infinite AND very large
        // values (> 1e30) to catch the MaxContent case.
        let is_indefinite_width = segment.width.is_infinite() || segment.width > 1e30;
        let alignment_offset = if is_indefinite_width {
            0.0 // No alignment offset for indefinite width
        } else {
            match physical_align {
                TextAlign::Center => remaining_space / 2.0,
                TextAlign::Right => remaining_space,
                _ => 0.0, // Left, Justify
            }
        };

        let mut main_axis_pen = segment.start_x + alignment_offset;
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "[Pos1Line] Segment width: {}, Item width: {}, Remaining space: {}, Initial pen: \
                 {}",
                segment.width, final_segment_width, remaining_space, main_axis_pen
            )));
        }

        // Apply text-indent only to the very first segment of the first line.
        if is_first_line_of_para && segment_idx == 0 {
            main_axis_pen += constraints.text_indent;
        }

        // Calculate total marker width for proper outside marker positioning
        // We need to position all marker clusters together in the padding gutter
        let total_marker_width: f32 = justified_segment_items
            .iter()
            .filter_map(|item| {
                if let ShapedItem::Cluster(c) = item {
                    if c.marker_position_outside == Some(true) {
                        return Some(get_item_measure(item, is_vertical));
                    }
                }
                None
            })
            .sum();

        // Track marker pen separately - starts at negative position for outside markers
        let marker_spacing = 4.0; // Small gap between marker and content
        let mut marker_pen = if total_marker_width > 0.0 {
            -(total_marker_width + marker_spacing)
        } else {
            0.0
        };

        // 4. Position the items belonging to this segment.
        //
        // Vertical alignment positioning (CSS vertical-align)
        //
        // Currently, we use `constraints.vertical_align` for ALL items on the line.
        // This is the GLOBAL vertical alignment set on the containing block.
        //
        // KNOWN LIMITATION / TODO:
        //
        // Per-item vertical-align (stored in `InlineImage.alignment`) is NOT used here.
        // According to CSS, each inline element can have its own vertical-align value:
        //   <img style="vertical-align: top"> would align to line top
        //   <img style="vertical-align: middle"> would center in line box
        //   <img style="vertical-align: bottom"> would align to line bottom
        //
        // To fix this, we would need dir_to:
        // 1. Add a helper function `get_item_vertical_align(&item)` that extracts the alignment
        //    from ShapedItem::Object -> InlineContent::Image -> alignment
        // 2. Use that alignment instead of `constraints.vertical_align` for Objects
        //
        // For now, all items use the global alignment which works correctly for
        // text-only content or when all images have the same alignment.
        //
        // Reference: CSS Inline Layout Level 3 § 4 Baseline Alignment
        // https://www.w3.org/TR/css-inline-3/#baseline-alignment
        for item in justified_segment_items {
            let (item_ascent, item_descent) = get_item_vertical_metrics(&item);
            let item_baseline_pos = match constraints.vertical_align {
                VerticalAlign::Top => line_top_y + item_ascent,
                VerticalAlign::Middle => {
                    line_top_y + (line_box_height / 2.0) - ((item_ascent + item_descent) / 2.0)
                        + item_ascent
                }
                VerticalAlign::Bottom => line_top_y + line_box_height - item_descent,
                _ => line_baseline_y, // Baseline
            };

            // Calculate item measure (needed for both positioning and pen advance)
            let item_measure = get_item_measure(&item, is_vertical);

            let position = if is_vertical {
                Point {
                    x: item_baseline_pos - item_ascent,
                    y: main_axis_pen,
                }
            } else {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[Pos1Line] is_vertical=false, main_axis_pen={}, item_baseline_pos={}, \
                         item_ascent={}",
                        main_axis_pen, item_baseline_pos, item_ascent
                    )));
                }

                // Check if this is an outside marker - if so, position it in the padding gutter
                let x_position = if let ShapedItem::Cluster(cluster) = &item {
                    if cluster.marker_position_outside == Some(true) {
                        // Use marker_pen for sequential marker positioning
                        let marker_width = item_measure;
                        if let Some(msgs) = debug_messages {
                            msgs.push(LayoutDebugMessage::info(format!(
                                "[Pos1Line] Outside marker detected! width={}, positioning at \
                                 marker_pen={}",
                                marker_width, marker_pen
                            )));
                        }
                        let pos = marker_pen;
                        marker_pen += marker_width; // Advance marker pen for next marker cluster
                        pos
                    } else {
                        main_axis_pen
                    }
                } else {
                    main_axis_pen
                };

                Point {
                    y: item_baseline_pos - item_ascent,
                    x: x_position,
                }
            };

            // item_measure is calculated above for marker positioning
            let item_text = item
                .as_cluster()
                .map(|c| c.text.as_str())
                .unwrap_or("[OBJ]");
            if let Some(msgs) = debug_messages {
                msgs.push(LayoutDebugMessage::info(format!(
                    "[Pos1Line] Positioning item '{}' at pen_x={}",
                    item_text, main_axis_pen
                )));
            }
            positioned.push(PositionedItem {
                item: item.clone(),
                position,
                line_index,
            });

            // Outside markers don't advance the pen - they're positioned in the padding gutter
            let is_outside_marker = if let ShapedItem::Cluster(c) = &item {
                c.marker_position_outside == Some(true)
            } else {
                false
            };

            if !is_outside_marker {
                main_axis_pen += item_measure;
            }

            // Apply calculated spacing to the pen (skip for outside markers)
            if !is_outside_marker && extra_char_spacing > 0.0 && can_justify_after(&item) {
                main_axis_pen += extra_char_spacing;
            }
            if let ShapedItem::Cluster(c) = &item {
                if !is_outside_marker {
                    let letter_spacing_px = match c.style.letter_spacing {
                        Spacing::Px(px) => px as f32,
                        Spacing::Em(em) => em * c.style.font_size_px,
                    };
                    main_axis_pen += letter_spacing_px;
                    if is_word_separator(&item) {
                        let word_spacing_px = match c.style.word_spacing {
                            Spacing::Px(px) => px as f32,
                            Spacing::Em(em) => em * c.style.font_size_px,
                        };
                        main_axis_pen += word_spacing_px;
                        main_axis_pen += extra_word_spacing;
                    }
                }
            }
        }
    }

    (positioned, line_box_height)
}

/// Calculates the starting pen offset to achieve the desired text alignment.
fn calculate_alignment_offset(
    items: &[ShapedItem],
    line_constraints: &LineConstraints,
    align: TextAlign,
    is_vertical: bool,
    constraints: &UnifiedConstraints,
) -> f32 {
    // Simplified to use the first segment for alignment.
    if let Some(segment) = line_constraints.segments.first() {
        let total_width: f32 = items
            .iter()
            .map(|item| get_item_measure(item, is_vertical))
            .sum();

        let available_width = if constraints.segment_alignment == SegmentAlignment::Total {
            line_constraints.total_available
        } else {
            segment.width
        };

        if total_width >= available_width {
            return 0.0; // No alignment needed if line is full or overflows
        }

        let remaining_space = available_width - total_width;

        match align {
            TextAlign::Center => remaining_space / 2.0,
            TextAlign::Right => remaining_space,
            _ => 0.0, // Left, Justify, Start, End
        }
    } else {
        0.0
    }
}

/// Calculates the extra spacing needed for justification without modifying the items.
///
/// This function is pure and does not mutate any state, making it safe to use
/// with cached `ShapedItem` data.
///
/// # Arguments
/// * `items` - A slice of items on the line.
/// * `line_constraints` - The geometric constraints for the line.
/// * `text_justify` - The type of justification to calculate.
/// * `is_vertical` - Whether the layout is vertical.
///
/// # Returns
/// A tuple `(extra_per_word, extra_per_char)` containing the extra space in pixels
/// to add at each word or character justification opportunity.
fn calculate_justification_spacing(
    items: &[ShapedItem],
    line_constraints: &LineConstraints,
    text_justify: JustifyContent,
    is_vertical: bool,
) -> (f32, f32) {
    // (extra_per_word, extra_per_char)
    let total_width: f32 = items
        .iter()
        .map(|item| get_item_measure(item, is_vertical))
        .sum();
    let available_width = line_constraints.total_available;

    if total_width >= available_width || available_width <= 0.0 {
        return (0.0, 0.0);
    }

    let extra_space = available_width - total_width;

    match text_justify {
        JustifyContent::InterWord => {
            // Count justification opportunities (spaces).
            let space_count = items.iter().filter(|item| is_word_separator(item)).count();
            if space_count > 0 {
                (extra_space / space_count as f32, 0.0)
            } else {
                (0.0, 0.0) // No spaces to expand, do nothing.
            }
        }
        JustifyContent::InterCharacter | JustifyContent::Distribute => {
            // Count justification opportunities (between non-combining characters).
            let gap_count = items
                .iter()
                .enumerate()
                .filter(|(i, item)| *i < items.len() - 1 && can_justify_after(item))
                .count();
            if gap_count > 0 {
                (0.0, extra_space / gap_count as f32)
            } else {
                (0.0, 0.0) // No gaps to expand, do nothing.
            }
        }
        // Kashida justification modifies the item list and is handled by a separate function.
        _ => (0.0, 0.0),
    }
}

/// Rebuilds a line of items, inserting Kashida glyphs for justification.
///
/// This function is non-mutating with respect to its inputs. It takes ownership of the
/// original items and returns a completely new `Vec`. This is necessary because Kashida
/// justification changes the number of items on the line, and must not modify cached data.
pub fn justify_kashida_and_rebuild<T: ParsedFontTrait>(
    items: Vec<ShapedItem>,
    line_constraints: &LineConstraints,
    is_vertical: bool,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    fonts: &LoadedFonts<T>,
) -> Vec<ShapedItem> {
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(
            "\n--- Entering justify_kashida_and_rebuild ---".to_string(),
        ));
    }
    let total_width: f32 = items
        .iter()
        .map(|item| get_item_measure(item, is_vertical))
        .sum();
    let available_width = line_constraints.total_available;
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Total item width: {}, Available width: {}",
            total_width, available_width
        )));
    }

    if total_width >= available_width || available_width <= 0.0 {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(
                "No justification needed (line is full or invalid).".to_string(),
            ));
        }
        return items;
    }

    let extra_space = available_width - total_width;
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Extra space to fill: {}",
            extra_space
        )));
    }

    let font_info = items.iter().find_map(|item| {
        if let ShapedItem::Cluster(c) = item {
            if let Some(glyph) = c.glyphs.first() {
                if glyph.script == Script::Arabic {
                    // Look up font from hash
                    if let Some(font) = fonts.get_by_hash(glyph.font_hash) {
                        return Some((
                            font.clone(),
                            glyph.font_hash,
                            glyph.font_metrics.clone(),
                            glyph.style.clone(),
                        ));
                    }
                }
            }
        }
        None
    });

    let (font, font_hash, font_metrics, style) = match font_info {
        Some(info) => {
            if let Some(msgs) = debug_messages {
                msgs.push(LayoutDebugMessage::info(
                    "Found Arabic font for kashida.".to_string(),
                ));
            }
            info
        }
        None => {
            if let Some(msgs) = debug_messages {
                msgs.push(LayoutDebugMessage::info(
                    "No Arabic font found on line. Cannot insert kashidas.".to_string(),
                ));
            }
            return items;
        }
    };

    let (kashida_glyph_id, kashida_advance) =
        match font.get_kashida_glyph_and_advance(style.font_size_px) {
            Some((id, adv)) if adv > 0.0 => {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "Font provides kashida glyph with advance {}",
                        adv
                    )));
                }
                (id, adv)
            }
            _ => {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(
                        "Font does not support kashida justification.".to_string(),
                    ));
                }
                return items;
            }
        };

    let opportunity_indices: Vec<usize> = items
        .windows(2)
        .enumerate()
        .filter_map(|(i, window)| {
            if let (ShapedItem::Cluster(cur), ShapedItem::Cluster(next)) = (&window[0], &window[1])
            {
                if is_arabic_cluster(cur)
                    && is_arabic_cluster(next)
                    && !is_word_separator(&window[1])
                {
                    return Some(i + 1);
                }
            }
            None
        })
        .collect();

    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Found {} kashida insertion opportunities at indices: {:?}",
            opportunity_indices.len(),
            opportunity_indices
        )));
    }

    if opportunity_indices.is_empty() {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(
                "No opportunities found. Exiting.".to_string(),
            ));
        }
        return items;
    }

    let num_kashidas_to_insert = (extra_space / kashida_advance).floor() as usize;
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Calculated number of kashidas to insert: {}",
            num_kashidas_to_insert
        )));
    }

    if num_kashidas_to_insert == 0 {
        return items;
    }

    let kashidas_per_point = num_kashidas_to_insert / opportunity_indices.len();
    let mut remainder = num_kashidas_to_insert % opportunity_indices.len();
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Distributing kashidas: {} per point, with {} remainder.",
            kashidas_per_point, remainder
        )));
    }

    let kashida_item = {
        /* ... as before ... */
        let kashida_glyph = ShapedGlyph {
            kind: GlyphKind::Kashida {
                width: kashida_advance,
            },
            glyph_id: kashida_glyph_id,
            font_hash,
            font_metrics: font_metrics.clone(),
            style: style.clone(),
            script: Script::Arabic,
            advance: kashida_advance,
            kerning: 0.0,
            cluster_offset: 0,
            offset: Point::default(),
            vertical_advance: 0.0,
            vertical_offset: Point::default(),
        };
        ShapedItem::Cluster(ShapedCluster {
            text: "\u{0640}".to_string(),
            source_cluster_id: GraphemeClusterId {
                source_run: u32::MAX,
                start_byte_in_run: u32::MAX,
            },
            source_content_index: ContentIndex {
                run_index: u32::MAX,
                item_index: u32::MAX,
            },
            source_node_id: None, // Kashida is generated, not from DOM
            glyphs: vec![kashida_glyph],
            advance: kashida_advance,
            direction: BidiDirection::Ltr,
            style,
            marker_position_outside: None,
        })
    };

    let mut new_items = Vec::with_capacity(items.len() + num_kashidas_to_insert);
    let mut last_copy_idx = 0;
    for &point in &opportunity_indices {
        new_items.extend_from_slice(&items[last_copy_idx..point]);
        let mut num_to_insert = kashidas_per_point;
        if remainder > 0 {
            num_to_insert += 1;
            remainder -= 1;
        }
        for _ in 0..num_to_insert {
            new_items.push(kashida_item.clone());
        }
        last_copy_idx = point;
    }
    new_items.extend_from_slice(&items[last_copy_idx..]);

    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "--- Exiting justify_kashida_and_rebuild, new item count: {} ---",
            new_items.len()
        )));
    }
    new_items
}

/// Helper to determine if a cluster belongs to the Arabic script.
fn is_arabic_cluster(cluster: &ShapedCluster) -> bool {
    // A cluster is considered Arabic if its first non-NotDef glyph is from the Arabic script.
    // This is a robust heuristic for mixed-script lines.
    cluster.glyphs.iter().any(|g| g.script == Script::Arabic)
}

/// Helper to identify if an item is a word separator (like a space).
pub fn is_word_separator(item: &ShapedItem) -> bool {
    if let ShapedItem::Cluster(c) = item {
        // A cluster is a word separator if its text is whitespace.
        // This is a simplification; a single glyph might be whitespace.
        c.text.chars().any(|g| g.is_whitespace())
    } else {
        false
    }
}

/// Helper to identify if space can be added after an item.
fn can_justify_after(item: &ShapedItem) -> bool {
    if let ShapedItem::Cluster(c) = item {
        c.text.chars().last().map_or(false, |g| {
            !g.is_whitespace() && classify_character(g as u32) != CharacterClass::Combining
        })
    } else {
        // Can generally justify after inline objects unless they are followed by a break.
        !matches!(item, ShapedItem::Break { .. })
    }
}

/// Classifies a character for layout purposes (e.g., justification behavior).
/// Copied from `mod.rs`.
fn classify_character(codepoint: u32) -> CharacterClass {
    match codepoint {
        0x0020 | 0x00A0 | 0x3000 => CharacterClass::Space,
        0x0021..=0x002F | 0x003A..=0x0040 | 0x005B..=0x0060 | 0x007B..=0x007E => {
            CharacterClass::Punctuation
        }
        0x4E00..=0x9FFF | 0x3400..=0x4DBF => CharacterClass::Ideograph,
        0x0300..=0x036F | 0x1AB0..=0x1AFF => CharacterClass::Combining,
        // Mongolian script range
        0x1800..=0x18AF => CharacterClass::Letter,
        _ => CharacterClass::Letter,
    }
}

/// Helper to get the primary measure (width or height) of a shaped item.
pub fn get_item_measure(item: &ShapedItem, is_vertical: bool) -> f32 {
    match item {
        ShapedItem::Cluster(c) => {
            // Total width = base advance + kerning adjustments
            // Kerning is stored separately in glyphs for inspection, but the total
            // cluster width must include it for correct layout positioning
            let total_kerning: f32 = c.glyphs.iter().map(|g| g.kerning).sum();
            c.advance + total_kerning
        }
        ShapedItem::Object { bounds, .. }
        | ShapedItem::CombinedBlock { bounds, .. }
        | ShapedItem::Tab { bounds, .. } => {
            if is_vertical {
                bounds.height
            } else {
                bounds.width
            }
        }
        ShapedItem::Break { .. } => 0.0,
    }
}

/// Helper to get the final positioned bounds of an item.
fn get_item_bounds(item: &PositionedItem) -> Rect {
    let measure = get_item_measure(&item.item, false); // for simplicity, use horizontal
    let cross_measure = match &item.item {
        ShapedItem::Object { bounds, .. } => bounds.height,
        _ => 20.0, // placeholder line height
    };
    Rect {
        x: item.position.x,
        y: item.position.y,
        width: measure,
        height: cross_measure,
    }
}

/// Calculates the available horizontal segments for a line at a given vertical position,
/// considering both shape boundaries and exclusions.
fn get_line_constraints(
    line_y: f32,
    line_height: f32,
    constraints: &UnifiedConstraints,
    debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
) -> LineConstraints {
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "\n--- Entering get_line_constraints for y={} ---",
            line_y
        )));
    }

    let mut available_segments = Vec::new();
    if constraints.shape_boundaries.is_empty() {
        // The segment_width is determined by available_width, NOT by TextWrap.
        // TextWrap::NoWrap only affects whether the LineBreaker can insert soft breaks,
        // it should NOT override a definite width constraint from CSS.
        // CSS Text Level 3: For 'white-space: pre/nowrap', text overflows horizontally
        // if it doesn't fit, rather than expanding the container.
        let segment_width = match constraints.available_width {
            AvailableSpace::Definite(w) => w, // Respect definite width from CSS
            AvailableSpace::MaxContent => f32::MAX / 2.0, // For intrinsic max-content sizing
            AvailableSpace::MinContent => 0.0, // For intrinsic min-content sizing
        };
        // Note: TextWrap::NoWrap is handled by the LineBreaker in break_one_line()
        // to prevent soft wraps. The text will simply overflow if it exceeds segment_width.
        available_segments.push(LineSegment {
            start_x: 0.0,
            width: segment_width,
            priority: 0,
        });
    } else {
        // ... complex boundary logic ...
    }

    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Initial available segments: {:?}",
            available_segments
        )));
    }

    for (idx, exclusion) in constraints.shape_exclusions.iter().enumerate() {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "Applying exclusion #{}: {:?}",
                idx, exclusion
            )));
        }
        let exclusion_spans =
            get_shape_horizontal_spans(exclusion, line_y, line_height).unwrap_or_default();
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "  Exclusion spans at y={}: {:?}",
                line_y, exclusion_spans
            )));
        }

        if exclusion_spans.is_empty() {
            continue;
        }

        let mut next_segments = Vec::new();
        for (excl_start, excl_end) in exclusion_spans {
            for segment in &available_segments {
                let seg_start = segment.start_x;
                let seg_end = segment.start_x + segment.width;

                // Create new segments by subtracting the exclusion
                if seg_end > excl_start && seg_start < excl_end {
                    if seg_start < excl_start {
                        // Left part
                        next_segments.push(LineSegment {
                            start_x: seg_start,
                            width: excl_start - seg_start,
                            priority: segment.priority,
                        });
                    }
                    if seg_end > excl_end {
                        // Right part
                        next_segments.push(LineSegment {
                            start_x: excl_end,
                            width: seg_end - excl_end,
                            priority: segment.priority,
                        });
                    }
                } else {
                    next_segments.push(segment.clone()); // No overlap
                }
            }
            available_segments = merge_segments(next_segments);
            next_segments = Vec::new();
        }
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "  Segments after exclusion #{}: {:?}",
                idx, available_segments
            )));
        }
    }

    let total_width = available_segments.iter().map(|s| s.width).sum();
    if let Some(msgs) = debug_messages {
        msgs.push(LayoutDebugMessage::info(format!(
            "Final segments: {:?}, total available width: {}",
            available_segments, total_width
        )));
        msgs.push(LayoutDebugMessage::info(
            "--- Exiting get_line_constraints ---".to_string(),
        ));
    }

    LineConstraints {
        segments: available_segments,
        total_available: total_width,
    }
}

/// Helper function to get the horizontal spans of any shape at a given y-coordinate.
/// Returns a list of (start_x, end_x) tuples.
fn get_shape_horizontal_spans(
    shape: &ShapeBoundary,
    y: f32,
    line_height: f32,
) -> Result<Vec<(f32, f32)>, LayoutError> {
    match shape {
        ShapeBoundary::Rectangle(rect) => {
            // Check for any overlap between the line box [y, y + line_height]
            // and the rectangle's vertical span [rect.y, rect.y + rect.height].
            let line_start = y;
            let line_end = y + line_height;
            let rect_start = rect.y;
            let rect_end = rect.y + rect.height;

            if line_start < rect_end && line_end > rect_start {
                Ok(vec![(rect.x, rect.x + rect.width)])
            } else {
                Ok(vec![])
            }
        }
        ShapeBoundary::Circle { center, radius } => {
            let line_center_y = y + line_height / 2.0;
            let dy = (line_center_y - center.y).abs();
            if dy <= *radius {
                let dx = (radius.powi(2) - dy.powi(2)).sqrt();
                Ok(vec![(center.x - dx, center.x + dx)])
            } else {
                Ok(vec![])
            }
        }
        ShapeBoundary::Ellipse { center, radii } => {
            let line_center_y = y + line_height / 2.0;
            let dy = line_center_y - center.y;
            if dy.abs() <= radii.height {
                // Formula: (x-h)^2/a^2 + (y-k)^2/b^2 = 1
                let y_term = dy / radii.height;
                let x_term_squared = 1.0 - y_term.powi(2);
                if x_term_squared >= 0.0 {
                    let dx = radii.width * x_term_squared.sqrt();
                    Ok(vec![(center.x - dx, center.x + dx)])
                } else {
                    Ok(vec![])
                }
            } else {
                Ok(vec![])
            }
        }
        ShapeBoundary::Polygon { points } => {
            let segments = polygon_line_intersection(points, y, line_height)?;
            Ok(segments
                .iter()
                .map(|s| (s.start_x, s.start_x + s.width))
                .collect())
        }
        ShapeBoundary::Path { .. } => Ok(vec![]), // TODO!
    }
}

/// Merges overlapping or adjacent line segments into larger ones.
fn merge_segments(mut segments: Vec<LineSegment>) -> Vec<LineSegment> {
    if segments.len() <= 1 {
        return segments;
    }
    segments.sort_by(|a, b| a.start_x.partial_cmp(&b.start_x).unwrap());
    let mut merged = vec![segments[0].clone()];
    for next_seg in segments.iter().skip(1) {
        let last = merged.last_mut().unwrap();
        if next_seg.start_x <= last.start_x + last.width {
            let new_width = (next_seg.start_x + next_seg.width) - last.start_x;
            last.width = last.width.max(new_width);
        } else {
            merged.push(next_seg.clone());
        }
    }
    merged
}

// TODO: Dummy polygon function to make it compile
fn polygon_line_intersection(
    points: &[Point],
    y: f32,
    line_height: f32,
) -> Result<Vec<LineSegment>, LayoutError> {
    if points.len() < 3 {
        return Ok(vec![]);
    }

    let line_center_y = y + line_height / 2.0;
    let mut intersections = Vec::new();

    // Use winding number algorithm for robustness with complex polygons.
    for i in 0..points.len() {
        let p1 = points[i];
        let p2 = points[(i + 1) % points.len()];

        // Skip horizontal edges as they don't intersect a horizontal scanline in a meaningful way.
        if (p2.y - p1.y).abs() < f32::EPSILON {
            continue;
        }

        // Check if our horizontal scanline at `line_center_y` crosses this polygon edge.
        let crosses = (p1.y <= line_center_y && p2.y > line_center_y)
            || (p1.y > line_center_y && p2.y <= line_center_y);

        if crosses {
            // Calculate intersection x-coordinate using linear interpolation.
            let t = (line_center_y - p1.y) / (p2.y - p1.y);
            let x = p1.x + t * (p2.x - p1.x);
            intersections.push(x);
        }
    }

    // Sort intersections by x-coordinate to form spans.
    intersections.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

    // Build segments from paired intersection points.
    let mut segments = Vec::new();
    for chunk in intersections.chunks_exact(2) {
        let start_x = chunk[0];
        let end_x = chunk[1];
        if end_x > start_x {
            segments.push(LineSegment {
                start_x,
                width: end_x - start_x,
                priority: 0,
            });
        }
    }

    Ok(segments)
}

// ADDITION: A helper function to get a hyphenator.
/// Helper to get a hyphenator for a given language.
/// TODO: In a real app, this would be cached.
#[cfg(feature = "text_layout_hyphenation")]
fn get_hyphenator(language: HyphenationLanguage) -> Result<Standard, LayoutError> {
    Standard::from_embedded(language).map_err(|e| LayoutError::HyphenationError(e.to_string()))
}

/// Stub when hyphenation is disabled - always returns an error
#[cfg(not(feature = "text_layout_hyphenation"))]
fn get_hyphenator(_language: Language) -> Result<Standard, LayoutError> {
    Err(LayoutError::HyphenationError("Hyphenation feature not enabled".to_string()))
}

fn is_break_opportunity(item: &ShapedItem) -> bool {
    // Break after spaces or explicit break items.
    if is_word_separator(item) {
        return true;
    }
    if let ShapedItem::Break { .. } = item {
        return true;
    }
    // Also consider soft hyphens as opportunities.
    if let ShapedItem::Cluster(c) = item {
        if c.text.starts_with('\u{00AD}') {
            return true;
        }
    }
    false
}

// A cursor to manage the state of the line breaking process.
// This allows us to handle items that are partially consumed by hyphenation.
pub struct BreakCursor<'a> {
    /// A reference to the complete list of shaped items.
    pub items: &'a [ShapedItem],
    /// The index of the next *full* item to be processed from the `items` slice.
    pub next_item_index: usize,
    /// The remainder of an item that was split by hyphenation on the previous line.
    /// This will be the very first piece of content considered for the next line.
    pub partial_remainder: Vec<ShapedItem>,
}

impl<'a> BreakCursor<'a> {
    pub fn new(items: &'a [ShapedItem]) -> Self {
        Self {
            items,
            next_item_index: 0,
            partial_remainder: Vec::new(),
        }
    }

    /// Checks if the cursor is at the very beginning of the content stream.
    pub fn is_at_start(&self) -> bool {
        self.next_item_index == 0 && self.partial_remainder.is_empty()
    }

    /// Consumes the cursor and returns all remaining items as a `Vec`.
    pub fn drain_remaining(&mut self) -> Vec<ShapedItem> {
        let mut remaining = std::mem::take(&mut self.partial_remainder);
        if self.next_item_index < self.items.len() {
            remaining.extend_from_slice(&self.items[self.next_item_index..]);
        }
        self.next_item_index = self.items.len();
        remaining
    }

    /// Checks if all content, including any partial remainders, has been processed.
    pub fn is_done(&self) -> bool {
        self.next_item_index >= self.items.len() && self.partial_remainder.is_empty()
    }

    /// Consumes a number of items from the cursor's stream.
    pub fn consume(&mut self, count: usize) {
        if count == 0 {
            return;
        }

        let remainder_len = self.partial_remainder.len();
        if count <= remainder_len {
            // Consuming only from the remainder.
            self.partial_remainder.drain(..count);
        } else {
            // Consuming all of the remainder and some from the main list.
            let from_main_list = count - remainder_len;
            self.partial_remainder.clear();
            self.next_item_index += from_main_list;
        }
    }

    /// Looks ahead and returns the next "unbreakable" unit of content.
    /// This is typically a word (a series of non-space clusters) followed by a
    /// space, or just a single space if that's next.
    pub fn peek_next_unit(&self) -> Vec<ShapedItem> {
        let mut unit = Vec::new();
        let mut source_items = self.partial_remainder.clone();
        source_items.extend_from_slice(&self.items[self.next_item_index..]);

        if source_items.is_empty() {
            return unit;
        }

        // If the first item is a break opportunity (like a space), it's a unit on its own.
        if is_break_opportunity(&source_items[0]) {
            unit.push(source_items[0].clone());
            return unit;
        }

        // Otherwise, collect all items until the next break opportunity.
        for item in source_items {
            if is_break_opportunity(&item) {
                break;
            }
            unit.push(item.clone());
        }
        unit
    }
}

// A structured result from a hyphenation attempt.
struct HyphenationResult {
    /// The items that fit on the current line, including the new hyphen.
    line_part: Vec<ShapedItem>,
    /// The remainder of the split item to be carried over to the next line.
    remainder_part: Vec<ShapedItem>,
}

fn perform_bidi_analysis<'a, 'b: 'a>(
    styled_runs: &'a [TextRunInfo],
    full_text: &'b str,
    force_lang: Option<Language>,
) -> Result<(Vec<VisualRun<'a>>, BidiDirection), LayoutError> {
    if full_text.is_empty() {
        return Ok((Vec::new(), BidiDirection::Ltr));
    }

    let bidi_info = BidiInfo::new(full_text, None);
    let para = &bidi_info.paragraphs[0];
    let base_direction = if para.level.is_rtl() {
        BidiDirection::Rtl
    } else {
        BidiDirection::Ltr
    };

    // Create a map from each byte index to its original styled run.
    let mut byte_to_run_index: Vec<usize> = vec![0; full_text.len()];
    for (run_idx, run) in styled_runs.iter().enumerate() {
        let start = run.logical_start;
        let end = start + run.text.len();
        for i in start..end {
            byte_to_run_index[i] = run_idx;
        }
    }

    let mut final_visual_runs = Vec::new();
    let (levels, visual_run_ranges) = bidi_info.visual_runs(para, para.range.clone());

    for range in visual_run_ranges {
        let bidi_level = levels[range.start];
        let mut sub_run_start = range.start;

        // Iterate through the bytes of the visual run to detect style changes.
        for i in (range.start + 1)..range.end {
            if byte_to_run_index[i] != byte_to_run_index[sub_run_start] {
                // Style boundary found. Finalize the previous sub-run.
                let original_run_idx = byte_to_run_index[sub_run_start];
                let script = crate::text3::script::detect_script(&full_text[sub_run_start..i])
                    .unwrap_or(Script::Latin);
                final_visual_runs.push(VisualRun {
                    text_slice: &full_text[sub_run_start..i],
                    style: styled_runs[original_run_idx].style.clone(),
                    logical_start_byte: sub_run_start,
                    bidi_level: BidiLevel::new(bidi_level.number()),
                    language: force_lang.unwrap_or_else(|| {
                        crate::text3::script::script_to_language(
                            script,
                            &full_text[sub_run_start..i],
                        )
                    }),
                    script,
                });
                // Start a new sub-run.
                sub_run_start = i;
            }
        }

        // Add the last sub-run (or the only one if no style change occurred).
        let original_run_idx = byte_to_run_index[sub_run_start];
        let script = crate::text3::script::detect_script(&full_text[sub_run_start..range.end])
            .unwrap_or(Script::Latin);

        final_visual_runs.push(VisualRun {
            text_slice: &full_text[sub_run_start..range.end],
            style: styled_runs[original_run_idx].style.clone(),
            logical_start_byte: sub_run_start,
            bidi_level: BidiLevel::new(bidi_level.number()),
            script,
            language: force_lang.unwrap_or_else(|| {
                crate::text3::script::script_to_language(
                    script,
                    &full_text[sub_run_start..range.end],
                )
            }),
        });
    }

    Ok((final_visual_runs, base_direction))
}

fn get_justification_priority(class: CharacterClass) -> u8 {
    match class {
        CharacterClass::Space => 0,
        CharacterClass::Punctuation => 64,
        CharacterClass::Ideograph => 128,
        CharacterClass::Letter => 192,
        CharacterClass::Symbol => 224,
        CharacterClass::Combining => 255,
    }
}

```

================================================================================
## FILE: layout/src/text3/default.rs
## Description: Text editing, cursor, selection
================================================================================
```
use std::{path::Path, sync::Arc};

use allsorts::{
    gpos,
    gsub::{self, FeatureInfo, FeatureMask, Features},
};
use azul_core::{geom::LogicalSize, glyph::Placement};
use azul_css::props::basic::FontRef;
use rust_fontconfig::FcFontCache;

use crate::{
    font::parsed::ParsedFont,
    text3::{
        cache::{
            BidiDirection, BidiLevel, FontManager, FontSelector, FontVariantCaps,
            FontVariantLigatures, FontVariantNumeric, Glyph, GlyphOrientation, GlyphSource,
            LayoutError, LayoutFontMetrics, ParsedFontTrait, Point, ShallowClone, StyleProperties,
            TextCombineUpright, TextDecoration, TextOrientation, VerticalMetrics, WritingMode,
        },
        script::Script,
    },
};

/// Creates a FontRef from font bytes by parsing them into a ParsedFont.
///
/// This is a bridge function that:
///
/// 1. Parses the bytes into a ParsedFont
/// 2. Wraps it in a FontRef with proper reference counting
///
/// # Arguments
///
/// - `font_bytes` - The raw font file data
/// - `font_index` - Index of the font in a font collection (0 for single fonts)
/// - `parse_outlines` - Whether to parse glyph outlines (expensive, usually false for layout)
pub fn font_ref_from_bytes(
    font_bytes: &[u8],
    font_index: usize,
    parse_outlines: bool,
) -> Option<FontRef> {
    // Parse the font bytes into ParsedFont
    let mut warnings = Vec::new();
    let parsed_font = ParsedFont::from_bytes(font_bytes, font_index, &mut warnings)?;

    Some(crate::parsed_font_to_font_ref(parsed_font))
}

/// A FontLoader that parses font data from a byte slice.
///
/// It is designed to be used in conjunction with a mechanism that reads font files
/// from paths into memory. This loader simply handles the parsing aspect.
#[derive(Debug, Default, Clone)]
pub struct PathLoader;

impl PathLoader {
    pub fn new() -> Self {
        PathLoader
    }

    /// A helper method to read a font from a path and delegate to the trait's `load_font`.
    /// Note: This is a convenience and not part of the `FontLoaderTrait`.
    pub fn load_from_path(&self, path: &Path, font_index: usize) -> Result<FontRef, LayoutError> {
        let font_bytes = std::fs::read(path).map_err(|e| {
            LayoutError::FontNotFound(FontSelector {
                family: path.to_string_lossy().into_owned(),
                weight: rust_fontconfig::FcWeight::Normal,
                style: crate::text3::cache::FontStyle::Normal,
                unicode_ranges: Vec::new(),
            })
        })?;
        self.load_font(&font_bytes, font_index)
    }
}

impl FontManager<FontRef> {
    pub fn new_with_fc_cache(fc_cache: FcFontCache) -> Result<Self, LayoutError> {
        FontManager::new(fc_cache)
    }
}

impl PathLoader {
    /// Loads a font from a byte slice.
    ///
    /// This implementation parses the bytes into a ParsedFont and wraps it in a FontRef.
    pub fn load_font(&self, font_bytes: &[u8], font_index: usize) -> Result<FontRef, LayoutError> {
        // Parse the font bytes and wrap in FontRef
        font_ref_from_bytes(font_bytes, font_index, true).ok_or_else(|| {
            LayoutError::ShapingError("Failed to parse font with allsorts".to_string())
        })
    }
}

// ParsedFontTrait Implementation for FontRef

// Implement ShallowClone for FontRef
impl crate::text3::cache::ShallowClone for FontRef {
    fn shallow_clone(&self) -> Self {
        // FontRef::clone increments the reference count
        self.clone()
    }
}

// Helper to get the inner ParsedFont from FontRef
#[inline]
fn get_parsed_font(font_ref: &FontRef) -> &ParsedFont {
    unsafe { &*(font_ref.get_parsed() as *const ParsedFont) }
}

impl ParsedFontTrait for FontRef {
    fn shape_text(
        &self,
        text: &str,
        script: Script,
        language: crate::text3::script::Language,
        direction: BidiDirection,
        style: &StyleProperties,
    ) -> Result<Vec<Glyph>, LayoutError> {
        // Delegate to the inner ParsedFont's shape_text, passing self as font_ref
        let parsed = get_parsed_font(self);
        parsed.shape_text_for_font_ref(self, text, script, language, direction, style)
    }

    fn get_hash(&self) -> u64 {
        get_parsed_font(self).hash
    }

    fn get_glyph_size(&self, glyph_id: u16, font_size: f32) -> Option<LogicalSize> {
        get_parsed_font(self).get_glyph_size(glyph_id, font_size)
    }

    fn get_hyphen_glyph_and_advance(&self, font_size: f32) -> Option<(u16, f32)> {
        get_parsed_font(self).get_hyphen_glyph_and_advance(font_size)
    }

    fn get_kashida_glyph_and_advance(&self, font_size: f32) -> Option<(u16, f32)> {
        get_parsed_font(self).get_kashida_glyph_and_advance(font_size)
    }

    fn has_glyph(&self, codepoint: u32) -> bool {
        get_parsed_font(self).has_glyph(codepoint)
    }

    fn get_vertical_metrics(&self, glyph_id: u16) -> Option<VerticalMetrics> {
        get_parsed_font(self).get_vertical_metrics(glyph_id)
    }

    fn get_font_metrics(&self) -> LayoutFontMetrics {
        get_parsed_font(self).font_metrics.clone()
    }

    fn num_glyphs(&self) -> u16 {
        get_parsed_font(self).num_glyphs
    }
}

/// Extension trait for FontRef to provide access to font bytes and metrics
///
/// This trait provides methods that require access to the inner ParsedFont data.
pub trait FontRefExt {
    /// Get the original font bytes
    fn get_bytes(&self) -> &[u8];
    /// Get the full font metrics (PDF-style metrics from HEAD, HHEA, OS/2 tables)
    fn get_full_font_metrics(&self) -> azul_css::props::basic::FontMetrics;
}

impl FontRefExt for FontRef {
    fn get_bytes(&self) -> &[u8] {
        &get_parsed_font(self).original_bytes
    }

    fn get_full_font_metrics(&self) -> azul_css::props::basic::FontMetrics {
        use azul_css::{OptionI16, OptionU16, OptionU32};

        let parsed = get_parsed_font(self);
        let pdf = &parsed.pdf_font_metrics;

        // PdfFontMetrics only has a subset of fields; fill others with defaults
        azul_css::props::basic::FontMetrics {
            // HEAD table fields
            units_per_em: pdf.units_per_em,
            font_flags: pdf.font_flags,
            x_min: pdf.x_min,
            y_min: pdf.y_min,
            x_max: pdf.x_max,
            y_max: pdf.y_max,

            // HHEA table fields
            ascender: pdf.ascender,
            descender: pdf.descender,
            line_gap: pdf.line_gap,
            advance_width_max: pdf.advance_width_max,
            min_left_side_bearing: 0,  // Not in PdfFontMetrics
            min_right_side_bearing: 0, // Not in PdfFontMetrics
            x_max_extent: 0,           // Not in PdfFontMetrics
            caret_slope_rise: pdf.caret_slope_rise,
            caret_slope_run: pdf.caret_slope_run,
            caret_offset: 0,  // Not in PdfFontMetrics
            num_h_metrics: 0, // Not in PdfFontMetrics

            // OS/2 table fields
            x_avg_char_width: pdf.x_avg_char_width,
            us_weight_class: pdf.us_weight_class,
            us_width_class: pdf.us_width_class,
            fs_type: 0,                // Not in PdfFontMetrics
            y_subscript_x_size: 0,     // Not in PdfFontMetrics
            y_subscript_y_size: 0,     // Not in PdfFontMetrics
            y_subscript_x_offset: 0,   // Not in PdfFontMetrics
            y_subscript_y_offset: 0,   // Not in PdfFontMetrics
            y_superscript_x_size: 0,   // Not in PdfFontMetrics
            y_superscript_y_size: 0,   // Not in PdfFontMetrics
            y_superscript_x_offset: 0, // Not in PdfFontMetrics
            y_superscript_y_offset: 0, // Not in PdfFontMetrics
            y_strikeout_size: pdf.y_strikeout_size,
            y_strikeout_position: pdf.y_strikeout_position,
            s_family_class: 0, // Not in PdfFontMetrics
            panose: azul_css::props::basic::Panose::zero(),
            ul_unicode_range1: 0,   // Not in PdfFontMetrics
            ul_unicode_range2: 0,   // Not in PdfFontMetrics
            ul_unicode_range3: 0,   // Not in PdfFontMetrics
            ul_unicode_range4: 0,   // Not in PdfFontMetrics
            ach_vend_id: 0,         // Not in PdfFontMetrics
            fs_selection: 0,        // Not in PdfFontMetrics
            us_first_char_index: 0, // Not in PdfFontMetrics
            us_last_char_index: 0,  // Not in PdfFontMetrics

            // OS/2 version 0 fields (optional)
            s_typo_ascender: OptionI16::None,
            s_typo_descender: OptionI16::None,
            s_typo_line_gap: OptionI16::None,
            us_win_ascent: OptionU16::None,
            us_win_descent: OptionU16::None,

            // OS/2 version 1 fields (optional)
            ul_code_page_range1: OptionU32::None,
            ul_code_page_range2: OptionU32::None,

            // OS/2 version 2 fields (optional)
            sx_height: OptionI16::None,
            s_cap_height: OptionI16::None,
            us_default_char: OptionU16::None,
            us_break_char: OptionU16::None,
            us_max_context: OptionU16::None,

            // OS/2 version 3 fields (optional)
            us_lower_optical_point_size: OptionU16::None,
            us_upper_optical_point_size: OptionU16::None,
        }
    }
}

// ParsedFont helper method for FontRef
//
// This allows ParsedFont to create glyphs that use FontRef
//
// FontRef is just a C-style Arc wrapper around ParsedFont, so we delegate to
// the common shaping implementation and convert the font reference type.

impl ParsedFont {
    /// Internal helper that shapes text and returns Glyph
    /// Delegates to shape_text_internal and converts the font reference.
    fn shape_text_for_font_ref(
        &self,
        font_ref: &FontRef,
        text: &str,
        script: Script,
        language: crate::text3::script::Language,
        direction: BidiDirection,
        style: &StyleProperties,
    ) -> Result<Vec<Glyph>, LayoutError> {
        // Use the common shaping implementation
        let shaped = shape_text_internal(self, text, script, language, direction, style)?;

        // Convert Glyph - now using font_hash and font_metrics instead of font reference
        let font_hash = font_ref.get_hash();
        let font_metrics = LayoutFontMetrics {
            ascent: self.font_metrics.ascent,
            descent: self.font_metrics.descent,
            line_gap: self.font_metrics.line_gap,
            units_per_em: self.font_metrics.units_per_em,
        };

        Ok(shaped
            .into_iter()
            .map(|g| Glyph {
                glyph_id: g.glyph_id,
                codepoint: g.codepoint,
                font_hash,
                font_metrics: font_metrics.clone(),
                style: g.style,
                source: g.source,
                logical_byte_index: g.logical_byte_index,
                logical_byte_len: g.logical_byte_len,
                content_index: g.content_index,
                cluster: g.cluster,
                advance: g.advance,
                kerning: g.kerning,
                offset: g.offset,
                vertical_advance: g.vertical_advance,
                vertical_origin_y: g.vertical_origin_y,
                vertical_bearing: g.vertical_bearing,
                orientation: g.orientation,
                script: g.script,
                bidi_level: g.bidi_level,
            })
            .collect())
    }

    fn get_hash(&self) -> u64 {
        self.hash
    }

    fn get_glyph_size(&self, glyph_id: u16, font_size_px: f32) -> Option<LogicalSize> {
        self.glyph_records_decoded.get(&glyph_id).map(|record| {
            let units_per_em = self.font_metrics.units_per_em as f32;
            let scale_factor = if units_per_em > 0.0 {
                font_size_px / units_per_em
            } else {
                0.01 // Avoid division by zero
            };

            // max_x, max_y, min_x, min_y in font units
            let bbox = &record.bounding_box;

            LogicalSize {
                width: (bbox.max_x - bbox.min_x) as f32 * scale_factor,
                height: (bbox.max_y - bbox.min_y) as f32 * scale_factor,
            }
        })
    }

    fn get_hyphen_glyph_and_advance(&self, font_size: f32) -> Option<(u16, f32)> {
        let glyph_id = self.lookup_glyph_index('-' as u32)?;
        let advance_units = self.get_horizontal_advance(glyph_id);
        let scale_factor = if self.font_metrics.units_per_em > 0 {
            font_size / (self.font_metrics.units_per_em as f32)
        } else {
            return None;
        };
        let scaled_advance = advance_units as f32 * scale_factor;
        Some((glyph_id, scaled_advance))
    }

    fn get_kashida_glyph_and_advance(&self, font_size: f32) -> Option<(u16, f32)> {
        // U+0640 is the Arabic Tatweel character, used for kashida justification.
        let glyph_id = self.lookup_glyph_index('\u{0640}' as u32)?;
        let advance_units = self.get_horizontal_advance(glyph_id);
        let scale_factor = if self.font_metrics.units_per_em > 0 {
            font_size / (self.font_metrics.units_per_em as f32)
        } else {
            return None;
        };
        let scaled_advance = advance_units as f32 * scale_factor;
        Some((glyph_id, scaled_advance))
    }
}

// Helper Functions

/// Builds a FeatureMask with the appropriate OpenType features for a given script.
/// This ensures proper text shaping for complex scripts like Arabic, Devanagari, etc.
///
/// The function includes:
/// - Common features for all scripts (ligatures, contextual alternates, etc.)
/// - Script-specific features (positional forms for Arabic, conjuncts for Indic, etc.)
///
/// This is designed to be stable and explicit - we control exactly which features
/// are enabled rather than relying on allsorts' defaults which may change.
fn build_feature_mask_for_script(script: Script) -> FeatureMask {
    use Script::*;

    // Start with common features that apply to most scripts
    let mut mask = FeatureMask::default(); // Includes: CALT, CCMP, CLIG, LIGA, LOCL, RLIG

    // Add script-specific features
    match script {
        // Arabic and related scripts - require positional forms
        Arabic => {
            mask |= FeatureMask::INIT; // Initial forms (at start of word)
            mask |= FeatureMask::MEDI; // Medial forms (middle of word)
            mask |= FeatureMask::FINA; // Final forms (end of word)
            mask |= FeatureMask::ISOL; // Isolated forms (standalone)
                                       // Note: RLIG (required ligatures) already in default for
                                       // lam-alef ligatures
        }

        // Indic scripts - require complex conjunct formation and reordering
        Devanagari | Bengali | Gujarati | Gurmukhi | Kannada | Malayalam | Oriya | Tamil
        | Telugu => {
            mask |= FeatureMask::NUKT; // Nukta forms
            mask |= FeatureMask::AKHN; // Akhand ligatures
            mask |= FeatureMask::RPHF; // Reph form
            mask |= FeatureMask::RKRF; // Rakar form
            mask |= FeatureMask::PREF; // Pre-base forms
            mask |= FeatureMask::BLWF; // Below-base forms
            mask |= FeatureMask::ABVF; // Above-base forms
            mask |= FeatureMask::HALF; // Half forms
            mask |= FeatureMask::PSTF; // Post-base forms
            mask |= FeatureMask::VATU; // Vattu variants
            mask |= FeatureMask::CJCT; // Conjunct forms
        }

        // Myanmar (Burmese) - has complex reordering
        Myanmar => {
            mask |= FeatureMask::PREF; // Pre-base forms
            mask |= FeatureMask::BLWF; // Below-base forms
            mask |= FeatureMask::PSTF; // Post-base forms
        }

        // Khmer - has complex reordering and stacking
        Khmer => {
            mask |= FeatureMask::PREF; // Pre-base forms
            mask |= FeatureMask::BLWF; // Below-base forms
            mask |= FeatureMask::ABVF; // Above-base forms
            mask |= FeatureMask::PSTF; // Post-base forms
        }

        // Thai - has tone marks and vowel reordering
        Thai => {
            // Thai mostly uses default features, but may have some special marks
            // The default mask is sufficient for most Thai fonts
        }

        // Hebrew - may have contextual forms but less complex than Arabic
        Hebrew => {
            // Hebrew fonts may use contextual alternates already in default
            // Some fonts have special features but they're rare
        }

        // Hangul (Korean) - has complex syllable composition
        Hangul => {
            // Note: Hangul jamo features (LJMO, VJMO, TJMO) are not available in allsorts'
            // FeatureMask Most modern Hangul fonts work correctly with the default
            // features as syllable composition is usually handled at a lower level
        }

        // Ethiopic - has syllabic script with some ligatures
        Ethiopic => {
            // Default features are usually sufficient
            // LIGA and CLIG already in default mask
        }

        // Latin, Greek, Cyrillic - standard features are sufficient
        Latin | Greek | Cyrillic => {
            // Default mask includes all needed features:
            // - LIGA: standard ligatures (fi, fl, etc.)
            // - CLIG: contextual ligatures
            // - CALT: contextual alternates
            // - CCMP: mark composition
        }

        // Georgian - uses standard features
        Georgian => {
            // Default features sufficient
        }

        // CJK scripts (Hiragana, Katakana, Mandarin/Hani)
        Hiragana | Katakana | Mandarin => {
            // CJK fonts may use vertical alternates, but those are controlled
            // by writing-mode, not GSUB features in the horizontal direction.
            // Default features are sufficient.
        }

        // Sinhala - Indic-derived but simpler
        Sinhala => {
            mask |= FeatureMask::AKHN; // Akhand ligatures
            mask |= FeatureMask::RPHF; // Reph form
            mask |= FeatureMask::VATU; // Vattu variants
        }
    }

    mask
}

/// Maps the layout engine's `Script` enum to an OpenType script tag `u32`.
fn to_opentype_script_tag(script: Script) -> u32 {
    use Script::*;
    // Tags from https://docs.microsoft.com/en-us/typography/opentype/spec/scripttags
    match script {
        Arabic => u32::from_be_bytes(*b"arab"),
        Bengali => u32::from_be_bytes(*b"beng"),
        Cyrillic => u32::from_be_bytes(*b"cyrl"),
        Devanagari => u32::from_be_bytes(*b"deva"),
        Ethiopic => u32::from_be_bytes(*b"ethi"),
        Georgian => u32::from_be_bytes(*b"geor"),
        Greek => u32::from_be_bytes(*b"grek"),
        Gujarati => u32::from_be_bytes(*b"gujr"),
        Gurmukhi => u32::from_be_bytes(*b"guru"),
        Hangul => u32::from_be_bytes(*b"hang"),
        Hebrew => u32::from_be_bytes(*b"hebr"),
        Hiragana => u32::from_be_bytes(*b"kana"),
        Kannada => u32::from_be_bytes(*b"knda"),
        Katakana => u32::from_be_bytes(*b"kana"),
        Khmer => u32::from_be_bytes(*b"khmr"),
        Latin => u32::from_be_bytes(*b"latn"),
        Malayalam => u32::from_be_bytes(*b"mlym"),
        Mandarin => u32::from_be_bytes(*b"hani"),
        Myanmar => u32::from_be_bytes(*b"mymr"),
        Oriya => u32::from_be_bytes(*b"orya"),
        Sinhala => u32::from_be_bytes(*b"sinh"),
        Tamil => u32::from_be_bytes(*b"taml"),
        Telugu => u32::from_be_bytes(*b"telu"),
        Thai => u32::from_be_bytes(*b"thai"),
    }
}

/// Parses a CSS-style font-feature-settings string like `"liga"`, `"liga=0"`, or `"ss01"`.
/// Returns an OpenType tag and a value.
fn parse_font_feature(feature_str: &str) -> Option<(u32, u32)> {
    let mut parts = feature_str.split('=');
    let tag_str = parts.next()?.trim();
    let value_str = parts.next().unwrap_or("1").trim(); // Default to 1 (on) if no value

    // OpenType feature tags must be 4 characters long.
    if tag_str.len() > 4 {
        return None;
    }
    // Pad with spaces if necessary
    let padded_tag_str = format!("{:<4}", tag_str);

    let tag = u32::from_be_bytes(padded_tag_str.as_bytes().try_into().ok()?);
    let value = value_str.parse::<u32>().ok()?;

    Some((tag, value))
}

/// A helper to add OpenType features based on CSS `font-variant-*` properties.
fn add_variant_features(style: &StyleProperties, features: &mut Vec<FeatureInfo>) {
    // Helper to add a feature that is simply "on".
    let mut add_on = |tag_str: &[u8; 4]| {
        features.push(FeatureInfo {
            feature_tag: u32::from_be_bytes(*tag_str),
            alternate: None,
        });
    };

    // Note on disabling features: The CSS properties `font-variant-ligatures: none` or
    // `no-common-ligatures` are meant to disable features that may be on by default for a
    // given script. The `allsorts` API for applying custom features is additive and does not
    // currently support disabling default features. This implementation only handles enabling
    // non-default features.

    // Ligatures
    match style.font_variant_ligatures {
        FontVariantLigatures::Discretionary => add_on(b"dlig"),
        FontVariantLigatures::Historical => add_on(b"hlig"),
        FontVariantLigatures::Contextual => add_on(b"calt"),
        _ => {} // Other cases are either default-on or require disabling.
    }

    // Caps
    match style.font_variant_caps {
        FontVariantCaps::SmallCaps => add_on(b"smcp"),
        FontVariantCaps::AllSmallCaps => {
            add_on(b"c2sc");
            add_on(b"smcp");
        }
        FontVariantCaps::PetiteCaps => add_on(b"pcap"),
        FontVariantCaps::AllPetiteCaps => {
            add_on(b"c2pc");
            add_on(b"pcap");
        }
        FontVariantCaps::Unicase => add_on(b"unic"),
        FontVariantCaps::TitlingCaps => add_on(b"titl"),
        FontVariantCaps::Normal => {}
    }

    // Numeric
    match style.font_variant_numeric {
        FontVariantNumeric::LiningNums => add_on(b"lnum"),
        FontVariantNumeric::OldstyleNums => add_on(b"onum"),
        FontVariantNumeric::ProportionalNums => add_on(b"pnum"),
        FontVariantNumeric::TabularNums => add_on(b"tnum"),
        FontVariantNumeric::DiagonalFractions => add_on(b"frac"),
        FontVariantNumeric::StackedFractions => add_on(b"afrc"),
        FontVariantNumeric::Ordinal => add_on(b"ordn"),
        FontVariantNumeric::SlashedZero => add_on(b"zero"),
        FontVariantNumeric::Normal => {}
    }
}

/// Maps the `hyphenation::Language` enum to an OpenType language tag `u32`.
#[cfg(feature = "text_layout_hyphenation")]
fn to_opentype_lang_tag(lang: hyphenation::Language) -> u32 {
    use hyphenation::Language::*;
    // A complete list of language tags can be found at:
    // https://docs.microsoft.com/en-us/typography/opentype/spec/languagetags
    let tag_bytes = match lang {
        Afrikaans => *b"AFK ",
        Albanian => *b"SQI ",
        Armenian => *b"HYE ",
        Assamese => *b"ASM ",
        Basque => *b"EUQ ",
        Belarusian => *b"BEL ",
        Bengali => *b"BEN ",
        Bulgarian => *b"BGR ",
        Catalan => *b"CAT ",
        Chinese => *b"ZHS ",
        Coptic => *b"COP ",
        Croatian => *b"HRV ",
        Czech => *b"CSY ",
        Danish => *b"DAN ",
        Dutch => *b"NLD ",
        EnglishGB => *b"ENG ",
        EnglishUS => *b"ENU ",
        Esperanto => *b"ESP ",
        Estonian => *b"ETI ",
        Ethiopic => *b"ETI ",
        Finnish => *b"FIN ",
        FinnishScholastic => *b"FIN ",
        French => *b"FRA ",
        Friulan => *b"FRL ",
        Galician => *b"GLC ",
        Georgian => *b"KAT ",
        German1901 => *b"DEU ",
        German1996 => *b"DEU ",
        GermanSwiss => *b"DES ",
        GreekAncient => *b"GRC ",
        GreekMono => *b"ELL ",
        GreekPoly => *b"ELL ",
        Gujarati => *b"GUJ ",
        Hindi => *b"HIN ",
        Hungarian => *b"HUN ",
        Icelandic => *b"ISL ",
        Indonesian => *b"IND ",
        Interlingua => *b"INA ",
        Irish => *b"IRI ",
        Italian => *b"ITA ",
        Kannada => *b"KAN ",
        Kurmanji => *b"KUR ",
        Latin => *b"LAT ",
        LatinClassic => *b"LAT ",
        LatinLiturgical => *b"LAT ",
        Latvian => *b"LVI ",
        Lithuanian => *b"LTH ",
        Macedonian => *b"MKD ",
        Malayalam => *b"MAL ",
        Marathi => *b"MAR ",
        Mongolian => *b"MNG ",
        NorwegianBokmal => *b"NOR ",
        NorwegianNynorsk => *b"NYN ",
        Occitan => *b"OCI ",
        Oriya => *b"ORI ",
        Pali => *b"PLI ",
        Panjabi => *b"PAN ",
        Piedmontese => *b"PMS ",
        Polish => *b"PLK ",
        Portuguese => *b"PTG ",
        Romanian => *b"ROM ",
        Romansh => *b"RMC ",
        Russian => *b"RUS ",
        Sanskrit => *b"SAN ",
        SerbianCyrillic => *b"SRB ",
        SerbocroatianCyrillic => *b"SHC ",
        SerbocroatianLatin => *b"SHL ",
        SlavonicChurch => *b"CSL ",
        Slovak => *b"SKY ",
        Slovenian => *b"SLV ",
        Spanish => *b"ESP ",
        Swedish => *b"SVE ",
        Tamil => *b"TAM ",
        Telugu => *b"TEL ",
        Thai => *b"THA ",
        Turkish => *b"TRK ",
        Turkmen => *b"TUK ",
        Ukrainian => *b"UKR ",
        Uppersorbian => *b"HSB ",
        Welsh => *b"CYM ",
    };
    u32::from_be_bytes(tag_bytes)
}

/// Internal shaping implementation - the single source of truth for text shaping.
/// Both FontRef and ParsedFont use this function.
fn shape_text_internal(
    parsed_font: &ParsedFont,
    text: &str,
    script: Script,
    language: crate::text3::script::Language,
    direction: BidiDirection,
    style: &StyleProperties,
) -> Result<Vec<Glyph>, LayoutError> {
    let script_tag = to_opentype_script_tag(script);
    #[cfg(feature = "text_layout_hyphenation")]
    let lang_tag = to_opentype_lang_tag(language);
    #[cfg(not(feature = "text_layout_hyphenation"))]
    let lang_tag = 0u32;

    let mut user_features: Vec<FeatureInfo> = style
        .font_features
        .iter()
        .filter_map(|s| parse_font_feature(s))
        .map(|(tag, value)| FeatureInfo {
            feature_tag: tag,
            alternate: if value > 1 {
                Some(value as usize)
            } else {
                None
            },
        })
        .collect();
    add_variant_features(style, &mut user_features);

    let opt_gdef = parsed_font.opt_gdef_table.as_ref().map(|v| &**v);

    let mut raw_glyphs: Vec<allsorts::gsub::RawGlyph<()>> = text
        .char_indices()
        .filter_map(|(cluster, ch)| {
            let glyph_index = parsed_font.lookup_glyph_index(ch as u32).unwrap_or(0);
            if cluster > u16::MAX as usize {
                None
            } else {
                Some(allsorts::gsub::RawGlyph {
                    unicodes: tinyvec::tiny_vec![[char; 1] => ch],
                    glyph_index,
                    liga_component_pos: cluster as u16,
                    glyph_origin: allsorts::gsub::GlyphOrigin::Char(ch),
                    flags: allsorts::gsub::RawGlyphFlags::empty(),
                    extra_data: (),
                    variation: None,
                })
            }
        })
        .collect();

    if let Some(gsub) = parsed_font.gsub_cache.as_ref() {
        let features = if user_features.is_empty() {
            Features::Mask(build_feature_mask_for_script(script))
        } else {
            Features::Custom(user_features.clone())
        };

        let dotted_circle_index = parsed_font
            .lookup_glyph_index(allsorts::DOTTED_CIRCLE as u32)
            .unwrap_or(0);
        gsub::apply(
            dotted_circle_index,
            gsub,
            opt_gdef,
            script_tag,
            Some(lang_tag),
            &features,
            None,
            parsed_font.num_glyphs(),
            &mut raw_glyphs,
        )
        .map_err(|e| LayoutError::ShapingError(e.to_string()))?;
    }

    let mut infos = gpos::Info::init_from_glyphs(opt_gdef, raw_glyphs);

    if let Some(gpos) = parsed_font.gpos_cache.as_ref() {
        let kern_table = parsed_font
            .opt_kern_table
            .as_ref()
            .map(|kt| kt.as_borrowed());
        let apply_kerning = kern_table.is_some();
        gpos::apply(
            gpos,
            opt_gdef,
            kern_table,
            apply_kerning,
            &Features::Custom(user_features),
            None,
            script_tag,
            Some(lang_tag),
            &mut infos,
        )
        .map_err(|e| LayoutError::ShapingError(e.to_string()))?;
    }

    let font_size = style.font_size_px;
    let scale_factor = if parsed_font.font_metrics.units_per_em > 0 {
        font_size / (parsed_font.font_metrics.units_per_em as f32)
    } else {
        0.01
    };

    let mut shaped_glyphs = Vec::new();
    for info in infos.iter() {
        let cluster = info.glyph.liga_component_pos as u32;
        let source_char = text
            .get(cluster as usize..)
            .and_then(|s| s.chars().next())
            .unwrap_or('\u{FFFD}');

        let base_advance = parsed_font.get_horizontal_advance(info.glyph.glyph_index);
        let advance = base_advance as f32 * scale_factor;
        let kerning = info.kerning as f32 * scale_factor;

        let (offset_x_units, offset_y_units) =
            if let allsorts::gpos::Placement::Distance(x, y) = info.placement {
                (x, y)
            } else {
                (0, 0)
            };
        let offset_x = offset_x_units as f32 * scale_factor;
        let offset_y = offset_y_units as f32 * scale_factor;

        let glyph = Glyph {
            glyph_id: info.glyph.glyph_index,
            codepoint: source_char,
            font_hash: parsed_font.get_hash(),
            font_metrics: LayoutFontMetrics {
                ascent: parsed_font.font_metrics.ascent,
                descent: parsed_font.font_metrics.descent,
                line_gap: parsed_font.font_metrics.line_gap,
                units_per_em: parsed_font.font_metrics.units_per_em,
            },
            style: Arc::new(style.clone()),
            source: GlyphSource::Char,
            logical_byte_index: cluster as usize,
            logical_byte_len: source_char.len_utf8(),
            content_index: 0,
            cluster,
            advance,
            kerning,
            offset: Point {
                x: offset_x,
                y: offset_y,
            },
            vertical_advance: 0.0,
            vertical_origin_y: 0.0,
            vertical_bearing: Point { x: 0.0, y: 0.0 },
            orientation: GlyphOrientation::Horizontal,
            script,
            bidi_level: BidiLevel::new(if direction.is_rtl() { 1 } else { 0 }),
        };
        shaped_glyphs.push(glyph);
    }

    Ok(shaped_glyphs)
}

/// Public helper function to shape text for ParsedFont, returning Glyph
/// This is used by the ParsedFontTrait implementation for ParsedFont
pub fn shape_text_for_parsed_font(
    parsed_font: &ParsedFont,
    text: &str,
    script: Script,
    language: crate::text3::script::Language,
    direction: BidiDirection,
    style: &StyleProperties,
) -> Result<Vec<Glyph>, LayoutError> {
    // Delegate to the single internal implementation
    shape_text_internal(parsed_font, text, script, language, direction, style)
}

```

================================================================================
## FILE: layout/src/text3/edit.rs
## Description: Text editing, cursor, selection
================================================================================
```
//! Pure functions for editing a `Vec<InlineContent>` based on selections.

use std::sync::Arc;

use azul_core::selection::{
    CursorAffinity, GraphemeClusterId, Selection, SelectionRange, TextCursor,
};

use crate::text3::cache::{ContentIndex, InlineContent, StyledRun};

/// An enum representing a single text editing action.
#[derive(Debug, Clone)]
pub enum TextEdit {
    Insert(String),
    DeleteBackward,
    DeleteForward,
}

/// The primary entry point for text modification. Takes the current content and selections,
/// applies an edit, and returns the new content and the resulting cursor positions.
pub fn edit_text(
    content: &[InlineContent],
    selections: &[Selection],
    edit: &TextEdit,
) -> (Vec<InlineContent>, Vec<Selection>) {
    if selections.is_empty() {
        return (content.to_vec(), Vec::new());
    }

    let mut new_content = content.to_vec();
    let mut new_selections = Vec::new();

    // To handle multiple cursors correctly, we must process edits
    // from the end of the document to the beginning. This ensures that
    // earlier edits do not invalidate the indices of later edits.
    let mut sorted_selections = selections.to_vec();
    sorted_selections.sort_by(|a, b| {
        let cursor_a = match a {
            Selection::Cursor(c) => c,
            Selection::Range(r) => &r.start,
        };
        let cursor_b = match b {
            Selection::Cursor(c) => c,
            Selection::Range(r) => &r.start,
        };
        cursor_b.cluster_id.cmp(&cursor_a.cluster_id) // Reverse sort
    });

    for selection in sorted_selections {
        let (mut temp_content, new_cursor) =
            apply_edit_to_selection(&new_content, &selection, edit);

        // When we insert/delete text, we need to adjust all previously-processed cursors
        // that come after this edit position in the same run
        let edit_run = match selection {
            Selection::Cursor(c) => c.cluster_id.source_run,
            Selection::Range(r) => r.start.cluster_id.source_run,
        };
        let edit_byte = match selection {
            Selection::Cursor(c) => c.cluster_id.start_byte_in_run,
            Selection::Range(r) => r.start.cluster_id.start_byte_in_run,
        };

        // Calculate the byte offset change
        let byte_offset_change: i32 = match edit {
            TextEdit::Insert(text) => text.len() as i32,
            TextEdit::DeleteBackward | TextEdit::DeleteForward => {
                // For simplicity, assume 1 grapheme deleted = some bytes
                // A full implementation would track actual bytes deleted
                -1
            }
        };

        // Adjust all previously-processed cursors in the same run that come after this position
        for prev_selection in new_selections.iter_mut() {
            if let Selection::Cursor(cursor) = prev_selection {
                if cursor.cluster_id.source_run == edit_run
                    && cursor.cluster_id.start_byte_in_run >= edit_byte
                {
                    cursor.cluster_id.start_byte_in_run =
                        (cursor.cluster_id.start_byte_in_run as i32 + byte_offset_change).max(0)
                            as u32;
                }
            }
        }

        new_content = temp_content;
        new_selections.push(Selection::Cursor(new_cursor));
    }

    // The new selections were added in reverse order, so we reverse them back.
    new_selections.reverse();

    (new_content, new_selections)
}

/// Applies a single edit to a single selection.
pub fn apply_edit_to_selection(
    content: &[InlineContent],
    selection: &Selection,
    edit: &TextEdit,
) -> (Vec<InlineContent>, TextCursor) {
    let mut new_content = content.to_vec();

    // First, if the selection is a range, we perform a deletion.
    // The result of a deletion is always a single cursor.
    let cursor_after_delete = match selection {
        Selection::Range(range) => {
            let (content_after_delete, cursor_pos) = delete_range(&new_content, range);
            new_content = content_after_delete;
            cursor_pos
        }
        Selection::Cursor(cursor) => *cursor,
    };

    // Now, apply the edit at the collapsed cursor position.
    match edit {
        TextEdit::Insert(text_to_insert) => {
            insert_text(&mut new_content, &cursor_after_delete, text_to_insert)
        }
        TextEdit::DeleteBackward => delete_backward(&mut new_content, &cursor_after_delete),
        TextEdit::DeleteForward => delete_forward(&mut new_content, &cursor_after_delete),
    }
}

/// Deletes the content within a given range.
pub fn delete_range(
    content: &[InlineContent],
    range: &SelectionRange,
) -> (Vec<InlineContent>, TextCursor) {
    // This is a highly complex function. A full implementation needs to handle:
    //
    // - Deletions within a single text run.
    // - Deletions that span across multiple text runs.
    // - Deletions that include non-text items like images.
    //
    // For now, we provide a simplified version that handles deletion within a
    // single run.

    let mut new_content = content.to_vec();
    let start_run_idx = range.start.cluster_id.source_run as usize;
    let end_run_idx = range.end.cluster_id.source_run as usize;

    if start_run_idx == end_run_idx {
        if let Some(InlineContent::Text(run)) = new_content.get_mut(start_run_idx) {
            let start_byte = range.start.cluster_id.start_byte_in_run as usize;
            let end_byte = range.end.cluster_id.start_byte_in_run as usize;
            if start_byte <= end_byte && end_byte <= run.text.len() {
                run.text.drain(start_byte..end_byte);
            }
        }
    } else {
        // TODO: Handle multi-run deletion
    }

    (new_content, range.start) // Return cursor at the start of the deleted range
}

/// Inserts text at a cursor position.
/// 
/// The cursor's affinity determines the exact insertion point:
/// - `Leading`: Insert at the start of the referenced cluster (start_byte_in_run)
/// - `Trailing`: Insert at the end of the referenced cluster (after the grapheme)
pub fn insert_text(
    content: &mut Vec<InlineContent>,
    cursor: &TextCursor,
    text_to_insert: &str,
) -> (Vec<InlineContent>, TextCursor) {
    use unicode_segmentation::UnicodeSegmentation;
    
    let mut new_content = content.clone();
    let run_idx = cursor.cluster_id.source_run as usize;
    let cluster_start_byte = cursor.cluster_id.start_byte_in_run as usize;

    if let Some(InlineContent::Text(run)) = new_content.get_mut(run_idx) {
        // Calculate the actual insertion byte offset based on affinity
        let byte_offset = match cursor.affinity {
            CursorAffinity::Leading => {
                // Insert at the start of the cluster
                cluster_start_byte
            },
            CursorAffinity::Trailing => {
                // Insert at the end of the cluster - find the next grapheme boundary
                // We need to find where this grapheme cluster ends
                if cluster_start_byte >= run.text.len() {
                    // Cursor is at/past end of run - insert at end
                    run.text.len()
                } else {
                    // Find the grapheme that starts at cluster_start_byte and get its end
                    run.text[cluster_start_byte..]
                        .grapheme_indices(true)
                        .next()
                        .map(|(_, grapheme)| cluster_start_byte + grapheme.len())
                        .unwrap_or(run.text.len())
                }
            },
        };
        
        if byte_offset <= run.text.len() {
            run.text.insert_str(byte_offset, text_to_insert);

            let new_cursor = TextCursor {
                cluster_id: GraphemeClusterId {
                    source_run: run_idx as u32,
                    start_byte_in_run: (byte_offset + text_to_insert.len()) as u32,
                },
                affinity: CursorAffinity::Leading,
            };
            return (new_content, new_cursor);
        }
    }

    // If insertion failed, return original state
    (content.to_vec(), *cursor)
}

/// Deletes one grapheme cluster backward from the cursor.
/// 
/// The cursor's affinity determines the actual cursor position:
/// - `Leading`: Cursor is at start of cluster, delete the previous grapheme
/// - `Trailing`: Cursor is at end of cluster, delete the current grapheme
pub fn delete_backward(
    content: &mut Vec<InlineContent>,
    cursor: &TextCursor,
) -> (Vec<InlineContent>, TextCursor) {
    use unicode_segmentation::UnicodeSegmentation;
    let mut new_content = content.clone();
    let run_idx = cursor.cluster_id.source_run as usize;
    let cluster_start_byte = cursor.cluster_id.start_byte_in_run as usize;

    if let Some(InlineContent::Text(run)) = new_content.get_mut(run_idx) {
        // Calculate the actual cursor byte offset based on affinity
        let byte_offset = match cursor.affinity {
            CursorAffinity::Leading => cluster_start_byte,
            CursorAffinity::Trailing => {
                // Cursor is at end of cluster - find the next grapheme boundary
                if cluster_start_byte >= run.text.len() {
                    run.text.len()
                } else {
                    run.text[cluster_start_byte..]
                        .grapheme_indices(true)
                        .next()
                        .map(|(_, grapheme)| cluster_start_byte + grapheme.len())
                        .unwrap_or(run.text.len())
                }
            },
        };
        
        if byte_offset > 0 {
            let prev_grapheme_start = run.text[..byte_offset]
                .grapheme_indices(true)
                .last()
                .map_or(0, |(i, _)| i);
            run.text.drain(prev_grapheme_start..byte_offset);

            let new_cursor = TextCursor {
                cluster_id: GraphemeClusterId {
                    source_run: run_idx as u32,
                    start_byte_in_run: prev_grapheme_start as u32,
                },
                affinity: CursorAffinity::Leading,
            };
            return (new_content, new_cursor);
        } else if run_idx > 0 {
            // Handle deleting across run boundaries (merge with previous run)
            if let Some(InlineContent::Text(prev_run)) = content.get(run_idx - 1).cloned() {
                let mut merged_text = prev_run.text;
                let new_cursor_byte_offset = merged_text.len();
                merged_text.push_str(&run.text);

                new_content[run_idx - 1] = InlineContent::Text(StyledRun {
                    text: merged_text,
                    style: prev_run.style,
                    logical_start_byte: prev_run.logical_start_byte,
                    source_node_id: prev_run.source_node_id,
                });
                new_content.remove(run_idx);

                let new_cursor = TextCursor {
                    cluster_id: GraphemeClusterId {
                        source_run: (run_idx - 1) as u32,
                        start_byte_in_run: new_cursor_byte_offset as u32,
                    },
                    affinity: CursorAffinity::Leading,
                };
                return (new_content, new_cursor);
            }
        }
    }

    (content.to_vec(), *cursor)
}

/// Deletes one grapheme cluster forward from the cursor.
/// 
/// The cursor's affinity determines the actual cursor position:
/// - `Leading`: Cursor is at start of cluster, delete the current grapheme
/// - `Trailing`: Cursor is at end of cluster, delete the next grapheme
pub fn delete_forward(
    content: &mut Vec<InlineContent>,
    cursor: &TextCursor,
) -> (Vec<InlineContent>, TextCursor) {
    use unicode_segmentation::UnicodeSegmentation;
    let mut new_content = content.clone();
    let run_idx = cursor.cluster_id.source_run as usize;
    let cluster_start_byte = cursor.cluster_id.start_byte_in_run as usize;

    if let Some(InlineContent::Text(run)) = new_content.get_mut(run_idx) {
        // Calculate the actual cursor byte offset based on affinity
        let byte_offset = match cursor.affinity {
            CursorAffinity::Leading => cluster_start_byte,
            CursorAffinity::Trailing => {
                // Cursor is at end of cluster - find the next grapheme boundary
                if cluster_start_byte >= run.text.len() {
                    run.text.len()
                } else {
                    run.text[cluster_start_byte..]
                        .grapheme_indices(true)
                        .next()
                        .map(|(_, grapheme)| cluster_start_byte + grapheme.len())
                        .unwrap_or(run.text.len())
                }
            },
        };
        
        if byte_offset < run.text.len() {
            let next_grapheme_end = run.text[byte_offset..]
                .grapheme_indices(true)
                .nth(1)
                .map_or(run.text.len(), |(i, _)| byte_offset + i);
            run.text.drain(byte_offset..next_grapheme_end);

            // Cursor position stays at the same byte offset but with Leading affinity
            let new_cursor = TextCursor {
                cluster_id: GraphemeClusterId {
                    source_run: run_idx as u32,
                    start_byte_in_run: byte_offset as u32,
                },
                affinity: CursorAffinity::Leading,
            };
            return (new_content, new_cursor);
        } else if run_idx < content.len() - 1 {
            // Handle deleting across run boundaries (merge with next run)
            if let Some(InlineContent::Text(next_run)) = content.get(run_idx + 1).cloned() {
                let mut merged_text = run.text.clone();
                merged_text.push_str(&next_run.text);

                new_content[run_idx] = InlineContent::Text(StyledRun {
                    text: merged_text,
                    style: run.style.clone(),
                    logical_start_byte: run.logical_start_byte,
                    source_node_id: run.source_node_id,
                });
                new_content.remove(run_idx + 1);

                return (new_content, *cursor);
            }
        }
    }

    (content.to_vec(), *cursor)
}

/// Inspect what would be deleted by a delete operation without actually deleting
///
/// Returns (range_that_would_be_deleted, text_that_would_be_deleted).
/// This is useful for callbacks to inspect pending delete operations.
///
/// # Arguments
///
/// - `content` - The current text content
/// - `selection` - The current selection (cursor or range)
/// - `forward` - If true, delete forward (Delete key); if false, delete backward (Backspace key)
///
/// # Returns
///
/// - `Some((range, deleted_text))` - The range and text that would be deleted
/// - `None` - Nothing would be deleted (e.g., cursor at start/end of document)
pub fn inspect_delete(
    content: &[InlineContent],
    selection: &Selection,
    forward: bool,
) -> Option<(SelectionRange, String)> {
    match selection {
        Selection::Range(range) => {
            // If there's already a selection, that's what would be deleted
            let deleted_text = extract_text_in_range(content, range);
            Some((*range, deleted_text))
        }
        Selection::Cursor(cursor) => {
            // No selection - would delete one grapheme cluster
            if forward {
                inspect_delete_forward(content, cursor)
            } else {
                inspect_delete_backward(content, cursor)
            }
        }
    }
}

/// Inspect what would be deleted by delete-forward (Delete key)
fn inspect_delete_forward(
    content: &[InlineContent],
    cursor: &TextCursor,
) -> Option<(SelectionRange, String)> {
    use unicode_segmentation::UnicodeSegmentation;

    let run_idx = cursor.cluster_id.source_run as usize;
    let byte_offset = cursor.cluster_id.start_byte_in_run as usize;

    if let Some(InlineContent::Text(run)) = content.get(run_idx) {
        if byte_offset < run.text.len() {
            // Delete within same run
            let next_grapheme_end = run.text[byte_offset..]
                .grapheme_indices(true)
                .nth(1)
                .map_or(run.text.len(), |(i, _)| byte_offset + i);

            let deleted_text = run.text[byte_offset..next_grapheme_end].to_string();

            let range = SelectionRange {
                start: *cursor,
                end: TextCursor {
                    cluster_id: GraphemeClusterId {
                        source_run: run_idx as u32,
                        start_byte_in_run: next_grapheme_end as u32,
                    },
                    affinity: CursorAffinity::Leading,
                },
            };

            return Some((range, deleted_text));
        } else if run_idx < content.len() - 1 {
            // Would delete across run boundary
            if let Some(InlineContent::Text(next_run)) = content.get(run_idx + 1) {
                let deleted_text = next_run.text.graphemes(true).next()?.to_string();

                let next_grapheme_end = next_run
                    .text
                    .grapheme_indices(true)
                    .nth(1)
                    .map_or(next_run.text.len(), |(i, _)| i);

                let range = SelectionRange {
                    start: *cursor,
                    end: TextCursor {
                        cluster_id: GraphemeClusterId {
                            source_run: (run_idx + 1) as u32,
                            start_byte_in_run: next_grapheme_end as u32,
                        },
                        affinity: CursorAffinity::Leading,
                    },
                };

                return Some((range, deleted_text));
            }
        }
    }

    None // At end of document, nothing to delete
}

/// Inspect what would be deleted by delete-backward (Backspace key)
fn inspect_delete_backward(
    content: &[InlineContent],
    cursor: &TextCursor,
) -> Option<(SelectionRange, String)> {
    use unicode_segmentation::UnicodeSegmentation;

    let run_idx = cursor.cluster_id.source_run as usize;
    let byte_offset = cursor.cluster_id.start_byte_in_run as usize;

    if let Some(InlineContent::Text(run)) = content.get(run_idx) {
        if byte_offset > 0 {
            // Delete within same run
            let prev_grapheme_start = run.text[..byte_offset]
                .grapheme_indices(true)
                .last()
                .map_or(0, |(i, _)| i);

            let deleted_text = run.text[prev_grapheme_start..byte_offset].to_string();

            let range = SelectionRange {
                start: TextCursor {
                    cluster_id: GraphemeClusterId {
                        source_run: run_idx as u32,
                        start_byte_in_run: prev_grapheme_start as u32,
                    },
                    affinity: CursorAffinity::Leading,
                },
                end: *cursor,
            };

            return Some((range, deleted_text));
        } else if run_idx > 0 {
            // Would delete across run boundary
            if let Some(InlineContent::Text(prev_run)) = content.get(run_idx - 1) {
                let deleted_text = prev_run.text.graphemes(true).last()?.to_string();

                let prev_grapheme_start = prev_run.text[..]
                    .grapheme_indices(true)
                    .last()
                    .map_or(0, |(i, _)| i);

                let range = SelectionRange {
                    start: TextCursor {
                        cluster_id: GraphemeClusterId {
                            source_run: (run_idx - 1) as u32,
                            start_byte_in_run: prev_grapheme_start as u32,
                        },
                        affinity: CursorAffinity::Leading,
                    },
                    end: *cursor,
                };

                return Some((range, deleted_text));
            }
        }
    }

    None // At start of document, nothing to delete
}

/// Extract the text within a selection range
fn extract_text_in_range(content: &[InlineContent], range: &SelectionRange) -> String {
    let start_run = range.start.cluster_id.source_run as usize;
    let end_run = range.end.cluster_id.source_run as usize;
    let start_byte = range.start.cluster_id.start_byte_in_run as usize;
    let end_byte = range.end.cluster_id.start_byte_in_run as usize;

    if start_run == end_run {
        // Single run
        if let Some(InlineContent::Text(run)) = content.get(start_run) {
            if start_byte <= end_byte && end_byte <= run.text.len() {
                return run.text[start_byte..end_byte].to_string();
            }
        }
    } else {
        // Multi-run selection (simplified - full implementation would handle images, etc.)
        let mut result = String::new();

        for (idx, item) in content.iter().enumerate() {
            if let InlineContent::Text(run) = item {
                if idx == start_run {
                    // First run - from start_byte to end
                    if start_byte < run.text.len() {
                        result.push_str(&run.text[start_byte..]);
                    }
                } else if idx > start_run && idx < end_run {
                    // Middle runs - entire text
                    result.push_str(&run.text);
                } else if idx == end_run {
                    // Last run - from 0 to end_byte
                    if end_byte <= run.text.len() {
                        result.push_str(&run.text[..end_byte]);
                    }
                    break;
                }
            }
        }

        return result;
    }

    String::new()
}

```

================================================================================
## FILE: layout/src/text3/glyphs.rs
## Description: Text editing, cursor, selection
================================================================================
```
//! A helper module to extract final, absolute glyph positions from a layout.
//! This is useful for renderers that work with simple lists of glyphs.

use std::sync::Arc;

use azul_core::{
    dom::NodeId,
    geom::{LogicalPosition, LogicalSize},
    ui_solver::GlyphInstance,
};
use azul_css::props::basic::ColorU;
use azul_css::props::style::StyleBackgroundContent;

use crate::text3::cache::{
    get_item_vertical_metrics, InlineBorderInfo, LoadedFonts, ParsedFontTrait, Point,
    PositionedItem, ShapedGlyph, ShapedItem, UnifiedLayout,
};

/// Represents a single glyph ready for rendering, with an absolute position on the baseline.
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct PositionedGlyph {
    pub glyph_id: u16,
    /// The absolute position of the glyph's origin on the baseline.
    pub position: Point,
    /// The advance width of the glyph, useful for caret placement.
    pub advance: f32,
}

/// A simple glyph run without font reference - used when fonts aren't available.
/// The font can be looked up later via font_hash if needed.
#[derive(Debug, Clone)]
pub struct SimpleGlyphRun {
    /// The glyphs in this run, with their positions relative to the start of the run.
    pub glyphs: Vec<GlyphInstance>,
    /// The color of the text in this glyph run.
    pub color: ColorU,
    /// Background color for this run (rendered behind text)
    pub background_color: Option<ColorU>,
    /// Full background content layers (for gradients, images, etc.)
    pub background_content: Vec<StyleBackgroundContent>,
    /// Border information for inline elements
    pub border: Option<InlineBorderInfo>,
    /// A hash of the font, useful for caching purposes.
    pub font_hash: u64,
    /// The font size in pixels.
    pub font_size_px: f32,
    /// Text decoration (underline, strikethrough, overline)
    pub text_decoration: crate::text3::cache::TextDecoration,
    /// Whether this is an IME composition preview (should be rendered with special styling)
    pub is_ime_preview: bool,
    /// The source DOM node that generated this text run (for hit-testing)
    pub source_node_id: Option<NodeId>,
}

#[derive(Debug, Clone)]
pub struct GlyphRun<T: ParsedFontTrait> {
    /// The glyphs in this run, with their positions relative to the start of the run.
    pub glyphs: Vec<GlyphInstance>,
    /// The color of the text in this glyph run.
    pub color: ColorU,
    /// The font used for this glyph run.
    pub font: T, // Changed from Arc<T> - T is already cheap to clone (e.g. FontRef)
    /// A hash of the font, useful for caching purposes.
    pub font_hash: u64,
    /// The font size in pixels.
    pub font_size_px: f32,
    /// Text decoration (underline, strikethrough, overline)
    pub text_decoration: crate::text3::cache::TextDecoration,
    /// Whether this is an IME composition preview (should be rendered with special styling)
    pub is_ime_preview: bool,
}

/// Simple version of get_glyph_runs that doesn't require fonts.
/// Use this when you only need glyph positions and don't need font references.
pub fn get_glyph_runs_simple(layout: &UnifiedLayout) -> Vec<SimpleGlyphRun> {
    let mut runs: Vec<SimpleGlyphRun> = Vec::new();
    let mut current_run: Option<SimpleGlyphRun> = None;

    for item in &layout.items {
        let (item_ascent, _) = get_item_vertical_metrics(&item.item);
        let baseline_y = item.position.y + item_ascent;

        let mut process_glyphs =
            |positioned_glyphs: &[ShapedGlyph],
             item_origin_x: f32,
             writing_mode: crate::text3::cache::WritingMode,
             source_node_id: Option<NodeId>| {
                let mut pen_x = item_origin_x;

                for glyph in positioned_glyphs {
                    let glyph_color = glyph.style.color;
                    let glyph_background = glyph.style.background_color;
                    let glyph_background_content = glyph.style.background_content.clone();
                    let glyph_border = glyph.style.border.clone();
                    let font_hash = glyph.font_hash;
                    let font_size_px = glyph.style.font_size_px;
                    let text_decoration = glyph.style.text_decoration.clone();

                    let absolute_position = LogicalPosition {
                        x: pen_x + glyph.offset.x,
                        y: baseline_y - glyph.offset.y,
                    };

                    let instance =
                        glyph.into_glyph_instance_at_simple(writing_mode, absolute_position);

                    if let Some(run) = current_run.as_mut() {
                        // Break run if any style property changes (including background, gradient, border, or source node)
                        if run.font_hash == font_hash
                            && run.color == glyph_color
                            && run.background_color == glyph_background
                            && run.background_content == glyph_background_content
                            && run.border == glyph_border
                            && run.font_size_px == font_size_px
                            && run.text_decoration == text_decoration
                            && run.source_node_id == source_node_id
                        {
                            run.glyphs.push(instance);
                        } else {
                            runs.push(run.clone());
                            current_run = Some(SimpleGlyphRun {
                                glyphs: vec![instance],
                                color: glyph_color,
                                background_color: glyph_background,
                                background_content: glyph_background_content.clone(),
                                border: glyph_border.clone(),
                                font_hash,
                                font_size_px,
                                text_decoration: text_decoration.clone(),
                                is_ime_preview: false,
                                source_node_id,
                            });
                        }
                    } else {
                        current_run = Some(SimpleGlyphRun {
                            glyphs: vec![instance],
                            color: glyph_color,
                            background_color: glyph_background,
                            background_content: glyph_background_content.clone(),
                            border: glyph_border.clone(),
                            font_hash,
                            font_size_px,
                            text_decoration: text_decoration.clone(),
                            is_ime_preview: false,
                            source_node_id,
                        });
                    }

                    pen_x += glyph.advance;
                }
            };

        match &item.item {
            ShapedItem::Cluster(cluster) => {
                let writing_mode = cluster.style.writing_mode;
                process_glyphs(&cluster.glyphs, item.position.x, writing_mode, cluster.source_node_id);
            }
            ShapedItem::CombinedBlock { glyphs, .. } => {
                for g in glyphs {
                    let writing_mode = g.style.writing_mode;
                    // CombinedBlock is for tate-chu-yoko, use None for source_node_id
                    process_glyphs(&[g.clone()], item.position.x, writing_mode, None);
                }
            }
            _ => {}
        }
    }

    if let Some(run) = current_run {
        runs.push(run);
    }

    runs
}

/// Same as `get_glyph_positions`, but returns a list of `GlyphRun`s
/// instead of a flat list of glyphs. This groups glyphs by their font and
/// color, which can be more efficient for rendering.
pub fn get_glyph_runs<T: ParsedFontTrait>(
    layout: &UnifiedLayout,
    fonts: &LoadedFonts<T>,
) -> Vec<GlyphRun<T>> {
    // Group glyphs by font and color
    let mut runs: Vec<GlyphRun<T>> = Vec::new();
    let mut current_run: Option<GlyphRun<T>> = None;

    for item in &layout.items {
        // We need the ascent of the item to find its baseline from its top-left position.
        let (item_ascent, _) = get_item_vertical_metrics(&item.item);
        let baseline_y = item.position.y + item_ascent;

        let mut process_glyphs =
            |positioned_glyphs: &[ShapedGlyph],
             item_origin_x: f32,
             writing_mode: crate::text3::cache::WritingMode| {
                let mut pen_x = item_origin_x;

                for glyph in positioned_glyphs {
                    let glyph_color = glyph.style.color;
                    let font_hash = glyph.font_hash;
                    let font_size_px = glyph.style.font_size_px;
                    let text_decoration = glyph.style.text_decoration.clone();

                    // Look up the font from the fonts container
                    let font = match fonts.get_by_hash(font_hash) {
                        Some(f) => f.clone(),
                        None => continue, // Skip glyphs with unknown fonts
                    };

                    // Calculate absolute position: baseline position + GPOS offset
                    let absolute_position = LogicalPosition {
                        x: pen_x + glyph.offset.x,
                        y: baseline_y - glyph.offset.y, // Y-down: subtract positive offset
                    };

                    let instance =
                        glyph.into_glyph_instance_at(writing_mode, absolute_position, fonts);

                    // Check if we can add to the current run
                    if let Some(run) = current_run.as_mut() {
                        if run.font_hash == font_hash
                            && run.color == glyph_color
                            && run.font_size_px == font_size_px
                            && run.text_decoration == text_decoration
                        {
                            run.glyphs.push(instance);
                        } else {
                            // Different font, color, size, or decoration: finalize the
                            // current run and start a new one
                            runs.push(run.clone());
                            current_run = Some(GlyphRun {
                                glyphs: vec![instance],
                                color: glyph_color,
                                font: font.clone(),
                                font_hash,
                                font_size_px,
                                text_decoration: text_decoration.clone(),
                                is_ime_preview: false, // TODO: Set from input context
                            });
                        }
                    } else {
                        // Start a new run
                        current_run = Some(GlyphRun {
                            glyphs: vec![instance],
                            color: glyph_color,
                            font: font.clone(),
                            font_hash,
                            font_size_px,
                            text_decoration: text_decoration.clone(),
                            is_ime_preview: false, // TODO: Set from input context
                        });
                    }

                    // Advance the pen for the next glyph in the cluster/block.
                    // TODO: writing-mode support (vertical text) here
                    pen_x += glyph.advance;
                }
            };

        match &item.item {
            ShapedItem::Cluster(cluster) => {
                let writing_mode = cluster.style.writing_mode;
                process_glyphs(&cluster.glyphs, item.position.x, writing_mode);
            }
            // This is a rare case for tate-chu-yoko (mixed horizontal+vertical text)
            ShapedItem::CombinedBlock {
                glyphs,
                source,
                bounds,
                baseline_offset,
            } => {
                for g in glyphs {
                    let writing_mode = g.style.writing_mode;
                    process_glyphs(&[g.clone()], item.position.x, writing_mode);
                }
            }
            _ => {
                // Ignore non-text items like objects, breaks, etc.
            }
        }
    }

    if let Some(run) = current_run {
        runs.push(run);
    }

    runs
}

/// A glyph run optimized for PDF rendering.
///
/// Groups glyphs by font, color, size, and style, while breaking at line boundaries.
/// This struct is used by the PDF renderer to efficiently render text with proper
/// styling, including inline background colors for `<span>` elements.
///
/// # Z-Order for Inline Backgrounds
///
/// The `background_color` field enables proper z-ordering of inline backgrounds:
/// - PDF renderers should iterate over all runs and render backgrounds FIRST
/// - Then iterate again and render all text SECOND
/// - This ensures backgrounds appear behind text, not on top of it
///
/// The display list (`paint_inline_content`) does NOT emit `push_rect()` for inline
/// backgrounds because that would cause double-rendering and z-order issues.
#[derive(Debug, Clone)]
pub struct PdfGlyphRun<T: ParsedFontTrait> {
    /// The glyphs in this run with their absolute positions
    pub glyphs: Vec<PdfPositionedGlyph>,
    /// The color of the text
    pub color: ColorU,
    /// Background color for inline elements (e.g., `<span style="background: yellow">`)
    ///
    /// This is rendered as a filled rectangle behind the text by the PDF renderer.
    /// The rectangle spans from ascent to descent and covers the full width of the run.
    pub background_color: Option<ColorU>,
    /// The font used for this run
    pub font: T,
    /// Font hash for identification
    pub font_hash: u64,
    /// Font size in pixels
    pub font_size_px: f32,
    /// Text decoration flags
    pub text_decoration: crate::text3::cache::TextDecoration,
    /// The line index this run belongs to (for breaking runs at line boundaries)
    pub line_index: usize,
    /// Text direction for this run
    pub direction: crate::text3::cache::BidiDirection,
    /// Writing mode for this run
    pub writing_mode: crate::text3::cache::WritingMode,
    /// The starting position (baseline) of this run - used for SetTextMatrix
    pub baseline_start: Point,
    /// Original cluster text for debugging/CID mapping
    pub cluster_texts: Vec<String>,
}

/// A glyph with its absolute position and cluster text for PDF rendering
#[derive(Debug, Clone)]
pub struct PdfPositionedGlyph {
    /// Glyph ID
    pub glyph_id: u16,
    /// Absolute position on the baseline (Y-down coordinate system)
    pub position: Point,
    /// The advance width of this glyph
    pub advance: f32,
    /// The Unicode character(s) this glyph represents (for PDF ToUnicode CMap)
    /// This is extracted from the cluster text using the glyph's cluster_offset
    pub unicode_codepoint: String,
}

/// Extract glyph runs optimized for PDF rendering.
/// This function:
/// - Groups consecutive glyphs by font, color, size, style, and line
/// - Breaks runs at line boundaries (different line_index)
/// - Preserves absolute positioning for each glyph (critical for RTL and complex scripts)
/// - Includes cluster text for proper CID/Unicode mapping
pub fn get_glyph_runs_pdf<T: ParsedFontTrait>(
    layout: &UnifiedLayout,
    fonts: &LoadedFonts<T>,
) -> Vec<PdfGlyphRun<T>> {
    let mut runs: Vec<PdfGlyphRun<T>> = Vec::new();
    let mut current_run: Option<PdfGlyphRun<T>> = None;

    for positioned_item in &layout.items {
        // Only process text clusters
        let cluster = match &positioned_item.item {
            ShapedItem::Cluster(c) => c,
            _ => continue, // Skip non-text items
        };

        if cluster.glyphs.is_empty() {
            continue;
        }

        // Calculate the baseline position for this cluster
        let (item_ascent, _) = get_item_vertical_metrics(&positioned_item.item);
        let baseline_y = positioned_item.position.y + item_ascent;

        // Process each glyph in the cluster
        let mut pen_x = positioned_item.position.x;

        // For extracting the correct unicode codepoint per glyph, we need to track
        // which portion of the cluster text each glyph represents.
        // The cluster_offset in ShapedGlyph is the byte offset into cluster.text
        let cluster_text = &cluster.text;
        let cluster_glyphs_count = cluster.glyphs.len();

        for (glyph_idx, glyph) in cluster.glyphs.iter().enumerate() {
            let glyph_color = glyph.style.color;
            let glyph_background = glyph.style.background_color;
            let font_hash = glyph.font_hash;
            let font_size_px = glyph.style.font_size_px;
            let text_decoration = glyph.style.text_decoration.clone();
            let line_index = positioned_item.line_index;
            let direction = cluster.direction;
            let writing_mode = cluster.style.writing_mode;

            // Look up the font from the fonts container
            let font = match fonts.get_by_hash(font_hash) {
                Some(f) => f.clone(),
                None => continue, // Skip glyphs with unknown fonts
            };

            // Calculate absolute glyph position on baseline
            let glyph_position = Point {
                x: pen_x + glyph.offset.x,
                y: baseline_y - glyph.offset.y, // Y-down: subtract positive GPOS offset
            };

            // Extract the unicode codepoint for this specific glyph
            // For simple 1:1 mappings, each glyph gets one character
            // For complex scripts (ligatures, etc.), we may need to assign
            // the whole cluster text to the first glyph, or split it appropriately
            let unicode_codepoint = if cluster_glyphs_count == 1 {
                // Simple case: one glyph represents the entire cluster
                cluster_text.clone()
            } else {
                // Multiple glyphs in cluster - try to extract the character at cluster_offset
                // cluster_offset is the byte offset into the cluster text
                let byte_offset = glyph.cluster_offset as usize;
                if byte_offset < cluster_text.len() {
                    // Get the character at this byte offset
                    cluster_text[byte_offset..]
                        .chars()
                        .next()
                        .map(|c| c.to_string())
                        .unwrap_or_else(|| cluster_text.clone())
                } else {
                    // Fallback: if offset is out of range, use the whole cluster for first glyph
                    // or empty for subsequent glyphs (they share the same codepoint)
                    if glyph_idx == 0 {
                        cluster_text.clone()
                    } else {
                        String::new()
                    }
                }
            };

            let pdf_glyph = PdfPositionedGlyph {
                glyph_id: glyph.glyph_id,
                position: glyph_position,
                advance: glyph.advance,
                unicode_codepoint,
            };

            // Check if we can add to the current run
            // Break the run if any style property or line changes (including background)
            let should_break = if let Some(run) = current_run.as_ref() {
                run.font_hash != font_hash
                    || run.color != glyph_color
                    || run.background_color != glyph_background
                    || run.font_size_px != font_size_px
                    || run.text_decoration != text_decoration
                    || run.line_index != line_index
                    || run.direction != direction
                    || run.writing_mode != writing_mode
            } else {
                false
            };

            if should_break {
                // Finalize the current run and start a new one
                if let Some(run) = current_run.take() {
                    runs.push(run);
                }
            }

            if let Some(run) = current_run.as_mut() {
                // Add to existing run
                run.glyphs.push(pdf_glyph);
                run.cluster_texts.push(cluster.text.clone());
            } else {
                // Start a new run
                current_run = Some(PdfGlyphRun {
                    glyphs: vec![pdf_glyph],
                    color: glyph_color,
                    background_color: glyph_background,
                    font: font.clone(),
                    font_hash,
                    font_size_px,
                    text_decoration: text_decoration.clone(),
                    line_index,
                    direction,
                    writing_mode,
                    baseline_start: Point {
                        x: pen_x,
                        y: baseline_y,
                    },
                    cluster_texts: vec![cluster.text.clone()],
                });
            }

            // Advance pen position - DON'T add kerning here because it's already
            // included in the positioned_item.position.x from the layout engine!
            // We only advance by the base advance to track our position within this cluster
            let old_pen_x = pen_x;
            pen_x += glyph.advance;
        }
    }

    // Push the final run if any
    if let Some(run) = current_run {
        runs.push(run);
    }

    runs
}

/// Transforms the final layout into a simple list of glyphs and their absolute positions.
///
/// This function iterates through all positioned items in a layout, filtering for text clusters
/// and combined text blocks. It calculates the absolute baseline position for each glyph within
/// these items and returns a flat vector of `PositionedGlyph` structs. This is useful for
/// rendering or for clients that need a lower-level representation of the text layout.
///
/// # Arguments
///
/// - `layout` - A reference to the final `UnifiedLayout` produced by the pipeline.
///
/// # Returns
///
/// A `Vec<PositionedGlyph>` containing all glyphs from the layout with their
/// absolute baseline positions.
pub fn get_glyph_positions(layout: &UnifiedLayout) -> Vec<PositionedGlyph> {
    let mut final_glyphs = Vec::new();

    for item in &layout.items {
        // We need the ascent of the item to find its baseline from its top-left position.
        let (item_ascent, _) = get_item_vertical_metrics(&item.item);
        let baseline_y = item.position.y + item_ascent;

        let mut process_glyphs = |positioned_glyphs: &[ShapedGlyph], item_origin_x: f32| {
            let mut pen_x = item_origin_x;
            for glyph in positioned_glyphs {
                // The glyph's final position is its origin on the baseline.
                // GPOS y-offsets shift the glyph up or down relative to the baseline.
                // In a Y-down coordinate system, a positive GPOS offset (up) means
                // subtracting from Y.
                let glyph_pos = Point {
                    x: pen_x + glyph.offset.x,
                    y: baseline_y - glyph.offset.y,
                };

                final_glyphs.push(PositionedGlyph {
                    glyph_id: glyph.glyph_id,
                    position: glyph_pos,
                    advance: glyph.advance,
                });

                // Advance the pen for the next glyph in the cluster/block.
                pen_x += glyph.advance;
            }
        };

        match &item.item {
            ShapedItem::Cluster(cluster) => {
                process_glyphs(&cluster.glyphs, item.position.x);
            }
            ShapedItem::CombinedBlock { glyphs, .. } => {
                // This assumes horizontal layout for the combined block's glyphs.
                process_glyphs(glyphs, item.position.x);
            }
            _ => {
                // Ignore non-text items like objects, breaks, etc.
            }
        }
    }

    final_glyphs
}

```

================================================================================
## FILE: layout/src/text3/knuth_plass.rs
## Description: Text editing, cursor, selection
================================================================================
```
//! An implementation of the Knuth-Plass line-breaking algorithm
//! for simple rectangular layouts.

use std::sync::Arc;

#[cfg(feature = "text_layout_hyphenation")]
use hyphenation::{Hyphenator, Standard};
#[cfg(not(feature = "text_layout_hyphenation"))]
use crate::text3::cache::Standard;

use crate::text3::cache::{
    get_base_direction_from_logical, get_item_measure, is_word_separator, AvailableSpace,
    BidiDirection, GlyphKind, JustifyContent, LayoutError, LoadedFonts, LogicalItem, OverflowInfo,
    ParsedFontTrait, Point, PositionedItem, Rect, ShapedCluster, ShapedGlyph, ShapedItem,
    TextAlign, UnifiedConstraints, UnifiedLayout,
};

const INFINITY_BADNESS: f32 = 10000.0;

/// Represents the elements of a paragraph for the line-breaking algorithm.
#[derive(Debug, Clone)]
enum LayoutNode {
    /// A non-stretchable, non-shrinkable item (a glyph cluster or an object).
    Box(ShapedItem, f32), // Item and its width
    /// A flexible space.
    Glue {
        item: ShapedItem,
        width: f32,
        stretch: f32,
        shrink: f32,
    },
    /// A point where a line break is allowed, with an associated cost.
    Penalty {
        /// Optional item associated with the penalty (e.g., a hyphen glyph).
        item: Option<ShapedItem>,
        width: f32,
        penalty: f32,
    },
}

/// Stores the result of the dynamic programming algorithm for a given point.
#[derive(Debug, Clone, Copy)]
struct Breakpoint {
    /// The total demerit score to reach this point.
    demerit: f32,
    /// The index of the previous breakpoint in the optimal path.
    previous: usize,
    /// The line number this breakpoint ends.
    line: usize,
}

/// Main entry point for the Knuth-Plass layout algorithm.
///
/// This implements optimal line-breaking as described in "Breaking Paragraphs into Lines"
/// (Knuth & Plass, 1981). Unlike greedy algorithms, it considers the entire paragraph
/// to find globally optimal break points.
///
/// # Use Cases
///
/// - `text-wrap: balance` - CSS property for balanced line lengths
/// - High-quality typesetting where line consistency matters
/// - Multi-line headings that should appear visually balanced
///
/// # Limitations
///
/// - Only supports horizontal text (vertical writing modes use greedy algorithm)
/// - Higher computational cost than greedy breaking
/// - May produce different results than browsers for edge cases
pub(crate) fn kp_layout<T: ParsedFontTrait>(
    items: &[ShapedItem],
    logical_items: &[LogicalItem],
    constraints: &UnifiedConstraints,
    hyphenator: Option<&Standard>,
    fonts: &LoadedFonts<T>,
) -> Result<UnifiedLayout, LayoutError> {
    if items.is_empty() {
        return Ok(UnifiedLayout {
            items: Vec::new(),
            overflow: OverflowInfo::default(),
        });
    }

    // Convert ShapedItems into a sequence of Boxes, Glue, and Penalties
    let nodes = convert_items_to_nodes(items, hyphenator, fonts);

    // Dynamic Programming to find optimal breakpoints
    let breaks = find_optimal_breakpoints(&nodes, constraints);

    // Use breakpoints to build and position the final lines
    let final_layout: UnifiedLayout =
        position_lines_from_breaks(&nodes, &breaks, logical_items, constraints);

    Ok(final_layout)
}

/// Converts a slice of ShapedItems into the Box/Glue/Penalty model.
fn convert_items_to_nodes<T: ParsedFontTrait>(
    items: &[ShapedItem],
    hyphenator: Option<&Standard>,
    fonts: &LoadedFonts<T>,
) -> Vec<LayoutNode> {
    let mut nodes = Vec::new();
    let is_vertical = false; // Knuth-Plass is horizontal-only for now
    let mut item_iter = items.iter().peekable();

    while let Some(item) = item_iter.next() {
        match item {
            item if is_word_separator(item) => {
                let width = get_item_measure(item, is_vertical);
                nodes.push(LayoutNode::Glue {
                    item: item.clone(),
                    width,
                    stretch: width * 0.5,
                    shrink: width * 0.33,
                });
                nodes.push(LayoutNode::Penalty {
                    item: None,
                    width: 0.0,
                    penalty: 0.0,
                });
            }
            ShapedItem::Cluster(cluster) => {
                // 1. Collect all adjacent clusters to form a full "word".
                let mut current_word_clusters = vec![cluster.clone()];
                while let Some(peeked_item) = item_iter.peek() {
                    if let ShapedItem::Cluster(next_cluster) = peeked_item {
                        current_word_clusters.push(next_cluster.clone());
                        item_iter.next(); // Consume the peeked item
                    } else {
                        // Stop if we hit a non-cluster item (space, object, etc.)
                        break;
                    }
                }

                // 2. Try to find all hyphenation opportunities for this word.
                let hyphenation_breaks = hyphenator.and_then(|h| {
                    crate::text3::cache::find_all_hyphenation_breaks(
                        &current_word_clusters,
                        h,
                        is_vertical,
                        fonts,
                    )
                });

                if hyphenation_breaks.is_none() {
                    // No hyphenation possible, add the whole word as boxes.
                    for c in current_word_clusters {
                        nodes.push(LayoutNode::Box(ShapedItem::Cluster(c.clone()), c.advance));
                    }
                } else {
                    // 3. Convert word + hyphenation breaks into a sequence of Boxes and Penalties.
                    let breaks = hyphenation_breaks.unwrap();
                    let mut current_item_cursor = 0;

                    for b in breaks.iter() {
                        // Add the items that form the next syllable (the part between the last
                        // break and this one)
                        let num_items_in_syllable = b.line_part.len() - current_item_cursor;
                        for item in b.line_part.iter().skip(current_item_cursor) {
                            nodes.push(LayoutNode::Box(
                                item.clone(),
                                get_item_measure(item, is_vertical),
                            ));
                        }
                        current_item_cursor += num_items_in_syllable;

                        // Add the hyphen penalty
                        let hyphen_measure = get_item_measure(&b.hyphen_item, is_vertical);
                        nodes.push(LayoutNode::Penalty {
                            item: Some(b.hyphen_item.clone()),
                            width: hyphen_measure,
                            penalty: 50.0, // Standard penalty for hyphenation
                        });
                    }

                    // Add the final remainder of the word.
                    if let Some(last_break) = breaks.last() {
                        for remainder_item in &last_break.remainder_part {
                            nodes.push(LayoutNode::Box(
                                remainder_item.clone(),
                                get_item_measure(remainder_item, is_vertical),
                            ));
                        }
                    } else {
                        // This case happens if find_all_hyphenation_breaks returned an empty vec.
                        // Fallback to just adding the original word.
                        for c in current_word_clusters {
                            nodes.push(LayoutNode::Box(ShapedItem::Cluster(c.clone()), c.advance));
                        }
                    }
                }
            }
            ShapedItem::Object { .. } | ShapedItem::CombinedBlock { .. } => {
                nodes.push(LayoutNode::Box(
                    item.clone(),
                    get_item_measure(item, is_vertical),
                ));
            }
            ShapedItem::Tab { bounds, .. } => {
                nodes.push(LayoutNode::Glue {
                    item: item.clone(),
                    width: bounds.width,
                    stretch: bounds.width * 0.5, // Treat like a space for flexibility
                    shrink: bounds.width * 0.33,
                });
            }
            ShapedItem::Break { .. } => {
                nodes.push(LayoutNode::Penalty {
                    item: None,
                    width: 0.0,
                    penalty: -INFINITY_BADNESS,
                });
            }
        }
    }

    nodes
}

/// Uses dynamic programming to find the optimal set of line breaks.
fn find_optimal_breakpoints(nodes: &[LayoutNode], constraints: &UnifiedConstraints) -> Vec<usize> {
    // For Knuth-Plass, we need a definite line width.
    //
    // For MaxContent, use a very large value (no line breaks unless forced).
    // For MinContent, use 0.0 (break at every opportunity).

    let line_width = match constraints.available_width {
        AvailableSpace::Definite(w) => w,
        AvailableSpace::MaxContent => f32::MAX / 2.0,
        AvailableSpace::MinContent => 0.0,
    };
    let mut breakpoints = vec![
        Breakpoint {
            demerit: INFINITY_BADNESS,
            previous: 0,
            line: 0
        };
        nodes.len() + 1
    ];
    breakpoints[0] = Breakpoint {
        demerit: 0.0,
        previous: 0,
        line: 0,
    };

    for i in 0..nodes.len() {
        // Optimization:
        //
        // A legal line break can only occur at a Penalty node. If the current node
        // is a Box or Glue, we can skip it as a potential breakpoint.

        if !matches!(nodes.get(i), Some(LayoutNode::Penalty { .. })) {
            continue;
        }

        for j in (0..=i).rev() {
            // Calculate the properties of a potential line from node `j` to `i`.
            let (mut current_width, mut stretch, mut shrink) = (0.0, 0.0, 0.0);

            for k in j..=i {
                match &nodes[k] {
                    LayoutNode::Box(_, w) => current_width += w,
                    LayoutNode::Glue {
                        width,
                        stretch: s,
                        shrink: k,
                        ..
                    } => {
                        current_width += width;
                        stretch += s;
                        shrink += k;
                    }
                    LayoutNode::Penalty { width, .. } => current_width += width,
                }
            }

            // Calculate adjustment ratio. If the line is wider than the available width
            // but has no glue to shrink, it is an invalid candidate.
            let ratio = if current_width < line_width {
                if stretch > 0.0 {
                    (line_width - current_width) / stretch
                } else {
                    INFINITY_BADNESS // Cannot stretch
                }
            } else if current_width > line_width {
                if shrink > 0.0 {
                    (line_width - current_width) / shrink
                } else {
                    INFINITY_BADNESS // Cannot shrink
                }
            } else {
                0.0 // Perfect fit
            };

            // Lines that must shrink too much are invalid.
            if ratio < -1.0 {
                continue;
            }

            // Calculate badness
            let mut badness = 100.0 * ratio.abs().powi(3);

            // Add penalty for the break point
            if let Some(LayoutNode::Penalty { penalty, .. }) = nodes.get(i) {
                if *penalty >= 0.0 {
                    badness += penalty;
                } else if *penalty <= -INFINITY_BADNESS {
                    badness = -INFINITY_BADNESS; // Forced break
                }
            }

            // TODO: Add demerits for consecutive lines with very different
            // ratios (fitness classes).
            //
            // For now, demerit is simply the cumulative badness.
            let demerit = badness + breakpoints[j].demerit;

            if demerit < breakpoints[i + 1].demerit {
                breakpoints[i + 1] = Breakpoint {
                    demerit,
                    previous: j,
                    line: breakpoints[j].line + 1,
                };
            }
        }
    }

    // Backtrack from the end to find the break points
    let mut breaks = Vec::new();
    let mut current = nodes.len();
    while current > 0 {
        breaks.push(current);
        let prev_idx = breakpoints[current].previous;
        current = prev_idx;
    }
    breaks.reverse();
    breaks
}

/// Takes the optimal break points and performs the final positioning.
fn position_lines_from_breaks(
    nodes: &[LayoutNode],
    breaks: &[usize],
    logical_items: &[LogicalItem],
    constraints: &UnifiedConstraints,
) -> UnifiedLayout {
    let mut positioned_items = Vec::new();
    let mut start_node = 0;
    let mut cross_axis_pen = 0.0;
    let base_direction = get_base_direction_from_logical(logical_items);
    // REMOVED: Do not pre-resolve alignment. The context is needed inside the loop.
    // let physical_align = resolve_logical_align(constraints.text_align, base_direction);

    for (line_index, &end_node) in breaks.iter().enumerate() {
        let line_nodes = &nodes[start_node..end_node];
        let is_last_line = line_index == breaks.len() - 1;

        let line_items: Vec<ShapedItem> = line_nodes
            .iter()
            .filter_map(|node| match node {
                LayoutNode::Box(item, _) => Some(item.clone()),
                LayoutNode::Glue { item, .. } => Some(item.clone()),
                LayoutNode::Penalty { item, .. } => item.clone(),
            })
            .collect();

        // Note: Calculate spacing, do not mutate items
        let mut extra_per_space = 0.0;
        let line_width: f32 = line_items.iter().map(|i| get_item_measure(i, false)).sum();

        let should_justify = constraints.text_justify != JustifyContent::None
            && (!is_last_line || constraints.text_align == TextAlign::JustifyAll);

        // Get the available width as f32 for calculations
        let available_width_f32 = match constraints.available_width {
            AvailableSpace::Definite(w) => w,
            AvailableSpace::MaxContent => f32::MAX / 2.0,
            AvailableSpace::MinContent => 0.0,
        };

        if should_justify {
            let space_to_add = available_width_f32 - line_width;
            if space_to_add > 0.0 {
                let space_count = line_items
                    .iter()
                    .filter(|item| is_word_separator(item))
                    .count();
                if space_count > 0 {
                    extra_per_space = space_to_add / space_count as f32;
                }
            }
        }

        // Alignment & Positioning
        let total_width: f32 = line_items
            .iter()
            .map(|item| get_item_measure(item, false))
            .sum();

        // For MaxContent, don't apply alignment (treat as left-aligned)
        let is_indefinite = matches!(
            constraints.available_width,
            AvailableSpace::MaxContent | AvailableSpace::MinContent
        );
        let remaining_space = if is_indefinite {
            0.0
        } else {
            available_width_f32
                - (total_width
                    + extra_per_space
                        * line_items
                            .iter()
                            .filter(|item| is_word_separator(item))
                            .count() as f32)
        };

        // Resolve the physical alignment here, inside the function,
        // just like in position_one_line
        let physical_align = match (constraints.text_align, base_direction) {
            (TextAlign::Start, BidiDirection::Ltr) => TextAlign::Left,
            (TextAlign::Start, BidiDirection::Rtl) => TextAlign::Right,
            (TextAlign::End, BidiDirection::Ltr) => TextAlign::Right,
            (TextAlign::End, BidiDirection::Rtl) => TextAlign::Left,
            (other, _) => other,
        };

        let mut main_axis_pen = match physical_align {
            TextAlign::Center => remaining_space / 2.0,
            TextAlign::Right => remaining_space,
            _ => 0.0,
        };

        for item in line_items {
            let item_advance = get_item_measure(&item, false);

            let draw_pos = match &item {
                ShapedItem::Cluster(c) if !c.glyphs.is_empty() => {
                    let glyph = &c.glyphs[0];
                    Point {
                        x: main_axis_pen + glyph.offset.x,
                        y: cross_axis_pen - glyph.offset.y, // Use - for GPOS offset
                    }
                }
                _ => Point {
                    x: main_axis_pen,
                    y: cross_axis_pen,
                },
            };

            positioned_items.push(PositionedItem {
                item: item.clone(),
                position: draw_pos,
                line_index,
            });

            main_axis_pen += item_advance;

            //Apply extra spacing to the pen
            if is_word_separator(&item) {
                main_axis_pen += extra_per_space;
            }
        }

        cross_axis_pen += constraints.line_height;
        start_node = end_node;
    }

    UnifiedLayout {
        items: positioned_items,
        overflow: OverflowInfo::default(),
    }
}

/// A helper to split a ShapedCluster at a specific glyph index for hyphenation.
fn split_cluster_for_hyphenation(
    cluster: &ShapedCluster,
    glyph_break_index: usize,
) -> Option<(ShapedCluster, ShapedCluster)> {
    if glyph_break_index >= cluster.glyphs.len() - 1 {
        return None;
    }

    let first_part_glyphs = cluster.glyphs[..=glyph_break_index].to_vec();
    let second_part_glyphs = cluster.glyphs[glyph_break_index + 1..].to_vec();
    if first_part_glyphs.is_empty() || second_part_glyphs.is_empty() {
        return None;
    }

    let first_part_advance: f32 = first_part_glyphs
        .iter()
        .map(|g| g.advance + g.kerning)
        .sum();
    let second_part_advance: f32 = second_part_glyphs
        .iter()
        .map(|g| g.advance + g.kerning)
        .sum();

    // We can approximate the split text, but a more robust solution
    // would map glyphs back to bytes.
    let first_part = ShapedCluster {
        glyphs: first_part_glyphs,
        advance: first_part_advance,
        ..cluster.clone()
    };
    let second_part = ShapedCluster {
        glyphs: second_part_glyphs,
        advance: second_part_advance,
        ..cluster.clone()
    };

    Some((first_part, second_part))
}

```

================================================================================
## FILE: layout/src/text3/mod.rs
## Description: Text editing, cursor, selection
================================================================================
```
use std::{
    cmp::Ordering,
    collections::{BTreeSet, HashMap},
    hash::{Hash, Hasher},
    mem::discriminant,
    num::NonZeroUsize,
    sync::{Arc, Mutex},
};

#[cfg(feature = "text_layout_hyphenation")]
use hyphenation::{Hyphenator as _, Language, Load as _, Standard};
use lru::LruCache;
use rust_fontconfig::{
    FcFontCache, FcPattern, FcWeight, FontId, FontMatch, PatternMatch, UnicodeRange,
};
use unicode_bidi::{get_base_direction, BidiInfo};
use unicode_segmentation::UnicodeSegmentation;

use crate::text3::script::Script;

pub mod cache;
pub mod default;
pub mod edit;
pub mod glyphs;
pub mod knuth_plass;
pub mod script;
pub mod selection;

```

================================================================================
## FILE: layout/src/text3/script.rs
## Description: Text editing, cursor, selection
================================================================================
```
// Taken from: https://github.com/greyblake/whatlang-rs/blob/master/src/scripts/detect.rs
//
// See: https://github.com/greyblake/whatlang-rs/pull/67

// License:
//
// (The MIT License)
//
// Copyright (c) 2017 Sergey Potapov <blake131313@gmail.com>
// Copyright (c) 2014 Titus Wormer <tituswormer@gmail.com>
// Copyright (c) 2008 Kent S Johnson
// Copyright (c) 2006 Jacob R Rideout <kde@jacobrideout.net>
// Copyright (c) 2004 Maciej Ceglowski
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// 'Software'), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#[cfg(feature = "text_layout_hyphenation")]
use hyphenation::Language as HyphenationLanguage;
#[cfg(feature = "text_layout_hyphenation")]
pub use hyphenation::Language;

/// Stub Language enum for when hyphenation is not enabled.
/// This mirrors the variants used in script detection functions.
#[cfg(not(feature = "text_layout_hyphenation"))]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[allow(dead_code)]
pub enum Language {
    // Latin script languages
    EnglishUS,
    French,
    German1996,
    Spanish,
    Portuguese,
    Estonian,
    Hungarian,
    Polish,
    Czech,
    Slovak,
    Latvian,
    Lithuanian,
    Romanian,
    Turkish,
    Croatian,
    Icelandic,
    Welsh,
    NorwegianBokmal,
    Swedish,
    // Cyrillic script languages
    Russian,
    Ukrainian,
    Belarusian,
    Bulgarian,
    Macedonian,
    SerbianCyrillic,
    Mongolian,
    SlavonicChurch,
    // Greek script languages
    GreekMono,
    GreekPoly,
    Coptic,
    // Indic script languages
    Hindi,
    Bengali,
    Assamese,
    Marathi,
    Sanskrit,
    Gujarati,
    Panjabi,
    Kannada,
    Malayalam,
    Oriya,
    Tamil,
    Telugu,
    // Other scripts
    Georgian,
    Ethiopic,
    Thai,
    Chinese,
}

use rust_fontconfig::UnicodeRange;

#[derive(PartialEq, Eq, Debug, Clone, Copy)]
pub enum Script {
    // Keep this in alphabetic order (for C bindings)
    Arabic,
    Bengali,
    Cyrillic,
    Devanagari,
    Ethiopic,
    Georgian,
    Greek,
    Gujarati,
    Gurmukhi,
    Hangul,
    Hebrew,
    Hiragana,
    Kannada,
    Katakana,
    Khmer,
    Latin,
    Malayalam,
    Mandarin,
    Myanmar,
    Oriya,
    Sinhala,
    Tamil,
    Telugu,
    Thai,
}

impl Script {
    /// Maps a Script to a vector of its representative Unicode character ranges.
    ///
    /// The ranges are extracted from the `is_*` functions in the provided source code.
    pub fn get_unicode_ranges(&self) -> Vec<UnicodeRange> {
        match self {
            Script::Arabic => vec![
                UnicodeRange {
                    start: 0x0600,
                    end: 0x06FF,
                },
                UnicodeRange {
                    start: 0x0750,
                    end: 0x07FF,
                },
                UnicodeRange {
                    start: 0x08A0,
                    end: 0x08FF,
                },
                UnicodeRange {
                    start: 0xFB50,
                    end: 0xFDFF,
                },
                UnicodeRange {
                    start: 0xFE70,
                    end: 0xFEFF,
                },
                UnicodeRange {
                    start: 0x10E60,
                    end: 0x10E7F,
                },
                UnicodeRange {
                    start: 0x1EE00,
                    end: 0x1EEFF,
                },
            ],
            Script::Bengali => vec![UnicodeRange {
                start: 0x0980,
                end: 0x09FF,
            }],
            Script::Cyrillic => vec![
                UnicodeRange {
                    start: 0x0400,
                    end: 0x0484,
                },
                UnicodeRange {
                    start: 0x0487,
                    end: 0x052F,
                },
                UnicodeRange {
                    start: 0x2DE0,
                    end: 0x2DFF,
                },
                UnicodeRange {
                    start: 0xA640,
                    end: 0xA69D,
                },
                UnicodeRange {
                    start: 0x1D2B,
                    end: 0x1D2B,
                },
                UnicodeRange {
                    start: 0x1D78,
                    end: 0x1D78,
                },
                UnicodeRange {
                    start: 0xA69F,
                    end: 0xA69F,
                },
            ],
            Script::Devanagari => vec![
                UnicodeRange {
                    start: 0x0900,
                    end: 0x097F,
                },
                UnicodeRange {
                    start: 0xA8E0,
                    end: 0xA8FF,
                },
                UnicodeRange {
                    start: 0x1CD0,
                    end: 0x1CFF,
                },
            ],
            Script::Ethiopic => vec![
                UnicodeRange {
                    start: 0x1200,
                    end: 0x139F,
                },
                UnicodeRange {
                    start: 0x2D80,
                    end: 0x2DDF,
                },
                UnicodeRange {
                    start: 0xAB00,
                    end: 0xAB2F,
                },
            ],
            Script::Georgian => vec![UnicodeRange {
                start: 0x10A0,
                end: 0x10FF,
            }],
            Script::Greek => vec![UnicodeRange {
                start: 0x0370,
                end: 0x03FF,
            }],
            Script::Gujarati => vec![UnicodeRange {
                start: 0x0A80,
                end: 0x0AFF,
            }],
            Script::Gurmukhi => vec![UnicodeRange {
                start: 0x0A00,
                end: 0x0A7F,
            }],
            Script::Hangul => vec![
                UnicodeRange {
                    start: 0xAC00,
                    end: 0xD7AF,
                },
                UnicodeRange {
                    start: 0x1100,
                    end: 0x11FF,
                },
                UnicodeRange {
                    start: 0x3130,
                    end: 0x318F,
                },
                UnicodeRange {
                    start: 0x3200,
                    end: 0x32FF,
                },
                UnicodeRange {
                    start: 0xA960,
                    end: 0xA97F,
                },
                UnicodeRange {
                    start: 0xD7B0,
                    end: 0xD7FF,
                },
                UnicodeRange {
                    start: 0xFF00,
                    end: 0xFFEF,
                },
            ],
            Script::Hebrew => vec![UnicodeRange {
                start: 0x0590,
                end: 0x05FF,
            }],
            Script::Hiragana => vec![UnicodeRange {
                start: 0x3040,
                end: 0x309F,
            }],
            Script::Kannada => vec![UnicodeRange {
                start: 0x0C80,
                end: 0x0CFF,
            }],
            Script::Katakana => vec![UnicodeRange {
                start: 0x30A0,
                end: 0x30FF,
            }],
            Script::Khmer => vec![
                UnicodeRange {
                    start: 0x1780,
                    end: 0x17FF,
                },
                UnicodeRange {
                    start: 0x19E0,
                    end: 0x19FF,
                },
            ],
            Script::Latin => vec![
                UnicodeRange {
                    start: 0x0041,
                    end: 0x005A,
                }, // A-Z
                UnicodeRange {
                    start: 0x0061,
                    end: 0x007A,
                }, // a-z
                UnicodeRange {
                    start: 0x0080,
                    end: 0x00FF,
                },
                UnicodeRange {
                    start: 0x0100,
                    end: 0x017F,
                },
                UnicodeRange {
                    start: 0x0180,
                    end: 0x024F,
                },
                UnicodeRange {
                    start: 0x0250,
                    end: 0x02AF,
                },
                UnicodeRange {
                    start: 0x1D00,
                    end: 0x1D7F,
                },
                UnicodeRange {
                    start: 0x1D80,
                    end: 0x1DBF,
                },
                UnicodeRange {
                    start: 0x1E00,
                    end: 0x1EFF,
                },
                UnicodeRange {
                    start: 0x2100,
                    end: 0x214F,
                },
                UnicodeRange {
                    start: 0x2C60,
                    end: 0x2C7F,
                },
                UnicodeRange {
                    start: 0xA720,
                    end: 0xA7FF,
                },
                UnicodeRange {
                    start: 0xAB30,
                    end: 0xAB6F,
                },
            ],
            Script::Malayalam => vec![UnicodeRange {
                start: 0x0D00,
                end: 0x0D7F,
            }],
            Script::Mandarin => vec![
                UnicodeRange {
                    start: 0x2E80,
                    end: 0x2E99,
                },
                UnicodeRange {
                    start: 0x2E9B,
                    end: 0x2EF3,
                },
                UnicodeRange {
                    start: 0x2F00,
                    end: 0x2FD5,
                },
                UnicodeRange {
                    start: 0x3005,
                    end: 0x3005,
                },
                UnicodeRange {
                    start: 0x3007,
                    end: 0x3007,
                },
                UnicodeRange {
                    start: 0x3021,
                    end: 0x3029,
                },
                UnicodeRange {
                    start: 0x3038,
                    end: 0x303B,
                },
                UnicodeRange {
                    start: 0x3400,
                    end: 0x4DB5,
                },
                UnicodeRange {
                    start: 0x4E00,
                    end: 0x9FCC,
                },
                UnicodeRange {
                    start: 0xF900,
                    end: 0xFA6D,
                },
                UnicodeRange {
                    start: 0xFA70,
                    end: 0xFAD9,
                },
            ],
            Script::Myanmar => vec![UnicodeRange {
                start: 0x1000,
                end: 0x109F,
            }],
            Script::Oriya => vec![UnicodeRange {
                start: 0x0B00,
                end: 0x0B7F,
            }],
            Script::Sinhala => vec![UnicodeRange {
                start: 0x0D80,
                end: 0x0DFF,
            }],
            Script::Tamil => vec![UnicodeRange {
                start: 0x0B80,
                end: 0x0BFF,
            }],
            Script::Telugu => vec![UnicodeRange {
                start: 0x0C00,
                end: 0x0C7F,
            }],
            Script::Thai => vec![UnicodeRange {
                start: 0x0E00,
                end: 0x0E7F,
            }],
        }
    }
}

// Is it space, punctuation or digit?
// Stop character is a character that does not give any value for script
// or language detection.
#[inline]
pub fn is_stop_char(ch: char) -> bool {
    matches!(ch, '\u{0000}'..='\u{0040}' | '\u{005B}'..='\u{0060}' | '\u{007B}'..='\u{007E}')
}

type ScriptCounter = (Script, fn(char) -> bool, usize);

/// Detect only a script by a given text
pub fn detect_script(text: &str) -> Option<Script> {
    let mut script_counters: [ScriptCounter; 24] = [
        (Script::Latin, is_latin, 0),
        (Script::Cyrillic, is_cyrillic, 0),
        (Script::Arabic, is_arabic, 0),
        (Script::Mandarin, is_mandarin, 0),
        (Script::Devanagari, is_devanagari, 0),
        (Script::Hebrew, is_hebrew, 0),
        (Script::Ethiopic, is_ethiopic, 0),
        (Script::Georgian, is_georgian, 0),
        (Script::Bengali, is_bengali, 0),
        (Script::Hangul, is_hangul, 0),
        (Script::Hiragana, is_hiragana, 0),
        (Script::Katakana, is_katakana, 0),
        (Script::Greek, is_greek, 0),
        (Script::Kannada, is_kannada, 0),
        (Script::Tamil, is_tamil, 0),
        (Script::Thai, is_thai, 0),
        (Script::Gujarati, is_gujarati, 0),
        (Script::Gurmukhi, is_gurmukhi, 0),
        (Script::Telugu, is_telugu, 0),
        (Script::Malayalam, is_malayalam, 0),
        (Script::Oriya, is_oriya, 0),
        (Script::Myanmar, is_myanmar, 0),
        (Script::Sinhala, is_sinhala, 0),
        (Script::Khmer, is_khmer, 0),
    ];

    let half = text.chars().count() / 2;

    for ch in text.chars() {
        if is_stop_char(ch) {
            continue;
        }

        // For performance reasons, we need to mutate script_counters by calling
        // `swap` function, it would not be possible to do using normal iterator.
        for i in 0..script_counters.len() {
            let found = {
                let (script, check_fn, ref mut count) = script_counters[i];
                if check_fn(ch) {
                    *count += 1;
                    if *count > half {
                        return Some(script);
                    }
                    true
                } else {
                    false
                }
            };
            // Have to let borrow of count fall out of scope before doing swapping, or we could
            // do this above.
            if found {
                // If script was found, move it closer to the front.
                // If the text contains largely 1 or 2 scripts, this will
                // cause these scripts to be eventually checked first.
                if i > 0 {
                    script_counters.swap(i - 1, i);
                }
                break;
            }
        }
    }

    let (script, _, count) = script_counters
        .iter()
        .cloned()
        .max_by_key(|&(_, _, count)| count)
        .unwrap();
    if count != 0 {
        Some(script)
    } else {
        None
    }
}

pub fn detect_char_script(ch: char) -> Option<Script> {
    let script_counters: [ScriptCounter; 24] = [
        (Script::Latin, is_latin, 0),
        (Script::Cyrillic, is_cyrillic, 0),
        (Script::Arabic, is_arabic, 0),
        (Script::Mandarin, is_mandarin, 0),
        (Script::Devanagari, is_devanagari, 0),
        (Script::Hebrew, is_hebrew, 0),
        (Script::Ethiopic, is_ethiopic, 0),
        (Script::Georgian, is_georgian, 0),
        (Script::Bengali, is_bengali, 0),
        (Script::Hangul, is_hangul, 0),
        (Script::Hiragana, is_hiragana, 0),
        (Script::Katakana, is_katakana, 0),
        (Script::Greek, is_greek, 0),
        (Script::Kannada, is_kannada, 0),
        (Script::Tamil, is_tamil, 0),
        (Script::Thai, is_thai, 0),
        (Script::Gujarati, is_gujarati, 0),
        (Script::Gurmukhi, is_gurmukhi, 0),
        (Script::Telugu, is_telugu, 0),
        (Script::Malayalam, is_malayalam, 0),
        (Script::Oriya, is_oriya, 0),
        (Script::Myanmar, is_myanmar, 0),
        (Script::Sinhala, is_sinhala, 0),
        (Script::Khmer, is_khmer, 0),
    ];

    for i in 0..script_counters.len() {
        let (script, check_fn, _) = script_counters[i];
        if check_fn(ch) {
            return Some(script);
        }
    }
    None
}

/// Iterates through the text once and returns as soon as an Assamese-specific character is found.
fn detect_bengali_language(text: &str) -> Language {
    for c in text.chars() {
        // These characters are specific to Assamese in the Bengali script block.
        // We can return immediately as this is the highest priority check.
        if matches!(c, '\u{09F0}' | '\u{09F1}') {
            // ৰ, ৱ
            return Language::Assamese;
        }
    }
    // If we finish the loop without finding any Assamese characters, it's Bengali.
    Language::Bengali
}

fn detect_cyrillic_language(text: &str) -> Language {
    for c in text.chars() {
        match c {
            // Highest priority: Old Cyrillic characters for Slavonic Church. Return immediately.
            '\u{0460}'..='\u{047F}' => return Language::SlavonicChurch,
            // Set flags for other languages. We don't return yet because a higher-priority
            // character (like the one above) could still appear.
            'ѓ' | 'ќ' | 'ѕ' => return Language::Macedonian,
            'ў' => return Language::Belarusian,
            'є' | 'і' | 'ї' | 'ґ' => return Language::Ukrainian,
            'ө' | 'ү' | 'һ' => return Language::Mongolian,
            'ј' | 'љ' | 'њ' | 'ћ' | 'ђ' | 'џ' => return Language::SerbianCyrillic,
            // Bulgarian 'ъ' is also in Russian, but 'щ' is a stronger indicator.
            // The logic implies that if either is present, it might be Bulgarian.
            'щ' => return Language::Bulgarian,
            _ => {}
        }
    }

    Language::Russian
}

fn detect_devanagari_language(text: &str) -> Language {
    for c in text.chars() {
        match c {
            // Marathi has higher priority in the original logic. Return immediately.
            '\u{0933}' => return Language::Marathi, // ळ
            // Flag for Sanskrit Vedic extensions.
            '\u{1CD0}'..='\u{1CFF}' => return Language::Sanskrit,
            _ => (),
        }
    }

    Language::Hindi
}

fn detect_greek_language(text: &str) -> Language {
    let mut has_polytonic = false;

    for c in text.chars() {
        match c {
            // Coptic has higher priority. Return immediately.
            '\u{2C80}'..='\u{2CFF}' => return Language::Coptic,
            // Flag for Greek Extended (Polytonic) characters.
            '\u{1F00}'..='\u{1FFF}' => return Language::GreekPoly,
            _ => {}
        }
    }

    Language::GreekMono
}

fn detect_latin_language(text: &str) -> Language {
    // Flags for languages checked near the end of the original if-else chain.
    let mut has_french_c = false;
    let mut has_portugese_o = false;
    let mut has_portuguese_a = false;

    for c in text.chars() {
        match c {
            // --- Early Return Cases (in order of priority) ---
            'ß' => return Language::German1996,
            'ő' | 'ű' => return Language::Hungarian,
            'ł' => return Language::Polish,
            'ř' | 'ů' => return Language::Czech,
            'ľ' | 'ĺ' | 'ŕ' => return Language::Slovak,
            'ā' | 'ē' | 'ģ' | 'ī' | 'ķ' | 'ļ' | 'ņ' | 'ō' | 'ū' => {
                return Language::Latvian
            }
            'ą' | 'ę' | 'ė' | 'į' | 'ų' => return Language::Lithuanian,
            'ă' | 'ș' | 'ț' => return Language::Romanian,
            'ğ' | 'ı' | 'ş' => return Language::Turkish,
            'đ' => return Language::Croatian, /* Also used in Vietnamese, but Croatian is the */
            // original's intent
            'þ' | 'ð' => return Language::Icelandic,
            'ŵ' | 'ŷ' => return Language::Welsh,
            'æ' | 'ø' => return Language::NorwegianBokmal, // And Danish
            'å' => return Language::Swedish,               // And Norwegian, Finnish
            'ñ' => return Language::Spanish,
            'ä' | 'ö' | 'ü' => return Language::German1996,

            // NOTE: 'õ' is used by both Estonian and Portuguese
            // Since Estonian is checked first, it takes precedence.
            'õ' => has_portugese_o = true,
            'ã' => has_portuguese_a = true,

            // --- Flag-setting Cases ---
            'ç' => has_french_c = true, // Also in Portuguese
            'á' | 'é' | 'í' | 'ó' | 'ú' => return Language::Spanish,

            _ => (),
        }
    }

    // decide between portuguese, estonian and french

    if has_french_c && !has_portugese_o && !has_portuguese_a {
        return Language::French;
    }

    if has_portugese_o && !has_french_c && !has_portuguese_a {
        return Language::Estonian;
    }

    if has_portugese_o || has_portuguese_a || has_french_c {
        return Language::Portuguese;
    }

    Language::EnglishUS
}

pub fn script_to_language(script: Script, text: &str) -> Language {
    match script {
        Script::Ethiopic => Language::Ethiopic,
        Script::Georgian => Language::Georgian,
        Script::Gujarati => Language::Gujarati,
        Script::Gurmukhi => Language::Panjabi,
        Script::Kannada => Language::Kannada,
        Script::Malayalam => Language::Malayalam,
        Script::Mandarin => Language::Chinese,
        Script::Oriya => Language::Oriya,
        Script::Tamil => Language::Tamil,
        Script::Telugu => Language::Telugu,
        Script::Thai => Language::Thai,
        Script::Bengali => detect_bengali_language(text),
        Script::Cyrillic => detect_cyrillic_language(text),
        Script::Devanagari => detect_devanagari_language(text),
        Script::Greek => detect_greek_language(text),
        Script::Latin => detect_latin_language(text),

        // not directly matchable
        Script::Myanmar => Language::Thai,
        Script::Khmer => Language::Thai,
        Script::Sinhala => Language::Hindi,

        // no classical hyphenation behaviour
        Script::Arabic => Language::Chinese,
        Script::Hebrew => Language::Chinese,
        Script::Hangul => Language::Chinese,
        Script::Hiragana => Language::Chinese,
        Script::Katakana => Language::Chinese,
    }
}

pub fn is_cyrillic(ch: char) -> bool {
    matches!(ch,
        '\u{0400}'..='\u{0484}'
        | '\u{0487}'..='\u{052F}'
        | '\u{2DE0}'..='\u{2DFF}'
        | '\u{A640}'..='\u{A69D}'
        | '\u{1D2B}'
        | '\u{1D78}'
        | '\u{A69F}'
    )
}

// https://en.wikipedia.org/wiki/Latin_script_in_Unicode
pub fn is_latin(ch: char) -> bool {
    matches!(ch,
        'a'..='z'
        | 'A'..='Z'
        | '\u{0080}'..='\u{00FF}'
        | '\u{0100}'..='\u{017F}'
        | '\u{0180}'..='\u{024F}'
        | '\u{0250}'..='\u{02AF}'
        | '\u{1D00}'..='\u{1D7F}'
        | '\u{1D80}'..='\u{1DBF}'
        | '\u{1E00}'..='\u{1EFF}'
        | '\u{2100}'..='\u{214F}'
        | '\u{2C60}'..='\u{2C7F}'
        | '\u{A720}'..='\u{A7FF}'
        | '\u{AB30}'..='\u{AB6F}'
    )
}

// Based on https://en.wikipedia.org/wiki/Arabic_script_in_Unicode
pub fn is_arabic(ch: char) -> bool {
    matches!(ch,
        '\u{0600}'..='\u{06FF}'
        | '\u{0750}'..='\u{07FF}'
        | '\u{08A0}'..='\u{08FF}'
        | '\u{FB50}'..='\u{FDFF}'
        | '\u{FE70}'..='\u{FEFF}'
        | '\u{10E60}'..='\u{10E7F}'
        | '\u{1EE00}'..='\u{1EEFF}'
    )
}

// Based on https://en.wikipedia.org/wiki/Devanagari#Unicode
pub fn is_devanagari(ch: char) -> bool {
    matches!(ch, '\u{0900}'..='\u{097F}' | '\u{A8E0}'..='\u{A8FF}' | '\u{1CD0}'..='\u{1CFF}')
}

// Based on https://www.key-shortcut.com/en/writing-systems/ethiopian-script/
pub fn is_ethiopic(ch: char) -> bool {
    matches!(ch, '\u{1200}'..='\u{139F}' | '\u{2D80}'..='\u{2DDF}' | '\u{AB00}'..='\u{AB2F}')
}

// Based on https://en.wikipedia.org/wiki/Hebrew_(Unicode_block)
pub fn is_hebrew(ch: char) -> bool {
    matches!(ch, '\u{0590}'..='\u{05FF}')
}

pub fn is_georgian(ch: char) -> bool {
    matches!(ch, '\u{10A0}'..='\u{10FF}')
}

pub fn is_mandarin(ch: char) -> bool {
    matches!(ch,
        '\u{2E80}'..='\u{2E99}'
        | '\u{2E9B}'..='\u{2EF3}'
        | '\u{2F00}'..='\u{2FD5}'
        | '\u{3005}'
        | '\u{3007}'
        | '\u{3021}'..='\u{3029}'
        | '\u{3038}'..='\u{303B}'
        | '\u{3400}'..='\u{4DB5}'
        | '\u{4E00}'..='\u{9FCC}'
        | '\u{F900}'..='\u{FA6D}'
        | '\u{FA70}'..='\u{FAD9}'
    )
}

pub fn is_bengali(ch: char) -> bool {
    matches!(ch, '\u{0980}'..='\u{09FF}')
}

pub fn is_hiragana(ch: char) -> bool {
    matches!(ch, '\u{3040}'..='\u{309F}')
}

pub fn is_katakana(ch: char) -> bool {
    matches!(ch, '\u{30A0}'..='\u{30FF}')
}

// Hangul is Korean Alphabet. Unicode ranges are taken from: https://en.wikipedia.org/wiki/Hangul
pub fn is_hangul(ch: char) -> bool {
    matches!(ch,
        '\u{AC00}'..='\u{D7AF}'
        | '\u{1100}'..='\u{11FF}'
        | '\u{3130}'..='\u{318F}'
        | '\u{3200}'..='\u{32FF}'
        | '\u{A960}'..='\u{A97F}'
        | '\u{D7B0}'..='\u{D7FF}'
        | '\u{FF00}'..='\u{FFEF}'
    )
}

// Taken from: https://en.wikipedia.org/wiki/Greek_and_Coptic
pub fn is_greek(ch: char) -> bool {
    matches!(ch, '\u{0370}'..='\u{03FF}')
}

// Based on: https://en.wikipedia.org/wiki/Kannada_(Unicode_block)
pub fn is_kannada(ch: char) -> bool {
    matches!(ch, '\u{0C80}'..='\u{0CFF}')
}

// Based on: https://en.wikipedia.org/wiki/Tamil_(Unicode_block)
pub fn is_tamil(ch: char) -> bool {
    matches!(ch, '\u{0B80}'..='\u{0BFF}')
}

// Based on: https://en.wikipedia.org/wiki/Thai_(Unicode_block)
pub fn is_thai(ch: char) -> bool {
    matches!(ch, '\u{0E00}'..='\u{0E7F}')
}

// Based on: https://en.wikipedia.org/wiki/Gujarati_(Unicode_block)
pub fn is_gujarati(ch: char) -> bool {
    matches!(ch, '\u{0A80}'..='\u{0AFF}')
}

// Gurmukhi is the script for Punjabi language.
// Based on: https://en.wikipedia.org/wiki/Gurmukhi_(Unicode_block)
pub fn is_gurmukhi(ch: char) -> bool {
    matches!(ch, '\u{0A00}'..='\u{0A7F}')
}

pub fn is_telugu(ch: char) -> bool {
    matches!(ch, '\u{0C00}'..='\u{0C7F}')
}

// Based on: https://en.wikipedia.org/wiki/Malayalam_(Unicode_block)
pub fn is_malayalam(ch: char) -> bool {
    matches!(ch, '\u{0D00}'..='\u{0D7F}')
}

// Based on: https://en.wikipedia.org/wiki/Malayalam_(Unicode_block)
pub fn is_oriya(ch: char) -> bool {
    matches!(ch, '\u{0B00}'..='\u{0B7F}')
}

// Based on: https://en.wikipedia.org/wiki/Myanmar_(Unicode_block)
pub fn is_myanmar(ch: char) -> bool {
    matches!(ch, '\u{1000}'..='\u{109F}')
}

// Based on: https://en.wikipedia.org/wiki/Sinhala_(Unicode_block)
pub fn is_sinhala(ch: char) -> bool {
    matches!(ch, '\u{0D80}'..='\u{0DFF}')
}

// Based on: https://en.wikipedia.org/wiki/Khmer_alphabet
pub fn is_khmer(ch: char) -> bool {
    matches!(ch, '\u{1780}'..='\u{17FF}' | '\u{19E0}'..='\u{19FF}')
}

```

================================================================================
## FILE: layout/src/text3/selection.rs
## Description: Text editing, cursor, selection
================================================================================
```
//! Text selection helper functions
//!
//! Provides word and paragraph selection algorithms.

use azul_core::selection::{CursorAffinity, GraphemeClusterId, SelectionRange, TextCursor};

use crate::text3::cache::{PositionedItem, ShapedCluster, ShapedItem, UnifiedLayout};

/// Select the word at the given cursor position
///
/// Uses Unicode word boundaries to determine word start/end.
/// Returns a SelectionRange covering the entire word.
pub fn select_word_at_cursor(
    cursor: &TextCursor,
    layout: &UnifiedLayout,
) -> Option<SelectionRange> {
    // Find the item containing this cursor
    let (item_idx, cluster) = find_cluster_at_cursor(cursor, layout)?;

    // Get the text from this cluster and surrounding clusters on the same line
    let line_text = extract_line_text_at_item(item_idx, layout);
    let cursor_byte_offset = cursor.cluster_id.start_byte_in_run as usize;

    // Find word boundaries
    let (word_start, word_end) = find_word_boundaries(&line_text, cursor_byte_offset);

    // Convert byte offsets to cursors
    let start_cursor = TextCursor {
        cluster_id: GraphemeClusterId {
            source_run: cursor.cluster_id.source_run,
            start_byte_in_run: word_start as u32,
        },
        affinity: CursorAffinity::Leading,
    };

    let end_cursor = TextCursor {
        cluster_id: GraphemeClusterId {
            source_run: cursor.cluster_id.source_run,
            start_byte_in_run: word_end as u32,
        },
        affinity: CursorAffinity::Trailing,
    };

    Some(SelectionRange {
        start: start_cursor,
        end: end_cursor,
    })
}

/// Select the paragraph/line at the given cursor position
///
/// Returns a SelectionRange covering the entire line from the first
/// to the last cluster on that line.
pub fn select_paragraph_at_cursor(
    cursor: &TextCursor,
    layout: &UnifiedLayout,
) -> Option<SelectionRange> {
    // Find the item containing this cursor
    let (item_idx, _) = find_cluster_at_cursor(cursor, layout)?;
    let item = &layout.items[item_idx];
    let line_index = item.line_index;

    // Find all items on this line
    let line_items: Vec<(usize, &PositionedItem)> = layout
        .items
        .iter()
        .enumerate()
        .filter(|(_, item)| item.line_index == line_index)
        .collect();

    if line_items.is_empty() {
        return None;
    }

    // Get first and last cluster on line
    let first_cluster = line_items
        .iter()
        .find_map(|(_, item)| item.item.as_cluster())?;

    let last_cluster = line_items
        .iter()
        .rev()
        .find_map(|(_, item)| item.item.as_cluster())?;

    // Create selection spanning entire line
    Some(SelectionRange {
        start: TextCursor {
            cluster_id: first_cluster.source_cluster_id,
            affinity: CursorAffinity::Leading,
        },
        end: TextCursor {
            cluster_id: last_cluster.source_cluster_id,
            affinity: CursorAffinity::Trailing,
        },
    })
}

// Helper Functions

/// Find the cluster containing the given cursor
fn find_cluster_at_cursor<'a>(
    cursor: &TextCursor,
    layout: &'a UnifiedLayout,
) -> Option<(usize, &'a ShapedCluster)> {
    layout.items.iter().enumerate().find_map(|(idx, item)| {
        if let ShapedItem::Cluster(cluster) = &item.item {
            if cluster.source_cluster_id == cursor.cluster_id {
                return Some((idx, cluster));
            }
        }
        None
    })
}

/// Extract text from all clusters on the same line as the given item
fn extract_line_text_at_item(item_idx: usize, layout: &UnifiedLayout) -> String {
    let line_index = layout.items[item_idx].line_index;

    let mut text = String::new();
    for item in &layout.items {
        if item.line_index != line_index {
            continue;
        }

        if let ShapedItem::Cluster(cluster) = &item.item {
            text.push_str(&cluster.text);
        }
    }

    text
}

/// Find word boundaries around the given byte offset
///
/// Uses a simple algorithm: word characters are alphanumeric or underscore,
/// everything else is a boundary.
fn find_word_boundaries(text: &str, cursor_offset: usize) -> (usize, usize) {
    // Clamp cursor offset to text length
    let cursor_offset = cursor_offset.min(text.len());

    // Find word start (scan backwards)
    let mut word_start = 0;
    let mut char_indices: Vec<(usize, char)> = text.char_indices().collect();

    for (i, (byte_idx, ch)) in char_indices.iter().enumerate().rev() {
        if *byte_idx >= cursor_offset {
            continue;
        }

        if !is_word_char(*ch) {
            // Found boundary, word starts after this char
            word_start = if i + 1 < char_indices.len() {
                char_indices[i + 1].0
            } else {
                text.len()
            };
            break;
        }
    }

    // Find word end (scan forwards)
    let mut word_end = text.len();
    for (byte_idx, ch) in char_indices.iter() {
        if *byte_idx <= cursor_offset {
            continue;
        }

        if !is_word_char(*ch) {
            // Found boundary, word ends before this char
            word_end = *byte_idx;
            break;
        }
    }

    // If cursor is on whitespace, select just that whitespace
    if let Some((_, ch)) = char_indices.iter().find(|(idx, _)| *idx == cursor_offset) {
        if !is_word_char(*ch) {
            // Find span of consecutive whitespace/punctuation
            let start = char_indices
                .iter()
                .rev()
                .find(|(idx, c)| *idx < cursor_offset && is_word_char(*c))
                .map(|(idx, c)| idx + c.len_utf8())
                .unwrap_or(0);

            let end = char_indices
                .iter()
                .find(|(idx, c)| *idx > cursor_offset && is_word_char(*c))
                .map(|(idx, _)| *idx)
                .unwrap_or(text.len());

            return (start, end);
        }
    }

    (word_start, word_end)
}

/// Check if a character is part of a word
#[inline]
fn is_word_char(ch: char) -> bool {
    ch.is_alphanumeric() || ch == '_'
}

```

### MACOS PLATFORM CODE

================================================================================
## FILE: dll/src/desktop/shell2/macos/accessibility.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! macOS accessibility integration via accesskit_macos
//!
//! This module handles the integration between Azul's accessibility tree
//! and macOS's NSAccessibility API through accesskit_macos.

#[cfg(feature = "a11y")]
use std::sync::mpsc::{channel, Receiver, Sender};
#[cfg(feature = "a11y")]
use std::sync::{Arc, Mutex};

#[cfg(feature = "a11y")]
use accesskit::{ActionRequest, NodeId as A11yNodeId, TreeUpdate};
#[cfg(feature = "a11y")]
use accesskit_macos::SubclassingAdapter;
#[cfg(feature = "a11y")]
use azul_core::dom::{AccessibilityAction, DomId, NodeId};

#[cfg(feature = "a11y")]
/// Activation handler that provides the initial accessibility tree on demand
struct TreeActivationHandler {
    tree_provider: Arc<Mutex<Option<TreeUpdate>>>,
}

#[cfg(feature = "a11y")]
impl accesskit::ActivationHandler for TreeActivationHandler {
    fn request_initial_tree(&mut self) -> Option<TreeUpdate> {
        // Use try_lock to avoid blocking - return None if lock unavailable
        self.tree_provider
            .try_lock()
            .ok()
            .and_then(|mut guard| guard.take())
    }
}

#[cfg(feature = "a11y")]
/// Action handler that queues actions for later processing
struct ChannelActionHandler {
    sender: Sender<ActionRequest>,
}

#[cfg(feature = "a11y")]
impl accesskit::ActionHandler for ChannelActionHandler {
    fn do_action(&mut self, request: ActionRequest) {
        let _ = self.sender.send(request);
    }
}

#[cfg(feature = "a11y")]
/// macOS accessibility adapter that bridges Azul's accessibility tree
/// with NSAccessibility via accesskit
pub struct MacOSAccessibilityAdapter {
    /// The accesskit_macos adapter instance
    adapter: SubclassingAdapter,
    /// Channel for receiving action requests from assistive technologies
    action_receiver: Receiver<ActionRequest>,
    /// Shared tree provider for activation
    tree_provider: Arc<Mutex<Option<TreeUpdate>>>,
}

#[cfg(feature = "a11y")]
impl MacOSAccessibilityAdapter {
    /// Create a new accessibility adapter for a macOS NSView
    ///
    /// # Arguments
    /// - `view`: Raw pointer to the NSView object
    ///
    /// # Returns
    /// A new adapter instance that will handle bidirectional communication
    /// between the app and screen readers
    pub fn new(view: *mut std::ffi::c_void) -> Self {
        let (action_sender, action_receiver) = channel();
        let tree_provider = Arc::new(Mutex::new(None));

        // Create handlers
        let activation_handler = TreeActivationHandler {
            tree_provider: tree_provider.clone(),
        };
        let action_handler = ChannelActionHandler {
            sender: action_sender,
        };

        // SAFETY: view must be a valid NSView pointer
        let adapter = unsafe { SubclassingAdapter::new(view, activation_handler, action_handler) };

        Self {
            adapter,
            action_receiver,
            tree_provider,
        }
    }

    /// Update the accessibility tree with new state
    ///
    /// This should be called after each layout pass to synchronize
    /// the OS accessibility system with the application state.
    ///
    /// # Arguments
    /// - `tree_update`: The new tree state to submit
    ///
    /// # Note
    /// This function is designed to be non-blocking. If the a11y lock cannot
    /// be acquired immediately, the update is skipped to prevent UI hangs.
    pub fn update_tree(&mut self, tree_update: TreeUpdate) {
        // Store for next activation - use try_lock to avoid blocking
        if let Ok(mut guard) = self.tree_provider.try_lock() {
            *guard = Some(tree_update.clone());
        } else {
            // Lock contention - skip this update to avoid blocking the UI
            return;
        }

        // Update active tree - wrapped in catch_unwind to prevent panics
        // from crashing the application
        let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            self.adapter.update_if_active(|| tree_update);
        }));
    }

    /// Poll for action requests from assistive technologies
    ///
    /// This should be called regularly (e.g., in the event loop) to
    /// check if screen readers have requested any actions.
    ///
    /// # Returns
    /// An Option containing the decoded action request, or None if no actions pending
    pub fn poll_action(&self) -> Option<(DomId, NodeId, AccessibilityAction)> {
        // Try to receive action without blocking
        if let Ok(request) = self.action_receiver.try_recv() {
            // Decode the NodeId back to DomId + NodeId
            let a11y_node_id: u64 = request.target.0.into();
            let dom_id = DomId {
                inner: (a11y_node_id >> 32) as usize,
            };
            let node_id = NodeId::new((a11y_node_id & 0xFFFFFFFF) as usize);

            // Map accesskit Action to Azul AccessibilityAction
            use azul_core::geom::LogicalPosition;
            use azul_css::{props::basic::FloatValue, AzString};
            let action = match request.action {
                accesskit::Action::Click => AccessibilityAction::Default,
                accesskit::Action::Focus => AccessibilityAction::Focus,
                accesskit::Action::Blur => AccessibilityAction::Blur,
                accesskit::Action::Collapse => AccessibilityAction::Collapse,
                accesskit::Action::Expand => AccessibilityAction::Expand,
                accesskit::Action::Increment => AccessibilityAction::Increment,
                accesskit::Action::Decrement => AccessibilityAction::Decrement,
                accesskit::Action::ShowContextMenu => AccessibilityAction::ShowContextMenu,
                accesskit::Action::HideTooltip => AccessibilityAction::HideTooltip,
                accesskit::Action::ShowTooltip => AccessibilityAction::ShowTooltip,
                accesskit::Action::ScrollUp => AccessibilityAction::ScrollUp,
                accesskit::Action::ScrollDown => AccessibilityAction::ScrollDown,
                accesskit::Action::ScrollLeft => AccessibilityAction::ScrollLeft,
                accesskit::Action::ScrollRight => AccessibilityAction::ScrollRight,
                accesskit::Action::ScrollIntoView => AccessibilityAction::ScrollIntoView,
                accesskit::Action::ReplaceSelectedText => {
                    if let Some(accesskit::ActionData::Value(value)) = request.data {
                        AccessibilityAction::ReplaceSelectedText(AzString::from(value.as_ref()))
                    } else {
                        return None;
                    }
                }
                accesskit::Action::ScrollToPoint => {
                    if let Some(accesskit::ActionData::ScrollToPoint(point)) = request.data {
                        AccessibilityAction::ScrollToPoint(LogicalPosition {
                            x: point.x as f32,
                            y: point.y as f32,
                        })
                    } else {
                        return None;
                    }
                }
                accesskit::Action::SetScrollOffset => {
                    if let Some(accesskit::ActionData::SetScrollOffset(point)) = request.data {
                        AccessibilityAction::SetScrollOffset(LogicalPosition {
                            x: point.x as f32,
                            y: point.y as f32,
                        })
                    } else {
                        return None;
                    }
                }
                accesskit::Action::SetTextSelection => {
                    if let Some(accesskit::ActionData::SetTextSelection(selection)) = request.data {
                        AccessibilityAction::SetTextSelection(
                            azul_core::dom::TextSelectionStartEnd {
                                selection_start: selection.anchor.character_index,
                                selection_end: selection.focus.character_index,
                            },
                        )
                    } else {
                        return None;
                    }
                }
                accesskit::Action::SetSequentialFocusNavigationStartingPoint => {
                    AccessibilityAction::SetSequentialFocusNavigationStartingPoint
                }
                accesskit::Action::SetValue => match request.data {
                    Some(accesskit::ActionData::Value(value)) => {
                        AccessibilityAction::SetValue(AzString::from(value.as_ref()))
                    }
                    Some(accesskit::ActionData::NumericValue(value)) => {
                        AccessibilityAction::SetNumericValue(FloatValue::new(value as f32))
                    }
                    _ => return None,
                },
                accesskit::Action::CustomAction => {
                    if let Some(accesskit::ActionData::CustomAction(id)) = request.data {
                        AccessibilityAction::CustomAction(id)
                    } else {
                        return None;
                    }
                }
            };

            Some((dom_id, node_id, action))
        } else {
            None
        }
    }
}

// Stub for when accessibility feature is disabled
#[cfg(not(feature = "a11y"))]
#[derive(Clone, Copy)]
pub struct MacOSAccessibilityAdapter;

#[cfg(not(feature = "a11y"))]
impl MacOSAccessibilityAdapter {
    pub fn new(_view: *mut std::ffi::c_void, _initial_tree: ()) -> Self {
        Self
    }

    pub fn update_tree(&self, _tree_update: ()) {}

    pub fn poll_action(&self) -> Option<()> {
        None
    }

    pub fn view(&self) -> *mut std::ffi::c_void {
        std::ptr::null_mut()
    }
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/clipboard.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! macOS clipboard integration
//!
//! Uses Cocoa NSPasteboard API via objc bindings

use std::mem::transmute;

use azul_layout::managers::clipboard::ClipboardManager;
use objc::runtime::{Class, Object};
use objc_foundation::{INSArray, INSObject, INSString, NSArray, NSDictionary, NSObject, NSString};
use objc_id::{Id, Owned};

use super::super::common::debug_server::LogCategory;
use crate::{log_debug, log_error, log_info, log_trace, log_warn};

#[macro_use]
use objc::{msg_send, sel, sel_impl};

// Required to bring NSPasteboard into the path of the class-resolver
#[link(name = "AppKit", kind = "framework")]
extern "C" {}

/// Synchronize clipboard manager content to macOS system clipboard
///
/// This is called after user callbacks to commit clipboard changes.
/// If the clipboard manager has pending copy content, it's written to
/// the macOS pasteboard via NSPasteboard API.
pub fn sync_clipboard(clipboard_manager: &mut ClipboardManager) {
    // Check if there's pending content to copy
    if let Some(content) = clipboard_manager.get_copy_content() {
        // Write to pasteboard
        if let Err(e) = write_to_pasteboard(&content.plain_text) {
            log_error!(
                LogCategory::Resources,
                "[macOS Clipboard] Failed to write: {:?}",
                e
            );
        }
    }

    // Clear the clipboard manager after sync
    clipboard_manager.clear();
}

/// Read content from macOS system clipboard
///
/// Returns the clipboard text content if available.
pub fn get_clipboard_content() -> Option<String> {
    read_from_pasteboard().ok()
}

/// Write string to macOS pasteboard
pub fn write_to_clipboard(text: &str) -> Result<(), ClipboardError> {
    write_to_pasteboard(text)
}

/// Write string to macOS pasteboard (internal implementation)
fn write_to_pasteboard(text: &str) -> Result<(), ClipboardError> {
    let pasteboard = get_general_pasteboard()?;

    let string_array = NSArray::from_vec(vec![NSString::from_str(text)]);
    let _: usize = unsafe { msg_send![pasteboard, clearContents] };
    let success: bool = unsafe { msg_send![pasteboard, writeObjects: string_array] };

    if success {
        Ok(())
    } else {
        Err(ClipboardError::WriteError)
    }
}

/// Read string from macOS pasteboard
fn read_from_pasteboard() -> Result<String, ClipboardError> {
    let pasteboard = get_general_pasteboard()?;

    let string_class: Id<NSObject> = {
        let cls: Id<Class> = unsafe { Id::from_ptr(class("NSString")) };
        unsafe { transmute(cls) }
    };

    let classes: Id<NSArray<NSObject, Owned>> = NSArray::from_vec(vec![string_class]);
    let options: Id<NSDictionary<NSObject, NSObject>> = NSDictionary::new();

    let string_array: Id<NSArray<NSString>> = unsafe {
        let obj: *mut NSArray<NSString> =
            msg_send![pasteboard, readObjectsForClasses:&*classes options:&*options];
        if obj.is_null() {
            return Err(ClipboardError::ReadError);
        }
        Id::from_ptr(obj)
    };

    if string_array.count() == 0 {
        Err(ClipboardError::EmptyClipboard)
    } else {
        Ok(string_array[0].as_str().to_owned())
    }
}

/// Get the general pasteboard instance
fn get_general_pasteboard() -> Result<Id<Object>, ClipboardError> {
    let cls = Class::get("NSPasteboard").ok_or(ClipboardError::PasteboardNotFound)?;
    let pasteboard: *mut Object = unsafe { msg_send![cls, generalPasteboard] };
    if pasteboard.is_null() {
        return Err(ClipboardError::NullPasteboard);
    }
    Ok(unsafe { Id::from_ptr(pasteboard) })
}

/// Get class by name
#[inline]
fn class(name: &str) -> *mut Class {
    unsafe { transmute(Class::get(name)) }
}

#[derive(Debug, Copy, Clone)]
pub enum ClipboardError {
    PasteboardNotFound,
    NullPasteboard,
    WriteError,
    ReadError,
    EmptyClipboard,
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/coregraphics.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! Core Graphics display-related FFI bindings
//!
//! This module provides access to CGDirectDisplayID and related
//! display enumeration functions for monitor identification.

use std::sync::Arc;

use objc2_foundation::{NSDictionary, NSNumber, NSString};

/// CGDirectDisplayID - unique identifier for a physical display
pub type CGDirectDisplayID = u32;

/// Main display ID constant
pub const CG_MAIN_DISPLAY_ID: CGDirectDisplayID = 0;

/// Core Graphics function pointers loaded via dlopen
pub struct CoreGraphicsFunctions {
    cg_main_display_id: unsafe extern "C" fn() -> CGDirectDisplayID,
    cg_display_bounds: unsafe extern "C" fn(display: CGDirectDisplayID) -> objc2_foundation::NSRect,

    // Keep the library handle to prevent unloading
    #[allow(dead_code)]
    lib: libloading::Library,
}

impl CoreGraphicsFunctions {
    /// Load Core Graphics functions via dlopen
    pub fn load() -> Result<Arc<Self>, String> {
        unsafe {
            // Load ApplicationServices framework (which includes CoreGraphics)
            let lib = libloading::Library::new(
                "/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices",
            )
            .map_err(|e| format!("Failed to load ApplicationServices framework: {}", e))?;

            // Load display functions
            let cg_main_display_id = *lib
                .get(b"CGMainDisplayID\0")
                .map_err(|e| format!("CGMainDisplayID not found: {}", e))?;

            let cg_display_bounds = *lib
                .get(b"CGDisplayBounds\0")
                .map_err(|e| format!("CGDisplayBounds not found: {}", e))?;

            Ok(Arc::new(Self {
                cg_main_display_id,
                cg_display_bounds,
                lib,
            }))
        }
    }

    /// Get the main display ID
    pub fn main_display_id(&self) -> CGDirectDisplayID {
        unsafe { (self.cg_main_display_id)() }
    }

    /// Get the bounds of a display
    pub fn display_bounds(&self, display: CGDirectDisplayID) -> objc2_foundation::NSRect {
        unsafe { (self.cg_display_bounds)(display) }
    }
}

/// Extract CGDirectDisplayID from NSScreen's deviceDescription
///
/// The deviceDescription dictionary contains a "NSScreenNumber" key
/// which maps to the CGDirectDisplayID for that screen.
pub fn get_display_id_from_screen(screen: &objc2_app_kit::NSScreen) -> Option<CGDirectDisplayID> {
    unsafe {
        use objc2::msg_send;

        // Get deviceDescription dictionary
        let device_description: *const NSDictionary<NSString, objc2_foundation::NSObject> =
            msg_send![screen, deviceDescription];

        if device_description.is_null() {
            return None;
        }

        // Get "NSScreenNumber" key
        let key = NSString::from_str("NSScreenNumber");
        let value: *const objc2_foundation::NSObject =
            msg_send![device_description, objectForKey: &*key];

        if value.is_null() {
            return None;
        }

        // Try to cast to NSNumber and extract u32
        let ns_number = value as *const NSNumber;
        if ns_number.is_null() {
            return None;
        }

        let display_id: u32 = msg_send![ns_number, unsignedIntValue];
        Some(display_id)
    }
}

/// Compute a stable hash for a monitor based on its properties
///
/// This hash can be used to identify the same physical monitor across sessions,
/// even if the index changes (e.g., monitors were plugged/unplugged).
pub fn compute_monitor_hash(
    display_id: CGDirectDisplayID,
    bounds: objc2_foundation::NSRect,
) -> u64 {
    use std::{
        collections::hash_map::DefaultHasher,
        hash::{Hash, Hasher},
    };

    let mut hasher = DefaultHasher::new();

    // Hash display ID (stable across sessions for the same physical monitor)
    display_id.hash(&mut hasher);

    // Hash bounds dimensions (width, height)
    // We don't hash position because it can change when monitors are rearranged
    let width = bounds.size.width as u64;
    let height = bounds.size.height as u64;
    width.hash(&mut hasher);
    height.hash(&mut hasher);

    hasher.finish()
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/corevideo.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! CoreVideo FFI bindings via dlopen for backward compatibility
//!
//! This module provides safe Rust wrappers around CoreVideo C APIs,
//! specifically CVDisplayLink for proper VSYNC synchronization.
//!
//! We use dlopen instead of static linking to support older macOS versions
//! where CoreVideo might not be available or behave differently.

use std::{
    os::raw::{c_int, c_void},
    sync::Arc,
};

/// CVDisplayLink opaque pointer
pub type CVDisplayLinkRef = *mut c_void;

/// CVReturn type (result code)
pub type CVReturn = i32;

/// Success return code
pub const K_CV_RETURN_SUCCESS: CVReturn = 0;

/// CVTimeStamp structure (simplified - we only need the minimal fields)
#[repr(C)]
pub struct CVTimeStamp {
    pub version: u32,
    pub video_time_scale: i32,
    pub video_time: i64,
    pub host_time: u64,
    pub rate_scalar: f64,
    pub video_refresh_period: i64,
    pub smpte_time: CVSMPTETime,
    pub flags: u64,
    pub reserved: u64,
}

#[repr(C)]
pub struct CVSMPTETime {
    pub subframes: i16,
    pub subframe_divisor: i16,
    pub counter: u32,
    pub type_: u32,
    pub flags: u32,
    pub hours: i16,
    pub minutes: i16,
    pub seconds: i16,
    pub frames: i16,
}

/// Display link output callback
pub type CVDisplayLinkOutputCallback = extern "C" fn(
    display_link: CVDisplayLinkRef,
    in_now: *const CVTimeStamp,
    in_output_time: *const CVTimeStamp,
    flags_in: u64,
    flags_out: *mut u64,
    display_link_context: *mut c_void,
) -> CVReturn;

/// CoreVideo function pointers loaded via dlopen
pub struct CoreVideoFunctions {
    // CVDisplayLink functions
    // Note: CVDisplayLinkCreateWithCGDisplays takes an array of display IDs and count
    cv_display_link_create_with_cg_displays: unsafe extern "C" fn(
        display_array: *const u32,
        count: u32,
        display_link_out: *mut CVDisplayLinkRef,
    ) -> CVReturn,
    cv_display_link_set_output_callback: unsafe extern "C" fn(
        display_link: CVDisplayLinkRef,
        callback: CVDisplayLinkOutputCallback,
        user_info: *mut c_void,
    ) -> CVReturn,
    cv_display_link_start: unsafe extern "C" fn(display_link: CVDisplayLinkRef) -> CVReturn,
    cv_display_link_stop: unsafe extern "C" fn(display_link: CVDisplayLinkRef) -> CVReturn,
    cv_display_link_release: unsafe extern "C" fn(display_link: CVDisplayLinkRef),
    cv_display_link_is_running: unsafe extern "C" fn(display_link: CVDisplayLinkRef) -> bool,

    // Keep the library handle to prevent unloading
    #[allow(dead_code)]
    lib: libloading::Library,
}

impl CoreVideoFunctions {
    /// Load CoreVideo functions via dlopen
    ///
    /// Returns None if CoreVideo framework is not available (older macOS versions)
    pub fn load() -> Result<Arc<Self>, String> {
        unsafe {
            // Try to load CoreVideo framework
            let lib = libloading::Library::new(
                "/System/Library/Frameworks/CoreVideo.framework/CoreVideo",
            )
            .map_err(|e| format!("Failed to load CoreVideo framework: {}", e))?;

            // Load CVDisplayLink functions
            let cv_display_link_create_with_cg_displays = *lib
                .get(b"CVDisplayLinkCreateWithCGDisplays\0")
                .map_err(|e| format!("CVDisplayLinkCreateWithCGDisplays not found: {}", e))?;

            let cv_display_link_set_output_callback = *lib
                .get(b"CVDisplayLinkSetOutputCallback\0")
                .map_err(|e| format!("CVDisplayLinkSetOutputCallback not found: {}", e))?;

            let cv_display_link_start = *lib
                .get(b"CVDisplayLinkStart\0")
                .map_err(|e| format!("CVDisplayLinkStart not found: {}", e))?;

            let cv_display_link_stop = *lib
                .get(b"CVDisplayLinkStop\0")
                .map_err(|e| format!("CVDisplayLinkStop not found: {}", e))?;

            let cv_display_link_release = *lib
                .get(b"CVDisplayLinkRelease\0")
                .map_err(|e| format!("CVDisplayLinkRelease not found: {}", e))?;

            let cv_display_link_is_running = *lib
                .get(b"CVDisplayLinkIsRunning\0")
                .map_err(|e| format!("CVDisplayLinkIsRunning not found: {}", e))?;

            Ok(Arc::new(Self {
                cv_display_link_create_with_cg_displays,
                cv_display_link_set_output_callback,
                cv_display_link_start,
                cv_display_link_stop,
                cv_display_link_release,
                cv_display_link_is_running,
                lib,
            }))
        }
    }

    /// Create a CVDisplayLink for a specific display
    pub fn create_display_link(&self, display_id: u32) -> Result<CVDisplayLinkRef, CVReturn> {
        unsafe {
            let mut display_link: CVDisplayLinkRef = std::ptr::null_mut();
            let display_array = [display_id];

            let result = (self.cv_display_link_create_with_cg_displays)(
                display_array.as_ptr(),
                1, // count
                &mut display_link,
            );

            if result == K_CV_RETURN_SUCCESS {
                if display_link.is_null() {
                    return Err(-1);
                }
                Ok(display_link)
            } else {
                Err(result)
            }
        }
    }

    /// Set output callback for CVDisplayLink
    pub fn set_output_callback(
        &self,
        display_link: CVDisplayLinkRef,
        callback: CVDisplayLinkOutputCallback,
        user_info: *mut c_void,
    ) -> CVReturn {
        unsafe { (self.cv_display_link_set_output_callback)(display_link, callback, user_info) }
    }

    /// Start the CVDisplayLink
    pub fn start(&self, display_link: CVDisplayLinkRef) -> CVReturn {
        unsafe { (self.cv_display_link_start)(display_link) }
    }

    /// Stop the CVDisplayLink
    pub fn stop(&self, display_link: CVDisplayLinkRef) -> CVReturn {
        unsafe { (self.cv_display_link_stop)(display_link) }
    }

    /// Release the CVDisplayLink
    pub fn release(&self, display_link: CVDisplayLinkRef) {
        unsafe { (self.cv_display_link_release)(display_link) }
    }

    /// Check if the CVDisplayLink is running
    pub fn is_running(&self, display_link: CVDisplayLinkRef) -> bool {
        unsafe { (self.cv_display_link_is_running)(display_link) }
    }
}

/// RAII wrapper for CVDisplayLink
pub struct DisplayLink {
    display_link: CVDisplayLinkRef,
    cv_functions: Arc<CoreVideoFunctions>,
}

impl DisplayLink {
    /// Create a new DisplayLink for a specific display
    pub fn new(display_id: u32, cv_functions: Arc<CoreVideoFunctions>) -> Result<Self, CVReturn> {
        let display_link = cv_functions.create_display_link(display_id)?;
        Ok(Self {
            display_link,
            cv_functions,
        })
    }

    /// Set the output callback
    pub fn set_output_callback(
        &self,
        callback: CVDisplayLinkOutputCallback,
        user_info: *mut c_void,
    ) -> CVReturn {
        self.cv_functions
            .set_output_callback(self.display_link, callback, user_info)
    }

    /// Start the display link
    pub fn start(&self) -> CVReturn {
        self.cv_functions.start(self.display_link)
    }

    /// Stop the display link
    pub fn stop(&self) -> CVReturn {
        self.cv_functions.stop(self.display_link)
    }

    /// Check if the display link is running
    pub fn is_running(&self) -> bool {
        self.cv_functions.is_running(self.display_link)
    }

    /// Get the raw CVDisplayLinkRef
    pub fn as_ptr(&self) -> CVDisplayLinkRef {
        self.display_link
    }
}

impl Drop for DisplayLink {
    fn drop(&mut self) {
        if !self.display_link.is_null() {
            // Stop if running
            if self.is_running() {
                self.stop();
            }
            // Release
            self.cv_functions.release(self.display_link);
        }
    }
}

// Safety: CVDisplayLink is thread-safe according to Apple documentation
unsafe impl Send for DisplayLink {}
unsafe impl Sync for DisplayLink {}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/events.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! macOS Event handling - converts NSEvent to Azul events and dispatches callbacks.

use super::super::common::debug_server::LogCategory;
use crate::{log_debug, log_error, log_info, log_trace, log_warn};

use azul_core::{
    callbacks::LayoutCallbackInfo,
    dom::{DomId, NodeId, ScrollbarOrientation},
    events::{EventFilter, MouseButton, ProcessEventResult, SyntheticEvent},
    geom::{LogicalPosition, PhysicalPositionI32},
    hit_test::{CursorTypeHitTest, FullHitTest},
    window::{
        CursorPosition, KeyboardState, MouseCursorType, MouseState, OptionMouseCursorType,
        VirtualKeyCode, WindowFrame,
    },
};
use azul_layout::{
    callbacks::CallbackInfo,
    managers::{
        hover::InputPointId,
        scroll_state::{ScrollbarComponent, ScrollbarHit},
    },
    solver3::display_list::DisplayList,
    window::LayoutWindow,
    window_state::FullWindowState,
};
use objc2_app_kit::{NSEvent, NSEventModifierFlags, NSEventType};
use objc2_foundation::NSPoint;

use super::MacOSWindow;
// Re-export common types
pub use crate::desktop::shell2::common::event_v2::HitTestNode;
// Import V2 cross-platform event processing trait
use crate::desktop::shell2::common::event_v2::PlatformWindowV2;

/// Convert macOS window coordinates to Azul logical coordinates.
///
/// macOS uses a bottom-left origin coordinate system where Y=0 is at the bottom.
/// Azul/WebRender uses a top-left origin coordinate system where Y=0 is at the top.
/// This function converts from macOS to Azul coordinates.
#[inline]
fn macos_to_azul_coords(location: NSPoint, window_height: f32) -> LogicalPosition {
    LogicalPosition::new(location.x as f32, window_height - location.y as f32)
}

/// Extension trait for Callback to convert from CoreCallback
trait CallbackExt {
    fn from_core(core_callback: azul_core::callbacks::CoreCallback) -> Self;
}

impl CallbackExt for azul_layout::callbacks::Callback {
    fn from_core(core_callback: azul_core::callbacks::CoreCallback) -> Self {
        // Use the existing safe wrapper method from Callback
        azul_layout::callbacks::Callback::from_core(core_callback)
    }
}

/// Result of processing an event - determines whether to redraw, update layout, etc.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum EventProcessResult {
    /// No action needed
    DoNothing,
    /// Request redraw (present() will be called)
    RequestRedraw,
    /// Layout changed, need full rebuild
    RegenerateDisplayList,
    /// Window should close
    CloseWindow,
}

/// Target for callback dispatch - either a specific node or all root nodes.
#[derive(Debug, Clone, Copy)]
pub enum CallbackTarget {
    /// Dispatch to callbacks on a specific node (e.g., mouse events, hover)
    Node(HitTestNode),
    /// Dispatch to callbacks on root nodes (NodeId::ZERO) across all DOMs (e.g., window events,
    /// keys)
    RootNodes,
}

impl MacOSWindow {
    /// Convert ProcessEventResult to platform-specific EventProcessResult
    #[inline]
    fn convert_process_result(result: azul_core::events::ProcessEventResult) -> EventProcessResult {
        use azul_core::events::ProcessEventResult as PER;
        match result {
            PER::DoNothing => EventProcessResult::DoNothing,
            PER::ShouldReRenderCurrentWindow => EventProcessResult::RequestRedraw,
            PER::ShouldUpdateDisplayListCurrentWindow => EventProcessResult::RegenerateDisplayList,
            PER::UpdateHitTesterAndProcessAgain => EventProcessResult::RegenerateDisplayList,
            PER::ShouldRegenerateDomCurrentWindow => EventProcessResult::RegenerateDisplayList,
            PER::ShouldRegenerateDomAllWindows => EventProcessResult::RegenerateDisplayList,
        }
    }

    // NOTE: perform_scrollbar_hit_test(), handle_scrollbar_click(), and handle_scrollbar_drag()
    // are now provided by the PlatformWindowV2 trait as default methods.
    // The trait methods are cross-platform and work identically.
    // See dll/src/desktop/shell2/common/event_v2.rs for the implementation.

    /// Process a mouse button down event.
    pub fn handle_mouse_down(
        &mut self,
        event: &NSEvent,
        button: MouseButton,
    ) -> EventProcessResult {
        let location = unsafe { event.locationInWindow() };
        let window_height = self.current_window_state.size.dimensions.height;
        let position = macos_to_azul_coords(location, window_height);

        // Check for scrollbar hit FIRST (before state changes)
        // Use trait method from PlatformWindowV2
        if let Some(scrollbar_hit_id) = PlatformWindowV2::perform_scrollbar_hit_test(self, position)
        {
            let result = PlatformWindowV2::handle_scrollbar_click(self, scrollbar_hit_id, position);
            return Self::convert_process_result(result);
        }

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update mouse state
        self.current_window_state.mouse_state.cursor_position = CursorPosition::InWindow(position);

        // Set appropriate button flag
        match button {
            MouseButton::Left => self.current_window_state.mouse_state.left_down = true,
            MouseButton::Right => self.current_window_state.mouse_state.right_down = true,
            MouseButton::Middle => self.current_window_state.mouse_state.middle_down = true,
            _ => {}
        }

        // Record input sample for gesture detection (button down starts new session)
        let button_state = match button {
            MouseButton::Left => 0x01,
            MouseButton::Right => 0x02,
            MouseButton::Middle => 0x04,
            _ => 0x00,
        };
        self.record_input_sample(position, button_state, true, false);

        // Perform hit testing and update last_hit_test
        self.update_hit_test(position);

        // Use V2 cross-platform event system - it will automatically:
        // - Detect MouseDown event (left/right/middle)
        // - Dispatch to hovered nodes (including CSD buttons with callbacks)
        // - Handle event propagation
        // - Process callback results recursively
        let result = self.process_window_events_recursive_v2(0);

        Self::convert_process_result(result)
    }

    /// Process a mouse button up event.
    pub fn handle_mouse_up(&mut self, event: &NSEvent, button: MouseButton) -> EventProcessResult {
        let location = unsafe { event.locationInWindow() };
        let window_height = self.current_window_state.size.dimensions.height;
        let position = macos_to_azul_coords(location, window_height);

        // End scrollbar drag if active (before state changes)
        if self.scrollbar_drag_state.is_some() {
            self.scrollbar_drag_state = None;
            return EventProcessResult::RequestRedraw;
        }

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update mouse state - clear appropriate button flag
        match button {
            MouseButton::Left => self.current_window_state.mouse_state.left_down = false,
            MouseButton::Right => self.current_window_state.mouse_state.right_down = false,
            MouseButton::Middle => self.current_window_state.mouse_state.middle_down = false,
            _ => {}
        }

        // Record input sample for gesture detection (button up ends session)
        let button_state = match button {
            MouseButton::Left => 0x01,
            MouseButton::Right => 0x02,
            MouseButton::Middle => 0x04,
            _ => 0x00,
        };
        self.record_input_sample(position, button_state, false, true);

        // Perform hit testing and update last_hit_test
        self.update_hit_test(position);

        // Check for right-click context menu (before event processing)
        if button == MouseButton::Right {
            if let Some(hit_node) = self.get_first_hovered_node() {
                if self
                    .try_show_context_menu(hit_node, position, event)
                    .is_some()
                {
                    return EventProcessResult::DoNothing;
                }
            }
        }

        // Use V2 cross-platform event system - automatically detects MouseUp
        let result = self.process_window_events_recursive_v2(0);
        Self::convert_process_result(result)
    }

    /// Process a mouse move event.
    pub fn handle_mouse_move(&mut self, event: &NSEvent) -> EventProcessResult {
        let location = unsafe { event.locationInWindow() };
        let window_height = self.current_window_state.size.dimensions.height;
        let position = macos_to_azul_coords(location, window_height);

        // Handle active scrollbar drag (special case - not part of normal event system)
        // Use trait method from PlatformWindowV2
        if self.scrollbar_drag_state.is_some() {
            let result = PlatformWindowV2::handle_scrollbar_drag(self, position);
            return Self::convert_process_result(result);
        }

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update mouse state
        self.current_window_state.mouse_state.cursor_position = CursorPosition::InWindow(position);

        // Record input sample for gesture detection (movement during button press)
        let button_state = if self.current_window_state.mouse_state.left_down {
            0x01
        } else {
            0x00
        } | if self.current_window_state.mouse_state.right_down {
            0x02
        } else {
            0x00
        } | if self.current_window_state.mouse_state.middle_down {
            0x04
        } else {
            0x00
        };
        self.record_input_sample(position, button_state, false, false);

        // Update hit test
        self.update_hit_test(position);

        // Update cursor based on CSS cursor properties
        // This is done BEFORE callbacks so callbacks can override the cursor
        if let Some(layout_window) = self.layout_window.as_ref() {
            if let Some(hit_test) = layout_window
                .hover_manager
                .get_current(&InputPointId::Mouse)
            {
                let cursor_test = layout_window.compute_cursor_type_hit_test(hit_test);
                // Update the window state cursor type
                self.current_window_state.mouse_state.mouse_cursor_type =
                    Some(cursor_test.cursor_icon).into();
                // Set the actual OS cursor
                let cursor_name = self.map_cursor_type_to_macos(cursor_test.cursor_icon);
                self.set_cursor(cursor_name);
            }
        }

        // V2 system will detect MouseOver/MouseEnter/MouseLeave/Drag from state diff
        let result = self.process_window_events_recursive_v2(0);
        Self::convert_process_result(result)
    }

    /// Process mouse entered window event.
    pub fn handle_mouse_entered(&mut self, event: &NSEvent) -> EventProcessResult {
        let location = unsafe { event.locationInWindow() };
        let window_height = self.current_window_state.size.dimensions.height;
        let position = macos_to_azul_coords(location, window_height);

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update mouse state - cursor is now in window
        self.current_window_state.mouse_state.cursor_position = CursorPosition::InWindow(position);

        // Update hit test
        self.update_hit_test(position);

        // V2 system will detect MouseEnter events from state diff
        let result = self.process_window_events_recursive_v2(0);
        Self::convert_process_result(result)
    }

    /// Process mouse exited window event.
    pub fn handle_mouse_exited(&mut self, event: &NSEvent) -> EventProcessResult {
        let location = unsafe { event.locationInWindow() };
        let window_height = self.current_window_state.size.dimensions.height;
        let position = macos_to_azul_coords(location, window_height);

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update mouse state - cursor left window
        self.current_window_state.mouse_state.cursor_position =
            CursorPosition::OutOfWindow(position);

        // Clear last hit test since mouse is out
        use azul_layout::managers::hover::InputPointId;
        if let Some(ref mut layout_window) = self.layout_window {
            layout_window
                .hover_manager
                .push_hit_test(InputPointId::Mouse, FullHitTest::empty(None));
        }

        // V2 system will detect MouseLeave events from state diff
        let result = self.process_window_events_recursive_v2(0);
        Self::convert_process_result(result)
    }

    /// Process a scroll wheel event.
    pub fn handle_scroll_wheel(&mut self, event: &NSEvent) -> EventProcessResult {
        let delta_x = unsafe { event.scrollingDeltaX() };
        let delta_y = unsafe { event.scrollingDeltaY() };
        let _has_precise = unsafe { event.hasPreciseScrollingDeltas() };

        let location = unsafe { event.locationInWindow() };
        let window_height = self.current_window_state.size.dimensions.height;
        let position = macos_to_azul_coords(location, window_height);

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update hit test FIRST (required for scroll manager)
        self.update_hit_test(position);

        // Record scroll sample using ScrollManager (if delta is significant)
        // The ScrollManager will update its internal state, and during the next render,
        // scroll_all_nodes() will synchronize the offsets to WebRender automatically.
        if (delta_x.abs() > 0.01 || delta_y.abs() > 0.01) {
            if let Some(layout_window) = self.get_layout_window_mut() {
                use azul_core::task::Instant;
                use azul_layout::managers::hover::InputPointId;

                let now = Instant::from(std::time::Instant::now());
                let _scroll_result = layout_window.scroll_manager.record_sample(
                    -delta_x as f32, // Invert for natural scrolling
                    -delta_y as f32,
                    &layout_window.hover_manager,
                    &InputPointId::Mouse,
                    now,
                );

                // Note: We do NOT call gpu_scroll() here - it would cause double-scrolling!
                // The scroll state will be automatically synchronized to WebRender during
                // the next render_and_present() call via scroll_all_nodes().
            }
        }

        // V2 system will detect Scroll event from ScrollManager state
        let result = self.process_window_events_recursive_v2(0);
        Self::convert_process_result(result)
    }

    /// Process a key down event.
    pub fn handle_key_down(&mut self, event: &NSEvent) -> EventProcessResult {
        let key_code = unsafe { event.keyCode() };
        let modifiers = unsafe { event.modifierFlags() };

        // Extract Unicode character from event
        let character = unsafe {
            event.characters().and_then(|s| {
                let s_str = s.to_string();
                s_str.chars().next()
            })
        };

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update keyboard state with keycode
        self.update_keyboard_state(key_code, modifiers, true);

        // Handle text input for printable characters
        // On macOS, interpretKeyEvents SHOULD trigger insertText: via NSTextInputClient,
        // but there seems to be an issue with protocol conformance in objc2.
        // So we handle printable characters directly here.
        // Control characters and modified keys (Cmd+X, Ctrl+C, etc.) are NOT inserted as text.
        if let Some(ch) = character {
            let is_control_char = ch.is_control();
            let has_cmd = modifiers.contains(objc2_app_kit::NSEventModifierFlags::Command);
            let has_ctrl = modifiers.contains(objc2_app_kit::NSEventModifierFlags::Control);
            
            // Only insert text for normal printable characters without Cmd/Ctrl
            if !is_control_char && !has_cmd && !has_ctrl {
                let text_input = ch.to_string();
                self.handle_text_input(&text_input);
            }
        }

        // V2 system will detect VirtualKeyDown and TextInput from state diff
        let result = self.process_window_events_recursive_v2(0);
        Self::convert_process_result(result)
    }

    /// Process a key up event.
    pub fn handle_key_up(&mut self, event: &NSEvent) -> EventProcessResult {
        let key_code = unsafe { event.keyCode() };
        let modifiers = unsafe { event.modifierFlags() };

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update keyboard state
        self.update_keyboard_state(key_code, modifiers, false);

        // Clear current character on key up
        self.update_keyboard_state_with_char(None);

        // V2 system will detect VirtualKeyUp from state diff
        let result = self.process_window_events_recursive_v2(0);
        Self::convert_process_result(result)
    }

    /// Process text input from IME (called from insertText:replacementRange:)
    ///
    /// This is the proper way to handle text input on macOS, as it respects
    /// the IME composition system for non-ASCII characters (accents, CJK, etc.)
    pub fn handle_text_input(&mut self, text: &str) {
        use crate::desktop::shell2::common::event_v2::{CallbackTarget, HitTestNode};
        use azul_core::events::ProcessEventResult;
        
        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Record text input - this returns a map of nodes that need TextInput event dispatched
        let affected_nodes = if let Some(layout_window) = self.get_layout_window_mut() {
            layout_window.record_text_input(text)
        } else {
            return; // No layout window, nothing to do
        };

        if affected_nodes.is_empty() {
            println!("[handle_text_input] No affected nodes returned from record_text_input");
            return;
        }

        // Manually process the generated text input event.
        // We do NOT call process_window_events_recursive_v2() here, because that function
        // is for discovering events from state diffs. Here, we already know the exact event.
        let mut overall_result = ProcessEventResult::DoNothing;
        
        for (dom_node_id, (event_filters, _needs_relayout)) in affected_nodes {
            // Convert DomNodeId to CallbackTarget
            if let Some(node_id) = dom_node_id.node.into_crate_internal() {
                let callback_target = CallbackTarget::Node(HitTestNode {
                    dom_id: dom_node_id.dom.inner as u64,
                    node_id: node_id.index() as u64,
                });
                
                // Invoke callbacks for each event filter (typically OnTextInput)
                for event_filter in &event_filters {
                    println!("[handle_text_input] Invoking callback for {:?}", event_filter);
                    let callback_results = self.invoke_callbacks_v2(callback_target.clone(), event_filter.clone());
                    
                    // Process each callback result
                    for callback_result in &callback_results {
                        let process_result = self.process_callback_result_v2(callback_result);
                        overall_result = overall_result.max(process_result);
                    }
                }
            }
        }

        // Apply text changeset after callbacks
        if let Some(layout_window) = self.get_layout_window_mut() {
            let dirty_nodes = layout_window.apply_text_changeset();
            if !dirty_nodes.is_empty() {
                println!("[handle_text_input] Applied text changeset, {} dirty nodes", dirty_nodes.len());
                overall_result = overall_result.max(ProcessEventResult::ShouldReRenderCurrentWindow);
            }
        }

        // Request redraw if needed
        if overall_result >= ProcessEventResult::ShouldReRenderCurrentWindow {
            self.frame_needs_regeneration = true;
        }
    }

    /// Process a flags changed event (modifier keys).
    pub fn handle_flags_changed(&mut self, event: &NSEvent) -> EventProcessResult {
        let modifiers = unsafe { event.modifierFlags() };

        // Determine which modifier keys are currently pressed
        let shift_pressed = modifiers.contains(NSEventModifierFlags::Shift);
        let ctrl_pressed = modifiers.contains(NSEventModifierFlags::Control);
        let alt_pressed = modifiers.contains(NSEventModifierFlags::Option);
        let cmd_pressed = modifiers.contains(NSEventModifierFlags::Command);

        // Track previous state to detect what changed
        let keyboard_state = &self.current_window_state.keyboard_state;
        let was_shift_down = keyboard_state.shift_down();
        let was_ctrl_down = keyboard_state.ctrl_down();
        let was_alt_down = keyboard_state.alt_down();
        let was_cmd_down = keyboard_state.super_down();

        // Update keyboard state based on changes
        use azul_core::window::VirtualKeyCode;

        // Shift key changed
        if shift_pressed != was_shift_down {
            if shift_pressed {
                self.update_keyboard_state(0x38, modifiers, true); // LShift keycode
            } else {
                self.update_keyboard_state(0x38, modifiers, false);
            }
        }

        // Control key changed
        if ctrl_pressed != was_ctrl_down {
            if ctrl_pressed {
                self.update_keyboard_state(0x3B, modifiers, true); // LControl keycode
            } else {
                self.update_keyboard_state(0x3B, modifiers, false);
            }
        }

        // Alt/Option key changed
        if alt_pressed != was_alt_down {
            if alt_pressed {
                self.update_keyboard_state(0x3A, modifiers, true); // LAlt keycode
            } else {
                self.update_keyboard_state(0x3A, modifiers, false);
            }
        }

        // Command key changed
        if cmd_pressed != was_cmd_down {
            if cmd_pressed {
                self.update_keyboard_state(0x37, modifiers, true); // LWin (Command) keycode
            } else {
                self.update_keyboard_state(0x37, modifiers, false);
            }
        }

        // Dispatch modifier changed callbacks if any modifier changed
        if shift_pressed != was_shift_down
            || ctrl_pressed != was_ctrl_down
            || alt_pressed != was_alt_down
            || cmd_pressed != was_cmd_down
        {
            // For now, just return DoNothing - could dispatch specific callbacks later
            EventProcessResult::DoNothing
        } else {
            EventProcessResult::DoNothing
        }
    }

    /// Process a window resize event.
    pub fn handle_resize(&mut self, new_width: f64, new_height: f64) -> EventProcessResult {
        use azul_core::geom::LogicalSize;

        let new_size = LogicalSize {
            width: new_width as f32,
            height: new_height as f32,
        };

        // Store old context for comparison
        let old_context = self.dynamic_selector_context.clone();

        // Update window state
        self.current_window_state.size.dimensions = new_size;

        // Update dynamic selector context with new viewport dimensions
        self.dynamic_selector_context.viewport_width = new_width as f32;
        self.dynamic_selector_context.viewport_height = new_height as f32;
        self.dynamic_selector_context.orientation = if new_width > new_height {
            azul_css::dynamic_selector::OrientationType::Landscape
        } else {
            azul_css::dynamic_selector::OrientationType::Portrait
        };

        // Check if DPI changed (window may have moved to different display)
        let current_hidpi = self.get_hidpi_factor();
        let old_hidpi = self.current_window_state.size.get_hidpi_factor();

        if (current_hidpi.inner.get() - old_hidpi.inner.get()).abs() > 0.001 {
            log_info!(
                LogCategory::Window,
                "[Resize] DPI changed: {} -> {}",
                old_hidpi.inner.get(),
                current_hidpi.inner.get()
            );
            self.current_window_state.size.dpi = (current_hidpi.inner.get() * 96.0) as u32;
        }

        // Notify compositor of resize (this is private in mod.rs, so we inline it here)
        if let Err(e) = self.handle_compositor_resize() {
            log_error!(LogCategory::Rendering, "Compositor resize failed: {}", e);
        }

        // Check if viewport dimensions actually changed (debounce rapid resize events)
        let viewport_changed =
            (old_context.viewport_width - self.dynamic_selector_context.viewport_width).abs() > 0.5
                || (old_context.viewport_height - self.dynamic_selector_context.viewport_height)
                    .abs()
                    > 0.5;

        if !viewport_changed {
            // No significant change, just update compositor
            return EventProcessResult::RequestRedraw;
        }

        // Check if any CSS breakpoints were crossed
        // Common breakpoints: 320, 480, 640, 768, 1024, 1280, 1440, 1920
        let breakpoints = [320.0, 480.0, 640.0, 768.0, 1024.0, 1280.0, 1440.0, 1920.0];
        let breakpoint_crossed =
            old_context.viewport_breakpoint_changed(&self.dynamic_selector_context, &breakpoints);

        if breakpoint_crossed {
            log_debug!(
                LogCategory::Layout,
                "[Resize] Breakpoint crossed: {}x{} -> {}x{}",
                old_context.viewport_width,
                old_context.viewport_height,
                self.dynamic_selector_context.viewport_width,
                self.dynamic_selector_context.viewport_height
            );
        }

        // Resize requires full display list rebuild
        EventProcessResult::RegenerateDisplayList
    }

    /// Process a file drop event.
    pub fn handle_file_drop(&mut self, paths: Vec<String>) -> EventProcessResult {
        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update cursor manager with dropped file
        if let Some(first_path) = paths.first() {
            if let Some(layout_window) = self.layout_window.as_mut() {
                layout_window
                    .file_drop_manager
                    .set_dropped_file(Some(first_path.clone().into()));
            }
        }

        // Update hit test at current cursor position
        if let CursorPosition::InWindow(pos) = self.current_window_state.mouse_state.cursor_position
        {
            self.update_hit_test(pos);
        }

        // V2 system will detect FileDrop event from state diff
        let result = self.process_window_events_recursive_v2(0);

        // Clear dropped file after processing (one-shot event)
        if let Some(layout_window) = self.layout_window.as_mut() {
            layout_window.file_drop_manager.set_dropped_file(None);
        }

        Self::convert_process_result(result)
    }

    /// Perform hit testing at given position using WebRender hit-testing API.
    fn perform_hit_test(&mut self, position: LogicalPosition) -> Option<HitTestNode> {
        use azul_core::window::CursorPosition;

        let layout_window = self.layout_window.as_ref()?;

        // Early return if no layout results
        if layout_window.layout_results.is_empty() {
            return None;
        }

        let cursor_position = CursorPosition::InWindow(position);

        // Get focused node from FocusManager
        let focused_node = layout_window.focus_manager.get_focused_node().copied();

        // Use layout_results directly (BTreeMap)
        let hit_test = crate::desktop::wr_translate2::fullhittest_new_webrender(
            &*self.hit_tester.resolve(),
            self.document_id,
            focused_node,
            &layout_window.layout_results,
            &cursor_position,
            self.current_window_state.size.get_hidpi_factor(),
        );

        // Extract first hovered node from hit test result
        hit_test
            .hovered_nodes
            .iter()
            .flat_map(|(dom_id, ht)| {
                ht.regular_hit_test_nodes.keys().next().map(|node_id| {
                    let node_id_value = node_id.index();
                    HitTestNode {
                        dom_id: dom_id.inner as u64,
                        node_id: node_id_value as u64,
                    }
                })
            })
            .next()
    }

    /// Convert macOS keycode to VirtualKeyCode.
    fn convert_keycode(&self, keycode: u16) -> Option<VirtualKeyCode> {
        // macOS keycodes: https://eastmanreference.com/complete-list-of-applescript-key-codes
        match keycode {
            0x00 => Some(VirtualKeyCode::A),
            0x01 => Some(VirtualKeyCode::S),
            0x02 => Some(VirtualKeyCode::D),
            0x03 => Some(VirtualKeyCode::F),
            0x04 => Some(VirtualKeyCode::H),
            0x05 => Some(VirtualKeyCode::G),
            0x06 => Some(VirtualKeyCode::Z),
            0x07 => Some(VirtualKeyCode::X),
            0x08 => Some(VirtualKeyCode::C),
            0x09 => Some(VirtualKeyCode::V),
            0x0B => Some(VirtualKeyCode::B),
            0x0C => Some(VirtualKeyCode::Q),
            0x0D => Some(VirtualKeyCode::W),
            0x0E => Some(VirtualKeyCode::E),
            0x0F => Some(VirtualKeyCode::R),
            0x10 => Some(VirtualKeyCode::Y),
            0x11 => Some(VirtualKeyCode::T),
            0x12 => Some(VirtualKeyCode::Key1),
            0x13 => Some(VirtualKeyCode::Key2),
            0x14 => Some(VirtualKeyCode::Key3),
            0x15 => Some(VirtualKeyCode::Key4),
            0x16 => Some(VirtualKeyCode::Key6),
            0x17 => Some(VirtualKeyCode::Key5),
            0x18 => Some(VirtualKeyCode::Equals),
            0x19 => Some(VirtualKeyCode::Key9),
            0x1A => Some(VirtualKeyCode::Key7),
            0x1B => Some(VirtualKeyCode::Minus),
            0x1C => Some(VirtualKeyCode::Key8),
            0x1D => Some(VirtualKeyCode::Key0),
            0x1E => Some(VirtualKeyCode::RBracket),
            0x1F => Some(VirtualKeyCode::O),
            0x20 => Some(VirtualKeyCode::U),
            0x21 => Some(VirtualKeyCode::LBracket),
            0x22 => Some(VirtualKeyCode::I),
            0x23 => Some(VirtualKeyCode::P),
            0x24 => Some(VirtualKeyCode::Return),
            0x25 => Some(VirtualKeyCode::L),
            0x26 => Some(VirtualKeyCode::J),
            0x27 => Some(VirtualKeyCode::Apostrophe),
            0x28 => Some(VirtualKeyCode::K),
            0x29 => Some(VirtualKeyCode::Semicolon),
            0x2A => Some(VirtualKeyCode::Backslash),
            0x2B => Some(VirtualKeyCode::Comma),
            0x2C => Some(VirtualKeyCode::Slash),
            0x2D => Some(VirtualKeyCode::N),
            0x2E => Some(VirtualKeyCode::M),
            0x2F => Some(VirtualKeyCode::Period),
            0x30 => Some(VirtualKeyCode::Tab),
            0x31 => Some(VirtualKeyCode::Space),
            0x32 => Some(VirtualKeyCode::Grave),
            0x33 => Some(VirtualKeyCode::Back),
            0x35 => Some(VirtualKeyCode::Escape),
            0x37 => Some(VirtualKeyCode::LWin), // Command
            0x38 => Some(VirtualKeyCode::LShift),
            0x39 => Some(VirtualKeyCode::Capital), // Caps Lock
            0x3A => Some(VirtualKeyCode::LAlt),    // Option
            0x3B => Some(VirtualKeyCode::LControl),
            0x3C => Some(VirtualKeyCode::RShift),
            0x3D => Some(VirtualKeyCode::RAlt),
            0x3E => Some(VirtualKeyCode::RControl),
            0x7B => Some(VirtualKeyCode::Left),
            0x7C => Some(VirtualKeyCode::Right),
            0x7D => Some(VirtualKeyCode::Down),
            0x7E => Some(VirtualKeyCode::Up),
            _ => None,
        }
    }

    /// Update keyboard state from event.
    fn update_keyboard_state(
        &mut self,
        keycode: u16,
        modifiers: NSEventModifierFlags,
        is_down: bool,
    ) {
        use azul_core::window::VirtualKeyCode;

        // Convert keycode to VirtualKeyCode first (before borrowing)
        let vk = match self.convert_keycode(keycode) {
            Some(k) => k,
            None => return,
        };

        let keyboard_state = &mut self.current_window_state.keyboard_state;

        if is_down {
            // Add to pressed keys if not already present
            let mut already_pressed = false;
            for pressed_key in keyboard_state.pressed_virtual_keycodes.as_ref() {
                if *pressed_key == vk {
                    already_pressed = true;
                    break;
                }
            }
            if !already_pressed {
                // Convert to Vec, add, convert back
                let mut pressed_vec: Vec<VirtualKeyCode> =
                    keyboard_state.pressed_virtual_keycodes.as_ref().to_vec();
                pressed_vec.push(vk);
                keyboard_state.pressed_virtual_keycodes =
                    azul_core::window::VirtualKeyCodeVec::from_vec(pressed_vec);
            }
            keyboard_state.current_virtual_keycode =
                azul_core::window::OptionVirtualKeyCode::Some(vk);
        } else {
            // Remove from pressed keys
            let pressed_vec: Vec<VirtualKeyCode> = keyboard_state
                .pressed_virtual_keycodes
                .as_ref()
                .iter()
                .copied()
                .filter(|k| *k != vk)
                .collect();
            keyboard_state.pressed_virtual_keycodes =
                azul_core::window::VirtualKeyCodeVec::from_vec(pressed_vec);
            keyboard_state.current_virtual_keycode = azul_core::window::OptionVirtualKeyCode::None;
        }
    }

    /// Update keyboard state with character from event
    /// NOTE: This method is deprecated and should not set current_char anymore.
    /// Text input is now handled by process_text_input() which receives the
    /// composed text directly from NSTextInputClient.
    fn update_keyboard_state_with_char(&mut self, _character: Option<char>) {
        // current_char field has been removed from KeyboardState
        // KeyboardState now only tracks virtual keys and scancodes
        // Text input is handled separately by LayoutWindow::process_text_input()
    }

    /// Handle compositor resize notification.
    fn handle_compositor_resize(&mut self) -> Result<(), String> {
        use webrender::api::units::{DeviceIntRect, DeviceIntSize, DevicePixelScale};

        // Get new physical size
        let physical_size = self.current_window_state.size.get_physical_size();
        let new_size = DeviceIntSize::new(physical_size.width as i32, physical_size.height as i32);
        let hidpi_factor = self.current_window_state.size.get_hidpi_factor();

        // Update WebRender document size
        let mut txn = webrender::Transaction::new();
        let device_rect = DeviceIntRect::from_size(new_size);
        // NOTE: azul_layout outputs coordinates in CSS pixels (logical pixels).
        txn.set_document_view(device_rect, DevicePixelScale::new(hidpi_factor.inner.get()));

        // Send transaction
        if let Some(ref layout_window) = self.layout_window {
            let document_id =
                crate::desktop::wr_translate2::wr_translate_document_id(layout_window.document_id);
            self.render_api.send_transaction(document_id, txn);
        }

        // Resize GL viewport (if OpenGL backend)
        if let Some(ref gl_context) = self.gl_context {
            // Make context current
            unsafe {
                gl_context.makeCurrentContext();
            }

            // Resize viewport
            if let Some(ref gl) = self.gl_functions {
                use azul_core::gl as gl_types;
                gl.functions.viewport(
                    0,
                    0,
                    physical_size.width as gl_types::GLint,
                    physical_size.height as gl_types::GLint,
                );
            }
        }

        // Resize CPU framebuffer if using CPU backend
        if let Some(cpu_view) = &self.cpu_view {
            unsafe {
                // Force the CPU view to resize its framebuffer on next draw
                // The actual resize happens in CPUView::drawRect when bounds change
                cpu_view.setNeedsDisplay(true);
            }
        }

        Ok(())
    }

    /// Try to show context menu for the given node at position.
    /// Returns Some if a menu was shown, None otherwise.
    fn try_show_context_menu(
        &mut self,
        node: HitTestNode,
        position: LogicalPosition,
        event: &NSEvent,
    ) -> Option<()> {
        use azul_core::dom::DomId;

        let layout_window = self.layout_window.as_ref()?;
        let dom_id = DomId {
            inner: node.dom_id as usize,
        };

        // Get layout result for this DOM
        let layout_result = layout_window.layout_results.get(&dom_id)?;

        // Check if this node has a context menu
        let node_id = azul_core::id::NodeId::from_usize(node.node_id as usize)?;
        let binding = layout_result.styled_dom.node_data.as_container();
        let node_data = binding.get(node_id)?;

        // Context menus are stored directly on NodeData, not as callbacks
        // Clone the menu to avoid borrow conflicts
        let context_menu = node_data.get_context_menu()?.clone();

        log_debug!(
            LogCategory::Input,
            "[Context Menu] Showing context menu at ({}, {}) for node {:?} with {} items",
            position.x,
            position.y,
            node,
            context_menu.items.as_slice().len()
        );

        // Check if native context menus are enabled
        if self.current_window_state.flags.use_native_context_menus {
            self.show_native_context_menu_at_position(&context_menu, position, event);
        } else {
            self.show_window_based_context_menu(&context_menu, position);
        }

        Some(())
    }

    /// Show an NSMenu as a context menu at the given screen position.
    fn show_native_context_menu_at_position(
        &mut self,
        menu: &azul_core::menu::Menu,
        position: LogicalPosition,
        event: &NSEvent,
    ) {
        use objc2_app_kit::{NSMenu, NSMenuItem};
        use objc2_foundation::{MainThreadMarker, NSPoint, NSString};

        let mtm = match MainThreadMarker::new() {
            Some(m) => m,
            None => {
                log_warn!(
                    LogCategory::Platform,
                    "[Context Menu] Not on main thread, cannot show menu"
                );
                return;
            }
        };

        let ns_menu = NSMenu::new(mtm);

        // Build menu items recursively from Azul menu structure
        Self::recursive_build_nsmenu(&ns_menu, menu.items.as_slice(), &mtm, &mut self.menu_state);

        // Show the menu at the specified position
        let view_point = NSPoint {
            x: position.x as f64,
            y: position.y as f64,
        };

        let view = if let Some(ref gl_view) = self.gl_view {
            Some(&**gl_view as &objc2::runtime::AnyObject)
        } else if let Some(ref cpu_view) = self.cpu_view {
            Some(&**cpu_view as &objc2::runtime::AnyObject)
        } else {
            None
        };

        if let Some(view) = view {
            log_debug!(
                LogCategory::Input,
                "[Context Menu] Showing native menu at position ({}, {}) with {} items",
                position.x,
                position.y,
                menu.items.as_slice().len()
            );

            unsafe {
                use objc2::{msg_send_id, rc::Retained, runtime::AnyObject, sel};

                let _: () = msg_send_id![
                    &ns_menu,
                    popUpMenuPositioningItem: Option::<&AnyObject>::None,
                    atLocation: view_point,
                    inView: view
                ];
            }
        }
    }

    /// Show a context menu using Azul window-based menu system
    ///
    /// This uses the same unified menu system as regular menus (crate::desktop::menu::show_menu)
    /// but spawns at cursor position instead of below a trigger rect.
    ///
    /// The menu window creation is queued and will be processed in Phase 3 of the event loop.
    fn show_window_based_context_menu(
        &mut self,
        menu: &azul_core::menu::Menu,
        position: LogicalPosition,
    ) {
        // Get parent window position
        let parent_pos = match self.current_window_state.position {
            azul_core::window::WindowPosition::Initialized(pos) => {
                LogicalPosition::new(pos.x as f32, pos.y as f32)
            }
            _ => LogicalPosition::new(0.0, 0.0),
        };

        // Create menu window options using the unified menu system
        // This is identical to how menu bar menus work, but with cursor_pos instead of trigger_rect
        let menu_options = crate::desktop::menu::show_menu(
            menu.clone(),
            self.system_style.clone(),
            parent_pos,
            None,           // No trigger rect for context menus (they spawn at cursor)
            Some(position), // Cursor position for menu positioning
            None,           // No parent menu
        );

        // Queue window creation request for processing in Phase 3 of the event loop
        // The event loop will create the window with MacOSWindow::new_with_fc_cache()
        log_debug!(
            LogCategory::Window,
            "[macOS] Queuing window-based context menu at screen ({}, {}) - will be created in \
             event loop Phase 3",
            position.x,
            position.y
        );

        self.pending_window_creates.push(menu_options);
    }

    /// Recursively builds an NSMenu from Azul MenuItem array
    ///
    /// This mirrors the Win32 recursive_construct_menu() logic:
    /// - Leaf items (no children) -> addItem with callback
    /// - Items with children -> create submenu and recurse
    /// - Separators -> add separator item
    pub(crate) fn recursive_build_nsmenu(
        menu: &objc2_app_kit::NSMenu,
        items: &[azul_core::menu::MenuItem],
        mtm: &objc2::MainThreadMarker,
        menu_state: &mut crate::desktop::shell2::macos::menu::MenuState,
    ) {
        use objc2_app_kit::{NSMenu, NSMenuItem};
        use objc2_foundation::NSString;

        for item in items {
            match item {
                azul_core::menu::MenuItem::String(string_item) => {
                    let menu_item = NSMenuItem::new(*mtm);
                    let title = NSString::from_str(&string_item.label);
                    menu_item.setTitle(&title);

                    // Set enabled/disabled state based on MenuItemState
                    let enabled = match string_item.menu_item_state {
                        azul_core::menu::MenuItemState::Normal => true,
                        azul_core::menu::MenuItemState::Disabled => false,
                        azul_core::menu::MenuItemState::Greyed => false,
                    };
                    menu_item.setEnabled(enabled);

                    // Check if this item has children (submenu)
                    if !string_item.children.as_ref().is_empty() {
                        // Create submenu and recurse
                        let submenu = NSMenu::new(*mtm);
                        let submenu_title = NSString::from_str(&string_item.label);
                        submenu.setTitle(&submenu_title);

                        // Recursively build submenu items
                        Self::recursive_build_nsmenu(
                            &submenu,
                            string_item.children.as_ref(),
                            mtm,
                            menu_state,
                        );

                        // Attach submenu to menu item
                        menu_item.setSubmenu(Some(&submenu));

                        log_debug!(
                            LogCategory::Input,
                            "[Context Menu] Created submenu '{}' with {} items",
                            string_item.label,
                            string_item.children.as_ref().len()
                        );
                    } else {
                        use crate::desktop::shell2::macos::menu;
                        // Leaf item - wire up callback using the same system as menu bar
                        if let Some(callback) = string_item.callback.as_option() {
                            let tag = menu_state.register_callback(callback.clone());
                            menu_item.setTag(tag as isize);

                            // Use shared AzulMenuTarget for callback dispatch
                            let target = menu::AzulMenuTarget::shared_instance(*mtm);
                            unsafe {
                                menu_item.setTarget(Some(&target));
                                menu_item.setAction(Some(objc2::sel!(menuItemAction:)));
                            }
                        }

                        // Set keyboard shortcut if present
                        if let Some(ref accelerator) = string_item.accelerator.into_option() {
                            menu::set_menu_item_accelerator(&menu_item, accelerator);
                        }
                    }

                    menu.addItem(&menu_item);
                }

                azul_core::menu::MenuItem::Separator => {
                    let separator = unsafe { NSMenuItem::separatorItem(*mtm) };
                    menu.addItem(&separator);
                }

                azul_core::menu::MenuItem::BreakLine => {
                    // BreakLine is for horizontal menu layouts, not supported in NSMenu
                    // Just add a separator as a visual indication
                    let separator = unsafe { NSMenuItem::separatorItem(*mtm) };
                    menu.addItem(&separator);
                }
            }
        }
    }

    // Helper Functions for V2 Event System

    /// Update hit test at given position and store in current_window_state.
    fn update_hit_test(&mut self, position: LogicalPosition) {
        if let Some(layout_window) = self.layout_window.as_mut() {
            let cursor_position = CursorPosition::InWindow(position);
            // Get focused node from FocusManager
            let focused_node = layout_window.focus_manager.get_focused_node().copied();
            let hit_test = crate::desktop::wr_translate2::fullhittest_new_webrender(
                &*self.hit_tester.resolve(),
                self.document_id,
                focused_node,
                &layout_window.layout_results,
                &cursor_position,
                self.current_window_state.size.get_hidpi_factor(),
            );
            use azul_layout::managers::hover::InputPointId;
            layout_window
                .hover_manager
                .push_hit_test(InputPointId::Mouse, hit_test);
        }
    }

    /// Get the first hovered node from current mouse hit test.
    fn get_first_hovered_node(&self) -> Option<HitTestNode> {
        use azul_layout::managers::hover::InputPointId;
        self.layout_window
            .as_ref()?
            .hover_manager
            .get_current(&InputPointId::Mouse)?
            .hovered_nodes
            .iter()
            .flat_map(|(dom_id, ht)| {
                ht.regular_hit_test_nodes
                    .keys()
                    .next()
                    .map(|node_id| HitTestNode {
                        dom_id: dom_id.inner as u64,
                        node_id: node_id.index() as u64,
                    })
            })
            .next()
    }

    /// Convert ProcessEventResult to EventProcessResult for old API compatibility.
    fn process_callback_result_to_event_result_v2(
        &self,
        result: ProcessEventResult,
    ) -> EventProcessResult {
        Self::convert_process_result(result)
    }

    // V2 Cross-Platform Event Processing
    // NOTE: All V2 event processing methods are now provided by the
    // PlatformWindowV2 trait in common/event_v2.rs. The trait provides:
    // - process_window_events_v2() - Entry point (public API)
    // - process_window_events_recursive_v2() - Recursive processing
    // - invoke_callbacks_v2() - Required method (implemented in mod.rs)
    // - process_callback_result_v2() - Result handling
    // This eliminates ~336 lines of platform-specific duplicated code.
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_keycode_conversion() {
        // Test some basic keycodes
        assert_eq!(Some(VirtualKeyCode::A), convert_keycode_test(0x00));
        assert_eq!(Some(VirtualKeyCode::Return), convert_keycode_test(0x24));
        assert_eq!(Some(VirtualKeyCode::Space), convert_keycode_test(0x31));
        assert_eq!(None, convert_keycode_test(0xFF)); // Invalid
    }

    fn convert_keycode_test(keycode: u16) -> Option<VirtualKeyCode> {
        // Helper for testing keycode conversion without MacOSWindow instance
        match keycode {
            0x00 => Some(VirtualKeyCode::A),
            0x24 => Some(VirtualKeyCode::Return),
            0x31 => Some(VirtualKeyCode::Space),
            _ => None,
        }
    }
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/gl.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
use std::{
    ffi::{c_char, c_void, CString},
    fmt,
    rc::Rc,
};

use gl_context_loader::GenericGlContext;

// Ensure we can call dlopen/dlsym/dlclose
#[link(name = "dl")]
extern "C" {
    fn dlopen(filename: *const c_char, flag: i32) -> *mut c_void;
    fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
    fn dlclose(handle: *mut c_void) -> i32;
}

// Wrapper to get access to the GL function pointers
pub struct GlFunctions {
    /// The handle returned by dlopen.
    _opengl_lib_handle: *mut c_void,

    /// Actual GL function pointers (glClear, glClearColor, etc.)
    pub functions: Rc<GenericGlContext>,
}

impl fmt::Debug for GlFunctions {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Just show the pointer’s numeric value
        write!(
            f,
            "GlFunctions {{ handle = {:0x?} }}",
            self._opengl_lib_handle as usize
        )
    }
}

impl GlFunctions {
    /// Allocates and loads the OpenGL function pointers via dlopen
    pub fn initialize() -> Result<Self, String> {
        fn get_func(symbol_name: &str, handle: *mut c_void) -> *mut gl_context_loader::c_void {
            let c_string = CString::new(symbol_name).unwrap();
            (unsafe { dlsym(handle, c_string.as_ptr()) }) as *mut _
        }

        // Typical flags for dlopen:
        const RTLD_NOW: i32 = 2;
        const RTLD_LOCAL: i32 = 0;
        const RTLD_GLOBAL: i32 = 8; // Or 0x100 if needed

        // Full path to Apple’s OpenGL framework library
        // Alternatively: "/System/Library/Frameworks/OpenGL.framework/OpenGL"
        let framework_path =
            CString::new("/System/Library/Frameworks/OpenGL.framework/OpenGL").unwrap();

        // RTLD_NOW means "resolve all symbols immediately".
        // RTLD_GLOBAL or RTLD_LOCAL depends on your use-case.
        let handle = unsafe { dlopen(framework_path.as_ptr(), RTLD_NOW | RTLD_GLOBAL) };
        if handle.is_null() {
            return Err("Could not dlopen OpenGL.framework/OpenGL".to_string());
        }

        // Zero-init the entire function table
        let context = GenericGlContext {
            glAccum: get_func("glAccum", handle),
            glActiveTexture: get_func("glActiveTexture", handle),
            glAlphaFunc: get_func("glAlphaFunc", handle),
            glAreTexturesResident: get_func("glAreTexturesResident", handle),
            glArrayElement: get_func("glArrayElement", handle),
            glAttachShader: get_func("glAttachShader", handle),
            glBegin: get_func("glBegin", handle),
            glBeginConditionalRender: get_func("glBeginConditionalRender", handle),
            glBeginQuery: get_func("glBeginQuery", handle),
            glBeginTransformFeedback: get_func("glBeginTransformFeedback", handle),
            glBindAttribLocation: get_func("glBindAttribLocation", handle),
            glBindBuffer: get_func("glBindBuffer", handle),
            glBindBufferBase: get_func("glBindBufferBase", handle),
            glBindBufferRange: get_func("glBindBufferRange", handle),
            glBindFragDataLocation: get_func("glBindFragDataLocation", handle),
            glBindFragDataLocationIndexed: get_func("glBindFragDataLocationIndexed", handle),
            glBindFramebuffer: get_func("glBindFramebuffer", handle),
            glBindRenderbuffer: get_func("glBindRenderbuffer", handle),
            glBindSampler: get_func("glBindSampler", handle),
            glBindTexture: get_func("glBindTexture", handle),
            glBindVertexArray: get_func("glBindVertexArray", handle),
            glBindVertexArrayAPPLE: get_func("glBindVertexArrayAPPLE", handle),
            glBitmap: get_func("glBitmap", handle),
            glBlendBarrierKHR: get_func("glBlendBarrierKHR", handle),
            glBlendColor: get_func("glBlendColor", handle),
            glBlendEquation: get_func("glBlendEquation", handle),
            glBlendEquationSeparate: get_func("glBlendEquationSeparate", handle),
            glBlendFunc: get_func("glBlendFunc", handle),
            glBlendFuncSeparate: get_func("glBlendFuncSeparate", handle),
            glBlitFramebuffer: get_func("glBlitFramebuffer", handle),
            glBufferData: get_func("glBufferData", handle),
            glBufferStorage: get_func("glBufferStorage", handle),
            glBufferSubData: get_func("glBufferSubData", handle),
            glCallList: get_func("glCallList", handle),
            glCallLists: get_func("glCallLists", handle),
            glCheckFramebufferStatus: get_func("glCheckFramebufferStatus", handle),
            glClampColor: get_func("glClampColor", handle),
            glClear: get_func("glClear", handle),
            glClearAccum: get_func("glClearAccum", handle),
            glClearBufferfi: get_func("glClearBufferfi", handle),
            glClearBufferfv: get_func("glClearBufferfv", handle),
            glClearBufferiv: get_func("glClearBufferiv", handle),
            glClearBufferuiv: get_func("glClearBufferuiv", handle),
            glClearColor: get_func("glClearColor", handle),
            glClearDepth: get_func("glClearDepth", handle),
            glClearIndex: get_func("glClearIndex", handle),
            glClearStencil: get_func("glClearStencil", handle),
            glClientActiveTexture: get_func("glClientActiveTexture", handle),
            glClientWaitSync: get_func("glClientWaitSync", handle),
            glClipPlane: get_func("glClipPlane", handle),
            glColor3b: get_func("glColor3b", handle),
            glColor3bv: get_func("glColor3bv", handle),
            glColor3d: get_func("glColor3d", handle),
            glColor3dv: get_func("glColor3dv", handle),
            glColor3f: get_func("glColor3f", handle),
            glColor3fv: get_func("glColor3fv", handle),
            glColor3i: get_func("glColor3i", handle),
            glColor3iv: get_func("glColor3iv", handle),
            glColor3s: get_func("glColor3s", handle),
            glColor3sv: get_func("glColor3sv", handle),
            glColor3ub: get_func("glColor3ub", handle),
            glColor3ubv: get_func("glColor3ubv", handle),
            glColor3ui: get_func("glColor3ui", handle),
            glColor3uiv: get_func("glColor3uiv", handle),
            glColor3us: get_func("glColor3us", handle),
            glColor3usv: get_func("glColor3usv", handle),
            glColor4b: get_func("glColor4b", handle),
            glColor4bv: get_func("glColor4bv", handle),
            glColor4d: get_func("glColor4d", handle),
            glColor4dv: get_func("glColor4dv", handle),
            glColor4f: get_func("glColor4f", handle),
            glColor4fv: get_func("glColor4fv", handle),
            glColor4i: get_func("glColor4i", handle),
            glColor4iv: get_func("glColor4iv", handle),
            glColor4s: get_func("glColor4s", handle),
            glColor4sv: get_func("glColor4sv", handle),
            glColor4ub: get_func("glColor4ub", handle),
            glColor4ubv: get_func("glColor4ubv", handle),
            glColor4ui: get_func("glColor4ui", handle),
            glColor4uiv: get_func("glColor4uiv", handle),
            glColor4us: get_func("glColor4us", handle),
            glColor4usv: get_func("glColor4usv", handle),
            glColorMask: get_func("glColorMask", handle),
            glColorMaski: get_func("glColorMaski", handle),
            glColorMaterial: get_func("glColorMaterial", handle),
            glColorP3ui: get_func("glColorP3ui", handle),
            glColorP3uiv: get_func("glColorP3uiv", handle),
            glColorP4ui: get_func("glColorP4ui", handle),
            glColorP4uiv: get_func("glColorP4uiv", handle),
            glColorPointer: get_func("glColorPointer", handle),
            glCompileShader: get_func("glCompileShader", handle),
            glCompressedTexImage1D: get_func("glCompressedTexImage1D", handle),
            glCompressedTexImage2D: get_func("glCompressedTexImage2D", handle),
            glCompressedTexImage3D: get_func("glCompressedTexImage3D", handle),
            glCompressedTexSubImage1D: get_func("glCompressedTexSubImage1D", handle),
            glCompressedTexSubImage2D: get_func("glCompressedTexSubImage2D", handle),
            glCompressedTexSubImage3D: get_func("glCompressedTexSubImage3D", handle),
            glCopyBufferSubData: get_func("glCopyBufferSubData", handle),
            glCopyImageSubData: get_func("glCopyImageSubData", handle),
            glCopyPixels: get_func("glCopyPixels", handle),
            glCopyTexImage1D: get_func("glCopyTexImage1D", handle),
            glCopyTexImage2D: get_func("glCopyTexImage2D", handle),
            glCopyTexSubImage1D: get_func("glCopyTexSubImage1D", handle),
            glCopyTexSubImage2D: get_func("glCopyTexSubImage2D", handle),
            glCopyTexSubImage3D: get_func("glCopyTexSubImage3D", handle),
            glCreateProgram: get_func("glCreateProgram", handle),
            glCreateShader: get_func("glCreateShader", handle),
            glCullFace: get_func("glCullFace", handle),
            glDebugMessageCallback: get_func("glDebugMessageCallback", handle),
            glDebugMessageCallbackKHR: get_func("glDebugMessageCallbackKHR", handle),
            glDebugMessageControl: get_func("glDebugMessageControl", handle),
            glDebugMessageControlKHR: get_func("glDebugMessageControlKHR", handle),
            glDebugMessageInsert: get_func("glDebugMessageInsert", handle),
            glDebugMessageInsertKHR: get_func("glDebugMessageInsertKHR", handle),
            glDeleteBuffers: get_func("glDeleteBuffers", handle),
            glDeleteFencesAPPLE: get_func("glDeleteFencesAPPLE", handle),
            glDeleteFramebuffers: get_func("glDeleteFramebuffers", handle),
            glDeleteLists: get_func("glDeleteLists", handle),
            glDeleteProgram: get_func("glDeleteProgram", handle),
            glDeleteQueries: get_func("glDeleteQueries", handle),
            glDeleteRenderbuffers: get_func("glDeleteRenderbuffers", handle),
            glDeleteSamplers: get_func("glDeleteSamplers", handle),
            glDeleteShader: get_func("glDeleteShader", handle),
            glDeleteSync: get_func("glDeleteSync", handle),
            glDeleteTextures: get_func("glDeleteTextures", handle),
            glDeleteVertexArrays: get_func("glDeleteVertexArrays", handle),
            glDeleteVertexArraysAPPLE: get_func("glDeleteVertexArraysAPPLE", handle),
            glDepthFunc: get_func("glDepthFunc", handle),
            glDepthMask: get_func("glDepthMask", handle),
            glDepthRange: get_func("glDepthRange", handle),
            glDetachShader: get_func("glDetachShader", handle),
            glDisable: get_func("glDisable", handle),
            glDisableClientState: get_func("glDisableClientState", handle),
            glDisableVertexAttribArray: get_func("glDisableVertexAttribArray", handle),
            glDisablei: get_func("glDisablei", handle),
            glDrawArrays: get_func("glDrawArrays", handle),
            glDrawArraysInstanced: get_func("glDrawArraysInstanced", handle),
            glDrawBuffer: get_func("glDrawBuffer", handle),
            glDrawBuffers: get_func("glDrawBuffers", handle),
            glDrawElements: get_func("glDrawElements", handle),
            glDrawElementsBaseVertex: get_func("glDrawElementsBaseVertex", handle),
            glDrawElementsInstanced: get_func("glDrawElementsInstanced", handle),
            glDrawElementsInstancedBaseVertex: get_func(
                "glDrawElementsInstancedBaseVertex",
                handle,
            ),
            glDrawPixels: get_func("glDrawPixels", handle),
            glDrawRangeElements: get_func("glDrawRangeElements", handle),
            glDrawRangeElementsBaseVertex: get_func("glDrawRangeElementsBaseVertex", handle),
            glEdgeFlag: get_func("glEdgeFlag", handle),
            glEdgeFlagPointer: get_func("glEdgeFlagPointer", handle),
            glEdgeFlagv: get_func("glEdgeFlagv", handle),
            glEnable: get_func("glEnable", handle),
            glEnableClientState: get_func("glEnableClientState", handle),
            glEnableVertexAttribArray: get_func("glEnableVertexAttribArray", handle),
            glEnablei: get_func("glEnablei", handle),
            glEnd: get_func("glEnd", handle),
            glEndConditionalRender: get_func("glEndConditionalRender", handle),
            glEndList: get_func("glEndList", handle),
            glEndQuery: get_func("glEndQuery", handle),
            glEndTransformFeedback: get_func("glEndTransformFeedback", handle),
            glEvalCoord1d: get_func("glEvalCoord1d", handle),
            glEvalCoord1dv: get_func("glEvalCoord1dv", handle),
            glEvalCoord1f: get_func("glEvalCoord1f", handle),
            glEvalCoord1fv: get_func("glEvalCoord1fv", handle),
            glEvalCoord2d: get_func("glEvalCoord2d", handle),
            glEvalCoord2dv: get_func("glEvalCoord2dv", handle),
            glEvalCoord2f: get_func("glEvalCoord2f", handle),
            glEvalCoord2fv: get_func("glEvalCoord2fv", handle),
            glEvalMesh1: get_func("glEvalMesh1", handle),
            glEvalMesh2: get_func("glEvalMesh2", handle),
            glEvalPoint1: get_func("glEvalPoint1", handle),
            glEvalPoint2: get_func("glEvalPoint2", handle),
            glFeedbackBuffer: get_func("glFeedbackBuffer", handle),
            glFenceSync: get_func("glFenceSync", handle),
            glFinish: get_func("glFinish", handle),
            glFinishFenceAPPLE: get_func("glFinishFenceAPPLE", handle),
            glFinishObjectAPPLE: get_func("glFinishObjectAPPLE", handle),
            glFlush: get_func("glFlush", handle),
            glFlushMappedBufferRange: get_func("glFlushMappedBufferRange", handle),
            glFogCoordPointer: get_func("glFogCoordPointer", handle),
            glFogCoordd: get_func("glFogCoordd", handle),
            glFogCoorddv: get_func("glFogCoorddv", handle),
            glFogCoordf: get_func("glFogCoordf", handle),
            glFogCoordfv: get_func("glFogCoordfv", handle),
            glFogf: get_func("glFogf", handle),
            glFogfv: get_func("glFogfv", handle),
            glFogi: get_func("glFogi", handle),
            glFogiv: get_func("glFogiv", handle),
            glFramebufferRenderbuffer: get_func("glFramebufferRenderbuffer", handle),
            glFramebufferTexture: get_func("glFramebufferTexture", handle),
            glFramebufferTexture1D: get_func("glFramebufferTexture1D", handle),
            glFramebufferTexture2D: get_func("glFramebufferTexture2D", handle),
            glFramebufferTexture3D: get_func("glFramebufferTexture3D", handle),
            glFramebufferTextureLayer: get_func("glFramebufferTextureLayer", handle),
            glFrontFace: get_func("glFrontFace", handle),
            glFrustum: get_func("glFrustum", handle),
            glGenBuffers: get_func("glGenBuffers", handle),
            glGenFencesAPPLE: get_func("glGenFencesAPPLE", handle),
            glGenFramebuffers: get_func("glGenFramebuffers", handle),
            glGenLists: get_func("glGenLists", handle),
            glGenQueries: get_func("glGenQueries", handle),
            glGenRenderbuffers: get_func("glGenRenderbuffers", handle),
            glGenSamplers: get_func("glGenSamplers", handle),
            glGenTextures: get_func("glGenTextures", handle),
            glGenVertexArrays: get_func("glGenVertexArrays", handle),
            glGenVertexArraysAPPLE: get_func("glGenVertexArraysAPPLE", handle),
            glGenerateMipmap: get_func("glGenerateMipmap", handle),
            glGetActiveAttrib: get_func("glGetActiveAttrib", handle),
            glGetActiveUniform: get_func("glGetActiveUniform", handle),
            glGetActiveUniformBlockName: get_func("glGetActiveUniformBlockName", handle),
            glGetActiveUniformBlockiv: get_func("glGetActiveUniformBlockiv", handle),
            glGetActiveUniformName: get_func("glGetActiveUniformName", handle),
            glGetActiveUniformsiv: get_func("glGetActiveUniformsiv", handle),
            glGetAttachedShaders: get_func("glGetAttachedShaders", handle),
            glGetAttribLocation: get_func("glGetAttribLocation", handle),
            glGetBooleani_v: get_func("glGetBooleani_v", handle),
            glGetBooleanv: get_func("glGetBooleanv", handle),
            glGetBufferParameteri64v: get_func("glGetBufferParameteri64v", handle),
            glGetBufferParameteriv: get_func("glGetBufferParameteriv", handle),
            glGetBufferPointerv: get_func("glGetBufferPointerv", handle),
            glGetBufferSubData: get_func("glGetBufferSubData", handle),
            glGetClipPlane: get_func("glGetClipPlane", handle),
            glGetCompressedTexImage: get_func("glGetCompressedTexImage", handle),
            glGetDebugMessageLog: get_func("glGetDebugMessageLog", handle),
            glGetDebugMessageLogKHR: get_func("glGetDebugMessageLogKHR", handle),
            glGetDoublev: get_func("glGetDoublev", handle),
            glGetError: get_func("glGetError", handle),
            glGetFloatv: get_func("glGetFloatv", handle),
            glGetFragDataIndex: get_func("glGetFragDataIndex", handle),
            glGetFragDataLocation: get_func("glGetFragDataLocation", handle),
            glGetFramebufferAttachmentParameteriv: get_func(
                "glGetFramebufferAttachmentParameteriv",
                handle,
            ),
            glGetInteger64i_v: get_func("glGetInteger64i_v", handle),
            glGetInteger64v: get_func("glGetInteger64v", handle),
            glGetIntegeri_v: get_func("glGetIntegeri_v", handle),
            glGetIntegerv: get_func("glGetIntegerv", handle),
            glGetLightfv: get_func("glGetLightfv", handle),
            glGetLightiv: get_func("glGetLightiv", handle),
            glGetMapdv: get_func("glGetMapdv", handle),
            glGetMapfv: get_func("glGetMapfv", handle),
            glGetMapiv: get_func("glGetMapiv", handle),
            glGetMaterialfv: get_func("glGetMaterialfv", handle),
            glGetMaterialiv: get_func("glGetMaterialiv", handle),
            glGetMultisamplefv: get_func("glGetMultisamplefv", handle),
            glGetObjectLabel: get_func("glGetObjectLabel", handle),
            glGetObjectLabelKHR: get_func("glGetObjectLabelKHR", handle),
            glGetObjectPtrLabel: get_func("glGetObjectPtrLabel", handle),
            glGetObjectPtrLabelKHR: get_func("glGetObjectPtrLabelKHR", handle),
            glGetPixelMapfv: get_func("glGetPixelMapfv", handle),
            glGetPixelMapuiv: get_func("glGetPixelMapuiv", handle),
            glGetPixelMapusv: get_func("glGetPixelMapusv", handle),
            glGetPointerv: get_func("glGetPointerv", handle),
            glGetPointervKHR: get_func("glGetPointervKHR", handle),
            glGetPolygonStipple: get_func("glGetPolygonStipple", handle),
            glGetProgramBinary: get_func("glGetProgramBinary", handle),
            glGetProgramInfoLog: get_func("glGetProgramInfoLog", handle),
            glGetProgramiv: get_func("glGetProgramiv", handle),
            glGetQueryObjecti64v: get_func("glGetQueryObjecti64v", handle),
            glGetQueryObjectiv: get_func("glGetQueryObjectiv", handle),
            glGetQueryObjectui64v: get_func("glGetQueryObjectui64v", handle),
            glGetQueryObjectuiv: get_func("glGetQueryObjectuiv", handle),
            glGetQueryiv: get_func("glGetQueryiv", handle),
            glGetRenderbufferParameteriv: get_func("glGetRenderbufferParameteriv", handle),
            glGetSamplerParameterIiv: get_func("glGetSamplerParameterIiv", handle),
            glGetSamplerParameterIuiv: get_func("glGetSamplerParameterIuiv", handle),
            glGetSamplerParameterfv: get_func("glGetSamplerParameterfv", handle),
            glGetSamplerParameteriv: get_func("glGetSamplerParameteriv", handle),
            glGetShaderInfoLog: get_func("glGetShaderInfoLog", handle),
            glGetShaderSource: get_func("glGetShaderSource", handle),
            glGetShaderiv: get_func("glGetShaderiv", handle),
            glGetString: get_func("glGetString", handle),
            glGetStringi: get_func("glGetStringi", handle),
            glGetSynciv: get_func("glGetSynciv", handle),
            glGetTexEnvfv: get_func("glGetTexEnvfv", handle),
            glGetTexEnviv: get_func("glGetTexEnviv", handle),
            glGetTexGendv: get_func("glGetTexGendv", handle),
            glGetTexGenfv: get_func("glGetTexGenfv", handle),
            glGetTexGeniv: get_func("glGetTexGeniv", handle),
            glGetTexImage: get_func("glGetTexImage", handle),
            glGetTexLevelParameterfv: get_func("glGetTexLevelParameterfv", handle),
            glGetTexLevelParameteriv: get_func("glGetTexLevelParameteriv", handle),
            glGetTexParameterIiv: get_func("glGetTexParameterIiv", handle),
            glGetTexParameterIuiv: get_func("glGetTexParameterIuiv", handle),
            glGetTexParameterPointervAPPLE: get_func("glGetTexParameterPointervAPPLE", handle),
            glGetTexParameterfv: get_func("glGetTexParameterfv", handle),
            glGetTexParameteriv: get_func("glGetTexParameteriv", handle),
            glGetTransformFeedbackVarying: get_func("glGetTransformFeedbackVarying", handle),
            glGetUniformBlockIndex: get_func("glGetUniformBlockIndex", handle),
            glGetUniformIndices: get_func("glGetUniformIndices", handle),
            glGetUniformLocation: get_func("glGetUniformLocation", handle),
            glGetUniformfv: get_func("glGetUniformfv", handle),
            glGetUniformiv: get_func("glGetUniformiv", handle),
            glGetUniformuiv: get_func("glGetUniformuiv", handle),
            glGetVertexAttribIiv: get_func("glGetVertexAttribIiv", handle),
            glGetVertexAttribIuiv: get_func("glGetVertexAttribIuiv", handle),
            glGetVertexAttribPointerv: get_func("glGetVertexAttribPointerv", handle),
            glGetVertexAttribdv: get_func("glGetVertexAttribdv", handle),
            glGetVertexAttribfv: get_func("glGetVertexAttribfv", handle),
            glGetVertexAttribiv: get_func("glGetVertexAttribiv", handle),
            glHint: get_func("glHint", handle),
            glIndexMask: get_func("glIndexMask", handle),
            glIndexPointer: get_func("glIndexPointer", handle),
            glIndexd: get_func("glIndexd", handle),
            glIndexdv: get_func("glIndexdv", handle),
            glIndexf: get_func("glIndexf", handle),
            glIndexfv: get_func("glIndexfv", handle),
            glIndexi: get_func("glIndexi", handle),
            glIndexiv: get_func("glIndexiv", handle),
            glIndexs: get_func("glIndexs", handle),
            glIndexsv: get_func("glIndexsv", handle),
            glIndexub: get_func("glIndexub", handle),
            glIndexubv: get_func("glIndexubv", handle),
            glInitNames: get_func("glInitNames", handle),
            glInsertEventMarkerEXT: get_func("glInsertEventMarkerEXT", handle),
            glInterleavedArrays: get_func("glInterleavedArrays", handle),
            glInvalidateBufferData: get_func("glInvalidateBufferData", handle),
            glInvalidateBufferSubData: get_func("glInvalidateBufferSubData", handle),
            glInvalidateFramebuffer: get_func("glInvalidateFramebuffer", handle),
            glInvalidateSubFramebuffer: get_func("glInvalidateSubFramebuffer", handle),
            glInvalidateTexImage: get_func("glInvalidateTexImage", handle),
            glInvalidateTexSubImage: get_func("glInvalidateTexSubImage", handle),
            glIsBuffer: get_func("glIsBuffer", handle),
            glIsEnabled: get_func("glIsEnabled", handle),
            glIsEnabledi: get_func("glIsEnabledi", handle),
            glIsFenceAPPLE: get_func("glIsFenceAPPLE", handle),
            glIsFramebuffer: get_func("glIsFramebuffer", handle),
            glIsList: get_func("glIsList", handle),
            glIsProgram: get_func("glIsProgram", handle),
            glIsQuery: get_func("glIsQuery", handle),
            glIsRenderbuffer: get_func("glIsRenderbuffer", handle),
            glIsSampler: get_func("glIsSampler", handle),
            glIsShader: get_func("glIsShader", handle),
            glIsSync: get_func("glIsSync", handle),
            glIsTexture: get_func("glIsTexture", handle),
            glIsVertexArray: get_func("glIsVertexArray", handle),
            glIsVertexArrayAPPLE: get_func("glIsVertexArrayAPPLE", handle),
            glLightModelf: get_func("glLightModelf", handle),
            glLightModelfv: get_func("glLightModelfv", handle),
            glLightModeli: get_func("glLightModeli", handle),
            glLightModeliv: get_func("glLightModeliv", handle),
            glLightf: get_func("glLightf", handle),
            glLightfv: get_func("glLightfv", handle),
            glLighti: get_func("glLighti", handle),
            glLightiv: get_func("glLightiv", handle),
            glLineStipple: get_func("glLineStipple", handle),
            glLineWidth: get_func("glLineWidth", handle),
            glLinkProgram: get_func("glLinkProgram", handle),
            glListBase: get_func("glListBase", handle),
            glLoadIdentity: get_func("glLoadIdentity", handle),
            glLoadMatrixd: get_func("glLoadMatrixd", handle),
            glLoadMatrixf: get_func("glLoadMatrixf", handle),
            glLoadName: get_func("glLoadName", handle),
            glLoadTransposeMatrixd: get_func("glLoadTransposeMatrixd", handle),
            glLoadTransposeMatrixf: get_func("glLoadTransposeMatrixf", handle),
            glLogicOp: get_func("glLogicOp", handle),
            glMap1d: get_func("glMap1d", handle),
            glMap1f: get_func("glMap1f", handle),
            glMap2d: get_func("glMap2d", handle),
            glMap2f: get_func("glMap2f", handle),
            glMapBuffer: get_func("glMapBuffer", handle),
            glMapBufferRange: get_func("glMapBufferRange", handle),
            glMapGrid1d: get_func("glMapGrid1d", handle),
            glMapGrid1f: get_func("glMapGrid1f", handle),
            glMapGrid2d: get_func("glMapGrid2d", handle),
            glMapGrid2f: get_func("glMapGrid2f", handle),
            glMaterialf: get_func("glMaterialf", handle),
            glMaterialfv: get_func("glMaterialfv", handle),
            glMateriali: get_func("glMateriali", handle),
            glMaterialiv: get_func("glMaterialiv", handle),
            glMatrixMode: get_func("glMatrixMode", handle),
            glMultMatrixd: get_func("glMultMatrixd", handle),
            glMultMatrixf: get_func("glMultMatrixf", handle),
            glMultTransposeMatrixd: get_func("glMultTransposeMatrixd", handle),
            glMultTransposeMatrixf: get_func("glMultTransposeMatrixf", handle),
            glMultiDrawArrays: get_func("glMultiDrawArrays", handle),
            glMultiDrawElements: get_func("glMultiDrawElements", handle),
            glMultiDrawElementsBaseVertex: get_func("glMultiDrawElementsBaseVertex", handle),
            glMultiTexCoord1d: get_func("glMultiTexCoord1d", handle),
            glMultiTexCoord1dv: get_func("glMultiTexCoord1dv", handle),
            glMultiTexCoord1f: get_func("glMultiTexCoord1f", handle),
            glMultiTexCoord1fv: get_func("glMultiTexCoord1fv", handle),
            glMultiTexCoord1i: get_func("glMultiTexCoord1i", handle),
            glMultiTexCoord1iv: get_func("glMultiTexCoord1iv", handle),
            glMultiTexCoord1s: get_func("glMultiTexCoord1s", handle),
            glMultiTexCoord1sv: get_func("glMultiTexCoord1sv", handle),
            glMultiTexCoord2d: get_func("glMultiTexCoord2d", handle),
            glMultiTexCoord2dv: get_func("glMultiTexCoord2dv", handle),
            glMultiTexCoord2f: get_func("glMultiTexCoord2f", handle),
            glMultiTexCoord2fv: get_func("glMultiTexCoord2fv", handle),
            glMultiTexCoord2i: get_func("glMultiTexCoord2i", handle),
            glMultiTexCoord2iv: get_func("glMultiTexCoord2iv", handle),
            glMultiTexCoord2s: get_func("glMultiTexCoord2s", handle),
            glMultiTexCoord2sv: get_func("glMultiTexCoord2sv", handle),
            glMultiTexCoord3d: get_func("glMultiTexCoord3d", handle),
            glMultiTexCoord3dv: get_func("glMultiTexCoord3dv", handle),
            glMultiTexCoord3f: get_func("glMultiTexCoord3f", handle),
            glMultiTexCoord3fv: get_func("glMultiTexCoord3fv", handle),
            glMultiTexCoord3i: get_func("glMultiTexCoord3i", handle),
            glMultiTexCoord3iv: get_func("glMultiTexCoord3iv", handle),
            glMultiTexCoord3s: get_func("glMultiTexCoord3s", handle),
            glMultiTexCoord3sv: get_func("glMultiTexCoord3sv", handle),
            glMultiTexCoord4d: get_func("glMultiTexCoord4d", handle),
            glMultiTexCoord4dv: get_func("glMultiTexCoord4dv", handle),
            glMultiTexCoord4f: get_func("glMultiTexCoord4f", handle),
            glMultiTexCoord4fv: get_func("glMultiTexCoord4fv", handle),
            glMultiTexCoord4i: get_func("glMultiTexCoord4i", handle),
            glMultiTexCoord4iv: get_func("glMultiTexCoord4iv", handle),
            glMultiTexCoord4s: get_func("glMultiTexCoord4s", handle),
            glMultiTexCoord4sv: get_func("glMultiTexCoord4sv", handle),
            glMultiTexCoordP1ui: get_func("glMultiTexCoordP1ui", handle),
            glMultiTexCoordP1uiv: get_func("glMultiTexCoordP1uiv", handle),
            glMultiTexCoordP2ui: get_func("glMultiTexCoordP2ui", handle),
            glMultiTexCoordP2uiv: get_func("glMultiTexCoordP2uiv", handle),
            glMultiTexCoordP3ui: get_func("glMultiTexCoordP3ui", handle),
            glMultiTexCoordP3uiv: get_func("glMultiTexCoordP3uiv", handle),
            glMultiTexCoordP4ui: get_func("glMultiTexCoordP4ui", handle),
            glMultiTexCoordP4uiv: get_func("glMultiTexCoordP4uiv", handle),
            glNewList: get_func("glNewList", handle),
            glNormal3b: get_func("glNormal3b", handle),
            glNormal3bv: get_func("glNormal3bv", handle),
            glNormal3d: get_func("glNormal3d", handle),
            glNormal3dv: get_func("glNormal3dv", handle),
            glNormal3f: get_func("glNormal3f", handle),
            glNormal3fv: get_func("glNormal3fv", handle),
            glNormal3i: get_func("glNormal3i", handle),
            glNormal3iv: get_func("glNormal3iv", handle),
            glNormal3s: get_func("glNormal3s", handle),
            glNormal3sv: get_func("glNormal3sv", handle),
            glNormalP3ui: get_func("glNormalP3ui", handle),
            glNormalP3uiv: get_func("glNormalP3uiv", handle),
            glNormalPointer: get_func("glNormalPointer", handle),
            glObjectLabel: get_func("glObjectLabel", handle),
            glObjectLabelKHR: get_func("glObjectLabelKHR", handle),
            glObjectPtrLabel: get_func("glObjectPtrLabel", handle),
            glObjectPtrLabelKHR: get_func("glObjectPtrLabelKHR", handle),
            glOrtho: get_func("glOrtho", handle),
            glPassThrough: get_func("glPassThrough", handle),
            glPixelMapfv: get_func("glPixelMapfv", handle),
            glPixelMapuiv: get_func("glPixelMapuiv", handle),
            glPixelMapusv: get_func("glPixelMapusv", handle),
            glPixelStoref: get_func("glPixelStoref", handle),
            glPixelStorei: get_func("glPixelStorei", handle),
            glPixelTransferf: get_func("glPixelTransferf", handle),
            glPixelTransferi: get_func("glPixelTransferi", handle),
            glPixelZoom: get_func("glPixelZoom", handle),
            glPointParameterf: get_func("glPointParameterf", handle),
            glPointParameterfv: get_func("glPointParameterfv", handle),
            glPointParameteri: get_func("glPointParameteri", handle),
            glPointParameteriv: get_func("glPointParameteriv", handle),
            glPointSize: get_func("glPointSize", handle),
            glPolygonMode: get_func("glPolygonMode", handle),
            glPolygonOffset: get_func("glPolygonOffset", handle),
            glPolygonStipple: get_func("glPolygonStipple", handle),
            glPopAttrib: get_func("glPopAttrib", handle),
            glPopClientAttrib: get_func("glPopClientAttrib", handle),
            glPopDebugGroup: get_func("glPopDebugGroup", handle),
            glPopDebugGroupKHR: get_func("glPopDebugGroupKHR", handle),
            glPopGroupMarkerEXT: get_func("glPopGroupMarkerEXT", handle),
            glPopMatrix: get_func("glPopMatrix", handle),
            glPopName: get_func("glPopName", handle),
            glPrimitiveRestartIndex: get_func("glPrimitiveRestartIndex", handle),
            glPrioritizeTextures: get_func("glPrioritizeTextures", handle),
            glProgramBinary: get_func("glProgramBinary", handle),
            glProgramParameteri: get_func("glProgramParameteri", handle),
            glProvokingVertex: get_func("glProvokingVertex", handle),
            glPushAttrib: get_func("glPushAttrib", handle),
            glPushClientAttrib: get_func("glPushClientAttrib", handle),
            glPushDebugGroup: get_func("glPushDebugGroup", handle),
            glPushDebugGroupKHR: get_func("glPushDebugGroupKHR", handle),
            glPushGroupMarkerEXT: get_func("glPushGroupMarkerEXT", handle),
            glPushMatrix: get_func("glPushMatrix", handle),
            glPushName: get_func("glPushName", handle),
            glQueryCounter: get_func("glQueryCounter", handle),
            glRasterPos2d: get_func("glRasterPos2d", handle),
            glRasterPos2dv: get_func("glRasterPos2dv", handle),
            glRasterPos2f: get_func("glRasterPos2f", handle),
            glRasterPos2fv: get_func("glRasterPos2fv", handle),
            glRasterPos2i: get_func("glRasterPos2i", handle),
            glRasterPos2iv: get_func("glRasterPos2iv", handle),
            glRasterPos2s: get_func("glRasterPos2s", handle),
            glRasterPos2sv: get_func("glRasterPos2sv", handle),
            glRasterPos3d: get_func("glRasterPos3d", handle),
            glRasterPos3dv: get_func("glRasterPos3dv", handle),
            glRasterPos3f: get_func("glRasterPos3f", handle),
            glRasterPos3fv: get_func("glRasterPos3fv", handle),
            glRasterPos3i: get_func("glRasterPos3i", handle),
            glRasterPos3iv: get_func("glRasterPos3iv", handle),
            glRasterPos3s: get_func("glRasterPos3s", handle),
            glRasterPos3sv: get_func("glRasterPos3sv", handle),
            glRasterPos4d: get_func("glRasterPos4d", handle),
            glRasterPos4dv: get_func("glRasterPos4dv", handle),
            glRasterPos4f: get_func("glRasterPos4f", handle),
            glRasterPos4fv: get_func("glRasterPos4fv", handle),
            glRasterPos4i: get_func("glRasterPos4i", handle),
            glRasterPos4iv: get_func("glRasterPos4iv", handle),
            glRasterPos4s: get_func("glRasterPos4s", handle),
            glRasterPos4sv: get_func("glRasterPos4sv", handle),
            glReadBuffer: get_func("glReadBuffer", handle),
            glReadPixels: get_func("glReadPixels", handle),
            glRectd: get_func("glRectd", handle),
            glRectdv: get_func("glRectdv", handle),
            glRectf: get_func("glRectf", handle),
            glRectfv: get_func("glRectfv", handle),
            glRecti: get_func("glRecti", handle),
            glRectiv: get_func("glRectiv", handle),
            glRects: get_func("glRects", handle),
            glRectsv: get_func("glRectsv", handle),
            glRenderMode: get_func("glRenderMode", handle),
            glRenderbufferStorage: get_func("glRenderbufferStorage", handle),
            glRenderbufferStorageMultisample: get_func("glRenderbufferStorageMultisample", handle),
            glRotated: get_func("glRotated", handle),
            glRotatef: get_func("glRotatef", handle),
            glSampleCoverage: get_func("glSampleCoverage", handle),
            glSampleMaski: get_func("glSampleMaski", handle),
            glSamplerParameterIiv: get_func("glSamplerParameterIiv", handle),
            glSamplerParameterIuiv: get_func("glSamplerParameterIuiv", handle),
            glSamplerParameterf: get_func("glSamplerParameterf", handle),
            glSamplerParameterfv: get_func("glSamplerParameterfv", handle),
            glSamplerParameteri: get_func("glSamplerParameteri", handle),
            glSamplerParameteriv: get_func("glSamplerParameteriv", handle),
            glScaled: get_func("glScaled", handle),
            glScalef: get_func("glScalef", handle),
            glScissor: get_func("glScissor", handle),
            glSecondaryColor3b: get_func("glSecondaryColor3b", handle),
            glSecondaryColor3bv: get_func("glSecondaryColor3bv", handle),
            glSecondaryColor3d: get_func("glSecondaryColor3d", handle),
            glSecondaryColor3dv: get_func("glSecondaryColor3dv", handle),
            glSecondaryColor3f: get_func("glSecondaryColor3f", handle),
            glSecondaryColor3fv: get_func("glSecondaryColor3fv", handle),
            glSecondaryColor3i: get_func("glSecondaryColor3i", handle),
            glSecondaryColor3iv: get_func("glSecondaryColor3iv", handle),
            glSecondaryColor3s: get_func("glSecondaryColor3s", handle),
            glSecondaryColor3sv: get_func("glSecondaryColor3sv", handle),
            glSecondaryColor3ub: get_func("glSecondaryColor3ub", handle),
            glSecondaryColor3ubv: get_func("glSecondaryColor3ubv", handle),
            glSecondaryColor3ui: get_func("glSecondaryColor3ui", handle),
            glSecondaryColor3uiv: get_func("glSecondaryColor3uiv", handle),
            glSecondaryColor3us: get_func("glSecondaryColor3us", handle),
            glSecondaryColor3usv: get_func("glSecondaryColor3usv", handle),
            glSecondaryColorP3ui: get_func("glSecondaryColorP3ui", handle),
            glSecondaryColorP3uiv: get_func("glSecondaryColorP3uiv", handle),
            glSecondaryColorPointer: get_func("glSecondaryColorPointer", handle),
            glSelectBuffer: get_func("glSelectBuffer", handle),
            glSetFenceAPPLE: get_func("glSetFenceAPPLE", handle),
            glShadeModel: get_func("glShadeModel", handle),
            glShaderSource: get_func("glShaderSource", handle),
            glShaderStorageBlockBinding: get_func("glShaderStorageBlockBinding", handle),
            glStencilFunc: get_func("glStencilFunc", handle),
            glStencilFuncSeparate: get_func("glStencilFuncSeparate", handle),
            glStencilMask: get_func("glStencilMask", handle),
            glStencilMaskSeparate: get_func("glStencilMaskSeparate", handle),
            glStencilOp: get_func("glStencilOp", handle),
            glStencilOpSeparate: get_func("glStencilOpSeparate", handle),
            glTestFenceAPPLE: get_func("glTestFenceAPPLE", handle),
            glTestObjectAPPLE: get_func("glTestObjectAPPLE", handle),
            glTexBuffer: get_func("glTexBuffer", handle),
            glTexCoord1d: get_func("glTexCoord1d", handle),
            glTexCoord1dv: get_func("glTexCoord1dv", handle),
            glTexCoord1f: get_func("glTexCoord1f", handle),
            glTexCoord1fv: get_func("glTexCoord1fv", handle),
            glTexCoord1i: get_func("glTexCoord1i", handle),
            glTexCoord1iv: get_func("glTexCoord1iv", handle),
            glTexCoord1s: get_func("glTexCoord1s", handle),
            glTexCoord1sv: get_func("glTexCoord1sv", handle),
            glTexCoord2d: get_func("glTexCoord2d", handle),
            glTexCoord2dv: get_func("glTexCoord2dv", handle),
            glTexCoord2f: get_func("glTexCoord2f", handle),
            glTexCoord2fv: get_func("glTexCoord2fv", handle),
            glTexCoord2i: get_func("glTexCoord2i", handle),
            glTexCoord2iv: get_func("glTexCoord2iv", handle),
            glTexCoord2s: get_func("glTexCoord2s", handle),
            glTexCoord2sv: get_func("glTexCoord2sv", handle),
            glTexCoord3d: get_func("glTexCoord3d", handle),
            glTexCoord3dv: get_func("glTexCoord3dv", handle),
            glTexCoord3f: get_func("glTexCoord3f", handle),
            glTexCoord3fv: get_func("glTexCoord3fv", handle),
            glTexCoord3i: get_func("glTexCoord3i", handle),
            glTexCoord3iv: get_func("glTexCoord3iv", handle),
            glTexCoord3s: get_func("glTexCoord3s", handle),
            glTexCoord3sv: get_func("glTexCoord3sv", handle),
            glTexCoord4d: get_func("glTexCoord4d", handle),
            glTexCoord4dv: get_func("glTexCoord4dv", handle),
            glTexCoord4f: get_func("glTexCoord4f", handle),
            glTexCoord4fv: get_func("glTexCoord4fv", handle),
            glTexCoord4i: get_func("glTexCoord4i", handle),
            glTexCoord4iv: get_func("glTexCoord4iv", handle),
            glTexCoord4s: get_func("glTexCoord4s", handle),
            glTexCoord4sv: get_func("glTexCoord4sv", handle),
            glTexCoordP1ui: get_func("glTexCoordP1ui", handle),
            glTexCoordP1uiv: get_func("glTexCoordP1uiv", handle),
            glTexCoordP2ui: get_func("glTexCoordP2ui", handle),
            glTexCoordP2uiv: get_func("glTexCoordP2uiv", handle),
            glTexCoordP3ui: get_func("glTexCoordP3ui", handle),
            glTexCoordP3uiv: get_func("glTexCoordP3uiv", handle),
            glTexCoordP4ui: get_func("glTexCoordP4ui", handle),
            glTexCoordP4uiv: get_func("glTexCoordP4uiv", handle),
            glTexCoordPointer: get_func("glTexCoordPointer", handle),
            glTexEnvf: get_func("glTexEnvf", handle),
            glTexEnvfv: get_func("glTexEnvfv", handle),
            glTexEnvi: get_func("glTexEnvi", handle),
            glTexEnviv: get_func("glTexEnviv", handle),
            glTexGend: get_func("glTexGend", handle),
            glTexGendv: get_func("glTexGendv", handle),
            glTexGenf: get_func("glTexGenf", handle),
            glTexGenfv: get_func("glTexGenfv", handle),
            glTexGeni: get_func("glTexGeni", handle),
            glTexGeniv: get_func("glTexGeniv", handle),
            glTexImage1D: get_func("glTexImage1D", handle),
            glTexImage2D: get_func("glTexImage2D", handle),
            glTexImage2DMultisample: get_func("glTexImage2DMultisample", handle),
            glTexImage3D: get_func("glTexImage3D", handle),
            glTexImage3DMultisample: get_func("glTexImage3DMultisample", handle),
            glTexParameterIiv: get_func("glTexParameterIiv", handle),
            glTexParameterIuiv: get_func("glTexParameterIuiv", handle),
            glTexParameterf: get_func("glTexParameterf", handle),
            glTexParameterfv: get_func("glTexParameterfv", handle),
            glTexParameteri: get_func("glTexParameteri", handle),
            glTexParameteriv: get_func("glTexParameteriv", handle),
            glTexStorage1D: get_func("glTexStorage1D", handle),
            glTexStorage2D: get_func("glTexStorage2D", handle),
            glTexStorage3D: get_func("glTexStorage3D", handle),
            glTexSubImage1D: get_func("glTexSubImage1D", handle),
            glTexSubImage2D: get_func("glTexSubImage2D", handle),
            glTexSubImage3D: get_func("glTexSubImage3D", handle),
            glTextureRangeAPPLE: get_func("glTextureRangeAPPLE", handle),
            glTransformFeedbackVaryings: get_func("glTransformFeedbackVaryings", handle),
            glTranslated: get_func("glTranslated", handle),
            glTranslatef: get_func("glTranslatef", handle),
            glUniform1f: get_func("glUniform1f", handle),
            glUniform1fv: get_func("glUniform1fv", handle),
            glUniform1i: get_func("glUniform1i", handle),
            glUniform1iv: get_func("glUniform1iv", handle),
            glUniform1ui: get_func("glUniform1ui", handle),
            glUniform1uiv: get_func("glUniform1uiv", handle),
            glUniform2f: get_func("glUniform2f", handle),
            glUniform2fv: get_func("glUniform2fv", handle),
            glUniform2i: get_func("glUniform2i", handle),
            glUniform2iv: get_func("glUniform2iv", handle),
            glUniform2ui: get_func("glUniform2ui", handle),
            glUniform2uiv: get_func("glUniform2uiv", handle),
            glUniform3f: get_func("glUniform3f", handle),
            glUniform3fv: get_func("glUniform3fv", handle),
            glUniform3i: get_func("glUniform3i", handle),
            glUniform3iv: get_func("glUniform3iv", handle),
            glUniform3ui: get_func("glUniform3ui", handle),
            glUniform3uiv: get_func("glUniform3uiv", handle),
            glUniform4f: get_func("glUniform4f", handle),
            glUniform4fv: get_func("glUniform4fv", handle),
            glUniform4i: get_func("glUniform4i", handle),
            glUniform4iv: get_func("glUniform4iv", handle),
            glUniform4ui: get_func("glUniform4ui", handle),
            glUniform4uiv: get_func("glUniform4uiv", handle),
            glUniformBlockBinding: get_func("glUniformBlockBinding", handle),
            glUniformMatrix2fv: get_func("glUniformMatrix2fv", handle),
            glUniformMatrix2x3fv: get_func("glUniformMatrix2x3fv", handle),
            glUniformMatrix2x4fv: get_func("glUniformMatrix2x4fv", handle),
            glUniformMatrix3fv: get_func("glUniformMatrix3fv", handle),
            glUniformMatrix3x2fv: get_func("glUniformMatrix3x2fv", handle),
            glUniformMatrix3x4fv: get_func("glUniformMatrix3x4fv", handle),
            glUniformMatrix4fv: get_func("glUniformMatrix4fv", handle),
            glUniformMatrix4x2fv: get_func("glUniformMatrix4x2fv", handle),
            glUniformMatrix4x3fv: get_func("glUniformMatrix4x3fv", handle),
            glUnmapBuffer: get_func("glUnmapBuffer", handle),
            glUseProgram: get_func("glUseProgram", handle),
            glValidateProgram: get_func("glValidateProgram", handle),
            glVertex2d: get_func("glVertex2d", handle),
            glVertex2dv: get_func("glVertex2dv", handle),
            glVertex2f: get_func("glVertex2f", handle),
            glVertex2fv: get_func("glVertex2fv", handle),
            glVertex2i: get_func("glVertex2i", handle),
            glVertex2iv: get_func("glVertex2iv", handle),
            glVertex2s: get_func("glVertex2s", handle),
            glVertex2sv: get_func("glVertex2sv", handle),
            glVertex3d: get_func("glVertex3d", handle),
            glVertex3dv: get_func("glVertex3dv", handle),
            glVertex3f: get_func("glVertex3f", handle),
            glVertex3fv: get_func("glVertex3fv", handle),
            glVertex3i: get_func("glVertex3i", handle),
            glVertex3iv: get_func("glVertex3iv", handle),
            glVertex3s: get_func("glVertex3s", handle),
            glVertex3sv: get_func("glVertex3sv", handle),
            glVertex4d: get_func("glVertex4d", handle),
            glVertex4dv: get_func("glVertex4dv", handle),
            glVertex4f: get_func("glVertex4f", handle),
            glVertex4fv: get_func("glVertex4fv", handle),
            glVertex4i: get_func("glVertex4i", handle),
            glVertex4iv: get_func("glVertex4iv", handle),
            glVertex4s: get_func("glVertex4s", handle),
            glVertex4sv: get_func("glVertex4sv", handle),
            glVertexAttrib1d: get_func("glVertexAttrib1d", handle),
            glVertexAttrib1dv: get_func("glVertexAttrib1dv", handle),
            glVertexAttrib1f: get_func("glVertexAttrib1f", handle),
            glVertexAttrib1fv: get_func("glVertexAttrib1fv", handle),
            glVertexAttrib1s: get_func("glVertexAttrib1s", handle),
            glVertexAttrib1sv: get_func("glVertexAttrib1sv", handle),
            glVertexAttrib2d: get_func("glVertexAttrib2d", handle),
            glVertexAttrib2dv: get_func("glVertexAttrib2dv", handle),
            glVertexAttrib2f: get_func("glVertexAttrib2f", handle),
            glVertexAttrib2fv: get_func("glVertexAttrib2fv", handle),
            glVertexAttrib2s: get_func("glVertexAttrib2s", handle),
            glVertexAttrib2sv: get_func("glVertexAttrib2sv", handle),
            glVertexAttrib3d: get_func("glVertexAttrib3d", handle),
            glVertexAttrib3dv: get_func("glVertexAttrib3dv", handle),
            glVertexAttrib3f: get_func("glVertexAttrib3f", handle),
            glVertexAttrib3fv: get_func("glVertexAttrib3fv", handle),
            glVertexAttrib3s: get_func("glVertexAttrib3s", handle),
            glVertexAttrib3sv: get_func("glVertexAttrib3sv", handle),
            glVertexAttrib4Nbv: get_func("glVertexAttrib4Nbv", handle),
            glVertexAttrib4Niv: get_func("glVertexAttrib4Niv", handle),
            glVertexAttrib4Nsv: get_func("glVertexAttrib4Nsv", handle),
            glVertexAttrib4Nub: get_func("glVertexAttrib4Nub", handle),
            glVertexAttrib4Nubv: get_func("glVertexAttrib4Nubv", handle),
            glVertexAttrib4Nuiv: get_func("glVertexAttrib4Nuiv", handle),
            glVertexAttrib4Nusv: get_func("glVertexAttrib4Nusv", handle),
            glVertexAttrib4bv: get_func("glVertexAttrib4bv", handle),
            glVertexAttrib4d: get_func("glVertexAttrib4d", handle),
            glVertexAttrib4dv: get_func("glVertexAttrib4dv", handle),
            glVertexAttrib4f: get_func("glVertexAttrib4f", handle),
            glVertexAttrib4fv: get_func("glVertexAttrib4fv", handle),
            glVertexAttrib4iv: get_func("glVertexAttrib4iv", handle),
            glVertexAttrib4s: get_func("glVertexAttrib4s", handle),
            glVertexAttrib4sv: get_func("glVertexAttrib4sv", handle),
            glVertexAttrib4ubv: get_func("glVertexAttrib4ubv", handle),
            glVertexAttrib4uiv: get_func("glVertexAttrib4uiv", handle),
            glVertexAttrib4usv: get_func("glVertexAttrib4usv", handle),
            glVertexAttribDivisor: get_func("glVertexAttribDivisor", handle),
            glVertexAttribI1i: get_func("glVertexAttribI1i", handle),
            glVertexAttribI1iv: get_func("glVertexAttribI1iv", handle),
            glVertexAttribI1ui: get_func("glVertexAttribI1ui", handle),
            glVertexAttribI1uiv: get_func("glVertexAttribI1uiv", handle),
            glVertexAttribI2i: get_func("glVertexAttribI2i", handle),
            glVertexAttribI2iv: get_func("glVertexAttribI2iv", handle),
            glVertexAttribI2ui: get_func("glVertexAttribI2ui", handle),
            glVertexAttribI2uiv: get_func("glVertexAttribI2uiv", handle),
            glVertexAttribI3i: get_func("glVertexAttribI3i", handle),
            glVertexAttribI3iv: get_func("glVertexAttribI3iv", handle),
            glVertexAttribI3ui: get_func("glVertexAttribI3ui", handle),
            glVertexAttribI3uiv: get_func("glVertexAttribI3uiv", handle),
            glVertexAttribI4bv: get_func("glVertexAttribI4bv", handle),
            glVertexAttribI4i: get_func("glVertexAttribI4i", handle),
            glVertexAttribI4iv: get_func("glVertexAttribI4iv", handle),
            glVertexAttribI4sv: get_func("glVertexAttribI4sv", handle),
            glVertexAttribI4ubv: get_func("glVertexAttribI4ubv", handle),
            glVertexAttribI4ui: get_func("glVertexAttribI4ui", handle),
            glVertexAttribI4uiv: get_func("glVertexAttribI4uiv", handle),
            glVertexAttribI4usv: get_func("glVertexAttribI4usv", handle),
            glVertexAttribIPointer: get_func("glVertexAttribIPointer", handle),
            glVertexAttribP1ui: get_func("glVertexAttribP1ui", handle),
            glVertexAttribP1uiv: get_func("glVertexAttribP1uiv", handle),
            glVertexAttribP2ui: get_func("glVertexAttribP2ui", handle),
            glVertexAttribP2uiv: get_func("glVertexAttribP2uiv", handle),
            glVertexAttribP3ui: get_func("glVertexAttribP3ui", handle),
            glVertexAttribP3uiv: get_func("glVertexAttribP3uiv", handle),
            glVertexAttribP4ui: get_func("glVertexAttribP4ui", handle),
            glVertexAttribP4uiv: get_func("glVertexAttribP4uiv", handle),
            glVertexAttribPointer: get_func("glVertexAttribPointer", handle),
            glVertexP2ui: get_func("glVertexP2ui", handle),
            glVertexP2uiv: get_func("glVertexP2uiv", handle),
            glVertexP3ui: get_func("glVertexP3ui", handle),
            glVertexP3uiv: get_func("glVertexP3uiv", handle),
            glVertexP4ui: get_func("glVertexP4ui", handle),
            glVertexP4uiv: get_func("glVertexP4uiv", handle),
            glVertexPointer: get_func("glVertexPointer", handle),
            glViewport: get_func("glViewport", handle),
            glWaitSync: get_func("glWaitSync", handle),
            glWindowPos2d: get_func("glWindowPos2d", handle),
            glWindowPos2dv: get_func("glWindowPos2dv", handle),
            glWindowPos2f: get_func("glWindowPos2f", handle),
            glWindowPos2fv: get_func("glWindowPos2fv", handle),
            glWindowPos2i: get_func("glWindowPos2i", handle),
            glWindowPos2iv: get_func("glWindowPos2iv", handle),
            glWindowPos2s: get_func("glWindowPos2s", handle),
            glWindowPos2sv: get_func("glWindowPos2sv", handle),
            glWindowPos3d: get_func("glWindowPos3d", handle),
            glWindowPos3dv: get_func("glWindowPos3dv", handle),
            glWindowPos3f: get_func("glWindowPos3f", handle),
            glWindowPos3fv: get_func("glWindowPos3fv", handle),
            glWindowPos3i: get_func("glWindowPos3i", handle),
            glWindowPos3iv: get_func("glWindowPos3iv", handle),
            glWindowPos3s: get_func("glWindowPos3s", handle),
            glWindowPos3sv: get_func("glWindowPos3sv", handle),
            glStartTilingQCOM: get_func("glStartTilingQCOM", handle),
            glEndTilingQCOM: get_func("glEndTilingQCOM", handle),
        };

        Ok(Self {
            _opengl_lib_handle: handle,
            functions: Rc::new(context),
        })
    }

    /// Returns the loaded function pointers (for use in your GL code).
    pub fn get_context(&self) -> Rc<GenericGlContext> {
        self.functions.clone()
    }
}

impl Drop for GlFunctions {
    fn drop(&mut self) {
        // On drop, close the handle.
        if !self._opengl_lib_handle.is_null() {
            unsafe {
                dlclose(self._opengl_lib_handle);
            }
        }
    }
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/menu.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! macOS menu integration for shell2
//!
//! Provides NSMenu creation and updates with hash-based diff to avoid
//! unnecessary menu recreation.

use std::{cell::RefCell, collections::HashMap, sync::Mutex};

use azul_core::menu::{Menu, MenuItem};
use objc2::{define_class, msg_send_id, rc::Retained, MainThreadMarker, MainThreadOnly};
use objc2_app_kit::{NSMenu, NSMenuItem};
use objc2_foundation::{NSObject, NSString};

use super::super::common::debug_server::LogCategory;
use crate::{log_debug, log_error, log_info, log_trace, log_warn};

/// Global queue for pending menu actions
/// When a menu item is clicked, its tag is pushed here and can be retrieved by the event loop
static PENDING_MENU_ACTIONS: Mutex<Vec<isize>> = Mutex::new(Vec::new());

/// Internal state for AzulMenuTarget
pub struct AzulMenuTargetIvars {
    _private: u8,
}

/// Objective-C class that receives menu item clicks
///
/// This class acts as the target for all NSMenuItem actions. When a menu item
/// is clicked, the menuItemAction: method is invoked, which adds the tag to
/// a global queue that the MacOSWindow event loop polls.
define_class!(
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[name = "AzulMenuTarget"]
    #[ivars = AzulMenuTargetIvars]
    pub struct AzulMenuTarget;

    impl AzulMenuTarget {
        /// Menu item action handler
        ///
        /// This method is called when any menu item with this object as its target
        /// is clicked. It extracts the tag from the sender and adds it to the
        /// global pending actions queue.
        #[unsafe(method(menuItemAction:))]
        fn menu_item_action(&self, sender: Option<&NSMenuItem>) {
            if let Some(menu_item) = sender {
                let tag = menu_item.tag();

                log_debug!(LogCategory::Input, "[AzulMenuTarget] Menu item clicked with tag: {}", tag);

                // Push tag to global queue
                if let Ok(mut queue) = PENDING_MENU_ACTIONS.lock() {
                    queue.push(tag);
                }
            }
        }
    }
);

impl AzulMenuTarget {
    /// Create a new AzulMenuTarget instance
    pub fn new(mtm: MainThreadMarker) -> Retained<Self> {
        let this = mtm.alloc::<Self>();
        let this = this.set_ivars(AzulMenuTargetIvars { _private: 0 });
        unsafe { msg_send_id![super(this), init] }
    }

    /// Get the shared singleton instance
    ///
    /// All menu items use the same target instance to reduce memory overhead
    /// and simplify the notification dispatch system.
    pub fn shared_instance(mtm: MainThreadMarker) -> Retained<Self> {
        thread_local! {
            static SHARED: RefCell<Option<Retained<AzulMenuTarget>>> = RefCell::new(None);
        }

        SHARED.with(|shared| {
            let mut shared = shared.borrow_mut();
            if shared.is_none() {
                *shared = Some(Self::new(mtm));
            }
            shared.as_ref().unwrap().clone()
        })
    }
}

/// Get all pending menu actions and clear the queue
///
/// This should be called from the event loop to process menu callbacks
pub fn take_pending_menu_actions() -> Vec<isize> {
    PENDING_MENU_ACTIONS
        .lock()
        .map(|mut queue| std::mem::take(&mut *queue))
        .unwrap_or_default()
}

/// Menu state tracking for diff-based updates
pub struct MenuState {
    /// Current menu hash
    current_hash: u64,
    /// The NSMenu instance
    ns_menu: Option<Retained<NSMenu>>,
    /// Command ID to callback mapping (tag -> CoreMenuCallback)
    command_map: HashMap<i64, azul_core::menu::CoreMenuCallback>,
}

impl MenuState {
    pub fn new() -> Self {
        Self {
            current_hash: 0,
            ns_menu: None,
            command_map: HashMap::new(),
        }
    }

    /// Update menu if hash changed, returns true if menu was recreated
    pub fn update_if_changed(&mut self, menu: &Menu, mtm: MainThreadMarker) -> bool {
        let new_hash = menu.get_hash();

        if new_hash != self.current_hash {
            // Menu changed, rebuild it
            let (ns_menu, command_map) = create_nsmenu(menu, mtm);
            self.ns_menu = Some(ns_menu);
            self.command_map = command_map;
            self.current_hash = new_hash;
            true
        } else {
            false
        }
    }

    /// Get the current NSMenu (if any)
    pub fn get_nsmenu(&self) -> Option<&Retained<NSMenu>> {
        self.ns_menu.as_ref()
    }

    /// Look up callback for a command tag
    pub fn get_callback_for_tag(&self, tag: i64) -> Option<&azul_core::menu::CoreMenuCallback> {
        self.command_map.get(&tag)
    }

    /// Register a callback and return a unique tag for it
    /// Used by context menus to register callbacks dynamically
    pub fn register_callback(&mut self, callback: azul_core::menu::CoreMenuCallback) -> i64 {
        // Find next available tag
        let tag = self.command_map.keys().max().unwrap_or(&1000) + 1;
        self.command_map.insert(tag, callback);
        tag
    }
}

/// Create an NSMenu from Azul Menu structure
fn create_nsmenu(
    menu: &Menu,
    mtm: MainThreadMarker,
) -> (
    Retained<NSMenu>,
    HashMap<i64, azul_core::menu::CoreMenuCallback>,
) {
    let ns_menu = NSMenu::new(mtm);
    let mut command_map = HashMap::new();
    let mut next_tag = 1i64;

    // Build menu items recursively
    build_menu_items(&menu.items, &ns_menu, &mut command_map, &mut next_tag, mtm);

    (ns_menu, command_map)
}

/// Recursively build menu items
fn build_menu_items(
    items: &azul_core::menu::MenuItemVec,
    parent_menu: &NSMenu,
    command_map: &mut HashMap<i64, azul_core::menu::CoreMenuCallback>,
    next_tag: &mut i64,
    mtm: MainThreadMarker,
) {
    let items = items.as_slice();
    for (index, item) in items.iter().enumerate() {
        match item {
            MenuItem::String(string_item) => {
                if string_item.children.is_empty() {
                    // Leaf menu item
                    let menu_item = NSMenuItem::new(mtm);
                    let title = NSString::from_str(&string_item.label);
                    menu_item.setTitle(&title);

                    // If has callback, assign tag and connect to target
                    if let Some(callback) = string_item.callback.as_option() {
                        let tag = *next_tag;
                        *next_tag += 1;

                        menu_item.setTag(tag as isize);
                        command_map.insert(tag, callback.clone());

                        // Set action and target for callback dispatch
                        let target = AzulMenuTarget::shared_instance(mtm);
                        unsafe {
                            menu_item.setTarget(Some(&target));
                            menu_item.setAction(Some(objc2::sel!(menuItemAction:)));
                        }
                    }

                    // Set keyboard accelerator if present
                    if let Some(accelerator) = string_item.accelerator.as_option() {
                        set_menu_item_accelerator(&menu_item, accelerator);
                    }

                    parent_menu.addItem(&menu_item);
                } else {
                    // Submenu
                    let submenu = NSMenu::new(mtm);
                    let title = NSString::from_str(&string_item.label);
                    submenu.setTitle(&title);

                    let menu_item = NSMenuItem::new(mtm);
                    menu_item.setTitle(&title);
                    menu_item.setSubmenu(Some(&submenu));

                    // Recursively build children
                    build_menu_items(&string_item.children, &submenu, command_map, next_tag, mtm);

                    parent_menu.addItem(&menu_item);
                }
            }
            MenuItem::Separator => {
                let separator = unsafe { NSMenuItem::separatorItem(mtm) };
                parent_menu.addItem(&separator);
            }
            MenuItem::BreakLine => {
                // BreakLine is not supported in macOS menus, treat as separator
                let separator = unsafe { NSMenuItem::separatorItem(mtm) };
                parent_menu.addItem(&separator);
            }
        }
    }
}

/// Set keyboard accelerator on NSMenuItem
///
/// Converts Azul VirtualKeyCodeCombo to macOS key equivalent and modifier mask.
/// macOS uses single character key equivalents (e.g., "x" for Cmd+X).
pub(crate) fn set_menu_item_accelerator(
    menu_item: &NSMenuItem,
    accelerator: &azul_core::window::VirtualKeyCodeCombo,
) {
    use azul_core::window::VirtualKeyCode;
    use objc2_app_kit::NSEventModifierFlags;

    if accelerator.keys.as_slice().is_empty() {
        return;
    }

    let keys = accelerator.keys.as_slice();
    let mut modifier_flags = NSEventModifierFlags::empty();
    let mut key_equivalent: Option<char> = None;

    // Parse modifier keys and find the main key
    for key in keys {
        match key {
            VirtualKeyCode::LControl | VirtualKeyCode::RControl => {
                modifier_flags.insert(NSEventModifierFlags::Control);
            }
            VirtualKeyCode::LShift | VirtualKeyCode::RShift => {
                modifier_flags.insert(NSEventModifierFlags::Shift);
            }
            VirtualKeyCode::LAlt | VirtualKeyCode::RAlt => {
                modifier_flags.insert(NSEventModifierFlags::Option);
            }
            VirtualKeyCode::LWin | VirtualKeyCode::RWin => {
                // On macOS, Windows key = Command key
                modifier_flags.insert(NSEventModifierFlags::Command);
            }
            // Map letter keys
            VirtualKeyCode::A => key_equivalent = Some('a'),
            VirtualKeyCode::B => key_equivalent = Some('b'),
            VirtualKeyCode::C => key_equivalent = Some('c'),
            VirtualKeyCode::D => key_equivalent = Some('d'),
            VirtualKeyCode::E => key_equivalent = Some('e'),
            VirtualKeyCode::F => key_equivalent = Some('f'),
            VirtualKeyCode::G => key_equivalent = Some('g'),
            VirtualKeyCode::H => key_equivalent = Some('h'),
            VirtualKeyCode::I => key_equivalent = Some('i'),
            VirtualKeyCode::J => key_equivalent = Some('j'),
            VirtualKeyCode::K => key_equivalent = Some('k'),
            VirtualKeyCode::L => key_equivalent = Some('l'),
            VirtualKeyCode::M => key_equivalent = Some('m'),
            VirtualKeyCode::N => key_equivalent = Some('n'),
            VirtualKeyCode::O => key_equivalent = Some('o'),
            VirtualKeyCode::P => key_equivalent = Some('p'),
            VirtualKeyCode::Q => key_equivalent = Some('q'),
            VirtualKeyCode::R => key_equivalent = Some('r'),
            VirtualKeyCode::S => key_equivalent = Some('s'),
            VirtualKeyCode::T => key_equivalent = Some('t'),
            VirtualKeyCode::U => key_equivalent = Some('u'),
            VirtualKeyCode::V => key_equivalent = Some('v'),
            VirtualKeyCode::W => key_equivalent = Some('w'),
            VirtualKeyCode::X => key_equivalent = Some('x'),
            VirtualKeyCode::Y => key_equivalent = Some('y'),
            VirtualKeyCode::Z => key_equivalent = Some('z'),
            // Map number keys
            VirtualKeyCode::Key0 => key_equivalent = Some('0'),
            VirtualKeyCode::Key1 => key_equivalent = Some('1'),
            VirtualKeyCode::Key2 => key_equivalent = Some('2'),
            VirtualKeyCode::Key3 => key_equivalent = Some('3'),
            VirtualKeyCode::Key4 => key_equivalent = Some('4'),
            VirtualKeyCode::Key5 => key_equivalent = Some('5'),
            VirtualKeyCode::Key6 => key_equivalent = Some('6'),
            VirtualKeyCode::Key7 => key_equivalent = Some('7'),
            VirtualKeyCode::Key8 => key_equivalent = Some('8'),
            VirtualKeyCode::Key9 => key_equivalent = Some('9'),

            // Special keys - use Unicode characters
            VirtualKeyCode::Return => key_equivalent = Some('\r'),
            VirtualKeyCode::Tab => key_equivalent = Some('\t'),
            VirtualKeyCode::Back => key_equivalent = Some('\u{0008}'), // Backspace
            VirtualKeyCode::Escape => key_equivalent = Some('\u{001B}'),
            VirtualKeyCode::Delete => key_equivalent = Some('\u{007F}'),

            // Function keys - use special NSF... constants (not directly char mappable)
            // For now, skip function keys as they require special handling
            _ => {}
        }
    }

    // Set key equivalent and modifier mask
    if let Some(ch) = key_equivalent {
        let key_str = NSString::from_str(&ch.to_string());
        unsafe {
            menu_item.setKeyEquivalent(&key_str);
            menu_item.setKeyEquivalentModifierMask(modifier_flags);
        }
    }
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/mod.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! macOS implementation using AppKit/Cocoa.
//!
//! This module implements the PlatformWindow trait for macOS using:
//! - NSWindow for window management
//! - NSOpenGLContext for GPU rendering (optional)
//! - NSMenu for menu bar and context menus
//! - NSEvent for event handling
//!
//! Note: macOS uses static linking for system frameworks (standard approach).

use std::{
    cell::{Cell, RefCell},
    rc::Rc,
    sync::{Arc, Condvar, Mutex},
};

use azul_core::{
    callbacks::LayoutCallbackInfo,
    dom::{DomId, NodeId},
    gl::{GlContextPtr, OptionGlContextPtr},
    hit_test::DocumentId,
    menu::Menu,
    refany::RefAny,
    resources::{DpiScaleFactor, IdNamespace, ImageCache, RendererResources},
    window::{
        HwAcceleration, MacOSHandle, MouseCursorType, RawWindowHandle, RendererType,
        WindowBackgroundMaterial, WindowDecorations, WindowFrame, WindowPosition, WindowSize,
    },
};
use azul_css::corety::OptionU32;
use azul_layout::{
    callbacks::ExternalSystemCallbacks,
    hit_test::FullHitTest,
    window::{LayoutWindow, ScrollbarDragState},
    window_state::{FullWindowState, WindowCreateOptions},
};
use objc2::{
    define_class,
    msg_send,
    msg_send_id,
    rc::{Allocated, Retained},
    runtime::{Bool, NSObjectProtocol, ProtocolObject, YES},
    AnyThread, // For alloc() method
    ClassType,
    DeclaredClass,
    MainThreadMarker,
    MainThreadOnly,
};
use objc2_app_kit::{
    NSAppKitVersionNumber, NSAppKitVersionNumber10_12, NSApplication,
    NSApplicationActivationPolicy, NSApplicationDelegate, NSBackingStoreType, NSBitmapImageRep,
    NSColor, NSCompositingOperation, NSEvent, NSEventMask, NSEventType, NSImage, NSMenu,
    NSMenuItem, NSOpenGLContext, NSOpenGLPixelFormat, NSOpenGLPixelFormatAttribute, NSOpenGLView,
    NSResponder, NSScreen, NSTextInputClient, NSTrackingArea, NSTrackingAreaOptions, NSView,
    NSVisualEffectView, NSWindow, NSWindowDelegate, NSWindowStyleMask, NSWindowTitleVisibility,
};
use objc2_foundation::{
    ns_string, NSAttributedString, NSData, NSNotification, NSObject, NSPoint, NSRange, NSRect,
    NSSize, NSString, NSTimer, NSUndoManager,
};
use rust_fontconfig::FcFontCache;

use super::common::debug_server::LogCategory;
use crate::{log_debug, log_error, log_info, log_trace, log_warn};

use crate::desktop::{
    shell2::common::{
        self,
        event_v2::{self, PlatformWindowV2}, // Import event_v2 module AND trait
        Compositor,
        CompositorError,
        CompositorMode,
        PlatformWindow,
        RenderContext,
        WindowError,
        WindowProperties,
    },
    wr_translate2::{
        default_renderer_options, translate_document_id_wr, translate_id_namespace_wr,
        wr_translate_document_id, wr_translate_pipeline_id, AsyncHitTester,
        Compositor as WrCompositor, Notifier, WrRenderApi, WrTransaction, WR_SHADER_CACHE,
    },
};

pub mod accessibility;
pub mod clipboard;
mod coregraphics;
mod corevideo;
mod events;
mod gl;
mod menu;
pub mod registry;
mod tooltip;

use coregraphics::CoreGraphicsFunctions;
use corevideo::CoreVideoFunctions;
use events::HitTestNode;
use gl::GlFunctions;

// IOKit FFI - Power Management (IOPMAssertion)

type IOPMAssertionID = u32;
type IOReturn = i32;

const kIOReturnSuccess: IOReturn = 0;

// IOPMAssertion types
#[allow(non_upper_case_globals)]
const kIOPMAssertionTypeNoDisplaySleep: &str = "PreventUserIdleDisplaySleep";

#[link(name = "IOKit", kind = "framework")]
extern "C" {
    fn IOPMAssertionCreateWithName(
        assertion_type: *const objc2_foundation::NSString,
        assertion_level: u32,
        assertion_name: *const objc2_foundation::NSString,
        assertion_id: *mut IOPMAssertionID,
    ) -> IOReturn;

    fn IOPMAssertionRelease(assertion_id: IOPMAssertionID) -> IOReturn;
}

const kIOPMAssertionLevelOn: u32 = 255;

#[derive(Clone, Copy, PartialEq, Debug)]
pub enum RenderBackend {
    OpenGL,
    CPU,
}

// GLView - OpenGL rendering view

/// Instance variables for GLView
pub struct GLViewIvars {
    gl_functions: RefCell<Option<Rc<gl_context_loader::GenericGlContext>>>,
    needs_reshape: Cell<bool>,
    tracking_area: RefCell<Option<Retained<NSTrackingArea>>>,
    mtm: MainThreadMarker, // Store MainThreadMarker to avoid unsafe new_unchecked
    /// Back-pointer to the owning MacOSWindow (as *mut to avoid forward reference)
    /// This is set after window creation via set_window_ptr()
    window_ptr: RefCell<Option<*mut std::ffi::c_void>>,
}

define_class!(
    #[unsafe(super(NSOpenGLView, NSView, NSResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[name = "AzulGLView"]
    #[ivars = GLViewIvars]
    pub struct GLView;

    impl GLView {
        #[unsafe(method(drawRect:))]
        fn draw_rect(&self, _rect: NSRect) {
            log_trace!(LogCategory::Rendering, "[GLView] drawRect: called - this is where ALL rendering happens");

            // Get the back-pointer to our MacOSWindow
            let window_ptr = match self.get_window_ptr() {
                Some(ptr) => ptr,
                None => {
                    log_warn!(LogCategory::Rendering, "[GLView] drawRect: No window pointer set yet, skipping render");
                    return;
                }
            };

            // SAFETY: We trust that the window pointer is valid and points to a MacOSWindow
            // The window owns the view, so the window outlives the view
            unsafe {
                let macos_window = &mut *(window_ptr as *mut MacOSWindow);

                // Call the rendering method on MacOSWindow
                // This will:
                // 1. Make GL context current
                // 2. Call renderer.update()
                // 3. Call renderer.render() to composite WebRender's scene
                // 4. Call flushBuffer() to swap
                log_debug!(LogCategory::Rendering, "[GLView] drawRect: render_and_present_in_draw_rect will be called");
                if let Err(e) = macos_window.render_and_present_in_draw_rect() {
                    log_error!(LogCategory::Rendering, "[GLView] drawRect: Error during rendering: {:?}", e);
                }
            }
        }

        #[unsafe(method(prepareOpenGL))]
        fn prepare_opengl(&self) {
            log_debug!(LogCategory::Rendering, "[GLView] prepareOpenGL called!");
            // Load GL functions via dlopen
            match GlFunctions::initialize() {
                Ok(functions) => {
                    log_debug!(LogCategory::Rendering, "[GLView] prepareOpenGL: GL functions loaded successfully");
                    *self.ivars().gl_functions.borrow_mut() = Some(functions.get_context());
                    self.ivars().needs_reshape.set(true);
                }
                Err(e) => {
                    log_error!(LogCategory::Rendering, "Failed to load GL functions: {}", e);
                }
            }
            log_debug!(LogCategory::Rendering, "[GLView] prepareOpenGL done");
        }

        #[unsafe(method(reshape))]
        fn reshape(&self) {
            log_trace!(LogCategory::Rendering, "[GLView] reshape called!");
            let mtm = self.ivars().mtm;

            // Update context - THIS IS STILL IMPORTANT
            unsafe {
                if let Some(context) = self.openGLContext() {
                    context.update(mtm);
                }
            }

            // NOTE: glViewport is now set in MacOSWindow::present() instead of here
            // This ensures the viewport is synchronized with every frame render,
            // not just when the OS decides to send a reshape event.

            self.ivars().needs_reshape.set(false);
        }

        // Event Handling

        #[unsafe(method(acceptsFirstResponder))]
        fn accepts_first_responder(&self) -> bool {
            true
        }

        #[unsafe(method(mouseDown:))]
        fn mouse_down(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_down(event, azul_core::events::MouseButton::Left);
                }
            }
        }

        #[unsafe(method(mouseUp:))]
        fn mouse_up(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_up(event, azul_core::events::MouseButton::Left);
                }
            }
        }

        #[unsafe(method(mouseDragged:))]
        fn mouse_dragged(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_move(event);
                }
            }
        }

        #[unsafe(method(rightMouseDown:))]
        fn right_mouse_down(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_down(event, azul_core::events::MouseButton::Right);
                }
            }
        }

        #[unsafe(method(rightMouseUp:))]
        fn right_mouse_up(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_up(event, azul_core::events::MouseButton::Right);
                }
            }
        }

        #[unsafe(method(scrollWheel:))]
        fn scroll_wheel(&self, event: &NSEvent) {
            // Forward to MacOSWindow for scroll handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_scroll_wheel(event);
                }
            }
        }

        #[unsafe(method(keyDown:))]
        fn key_down(&self, event: &NSEvent) {
            // CRITICAL: Call interpretKeyEvents to trigger NSTextInputClient insertText:
            unsafe {
                let events = objc2_foundation::NSArray::from_slice(&[event]);
                self.interpretKeyEvents(&events);
            }
            // Forward to MacOSWindow for non-text keys
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    use crate::desktop::shell2::macos::events::EventProcessResult;
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    let result = macos_window.handle_key_down(event);
                    if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                        macos_window.frame_needs_regeneration = true;
                        macos_window.request_redraw();
                    }
                }
            }
        }

        #[unsafe(method(keyUp:))]
        fn key_up(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    use crate::desktop::shell2::macos::events::EventProcessResult;
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    let result = macos_window.handle_key_up(event);
                    if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                        macos_window.frame_needs_regeneration = true;
                        macos_window.request_redraw();
                    }
                }
            }
        }

        #[unsafe(method(flagsChanged:))]
        fn flags_changed(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    use crate::desktop::shell2::macos::events::EventProcessResult;
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    let result = macos_window.handle_flags_changed(event);
                    if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                        macos_window.frame_needs_regeneration = true;
                        macos_window.request_redraw();
                    }
                }
            }
        }

        // NSResponder Undo/Redo Support
        // These methods are called automatically by macOS when Cmd+Z / Cmd+Shift+Z are pressed

        #[unsafe(method(undo:))]
        fn undo(&self, _sender: Option<&NSObject>) {
            // Forward to MacOSWindow for actual undo logic
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.perform_undo();
                }
            }
        }

        #[unsafe(method(redo:))]
        fn redo(&self, _sender: Option<&NSObject>) {
            // Forward to MacOSWindow for actual redo logic
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.perform_redo();
                }
            }
        }

        #[unsafe(method(validateUserInterfaceItem:))]
        fn validate_user_interface_item(&self, item: &ProtocolObject<dyn NSObjectProtocol>) -> Bool {
            // Check if we can undo/redo and enable/disable menu items accordingly
            use objc2::sel;
            use objc2::runtime::{AnyObject, Sel};

            // Try to get the action from the item (if it's an NSMenuItem)
            let action: Option<Sel> = unsafe {
                let obj = item as *const _ as *const AnyObject;
                objc2::msg_send![obj, action]
            };

            if action == Some(sel!(undo:)) {
                if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                    unsafe {
                        let macos_window = &*(window_ptr as *const MacOSWindow);
                        return Bool::from(macos_window.can_undo());
                    }
                }
                return Bool::from(false);
            } else if action == Some(sel!(redo:)) {
                if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                    unsafe {
                        let macos_window = &*(window_ptr as *const MacOSWindow);
                        return Bool::from(macos_window.can_redo());
                    }
                }
                return Bool::from(false);
            }

            Bool::from(true) // Default: enable other items
        }

        /// Timer tick method - called by NSTimer with repeats:true
        /// This method invokes expired timers via the stored MacOSWindow pointer.
        #[unsafe(method(tickTimers:))]
        fn tick_timers(&self, _sender: Option<&NSObject>) {
            use azul_core::callbacks::Update;
            use crate::desktop::shell2::common::event_v2::PlatformWindowV2;

            // Only log every ~60 frames to avoid spam, but always log if there's work
            static TICK_COUNT: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);
            let tick = TICK_COUNT.fetch_add(1, std::sync::atomic::Ordering::Relaxed);

            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);

                    // Invoke all expired timer callbacks
                    let timer_results = macos_window.invoke_expired_timers();

                    // Process each callback result to handle window state modifications
                    let mut needs_redraw = false;
                    for result in &timer_results {
                        // Apply window state changes from callback result
                        // Also process queued_window_states (for debug server click simulation)
                        // Also process nodes_scrolled_in_callbacks (for scroll_node_by API)
                        let has_window_changes = result.modified_window_state.is_some()
                            || !result.queued_window_states.is_empty();
                        let has_scroll_changes = result.nodes_scrolled_in_callbacks.as_ref()
                            .map(|s| !s.is_empty()).unwrap_or(false);

                        if has_window_changes || has_scroll_changes {
                            // Save previous state BEFORE applying changes (for sync_window_state diff)
                            macos_window.previous_window_state = Some(macos_window.current_window_state.clone());
                            let _ = macos_window.process_callback_result_v2(result);
                            // Synchronize window state with OS immediately after change
                            // This handles close_requested, title, size, position, etc.
                            macos_window.sync_window_state();
                        }
                        // Check if redraw needed
                        if matches!(result.callbacks_update_screen, Update::RefreshDom | Update::RefreshDomAllWindows) {
                            needs_redraw = true;
                        }
                    }

                    if needs_redraw {
                        macos_window.frame_needs_regeneration = true;
                        let _: () = msg_send![self, setNeedsDisplay: true];
                    }
                }
            }
            // Note: NSTimer with repeats:true automatically reschedules itself
        }

        #[unsafe(method_id(initWithFrame:pixelFormat:))]
        fn init_with_frame_pixel_format(
            this: Allocated<Self>,
            frame: NSRect,
            pixel_format: Option<&NSOpenGLPixelFormat>,
        ) -> Option<Retained<Self>> {
            // Get MainThreadMarker - we're guaranteed to be on main thread in init
            let mtm = MainThreadMarker::new().expect("init must be called on main thread");

            let this = this.set_ivars(GLViewIvars {
                gl_functions: RefCell::new(None),
                needs_reshape: Cell::new(true),
                tracking_area: RefCell::new(None),
                mtm,
                window_ptr: RefCell::new(None),
            });
            unsafe {
                msg_send_id![super(this), initWithFrame: frame, pixelFormat: pixel_format]
            }
        }

        #[unsafe(method(updateTrackingAreas))]
        fn update_tracking_areas(&self) {
            // Remove old tracking area if exists
            if let Some(old_area) = self.ivars().tracking_area.borrow_mut().take() {
                unsafe {
                    self.removeTrackingArea(&old_area);
                }
            }

            // Create new tracking area for mouse enter/exit events
            let bounds = unsafe { self.bounds() };
            let options = NSTrackingAreaOptions::MouseEnteredAndExited
                | NSTrackingAreaOptions::ActiveInKeyWindow
                | NSTrackingAreaOptions::InVisibleRect;

            let tracking_area = unsafe {
                NSTrackingArea::initWithRect_options_owner_userInfo(
                    NSTrackingArea::alloc(),
                    bounds,
                    options,
                    Some(self),
                    None,
                )
            };

            unsafe {
                self.addTrackingArea(&tracking_area);
            }

            *self.ivars().tracking_area.borrow_mut() = Some(tracking_area);
        }

        #[unsafe(method(mouseEntered:))]
        fn mouse_entered(&self, _event: &NSEvent) {
            // Event will be handled by MacOSWindow
        }

        #[unsafe(method(mouseExited:))]
        fn mouse_exited(&self, _event: &NSEvent) {
            // Event will be handled by MacOSWindow
        }

        #[unsafe(method(mouseMoved:))]
        fn mouse_moved(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_move(event);
                }
            }
        }

        // NSTextInputClient Protocol
        // Basic IME support for Unicode composition (e.g., Japanese, Chinese, accented characters)

        #[unsafe(method(hasMarkedText))]
        fn has_marked_text(&self) -> bool {
            // For now, we don't track marked text ranges
            false
        }

        #[unsafe(method(markedRange))]
        fn marked_range(&self) -> NSRange {
            // Return NSNotFound to indicate no marked text
            NSRange {
                location: usize::MAX,
                length: 0,
            }
        }

        #[unsafe(method(selectedRange))]
        fn selected_range(&self) -> NSRange {
            // CRITICAL: Return a valid cursor position (location 0, length 0 = cursor at position 0)
            // Returning NSNotFound (usize::MAX) tells macOS there's no insertion point,
            // and it will NOT call insertText:replacementRange:
            NSRange {
                location: 0,
                length: 0,
            }
        }

        #[unsafe(method(setMarkedText:selectedRange:replacementRange:))]
        fn set_marked_text(
            &self,
            _string: &NSObject,
            _selected_range: NSRange,
            _replacement_range: NSRange,
        ) {
            println!("[GLView::setMarkedText] Called");
            // Phase 2: OnCompositionStart callback - sync IME position
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.sync_ime_position_to_os();
                }
            }
        }

        #[unsafe(method(unmarkText))]
        fn unmark_text(&self) {
            println!("[GLView::unmarkText] Called");
            // Called when IME composition is finished
        }

        #[unsafe(method_id(validAttributesForMarkedText))]
        fn valid_attributes_for_marked_text(&self) -> Retained<objc2_foundation::NSArray> {
            // Return empty array - no special attributes needed
            unsafe { objc2_foundation::NSArray::new() }
        }

        #[unsafe(method_id(attributedSubstringForProposedRange:actualRange:))]
        fn attributed_substring_for_proposed_range(
            &self,
            _range: NSRange,
            _actual_range: *mut NSRange,
        ) -> Option<Retained<NSAttributedString>> {
            None
        }

        #[unsafe(method(insertText:replacementRange:))]
        fn insert_text(&self, string: &NSObject, _replacement_range: NSRange) {
            println!("[GLView::insert_text] Called!");
            
            // Get the back-pointer to our MacOSWindow
            let window_ptr = match self.get_window_ptr() {
                Some(ptr) => ptr,
                None => {
                    println!("[GLView::insert_text] ERROR: No window pointer!");
                    return;
                }
            };

            // SAFETY: We trust that the window pointer is valid.
            unsafe {
                let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                if let Some(ns_string) = string.downcast_ref::<NSString>() {
                    let text = ns_string.to_string();
                    println!("[GLView::insert_text] Inserting text: '{}'", text);
                    macos_window.handle_text_input(&text);
                } else {
                    println!("[GLView::insert_text] ERROR: Could not downcast to NSString");
                }
            }
        }

        #[unsafe(method(characterIndexForPoint:))]
        fn character_index_for_point(&self, _point: NSPoint) -> usize {
            // Return NSNotFound
            usize::MAX
        }

        #[unsafe(method(firstRectForCharacterRange:actualRange:))]
        fn first_rect_for_character_range(
            &self,
            _range: NSRange,
            _actual_range: *mut NSRange,
        ) -> NSRect {
            use azul_core::window::ImePosition;

            // Get ime_position from window state
            let window_ptr = match self.get_window_ptr() {
                Some(ptr) => ptr,
                None => return NSRect::ZERO,
            };

            unsafe {
                let window = &*(window_ptr as *const MacOSWindow);
                if let ImePosition::Initialized(rect) = window.current_window_state.ime_position {
                    // Convert from window-local coordinates to screen coordinates
                    let window_frame = window.window.frame();

                    return NSRect {
                        origin: NSPoint {
                            x: window_frame.origin.x + rect.origin.x as f64,
                            y: window_frame.origin.y + rect.origin.y as f64,
                        },
                        size: NSSize {
                            width: rect.size.width as f64,
                            height: rect.size.height as f64,
                        },
                    };
                }
            }

            NSRect::ZERO
        }

        #[unsafe(method(doCommandBySelector:))]
        fn do_command_by_selector(&self, _selector: objc2::runtime::Sel) {
            // Called for special key commands during IME
        }
    }
);

// CPUView - CPU rendering view

/// Instance variables for CPUView
pub struct CPUViewIvars {
    framebuffer: RefCell<Vec<u8>>,
    width: Cell<usize>,
    height: Cell<usize>,
    needs_redraw: Cell<bool>,
    tracking_area: RefCell<Option<Retained<NSTrackingArea>>>,
    mtm: MainThreadMarker, // Store MainThreadMarker to avoid unsafe new_unchecked
    window_ptr: RefCell<Option<*mut std::ffi::c_void>>, // Back-pointer to MacOSWindow
}

define_class!(
    #[unsafe(super(NSView, NSResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[name = "AzulCPUView"]
    #[ivars = CPUViewIvars]
    pub struct CPUView;

    impl CPUView {
        #[unsafe(method(drawRect:))]
        fn draw_rect(&self, _dirty_rect: NSRect) {
            let bounds = unsafe { self.bounds() };
            let width = bounds.size.width as usize;
            let height = bounds.size.height as usize;

            let ivars = self.ivars();

            // Resize framebuffer if needed
            let current_width = ivars.width.get();
            let current_height = ivars.height.get();

            if current_width != width || current_height != height {
                ivars.width.set(width);
                ivars.height.set(height);
                ivars.framebuffer.borrow_mut().resize(width * height * 4, 0);
            }

            // Render blue gradient to framebuffer
            {
                let mut framebuffer = ivars.framebuffer.borrow_mut();
                for y in 0..height {
                    for x in 0..width {
                        let idx = (y * width + x) * 4;
                        framebuffer[idx] = (x * 128 / width.max(1)) as u8; // R
                        framebuffer[idx + 1] = (y * 128 / height.max(1)) as u8; // G
                        framebuffer[idx + 2] = 255; // B - Blue
                        framebuffer[idx + 3] = 255; // A
                    }
                }
            }

            // Blit framebuffer to window
            unsafe {
                let mtm = ivars.mtm; // Get mtm from ivars
                let framebuffer = ivars.framebuffer.borrow();

                // Use NSData::with_bytes to wrap our framebuffer
                let data = NSData::with_bytes(&framebuffer[..]);

                if let Some(bitmap) = NSBitmapImageRep::initWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bytesPerRow_bitsPerPixel(
                    NSBitmapImageRep::alloc(),
                    std::ptr::null_mut(),
                    width as isize,
                    height as isize,
                    8,
                    4,
                    true,
                    false,
                    ns_string!("NSCalibratedRGBColorSpace"),
                    (width * 4) as isize,
                    32,
                ) {
                    // Copy framebuffer data to bitmap
                    std::ptr::copy_nonoverlapping(
                        framebuffer.as_ptr(),
                        bitmap.bitmapData(),
                        framebuffer.len(),
                    );

                    // Create image and draw
                    let image = NSImage::initWithSize(NSImage::alloc(), bounds.size);
                    image.addRepresentation(&bitmap);
                    image.drawInRect(bounds);
                }
            }
        }

        #[unsafe(method(isOpaque))]
        fn is_opaque(&self) -> bool {
            true
        }

        // Event Handling

        #[unsafe(method(acceptsFirstResponder))]
        fn accepts_first_responder(&self) -> bool {
            true
        }

        #[unsafe(method(mouseDown:))]
        fn mouse_down(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_down(event, azul_core::events::MouseButton::Left);
                }
            }
        }

        #[unsafe(method(mouseUp:))]
        fn mouse_up(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_up(event, azul_core::events::MouseButton::Left);
                }
            }
        }

        #[unsafe(method(mouseDragged:))]
        fn mouse_dragged(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_move(event);
                }
            }
        }

        #[unsafe(method(rightMouseDown:))]
        fn right_mouse_down(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_down(event, azul_core::events::MouseButton::Right);
                }
            }
        }

        #[unsafe(method(rightMouseUp:))]
        fn right_mouse_up(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_up(event, azul_core::events::MouseButton::Right);
                }
            }
        }

        #[unsafe(method(scrollWheel:))]
        fn scroll_wheel(&self, event: &NSEvent) {
            // Forward to MacOSWindow for scroll handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_scroll_wheel(event);
                }
            }
        }

        #[unsafe(method(keyDown:))]
        fn key_down(&self, event: &NSEvent) {
            // CRITICAL: Call interpretKeyEvents to trigger NSTextInputClient insertText:
            unsafe {
                let events = objc2_foundation::NSArray::from_slice(&[event]);
                self.interpretKeyEvents(&events);
            }
            // Forward to MacOSWindow for non-text keys
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    use crate::desktop::shell2::macos::events::EventProcessResult;
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    let result = macos_window.handle_key_down(event);
                    if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                        macos_window.frame_needs_regeneration = true;
                        macos_window.request_redraw();
                    }
                }
            }
        }

        #[unsafe(method(keyUp:))]
        fn key_up(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    use crate::desktop::shell2::macos::events::EventProcessResult;
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    let result = macos_window.handle_key_up(event);
                    if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                        macos_window.frame_needs_regeneration = true;
                        macos_window.request_redraw();
                    }
                }
            }
        }

        #[unsafe(method(flagsChanged:))]
        fn flags_changed(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    use crate::desktop::shell2::macos::events::EventProcessResult;
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    let result = macos_window.handle_flags_changed(event);
                    if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                        macos_window.frame_needs_regeneration = true;
                        macos_window.request_redraw();
                    }
                }
            }
        }

        // NSResponder Undo/Redo Support
        // These methods are called automatically by macOS when Cmd+Z / Cmd+Shift+Z are pressed

        #[unsafe(method(undo:))]
        fn undo(&self, _sender: Option<&NSObject>) {
            // Forward to MacOSWindow for actual undo logic
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.perform_undo();
                }
            }
        }

        #[unsafe(method(redo:))]
        fn redo(&self, _sender: Option<&NSObject>) {
            // Forward to MacOSWindow for actual redo logic
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.perform_redo();
                }
            }
        }

        /// Timer tick method - called by NSTimer with repeats:true
        /// This method invokes expired timers via the stored MacOSWindow pointer.
        #[unsafe(method(tickTimers:))]
        fn tick_timers(&self, _sender: Option<&NSObject>) {
            use azul_core::callbacks::Update;
            use crate::desktop::shell2::common::event_v2::PlatformWindowV2;

            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);

                    // Invoke all expired timer callbacks
                    let timer_results = macos_window.invoke_expired_timers();

                    // Process each callback result to handle window state modifications
                    let mut needs_redraw = false;
                    for result in &timer_results {
                        // Apply window state changes from callback result
                        // Also process queued_window_states (for debug server click simulation)
                        // Also process nodes_scrolled_in_callbacks (for scroll_node_by API)
                        let has_window_changes = result.modified_window_state.is_some()
                            || !result.queued_window_states.is_empty();
                        let has_scroll_changes = result.nodes_scrolled_in_callbacks.as_ref()
                            .map(|s| !s.is_empty()).unwrap_or(false);

                        if has_window_changes || has_scroll_changes {
                            // Save previous state BEFORE applying changes (for sync_window_state diff)
                            macos_window.previous_window_state = Some(macos_window.current_window_state.clone());
                            let _ = macos_window.process_callback_result_v2(result);
                            // Synchronize window state with OS immediately after change
                            // This handles close_requested, title, size, position, etc.
                            macos_window.sync_window_state();
                        }
                        // Check if redraw needed
                        if matches!(result.callbacks_update_screen, Update::RefreshDom | Update::RefreshDomAllWindows) {
                            needs_redraw = true;
                        }
                    }

                    if needs_redraw {
                        macos_window.frame_needs_regeneration = true;
                        let _: () = msg_send![self, setNeedsDisplay: true];
                    }
                }
            }
            // Note: NSTimer with repeats:true automatically reschedules itself
        }

        #[unsafe(method(validateUserInterfaceItem:))]
        fn validate_user_interface_item(&self, item: &ProtocolObject<dyn NSObjectProtocol>) -> Bool {
            // Check if we can undo/redo and enable/disable menu items accordingly
            use objc2::sel;
            use objc2::runtime::{AnyObject, Sel};

            // Try to get the action from the item (if it's an NSMenuItem)
            let action: Option<Sel> = unsafe {
                let obj = item as *const _ as *const AnyObject;
                objc2::msg_send![obj, action]
            };

            if action == Some(sel!(undo:)) {
                if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                    unsafe {
                        let macos_window = &*(window_ptr as *const MacOSWindow);
                        return Bool::from(macos_window.can_undo());
                    }
                }
                return Bool::from(false);
            } else if action == Some(sel!(redo:)) {
                if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                    unsafe {
                        let macos_window = &*(window_ptr as *const MacOSWindow);
                        return Bool::from(macos_window.can_redo());
                    }
                }
                return Bool::from(false);
            }

            Bool::from(true) // Default: enable other items
        }

        #[unsafe(method_id(initWithFrame:))]
        fn init_with_frame(
            this: Allocated<Self>,
            frame: NSRect,
        ) -> Option<Retained<Self>> {
            // Get MainThreadMarker - we're guaranteed to be on main thread in init
            let mtm = MainThreadMarker::new().expect("init must be called on main thread");

            let this = this.set_ivars(CPUViewIvars {
                framebuffer: RefCell::new(Vec::new()),
                width: Cell::new(0),
                height: Cell::new(0),
                needs_redraw: Cell::new(true),
                tracking_area: RefCell::new(None),
                mtm,
                window_ptr: RefCell::new(None),
            });
            unsafe {
                msg_send_id![super(this), initWithFrame: frame]
            }
        }

        #[unsafe(method(updateTrackingAreas))]
        fn update_tracking_areas(&self) {
            // Remove old tracking area if exists
            if let Some(old_area) = self.ivars().tracking_area.borrow_mut().take() {
                unsafe {
                    self.removeTrackingArea(&old_area);
                }
            }

            // Create new tracking area for mouse enter/exit/move events
            let bounds = unsafe { self.bounds() };
            let options = NSTrackingAreaOptions::MouseEnteredAndExited
                | NSTrackingAreaOptions::MouseMoved
                | NSTrackingAreaOptions::ActiveInKeyWindow
                | NSTrackingAreaOptions::InVisibleRect;

            let tracking_area = unsafe {
                NSTrackingArea::initWithRect_options_owner_userInfo(
                    NSTrackingArea::alloc(),
                    bounds,
                    options,
                    Some(self),
                    None,
                )
            };

            unsafe {
                self.addTrackingArea(&tracking_area);
            }

            *self.ivars().tracking_area.borrow_mut() = Some(tracking_area);
        }

        #[unsafe(method(mouseEntered:))]
        fn mouse_entered(&self, _event: &NSEvent) {
            // Event will be handled by MacOSWindow
        }

        #[unsafe(method(mouseExited:))]
        fn mouse_exited(&self, _event: &NSEvent) {
            // Event will be handled by MacOSWindow
        }

        #[unsafe(method(mouseMoved:))]
        fn mouse_moved(&self, event: &NSEvent) {
            // Forward to MacOSWindow for handling
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.handle_mouse_move(event);
                }
            }
        }

        // NSTextInputClient Protocol
        // Same IME implementation as GLView

        #[unsafe(method(hasMarkedText))]
        fn has_marked_text(&self) -> bool {
            false
        }

        #[unsafe(method(markedRange))]
        fn marked_range(&self) -> NSRange {
            NSRange {
                location: usize::MAX,
                length: 0,
            }
        }

        #[unsafe(method(selectedRange))]
        fn selected_range(&self) -> NSRange {
            // CRITICAL: Return a valid cursor position (location 0, length 0 = cursor at position 0)
            // Returning NSNotFound (usize::MAX) tells macOS there's no insertion point,
            // and it will NOT call insertText:replacementRange:
            NSRange {
                location: 0,
                length: 0,
            }
        }

        #[unsafe(method(setMarkedText:selectedRange:replacementRange:))]
        fn set_marked_text(
            &self,
            _string: &NSObject,
            _selected_range: NSRange,
            _replacement_range: NSRange,
        ) {
            // Phase 2: OnCompositionStart callback - sync IME position
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.sync_ime_position_to_os();
                }
            }
        }

        #[unsafe(method(unmarkText))]
        fn unmark_text(&self) {
        }

        #[unsafe(method_id(validAttributesForMarkedText))]
        fn valid_attributes_for_marked_text(&self) -> Retained<objc2_foundation::NSArray> {
            unsafe { objc2_foundation::NSArray::new() }
        }

        #[unsafe(method_id(attributedSubstringForProposedRange:actualRange:))]
        fn attributed_substring_for_proposed_range(
            &self,
            _range: NSRange,
            _actual_range: *mut NSRange,
        ) -> Option<Retained<NSAttributedString>> {
            None
        }

        #[unsafe(method(insertText:replacementRange:))]
        fn insert_text(&self, string: &NSObject, _replacement_range: NSRange) {
            println!("[CPUView::insert_text] Called!");
            
            // Get the back-pointer to our MacOSWindow
            let window_ptr = match self.get_window_ptr() {
                Some(ptr) => ptr,
                None => {
                    println!("[CPUView::insert_text] ERROR: No window pointer!");
                    return;
                }
            };

            // SAFETY: We trust that the window pointer is valid.
            unsafe {
                let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                if let Some(ns_string) = string.downcast_ref::<NSString>() {
                    let text = ns_string.to_string();
                    println!("[CPUView::insert_text] Inserting text: '{}'", text);
                    macos_window.handle_text_input(&text);
                } else {
                    println!("[CPUView::insert_text] ERROR: Could not downcast to NSString");
                }
            }
        }

        #[unsafe(method(characterIndexForPoint:))]
        fn character_index_for_point(&self, _point: NSPoint) -> usize {
            usize::MAX
        }

        #[unsafe(method(firstRectForCharacterRange:actualRange:))]
        fn first_rect_for_character_range(
            &self,
            _range: NSRange,
            _actual_range: *mut NSRange,
        ) -> NSRect {
            use azul_core::window::ImePosition;

            // Get ime_position from window state
            let window_ptr = match self.get_window_ptr() {
                Some(ptr) => ptr,
                None => return NSRect::ZERO,
            };

            unsafe {
                let window = &*(window_ptr as *const MacOSWindow);
                if let ImePosition::Initialized(rect) = window.current_window_state.ime_position {
                    // Convert from window-local coordinates to screen coordinates
                    let window_frame = window.window.frame();

                    return NSRect {
                        origin: NSPoint {
                            x: window_frame.origin.x + rect.origin.x as f64,
                            y: window_frame.origin.y + rect.origin.y as f64,
                        },
                        size: NSSize {
                            width: rect.size.width as f64,
                            height: rect.size.height as f64,
                        },
                    };
                }
            }

            NSRect::ZERO
        }

        #[unsafe(method(doCommandBySelector:))]
        fn do_command_by_selector(&self, _selector: objc2::runtime::Sel) {
        }
    }
);

// GLView Helper Methods (outside define_class!)

impl GLView {
    /// Set the back-pointer to the owning MacOSWindow
    /// SAFETY: Caller must ensure the pointer remains valid for the lifetime of the view
    pub unsafe fn set_window_ptr(&self, window_ptr: *mut std::ffi::c_void) {
        *self.ivars().window_ptr.borrow_mut() = Some(window_ptr);

        // Start the timer tick loop - this will invoke timer callbacks every 16ms
        // and reschedule itself via performSelector:withObject:afterDelay:
        use objc2::sel;
        let delay: f64 = 0.016;
        let _: () = msg_send![self, performSelector: sel!(tickTimers:), withObject: std::ptr::null::<NSObject>(), afterDelay: delay];
    }

    /// Get the back-pointer to the owning MacOSWindow
    fn get_window_ptr(&self) -> Option<*mut std::ffi::c_void> {
        *self.ivars().window_ptr.borrow()
    }
}

// CPUView Helper Methods (outside define_class!)

impl CPUView {
    /// Set the back-pointer to the owning MacOSWindow
    /// SAFETY: Caller must ensure the pointer remains valid for the lifetime of the view
    pub unsafe fn set_window_ptr(&self, window_ptr: *mut std::ffi::c_void) {
        *self.ivars().window_ptr.borrow_mut() = Some(window_ptr);

        // Start the timer tick loop - this will invoke timer callbacks every 16ms
        // and reschedule itself via performSelector:withObject:afterDelay:
        use objc2::sel;
        let delay: f64 = 0.016;
        let _: () = msg_send![self, performSelector: sel!(tickTimers:), withObject: std::ptr::null::<NSObject>(), afterDelay: delay];
    }

    /// Get the back-pointer to the owning MacOSWindow
    fn get_window_ptr(&self) -> Option<*mut std::ffi::c_void> {
        *self.ivars().window_ptr.borrow()
    }
}

// WindowDelegate - Handles window lifecycle events (close, resize, etc.)

/// Instance variables for WindowDelegate
pub struct WindowDelegateIvars {
    /// Back-pointer to the owning MacOSWindow for handling close callbacks
    /// This is set after window creation via set_window_ptr()
    window_ptr: RefCell<Option<*mut std::ffi::c_void>>,
}

define_class!(
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[name = "AzulWindowDelegate"]
    #[ivars = WindowDelegateIvars]
    pub struct WindowDelegate;

    impl WindowDelegate {
        #[unsafe(method(windowShouldClose:))]
        fn window_should_close(&self, _sender: Option<&NSWindow>) -> Bool {
            let window_ptr = *self.ivars().window_ptr.borrow();

            if let Some(window_ptr) = window_ptr {
                log_debug!(LogCategory::Window, "[WindowDelegate] Close requested, invoking callback");

                // SAFETY: window_ptr points to MacOSWindow which owns this delegate
                // The window outlives the delegate, so this pointer is always valid
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);

                    // Call the MacOSWindow method to handle close
                    // This will invoke callbacks and determine if close should proceed
                    match macos_window.handle_window_should_close() {
                        Ok(should_close) => {
                            if should_close {
                                log_debug!(LogCategory::Window, "[WindowDelegate] Allowing close");
                                Bool::YES
                            } else {
                                log_debug!(LogCategory::Window, "[WindowDelegate] Preventing close (callback cancelled)");
                                Bool::NO
                            }
                        }
                        Err(e) => {
                            log_error!(LogCategory::Window, "[WindowDelegate] Error handling close: {}, allowing close", e);
                            Bool::YES // Allow close on error to avoid stuck window
                        }
                    }
                }
            } else {
                // No window pointer, allow close by default
                log_debug!(LogCategory::Window, "[WindowDelegate] No window pointer, allowing close");
                Bool::YES
            }
        }

        /// Called when the window is about to close
        /// This is where we unregister the window from the global registry
        #[unsafe(method(windowWillClose:))]
        fn window_will_close(&self, _notification: &NSNotification) {
            log_debug!(LogCategory::Window, "[WindowDelegate] Window will close, unregistering from registry");

            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    let ns_window = macos_window.get_ns_window_ptr();

                    // Unregister from global window registry
                    registry::unregister_window(ns_window);
                    log_debug!(LogCategory::Window, "[WindowDelegate] Window unregistered, remaining windows: {}", registry::window_count());
                }
            }
        }

        /// Called when the window is minimized to the Dock
        #[unsafe(method(windowDidMiniaturize:))]
        fn window_did_miniaturize(&self, _notification: &NSNotification) {
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.current_window_state.flags.frame = WindowFrame::Minimized;
                }
                log_debug!(LogCategory::Window, "[WindowDelegate] Window minimized");
            }
        }

        /// Called when the window is restored from the Dock
        #[unsafe(method(windowDidDeminiaturize:))]
        fn window_did_deminiaturize(&self, _notification: &NSNotification) {
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.current_window_state.flags.frame = WindowFrame::Normal;
                }
                log_debug!(LogCategory::Window, "[WindowDelegate] Window deminiaturized");
            }
        }

        /// Called when the window enters fullscreen mode
        #[unsafe(method(windowDidEnterFullScreen:))]
        fn window_did_enter_fullscreen(&self, _notification: &NSNotification) {
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.current_window_state.flags.frame = WindowFrame::Fullscreen;
                }
                log_debug!(LogCategory::Window, "[WindowDelegate] Window entered fullscreen");
            }
        }

        /// Called when the window exits fullscreen mode
        #[unsafe(method(windowDidExitFullScreen:))]
        fn window_did_exit_fullscreen(&self, _notification: &NSNotification) {
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    // Return to normal frame, will be updated by resize check if maximized
                    macos_window.current_window_state.flags.frame = WindowFrame::Normal;
                }
                log_debug!(LogCategory::Window, "[WindowDelegate] Window exited fullscreen");
            }
        }

        /// Called when the window is resized
        #[unsafe(method(windowDidResize:))]
        fn window_did_resize(&self, _notification: &NSNotification) {
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);

                    // Get new logical size from content view
                    if let Some(content_view) = macos_window.window.contentView() {
                        let bounds = content_view.bounds();
                        let new_logical_width = bounds.size.width as f32;
                        let new_logical_height = bounds.size.height as f32;

                        // Update dimensions if changed
                        let old_dims = macos_window.current_window_state.size.dimensions;
                        if (old_dims.width - new_logical_width).abs() > 0.5
                            || (old_dims.height - new_logical_height).abs() > 0.5
                        {
                            macos_window.current_window_state.size.dimensions =
                                azul_core::geom::LogicalSize {
                                    width: new_logical_width,
                                    height: new_logical_height,
                                };

                            log_debug!(LogCategory::Window,
                                "[WindowDelegate] Window resized: {}x{} -> {}x{}",
                                old_dims.width, old_dims.height,
                                new_logical_width, new_logical_height
                            );

                            // Mark frame for regeneration with new size
                            // Window state sync happens in build_atomic_txn before WebRender transaction
                            macos_window.frame_needs_regeneration = true;

                            // Trigger re-layout and request redraw
                            // Must call request_redraw() to trigger drawRect: with new size
                            macos_window.request_redraw();
                        }
                    }

                    // Only check for maximized state if not in fullscreen
                    let frame = macos_window.current_window_state.flags.frame;
                    if frame != WindowFrame::Fullscreen {
                        // Check maximized state will be done in event loop
                    }
                }
            }
        }

        /// Called when the window becomes the key window (receives focus)
        #[unsafe(method(windowDidBecomeKey:))]
        fn window_did_become_key(&self, _notification: &NSNotification) {
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.current_window_state.window_focused = true;

                    // Phase 2: OnFocus callback - sync IME position after focus
                    macos_window.sync_ime_position_to_os();
                }
            }
        }

        /// Called when the window resigns key window status (loses focus)
        #[unsafe(method(windowDidResignKey:))]
        fn window_did_resign_key(&self, _notification: &NSNotification) {
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let macos_window = &mut *(window_ptr as *mut MacOSWindow);
                    macos_window.current_window_state.window_focused = false;
                }
            }
        }

        /// Called when the window is moved
        #[unsafe(method(windowDidMove:))]
        fn window_did_move(&self, _notification: &NSNotification) {
            // Window position is tracked in the main event loop
            // No need to update state here, just for consistency
        }

        #[unsafe(method(windowDidChangeBackingProperties:))]
        fn window_did_change_backing_properties(&self, _notification: &NSNotification) {
            // DPI/scale factor changed (e.g., moved to different display)
            if let Some(window_ptr) = *self.ivars().window_ptr.borrow() {
                unsafe {
                    let window = &mut *(window_ptr as *mut MacOSWindow);
                    if let Err(e) = window.handle_dpi_change() {
                        log_error!(LogCategory::Platform, "[macOS] DPI change error: {}", e);
                    }
                }
            }
        }

        #[unsafe(method_id(init))]
        fn init(this: Allocated<Self>) -> Option<Retained<Self>> {
            let this = this.set_ivars(WindowDelegateIvars {
                window_ptr: RefCell::new(None),
            });
            unsafe { msg_send_id![super(this), init] }
        }
    }
);

// SAFETY: NSObjectProtocol has no safety requirements
unsafe impl NSObjectProtocol for WindowDelegate {}

// SAFETY: NSWindowDelegate has no safety requirements, and WindowDelegate is MainThreadOnly
unsafe impl NSWindowDelegate for WindowDelegate {}

impl WindowDelegate {
    /// Create a new WindowDelegate
    pub fn new(mtm: MainThreadMarker) -> Retained<Self> {
        let result: Option<Retained<Self>> = unsafe { msg_send_id![Self::alloc(mtm), init] };
        result.expect("Failed to initialize WindowDelegate")
    }

    /// Set the window pointer for this delegate
    ///
    /// SAFETY: Caller must ensure the pointer remains valid for the lifetime of the delegate
    pub unsafe fn set_window_ptr(&self, window_ptr: *mut std::ffi::c_void) {
        *self.ivars().window_ptr.borrow_mut() = Some(window_ptr);
    }
}

// Helper Functions

/// Create OpenGL pixel format with proper attributes
fn create_opengl_pixel_format(
    mtm: MainThreadMarker,
) -> Result<Retained<NSOpenGLPixelFormat>, WindowError> {
    // OpenGL 3.2 Core Profile attributes
    let attrs: Vec<u32> = vec![
        5, // NSOpenGLPFADoubleBuffer
        12, 24, // NSOpenGLPFADepthSize(24)
        99, 0x3200, // NSOpenGLPFAOpenGLProfile(3.2 Core)
        8, 24, // NSOpenGLPFAColorSize(24)
        11, 8,  // NSOpenGLPFAAlphaSize(8)
        73, // NSOpenGLPFAAccelerated
        0,  // Null terminator
    ];

    // Note: NSOpenGLPixelFormat::initWithAttributes expects NonNull<u32> in objc2-app-kit 0.3.2
    unsafe {
        let attrs_ptr = std::ptr::NonNull::new_unchecked(attrs.as_ptr() as *mut u32);
        NSOpenGLPixelFormat::initWithAttributes(NSOpenGLPixelFormat::alloc(), attrs_ptr)
            .ok_or_else(|| WindowError::ContextCreationFailed)
    }
}

// MacOSWindow - Main window implementation

/// macOS window implementation with dual rendering backend support
pub struct MacOSWindow {
    /// The NSWindow instance
    window: Retained<NSWindow>,
    /// Window delegate for handling window events
    window_delegate: Retained<WindowDelegate>,
    /// Selected rendering backend
    backend: RenderBackend,
    /// OpenGL rendering components (if backend == OpenGL)
    gl_view: Option<Retained<GLView>>,
    /// OpenGL context
    gl_context: Option<Retained<NSOpenGLContext>>,
    /// OpenGL function loader
    gl_functions: Option<Rc<GlFunctions>>,
    /// CPU rendering components (if backend == CPU)
    cpu_view: Option<Retained<CPUView>>,
    /// Window is open flag
    is_open: bool,
    /// Main thread marker (required for AppKit)
    mtm: MainThreadMarker,
    /// Window state from previous frame (for diff detection)
    previous_window_state: Option<FullWindowState>,
    /// Current window state
    current_window_state: FullWindowState,
    /// Last hovered node (for hover state tracking)
    last_hovered_node: Option<HitTestNode>,
    /// LayoutWindow integration (for UI callbacks and display list)
    layout_window: Option<LayoutWindow>,
    /// Menu state (for hash-based diff updates)
    menu_state: menu::MenuState,

    // Resource caches for LayoutWindow
    /// Image cache for texture management
    image_cache: ImageCache,
    /// Renderer resources (GPU textures, etc.)
    renderer_resources: RendererResources,

    // WebRender infrastructure for proper hit-testing and rendering
    /// Main render API for registering fonts, images, display lists
    pub render_api: webrender::RenderApi,
    /// WebRender renderer (software or hardware depending on backend)
    pub renderer: Option<webrender::Renderer>,
    /// Hit-tester for fast asynchronous hit-testing (updated on layout changes)
    pub hit_tester: crate::desktop::wr_translate2::AsyncHitTester,
    /// WebRender document ID
    pub document_id: DocumentId,
    /// WebRender ID namespace
    pub id_namespace: IdNamespace,
    /// OpenGL context pointer with compiled SVG and FXAA shaders
    pub gl_context_ptr: OptionGlContextPtr,

    // Application-level shared state
    /// Shared application data (used by callbacks, shared across windows)
    app_data: Arc<RefCell<RefAny>>,
    /// Shared font cache (shared across windows to cache font loading)
    fc_cache: Arc<rust_fontconfig::FcFontCache>,
    /// System style (shared across windows)
    system_style: Arc<azul_css::system::SystemStyle>,
    /// Dynamic selector context for evaluating conditional CSS properties
    /// (viewport size, OS, theme, etc.) - updated on resize and theme change
    dynamic_selector_context: azul_css::dynamic_selector::DynamicSelectorContext,
    /// Icon provider for resolving icon names to renderable content
    icon_provider: azul_core::icon::SharedIconProvider,
    /// Track if frame needs regeneration (to avoid multiple generate_frame calls)
    frame_needs_regeneration: bool,
    /// Current scrollbar drag state (if dragging a scrollbar thumb)
    scrollbar_drag_state: Option<ScrollbarDragState>,
    /// Synchronization for frame readiness (signals when WebRender has a new frame ready)
    new_frame_ready: Arc<(Mutex<bool>, Condvar)>,

    // Accessibility support
    /// Accessibility adapter for NSAccessibility integration (macOS screen readers)
    #[cfg(feature = "a11y")]
    accessibility_adapter: Option<accessibility::MacOSAccessibilityAdapter>,

    // Multi-window support
    /// Pending window creation requests (for popup menus, dialogs, etc.)
    /// Processed in Phase 3 of the event loop
    pub pending_window_creates: Vec<WindowCreateOptions>,

    // Tooltip
    /// Tooltip panel (for programmatic tooltip display)
    tooltip: Option<tooltip::TooltipWindow>,

    // Power Management
    /// IOPMAssertion ID for preventing system sleep (video playback)
    pm_assertion_id: Option<IOPMAssertionID>,

    // Timers and threads
    /// Active timers (TimerId -> NSTimer object)
    timers: std::collections::HashMap<usize, Retained<objc2_foundation::NSTimer>>,
    /// Thread timer (for polling thread messages every 16ms)
    thread_timer_running: Option<Retained<objc2_foundation::NSTimer>>,

    // VSYNC and Display Management
    /// CVDisplayLink for proper VSYNC synchronization (optional, loaded via dlopen)
    display_link: Option<corevideo::DisplayLink>,
    /// CoreVideo functions (loaded via dlopen for backward compatibility)
    cv_functions: Option<Arc<CoreVideoFunctions>>,
    /// Core Graphics functions (for display enumeration)
    cg_functions: Option<Arc<CoreGraphicsFunctions>>,
    /// Current display ID (CGDirectDisplayID) for this window
    current_display_id: Option<u32>,
}

// Implement PlatformWindowV2 trait for cross-platform event processing

impl event_v2::PlatformWindowV2 for MacOSWindow {
    // REQUIRED: Simple Getter Methods

    fn get_layout_window_mut(&mut self) -> Option<&mut LayoutWindow> {
        self.layout_window.as_mut()
    }

    fn get_layout_window(&self) -> Option<&LayoutWindow> {
        self.layout_window.as_ref()
    }

    fn get_current_window_state(&self) -> &FullWindowState {
        &self.current_window_state
    }

    fn get_current_window_state_mut(&mut self) -> &mut FullWindowState {
        &mut self.current_window_state
    }

    fn get_previous_window_state(&self) -> &Option<FullWindowState> {
        &self.previous_window_state
    }

    fn set_previous_window_state(&mut self, state: FullWindowState) {
        self.previous_window_state = Some(state);
    }

    fn get_image_cache_mut(&mut self) -> &mut ImageCache {
        &mut self.image_cache
    }

    fn get_renderer_resources_mut(&mut self) -> &mut RendererResources {
        &mut self.renderer_resources
    }

    fn get_fc_cache(&self) -> &Arc<FcFontCache> {
        &self.fc_cache
    }

    fn get_gl_context_ptr(&self) -> &OptionGlContextPtr {
        &self.gl_context_ptr
    }

    fn get_system_style(&self) -> &Arc<azul_css::system::SystemStyle> {
        &self.system_style
    }

    fn get_app_data(&self) -> &Arc<RefCell<RefAny>> {
        &self.app_data
    }

    fn get_scrollbar_drag_state(&self) -> Option<&ScrollbarDragState> {
        self.scrollbar_drag_state.as_ref()
    }

    fn get_scrollbar_drag_state_mut(&mut self) -> &mut Option<ScrollbarDragState> {
        &mut self.scrollbar_drag_state
    }

    fn set_scrollbar_drag_state(&mut self, state: Option<ScrollbarDragState>) {
        self.scrollbar_drag_state = state;
    }

    fn get_hit_tester(&self) -> &AsyncHitTester {
        &self.hit_tester
    }

    fn get_hit_tester_mut(&mut self) -> &mut AsyncHitTester {
        &mut self.hit_tester
    }

    fn get_last_hovered_node(&self) -> Option<&event_v2::HitTestNode> {
        self.last_hovered_node.as_ref()
    }

    fn set_last_hovered_node(&mut self, node: Option<event_v2::HitTestNode>) {
        self.last_hovered_node = node;
    }

    fn get_document_id(&self) -> DocumentId {
        self.document_id
    }

    fn get_id_namespace(&self) -> IdNamespace {
        self.id_namespace
    }

    fn get_render_api(&self) -> &WrRenderApi {
        &self.render_api
    }

    fn get_render_api_mut(&mut self) -> &mut WrRenderApi {
        &mut self.render_api
    }

    fn get_renderer(&self) -> Option<&webrender::Renderer> {
        self.renderer.as_ref()
    }

    fn get_renderer_mut(&mut self) -> Option<&mut webrender::Renderer> {
        self.renderer.as_mut()
    }

    fn get_raw_window_handle(&self) -> RawWindowHandle {
        RawWindowHandle::MacOS(MacOSHandle {
            ns_window: &*self.window as *const NSWindow as *mut std::ffi::c_void,
            ns_view: std::ptr::null_mut(), // Not used in current implementation
        })
    }

    fn needs_frame_regeneration(&self) -> bool {
        self.frame_needs_regeneration
    }

    fn mark_frame_needs_regeneration(&mut self) {
        self.frame_needs_regeneration = true;
    }

    fn clear_frame_regeneration_flag(&mut self) {
        self.frame_needs_regeneration = false;
    }

    fn prepare_callback_invocation(&mut self) -> event_v2::InvokeSingleCallbackBorrows {
        let layout_window = self
            .layout_window
            .as_mut()
            .expect("Layout window must exist for callback invocation");

        event_v2::InvokeSingleCallbackBorrows {
            layout_window,
            window_handle: RawWindowHandle::MacOS(MacOSHandle {
                ns_window: &*self.window as *const NSWindow as *mut std::ffi::c_void,
                ns_view: std::ptr::null_mut(),
            }),
            gl_context_ptr: &self.gl_context_ptr,
            image_cache: &mut self.image_cache,
            fc_cache_clone: (*self.fc_cache).clone(),
            system_style: self.system_style.clone(),
            previous_window_state: &self.previous_window_state,
            current_window_state: &self.current_window_state,
            renderer_resources: &mut self.renderer_resources,
        }
    }

    // Timer Management (macOS/NSTimer Implementation)

    fn start_timer(&mut self, timer_id: usize, timer: azul_layout::timer::Timer) {
        use super::common::event_v2::PlatformWindowV2;

        let interval: f64 = timer.tick_millis() as f64 / 1000.0;

        // Store the timer in layout_window first
        if let Some(layout_window) = self.layout_window.as_mut() {
            layout_window
                .timers
                .insert(azul_core::task::TimerId { id: timer_id }, timer);
        }

        // Create NSTimer that calls tickTimers: on the GLView
        // This is safe because:
        // 1. The timer is invalidated in stop_timer() before the view is released
        // 2. NSTimer retains the target, so the view won't be deallocated while timer is active
        // 3. tickTimers: checks if window_ptr is valid before dereferencing
        let timer_obj: Retained<NSTimer> = if let Some(ref gl_view) = self.gl_view {
            unsafe {
                msg_send_id![
                    NSTimer::class(),
                    scheduledTimerWithTimeInterval: interval,
                    target: &**gl_view,
                    selector: objc2::sel!(tickTimers:),
                    userInfo: std::ptr::null::<NSObject>(),
                    repeats: true
                ]
            }
        } else {
            return; // No view, can't create timer
        };

        self.timers.insert(timer_id, timer_obj);
    }

    fn stop_timer(&mut self, timer_id: usize) {
        // Invalidate NSTimer
        if let Some(timer) = self.timers.remove(&timer_id) {
            unsafe {
                timer.invalidate();
            }
        }

        // Remove from layout_window
        if let Some(layout_window) = self.layout_window.as_mut() {
            layout_window
                .timers
                .remove(&azul_core::task::TimerId { id: timer_id });
        }
    }

    // Thread Management (macOS/NSTimer Implementation)

    fn start_thread_poll_timer(&mut self) {
        use block2::RcBlock;

        if self.thread_timer_running.is_some() {
            log_debug!(LogCategory::Timer, "[start_thread_poll_timer] Timer already running, skipping");
            return; // Already running
        }

        log_debug!(LogCategory::Timer, "[start_thread_poll_timer] Starting thread poll timer (16ms interval)");

        // Create a timer that fires every 16ms (~60 FPS) to poll threads
        let ns_window = self.window.clone();
        let timer: Retained<NSTimer> = unsafe {
            let interval: f64 = 0.016; // 16ms
            msg_send_id![
                NSTimer::class(),
                scheduledTimerWithTimeInterval: interval,
                repeats: true,
                block: &*RcBlock::new(move || {
                    // Thread polling - request redraw to check threads
                    let _: () = msg_send![&*ns_window, setViewsNeedDisplay: true];
                })
            ]
        };

        self.thread_timer_running = Some(timer);
    }

    fn stop_thread_poll_timer(&mut self) {
        if let Some(timer) = self.thread_timer_running.take() {
            unsafe {
                timer.invalidate();
            }
        }
    }

    fn add_threads(
        &mut self,
        threads: std::collections::BTreeMap<azul_core::task::ThreadId, azul_layout::thread::Thread>,
    ) {
        log_debug!(LogCategory::Timer, "[add_threads] Adding {} threads", threads.len());
        if let Some(layout_window) = self.layout_window.as_mut() {
            for (thread_id, thread) in threads {
                layout_window.threads.insert(thread_id, thread);
            }
        }
    }

    fn remove_threads(
        &mut self,
        thread_ids: &std::collections::BTreeSet<azul_core::task::ThreadId>,
    ) {
        if let Some(layout_window) = self.layout_window.as_mut() {
            for thread_id in thread_ids {
                layout_window.threads.remove(thread_id);
            }
        }
    }

    // REQUIRED: Menu Display

    fn show_menu_from_callback(
        &mut self,
        menu: &azul_core::menu::Menu,
        position: azul_core::geom::LogicalPosition,
    ) {
        // Check if native menus are enabled
        if self.current_window_state.flags.use_native_context_menus {
            // Show native NSMenu
            self.show_native_menu_at_position(menu, position);
        } else {
            // Show fallback DOM-based menu
            // Make show_window_based_context_menu public or inline its logic
            self.show_fallback_menu(menu, position);
        }
    }

    fn show_tooltip_from_callback(
        &mut self,
        text: &str,
        position: azul_core::geom::LogicalPosition,
    ) {
        if let Err(e) = self.show_tooltip(text, position) {
            log_error!(
                LogCategory::Platform,
                "[macOS] Failed to show tooltip: {}",
                e
            );
        }
    }

    fn hide_tooltip_from_callback(&mut self) {
        if let Err(e) = self.hide_tooltip() {
            log_error!(
                LogCategory::Platform,
                "[macOS] Failed to hide tooltip: {}",
                e
            );
        }
    }
}

impl MacOSWindow {
    /// Determine which rendering backend to use
    fn determine_backend(options: &WindowCreateOptions) -> RenderBackend {
        // 1. Check environment variable override
        if let Ok(val) = std::env::var("AZUL_RENDERER") {
            match val.to_lowercase().as_str() {
                "cpu" => return RenderBackend::CPU,
                "opengl" | "gl" => return RenderBackend::OpenGL,
                _ => {}
            }
        }

        // 2. Check options.renderer - if it's Some, check hw_accel field
        if let Some(renderer) = options.renderer.as_option() {
            match renderer.hw_accel {
                HwAcceleration::Disabled => return RenderBackend::CPU,
                HwAcceleration::Enabled => return RenderBackend::OpenGL,
                HwAcceleration::DontCare => {} // Continue to default
            }
        }

        // 3. Default: Try OpenGL
        RenderBackend::OpenGL
    }

    /// Create OpenGL view with context and functions
    fn create_gl_view(
        frame: NSRect,
        mtm: MainThreadMarker,
    ) -> Result<(Retained<GLView>, Retained<NSOpenGLContext>, Rc<GlFunctions>), WindowError> {
        // Create pixel format
        let pixel_format = create_opengl_pixel_format(mtm)?;

        // Create GLView
        let gl_view: Option<Retained<GLView>> = unsafe {
            msg_send_id![
                GLView::alloc(mtm),
                initWithFrame: frame,
                pixelFormat: &*pixel_format,
            ]
        };

        let gl_view =
            gl_view.ok_or_else(|| WindowError::PlatformError("Failed to create GLView".into()))?;

        // Enable high-resolution backing store for Retina displays
        unsafe {
            let _: () = msg_send![&*gl_view, setWantsBestResolutionOpenGLSurface: YES];
        }

        // On macOS 10.13+, views automatically become layer-backed shortly after being added to
        // a window. Changing the layer-backedness of a view breaks the association between
        // the view and its associated OpenGL context. To work around this, we explicitly make
        // the view layer-backed up front so that AppKit doesn't do it itself and break the
        // association with its context.
        if unsafe { NSAppKitVersionNumber }.floor() > NSAppKitVersionNumber10_12 {
            let _: () = unsafe { msg_send![&*gl_view, setWantsLayer: YES] };
        }

        // Get OpenGL context
        let gl_context =
            unsafe { gl_view.openGLContext() }.ok_or_else(|| WindowError::ContextCreationFailed)?;

        // Load GL functions
        let gl_functions = GlFunctions::initialize()
            .map_err(|e| WindowError::PlatformError(format!("Failed to load GL: {}", e).into()))?;

        Ok((gl_view, gl_context, Rc::new(gl_functions)))
    }

    /// Create CPU view
    fn create_cpu_view(frame: NSRect, mtm: MainThreadMarker) -> Retained<CPUView> {
        let view: Option<Retained<CPUView>> =
            unsafe { msg_send_id![CPUView::alloc(mtm), initWithFrame: frame] };
        view.expect("Failed to create CPUView")
    }

    /// Configure VSync on an OpenGL context
    ///
    /// NOTE: NSOpenGLContext setValues:forParameter: is deprecated on macOS 10.14+
    /// CVDisplayLink is the preferred approach for frame synchronization.
    /// This function is kept as a fallback but currently disabled due to
    /// type encoding issues with objc2's msg_send! macro.
    fn configure_vsync(_gl_context: &NSOpenGLContext, vsync: azul_core::window::Vsync) {
        use azul_core::window::Vsync;

        // TODO: Re-enable once objc2-open-gl feature is properly configured
        // The issue is that msg_send! expects specific type encodings:
        // - vals: *const GLint (i32)
        // - param: NSOpenGLContextParameter (wraps NSInteger = isize)
        // Using raw msg_send! with incorrect types causes runtime panics.
        //
        // For now, we rely on CVDisplayLink for vsync (see initialize_display_link)

        let swap_interval = match vsync {
            Vsync::Enabled => 1,
            Vsync::Disabled => 0,
            Vsync::DontCare => 1,
        };

        log_debug!(
            LogCategory::Rendering,
            "[MacOSWindow::configure_vsync] VSync {} requested (swap interval: {}), using \
             CVDisplayLink instead",
            if swap_interval == 1 {
                "enabled"
            } else {
                "disabled"
            },
            swap_interval
        );
    }

    /// Detect the current monitor the window is on and update monitor_id
    ///
    /// This uses NSScreen's deviceDescription to extract CGDirectDisplayID,
    /// then computes a stable hash for the MonitorId.
    fn detect_current_monitor(&mut self) {
        use azul_core::window::MonitorId;

        // Get the screen the window is currently on
        let screen = unsafe { self.window.screen() };

        if let Some(screen) = screen {
            // Try to get CGDirectDisplayID from screen
            if let Some(display_id) = coregraphics::get_display_id_from_screen(&screen) {
                self.current_display_id = Some(display_id);

                // Get display bounds for hash computation
                let bounds = unsafe { screen.frame() };

                // Compute stable hash
                let hash = coregraphics::compute_monitor_hash(display_id, bounds);

                // For now, use display_id as index (not perfect but reasonable)
                // In a full implementation, we would enumerate all displays and assign indices
                let monitor_id = MonitorId {
                    index: display_id as usize,
                    hash,
                };

                self.current_window_state.monitor_id = OptionU32::Some(monitor_id.index as u32);

                log_debug!(
                    LogCategory::Window,
                    "[MacOSWindow] Monitor detected: display_id={}, index={}, hash={:x}",
                    display_id,
                    monitor_id.index,
                    hash
                );
            } else {
                log_warn!(
                    LogCategory::Window,
                    "[MacOSWindow] Failed to get CGDirectDisplayID from screen"
                );
                // Fallback: Use index 0 (main display)
                self.current_window_state.monitor_id = OptionU32::Some(0);
            }
        } else {
            log_warn!(
                LogCategory::Window,
                "[MacOSWindow] No screen associated with window"
            );
            // Fallback: Use index 0 (main display)
            self.current_window_state.monitor_id = OptionU32::Some(0);
        }
    }

    /// Initialize CVDisplayLink for VSYNC synchronization
    ///
    /// This is called during window creation if VSYNC is enabled.
    /// CVDisplayLink provides smooth frame pacing synchronized to the display refresh rate.
    fn initialize_display_link(&mut self) -> Result<(), String> {
        use azul_core::window::Vsync;

        // Check if VSYNC is enabled
        let vsync = self.current_window_state.renderer_options.vsync;
        if vsync == Vsync::Disabled {
            log_debug!(
                LogCategory::Rendering,
                "[CVDisplayLink] VSYNC disabled, skipping CVDisplayLink"
            );
            return Ok(());
        }

        // Check if CoreVideo functions are available
        let cv_functions = match &self.cv_functions {
            Some(funcs) => funcs.clone(),
            None => {
                log_debug!(
                    LogCategory::Rendering,
                    "[CVDisplayLink] CoreVideo not available, using fallback VSync"
                );
                // Try traditional VSync as fallback
                if let Some(ref gl_context) = self.gl_context {
                    Self::configure_vsync(gl_context, vsync);
                }
                return Ok(());
            }
        };

        // Get the display ID for this window
        let display_id = self.current_display_id.unwrap_or_else(|| {
            // Fallback to main display
            if let Some(ref cg_funcs) = self.cg_functions {
                cg_funcs.main_display_id()
            } else {
                0 // CG_MAIN_DISPLAY_ID constant
            }
        });

        log_debug!(
            LogCategory::Rendering,
            "[CVDisplayLink] Creating display link for display {}",
            display_id
        );

        // Create CVDisplayLink for this display
        let display_link = corevideo::DisplayLink::new(display_id, cv_functions.clone())
            .map_err(|code| format!("CVDisplayLinkCreateWithCGDisplays failed: {}", code))?;

        // Set output callback
        // For now, we'll use a simple callback that just marks the window for redraw
        extern "C" fn display_link_callback(
            _display_link: corevideo::CVDisplayLinkRef,
            _in_now: *const corevideo::CVTimeStamp,
            _in_output_time: *const corevideo::CVTimeStamp,
            _flags_in: u64,
            _flags_out: *mut u64,
            display_link_context: *mut std::ffi::c_void,
        ) -> corevideo::CVReturn {
            // SAFETY: display_link_context is a pointer to NSWindow
            unsafe {
                if !display_link_context.is_null() {
                    let ns_window = display_link_context as *const NSWindow;
                    // Request display (setNeedsDisplay equivalent)
                    // This will trigger drawRect on the next runloop iteration
                    use objc2::msg_send;
                    let _: () = msg_send![ns_window, setViewsNeedDisplay: true];
                }
            }
            corevideo::K_CV_RETURN_SUCCESS
        }

        // Pass NSWindow pointer as context
        let window_ptr = &*self.window as *const NSWindow as *mut std::ffi::c_void;
        let result = display_link.set_output_callback(display_link_callback, window_ptr);

        if result != corevideo::K_CV_RETURN_SUCCESS {
            return Err(format!("CVDisplayLinkSetOutputCallback failed: {}", result));
        }

        // Start the display link
        let result = display_link.start();
        if result != corevideo::K_CV_RETURN_SUCCESS {
            return Err(format!("CVDisplayLinkStart failed: {}", result));
        }

        log_info!(
            LogCategory::Rendering,
            "[CVDisplayLink] Display link started successfully"
        );
        self.display_link = Some(display_link);

        Ok(())
    }

    /// Create a new macOS window with given options and shared font cache.
    pub fn new_with_fc_cache(
        options: WindowCreateOptions,
        app_data: RefAny,
        config: azul_core::resources::AppConfig,
        shared_icon_provider: azul_core::icon::SharedIconProvider,
        fc_cache: Arc<rust_fontconfig::FcFontCache>,
        mtm: MainThreadMarker,
    ) -> Result<Self, WindowError> {
        Self::new_with_options_internal(options, app_data, config, shared_icon_provider, Some(fc_cache), mtm)
    }

    /// Create a new macOS window with given options.
    pub fn new_with_options(
        options: WindowCreateOptions,
        app_data: RefAny,
        config: azul_core::resources::AppConfig,
        shared_icon_provider: azul_core::icon::SharedIconProvider,
        mtm: MainThreadMarker,
    ) -> Result<Self, WindowError> {
        Self::new_with_options_internal(options, app_data, config, shared_icon_provider, None, mtm)
    }

    /// Internal constructor with optional fc_cache parameter
    fn new_with_options_internal(
        options: WindowCreateOptions,
        app_data: RefAny,
        config: azul_core::resources::AppConfig,
        shared_icon_provider: azul_core::icon::SharedIconProvider,
        fc_cache_opt: Option<Arc<rust_fontconfig::FcFontCache>>,
        mtm: MainThreadMarker,
    ) -> Result<Self, WindowError> {
        log_debug!(
            LogCategory::Window,
            "[MacOSWindow::new] Starting window creation"
        );

        // Initialize NSApplication if needed
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Getting NSApplication..."
        );
        let app = NSApplication::sharedApplication(mtm);
        app.setActivationPolicy(NSApplicationActivationPolicy::Regular);
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] NSApplication configured"
        );

        // Get screen dimensions for window positioning
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Getting main screen..."
        );
        let screen = NSScreen::mainScreen(mtm)
            .ok_or_else(|| WindowError::PlatformError("No main screen".into()))?;

        let screen_frame = screen.frame();
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Screen frame: {}x{}",
            screen_frame.size.width,
            screen_frame.size.height
        );

        // Determine window size from options
        let window_size = options.window_state.size.dimensions;
        let width = window_size.width as f64;
        let height = window_size.height as f64;

        // Center window on screen
        let x = (screen_frame.size.width - width) / 2.0;
        let y = (screen_frame.size.height - height) / 2.0;

        let content_rect = NSRect::new(NSPoint::new(x, y), NSSize::new(width, height));

        // Determine rendering backend
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Determining rendering backend..."
        );
        let requested_backend = Self::determine_backend(&options);
        log_debug!(
            LogCategory::Window,
            "[MacOSWindow::new] Backend: {:?}",
            requested_backend
        );

        // Create content view based on backend
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Creating content view..."
        );
        let (backend, gl_view, gl_context, gl_functions, cpu_view) = match requested_backend {
            RenderBackend::OpenGL => match Self::create_gl_view(content_rect, mtm) {
                Ok((view, ctx, funcs)) => {
                    log_debug!(
                        LogCategory::Rendering,
                        "[MacOSWindow::new] OpenGL view created successfully"
                    );
                    log_trace!(
                        LogCategory::Rendering,
                        "[MacOSWindow::new] Configuring VSync..."
                    );
                    let vsync = options.window_state.renderer_options.vsync;
                    Self::configure_vsync(&ctx, vsync);
                    log_trace!(
                        LogCategory::Rendering,
                        "[MacOSWindow::new] VSync configured, returning from match..."
                    );
                    (
                        RenderBackend::OpenGL,
                        Some(view),
                        Some(ctx),
                        Some(funcs),
                        None,
                    )
                }
                Err(e) => {
                    log_warn!(
                        LogCategory::Rendering,
                        "OpenGL initialization failed: {}, falling back to CPU",
                        e
                    );
                    let view = Self::create_cpu_view(content_rect, mtm);
                    (RenderBackend::CPU, None, None, None, Some(view))
                }
            },
            RenderBackend::CPU => {
                let view = Self::create_cpu_view(content_rect, mtm);
                (RenderBackend::CPU, None, None, None, Some(view))
            }
        };
        log_debug!(
            LogCategory::Window,
            "[MacOSWindow::new] Content view created, backend: {:?}",
            backend
        );

        // Create window style mask
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Creating window with style mask..."
        );
        let style_mask = NSWindowStyleMask::Titled
            | NSWindowStyleMask::Closable
            | NSWindowStyleMask::Miniaturizable
            | NSWindowStyleMask::Resizable;

        // Create the window
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Allocating NSWindow..."
        );
        let window = unsafe {
            NSWindow::initWithContentRect_styleMask_backing_defer(
                mtm.alloc(),
                content_rect,
                style_mask,
                NSBackingStoreType::Buffered,
                false,
            )
        };
        log_trace!(LogCategory::Window, "[MacOSWindow::new] NSWindow created");

        // Set window title
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Setting window title..."
        );
        let title = NSString::from_str(&options.window_state.title);
        window.setTitle(&title);
        log_trace!(LogCategory::Window, "[MacOSWindow::new] Window title set");

        // Set content view (either GL or CPU)
        // SAFE: Both GLView and CPUView inherit from NSView, so we can upcast safely
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Setting content view..."
        );
        if let Some(ref gl) = gl_view {
            log_trace!(
                LogCategory::Rendering,
                "[MacOSWindow::new] Setting GL view as content view..."
            );
            unsafe {
                // GLView is a subclass of NSView, so we can use it as NSView
                let view_ptr = Retained::as_ptr(gl) as *const NSView;
                let view_ref = &*view_ptr;
                window.setContentView(Some(view_ref));
            }
            log_trace!(LogCategory::Rendering, "[MacOSWindow::new] GL view set");
        } else if let Some(ref cpu) = cpu_view {
            log_trace!(
                LogCategory::Rendering,
                "[MacOSWindow::new] Setting CPU view as content view..."
            );
            unsafe {
                // CPUView is a subclass of NSView, so we can use it as NSView
                let view_ptr = Retained::as_ptr(cpu) as *const NSView;
                let view_ref = &*view_ptr;
                window.setContentView(Some(view_ref));
            }
        } else {
            return Err(WindowError::PlatformError("No content view created".into()));
        }
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Content view configured"
        );

        // DO NOT show the window yet - we will show it after the first frame
        // is ready to prevent white flash
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Positioning window..."
        );
        unsafe {
            // Simplified positioning: just center the window
            // Complex monitor enumeration can hang before event loop starts
            window.center();

            // TODO: Implement proper multi-monitor positioning after event loop starts
            // For now, user can move window manually or we can position it later

            // REMOVED: makeKeyAndOrderFront - will be called after first frame is ready
        }
        log_trace!(LogCategory::Window, "[MacOSWindow::new] Window centered");

        // Apply initial window state based on options.window_state.flags.frame
        // Note: These will be applied before window is visible
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::new] Applying window frame state..."
        );
        unsafe {
            match options.window_state.flags.frame {
                WindowFrame::Fullscreen => {
                    window.toggleFullScreen(None);
                }
                WindowFrame::Maximized => {
                    window.performZoom(None);
                }
                WindowFrame::Minimized => {
                    window.miniaturize(None);
                }
                WindowFrame::Normal => {
                    // Window is already in normal state
                }
            }
        }

        // Create and set window delegate for handling window events
        let window_delegate = WindowDelegate::new(mtm);
        unsafe {
            let delegate_obj = ProtocolObject::from_ref(&*window_delegate);
            window.setDelegate(Some(delegate_obj));
            
            // Enable mouse moved events - required for cursor updates on hover
            // Without this, macOS only sends mouse events when a button is pressed
            window.setAcceptsMouseMovedEvents(true);
        }

        // Query actual HiDPI factor from NSWindow's screen
        let actual_hidpi_factor = unsafe {
            window
                .screen()
                .map(|screen| screen.backingScaleFactor() as f32)
                .unwrap_or(1.0)
        };

        // Make OpenGL context current before initializing WebRender
        if let Some(ref ctx) = gl_context {
            unsafe {
                ctx.makeCurrentContext();
            }
        }

        // Initialize WebRender renderer
        let renderer_type = match backend {
            RenderBackend::OpenGL => RendererType::Hardware,
            RenderBackend::CPU => RendererType::Software,
        };

        log_debug!(
            LogCategory::Rendering,
            "[Window Init] Renderer type: {:?}",
            renderer_type
        );

        let gl_funcs = if let Some(ref f) = gl_functions {
            log_trace!(
                LogCategory::Rendering,
                "[Window Init] Using GL functions from context"
            );
            f.functions.clone()
        } else {
            log_trace!(
                LogCategory::Rendering,
                "[Window Init] Loading GL functions for CPU fallback"
            );
            // Fallback for CPU backend - initialize GL functions or fail gracefully
            match gl::GlFunctions::initialize() {
                Ok(f) => f.functions.clone(),
                Err(e) => {
                    return Err(WindowError::PlatformError(format!(
                        "Failed to initialize GL functions: {}",
                        e
                    )));
                }
            }
        };

        log_debug!(
            LogCategory::Rendering,
            "[Window Init] Creating WebRender instance"
        );

        // Create synchronization primitives for frame readiness
        let new_frame_ready = Arc::new((Mutex::new(false), Condvar::new()));

        let notifier = Notifier {
            new_frame_ready: new_frame_ready.clone(),
        };

        let (mut renderer, sender) = webrender::create_webrender_instance(
            gl_funcs.clone(),
            Box::new(notifier),
            default_renderer_options(&options),
            None, // shaders cache
        )
        .map_err(|e| {
            WindowError::PlatformError(format!("WebRender initialization failed: {:?}", e))
        })?;

        renderer.set_external_image_handler(Box::new(WrCompositor::default()));

        let mut render_api = sender.create_api();

        // Get physical size for framebuffer (using actual HiDPI factor from screen)
        let physical_size = azul_core::geom::PhysicalSize {
            width: (options.window_state.size.dimensions.width * actual_hidpi_factor) as u32,
            height: (options.window_state.size.dimensions.height * actual_hidpi_factor) as u32,
        };

        let framebuffer_size = webrender::api::units::DeviceIntSize::new(
            physical_size.width as i32,
            physical_size.height as i32,
        );

        // Create WebRender document (one per window)
        let document_id = translate_document_id_wr(render_api.add_document(framebuffer_size));
        let id_namespace = translate_id_namespace_wr(render_api.get_namespace_id());

        // Request hit tester for this document
        let hit_tester = render_api
            .request_hit_tester(wr_translate_document_id(document_id))
            .resolve();

        // Create GlContextPtr for LayoutWindow
        let gl_context_ptr: OptionGlContextPtr = gl_context
            .as_ref()
            .map(|_| GlContextPtr::new(renderer_type, gl_funcs.clone()))
            .into();

        // Initialize window state with actual HiDPI factor from screen
        let actual_dpi = (actual_hidpi_factor * 96.0) as u32; // Convert scale factor to DPI
        let mut current_window_state = FullWindowState {
            window_id: options.window_state.window_id.clone(),
            title: options.window_state.title.clone(),
            size: WindowSize {
                dimensions: options.window_state.size.dimensions,
                dpi: actual_dpi, // Use actual DPI from screen
                min_dimensions: options.window_state.size.min_dimensions,
                max_dimensions: options.window_state.size.max_dimensions,
            },
            position: options.window_state.position,
            flags: options.window_state.flags,
            theme: options.window_state.theme,
            debug_state: options.window_state.debug_state,
            keyboard_state: Default::default(),
            mouse_state: Default::default(),
            touch_state: Default::default(),
            ime_position: options.window_state.ime_position,
            platform_specific_options: options.window_state.platform_specific_options.clone(),
            renderer_options: options.window_state.renderer_options,
            background_color: options.window_state.background_color,
            layout_callback: options.window_state.layout_callback,
            close_callback: options.window_state.close_callback.clone(),
            monitor_id: OptionU32::None, // Monitor ID will be set when we detect the actual monitor
            window_focused: true,
        };

        // Initialize resource caches
        let image_cache = ImageCache::default();
        let renderer_resources = RendererResources::default();

        // Initialize LayoutWindow with shared fc_cache or build a new one
        let fc_cache =
            fc_cache_opt.unwrap_or_else(|| Arc::new(rust_fontconfig::FcFontCache::build()));
        let mut layout_window = LayoutWindow::new((*fc_cache).clone()).map_err(|e| {
            WindowError::PlatformError(format!("Failed to create LayoutWindow: {:?}", e))
        })?;

        // Set document_id and id_namespace for this window
        layout_window.document_id = document_id;
        layout_window.id_namespace = id_namespace;
        layout_window.current_window_state = current_window_state.clone();
        layout_window.renderer_type = Some(renderer_type);

        log_debug!(
            LogCategory::Layout,
            "[Window Init] LayoutWindow configured with document_id: {:?}",
            document_id
        );

        // NOTE: Keep OpenGL context current - WebRender needs it for rendering
        // Do NOT call clearCurrentContext() here

        // Initialize shared application data from the provided app_data
        let app_data_arc = Arc::new(RefCell::new(app_data));

        // NOTE: We will set the window state pointer AFTER creating the MacOSWindow struct
        // because current_window_state will be moved into the struct, invalidating any pointer
        // we create now.

        log_info!(
            LogCategory::Window,
            "[Window Init] Window created successfully"
        );
        log_debug!(LogCategory::Window, "[Window Init] Backend: {:?}", backend);
        log_debug!(
            LogCategory::Rendering,
            "[Window Init] Renderer initialized: true"
        );
        log_debug!(
            LogCategory::Rendering,
            "[Window Init] GL Context: {}",
            if gl_context.is_some() { "Some" } else { "None" }
        );

        // Load CoreVideo and Core Graphics functions for VSYNC and monitor detection
        let cv_functions = match CoreVideoFunctions::load() {
            Ok(funcs) => {
                log_debug!(
                    LogCategory::Platform,
                    "[Window Init] CoreVideo loaded successfully"
                );
                Some(funcs)
            }
            Err(e) => {
                log_debug!(
                    LogCategory::Platform,
                    "[Window Init] CoreVideo not available: {} - VSYNC will use fallback",
                    e
                );
                None
            }
        };

        let cg_functions = match CoreGraphicsFunctions::load() {
            Ok(funcs) => {
                log_debug!(
                    LogCategory::Platform,
                    "[Window Init] Core Graphics loaded successfully"
                );
                Some(funcs)
            }
            Err(e) => {
                log_debug!(
                    LogCategory::Platform,
                    "[Window Init] Core Graphics not available: {} - monitor detection will use \
                     fallback",
                    e
                );
                None
            }
        };

        // Create dynamic selector context before moving current_window_state
        let initial_viewport_width = current_window_state.size.dimensions.width;
        let initial_viewport_height = current_window_state.size.dimensions.height;
        let dynamic_selector_context = {
            let sys = azul_css::system::SystemStyle::new();
            let mut ctx =
                azul_css::dynamic_selector::DynamicSelectorContext::from_system_style(&sys);
            ctx.viewport_width = initial_viewport_width;
            ctx.viewport_height = initial_viewport_height;
            ctx.orientation = if initial_viewport_width > initial_viewport_height {
                azul_css::dynamic_selector::OrientationType::Landscape
            } else {
                azul_css::dynamic_selector::OrientationType::Portrait
            };
            ctx
        };

        let mut window = Self {
            window,
            window_delegate,
            backend,
            gl_view,
            gl_context,
            gl_functions,
            cpu_view,
            is_open: true,
            mtm,
            previous_window_state: None,
            current_window_state,
            last_hovered_node: None,
            layout_window: Some(layout_window),
            menu_state: menu::MenuState::new(), // TODO: build initial menu state from layout_window
            image_cache,
            renderer_resources,
            render_api,
            renderer: Some(renderer),
            hit_tester: AsyncHitTester::Resolved(hit_tester),
            document_id,
            id_namespace,
            gl_context_ptr,
            app_data: app_data_arc,
            fc_cache,
            system_style: Arc::new(azul_css::system::SystemStyle::new()),
            dynamic_selector_context,
            icon_provider: shared_icon_provider,
            frame_needs_regeneration: false,
            scrollbar_drag_state: None,
            new_frame_ready,
            #[cfg(feature = "a11y")]
            accessibility_adapter: None, // Will be initialized after first layout
            pending_window_creates: Vec::new(),
            tooltip: None,         // Created lazily when first needed
            pm_assertion_id: None, // No sleep prevention by default
            timers: std::collections::HashMap::new(),
            thread_timer_running: None,
            display_link: None, // Will be initialized when VSYNC is enabled
            cv_functions,
            cg_functions,
            current_display_id: None, // Will be set after monitor detection
        };

        // NOTE: Do NOT set the delegate pointer here!
        // The window will be moved out of this function (returned by value),
        // so any pointer we set here will become invalid.
        // Instead, call finalize_delegate_pointer() AFTER the window is in its final location.

        // Set up WebRender document with root pipeline and viewport
        // This only needs to be done once at initialization

        // NOTE: Don't send any transaction during initialization!
        // The first transaction will be sent in drawRect
        // when drawRect is called by macOS.

        // Invoke create_callback if provided (for GL resource upload, config loading, etc.)
        // This runs AFTER GL context is ready but BEFORE any layout is done
        if let Some(mut callback) = options.create_callback.into_option() {
            log_debug!(
                LogCategory::Callbacks,
                "[Window Init] Invoking create_callback..."
            );

            use azul_core::window::RawWindowHandle;
            use std::ptr;

            let raw_handle = RawWindowHandle::MacOS(azul_core::window::MacOSHandle {
                ns_window: Retained::as_ptr(&window.window) as *mut _,
                ns_view: ptr::null_mut(),
            });

            // Get mutable references needed for invoke_single_callback
            let layout_window = window
                .layout_window
                .as_mut()
                .expect("LayoutWindow should exist at this point");
            let mut fc_cache_clone = (*window.fc_cache).clone();

            // Get app_data for callback
            let mut app_data_ref = window.app_data.borrow_mut();

            let callback_result = layout_window.invoke_single_callback(
                &mut callback,
                &mut *app_data_ref,
                &raw_handle,
                &window.gl_context_ptr,
                &mut window.image_cache,
                &mut fc_cache_clone,
                window.system_style.clone(),
                &azul_layout::callbacks::ExternalSystemCallbacks::rust_internal(),
                &window.previous_window_state,
                &window.current_window_state,
                &window.renderer_resources,
            );

            // Process callback result (timers, threads, etc.)
            drop(app_data_ref); // Release borrow before process_callback_result_v2
            use crate::desktop::shell2::common::event_v2::PlatformWindowV2;
            window.previous_window_state = Some(window.current_window_state.clone());
            let _ = window.process_callback_result_v2(&callback_result);
            // Sync window state to OS (handles close_requested, title, size, etc.)
            window.sync_window_state();

            log_debug!(
                LogCategory::Callbacks,
                "[Window Init] create_callback completed"
            );
        }

        // Register debug timer if AZUL_DEBUG is enabled
        #[cfg(feature = "std")]
        if crate::desktop::shell2::common::debug_server::is_debug_enabled() {
            log_debug!(
                LogCategory::DebugServer,
                "[Window Init] Registering debug timer (AZUL_DEBUG is set)"
            );

            use super::common::event_v2::PlatformWindowV2;
            use azul_layout::callbacks::ExternalSystemCallbacks;

            let timer_id: usize = 0xDEBE; // Special debug timer ID
            // Clone app_data so GetAppState/SetAppState can access it in the timer callback
            let app_data_for_timer = window.app_data.borrow().clone();
            let debug_timer = crate::desktop::shell2::common::debug_server::create_debug_timer(
                app_data_for_timer,
                ExternalSystemCallbacks::rust_internal().get_system_time_fn,
            );
            // Use start_timer to register both in layout_window AND create native NSTimer
            window.start_timer(timer_id, debug_timer);
            log_debug!(
                LogCategory::DebugServer,
                "[Window Init] Debug timer registered with ID 0x{:X}",
                timer_id
            );
        }

        // Perform initial layout
        log_debug!(
            LogCategory::Layout,
            "[Window Init] Performing initial layout"
        );
        if let Err(e) = window.regenerate_layout() {
            log_warn!(
                LogCategory::Layout,
                "[Window Init] WARNING: Initial layout failed: {}",
                e
            );
        }

        // Initialize accessibility adapter after first layout
        #[cfg(feature = "a11y")]
        {
            log_debug!(
                LogCategory::Platform,
                "[Window Init] Initializing accessibility support"
            );
            window.init_accessibility();
        }

        // Set frame_needs_regeneration to true so drawRect will build and send transaction
        window.frame_needs_regeneration = true;

        // Detect current monitor and set monitor_id
        window.detect_current_monitor();

        // Initialize CVDisplayLink for VSYNC (if enabled and available)
        if let Err(e) = window.initialize_display_link() {
            log_warn!(
                LogCategory::Rendering,
                "[Window Init] CVDisplayLink initialization failed: {}",
                e
            );
            // Not a fatal error - window will still work, just without VSYNC
        }

        // Show window immediately - drawRect will handle the first frame rendering
        log_debug!(
            LogCategory::Window,
            "[Window Init] Making window visible (first frame will be rendered in drawRect)..."
        );
        unsafe {
            window.window.makeKeyAndOrderFront(None);
        }

        log_info!(
            LogCategory::Window,
            "[Window Init] Window initialization complete"
        );
        Ok(window)
    }

    /// Synchronize window state with the OS based on diff between previous and current state
    /// Regenerate layout and display list for the current window.
    ///
    /// This should be called when:
    /// - The window is resized
    /// - The DOM changes (via callbacks)
    /// - Layout callback changes
    pub fn regenerate_layout(&mut self) -> Result<(), String> {
        let layout_window = self.layout_window.as_mut().ok_or("No layout window")?;

        // Collect debug messages if debug server is enabled
        let debug_enabled = crate::desktop::shell2::common::debug_server::is_debug_enabled();
        let mut debug_messages = if debug_enabled {
            Some(Vec::new())
        } else {
            None
        };

        // Call unified regenerate_layout from common module
        crate::desktop::shell2::common::layout_v2::regenerate_layout(
            layout_window,
            &self.app_data,
            &self.current_window_state,
            &mut self.renderer_resources,
            &mut self.render_api,
            &self.image_cache,
            &self.gl_context_ptr,
            &self.fc_cache,
            &self.system_style,
            &self.icon_provider,
            self.document_id,
            &mut debug_messages,
        )?;

        // Forward layout debug messages to the debug server's log queue
        if let Some(msgs) = debug_messages {
            for msg in msgs {
                crate::desktop::shell2::common::debug_server::log(
                    crate::desktop::shell2::common::debug_server::LogLevel::Debug,
                    crate::desktop::shell2::common::debug_server::LogCategory::Layout,
                    msg.message.as_str().to_string(),
                    None,
                );
            }
        }

        // Mark that frame needs regeneration (will be called once at event processing end)
        self.frame_needs_regeneration = true;

        // Update accessibility tree after layout
        #[cfg(feature = "a11y")]
        self.update_accessibility();

        // Phase 2: Post-Layout callback - sync IME position after layout (MOST IMPORTANT)
        self.update_ime_position_from_cursor();
        self.sync_ime_position_to_os();

        Ok(())
    }

    /// Update ime_position in window state from focused text cursor
    /// Called after layout to ensure IME window appears at correct position
    fn update_ime_position_from_cursor(&mut self) {
        use azul_core::window::ImePosition;

        if let Some(layout_window) = &self.layout_window {
            if let Some(cursor_rect) = layout_window.get_focused_cursor_rect_viewport() {
                // Successfully calculated cursor position from text layout
                self.current_window_state.ime_position = ImePosition::Initialized(cursor_rect);
            }
        }
    }

    /// Generate frame if needed and reset flag
    pub fn generate_frame_if_needed(&mut self) {
        if !self.frame_needs_regeneration {
            return;
        }

        if let Some(ref mut layout_window) = self.layout_window {
            crate::desktop::shell2::common::layout_v2::generate_frame(
                layout_window,
                &mut self.render_api,
                self.document_id,
            );

            // After sending display list, request new hit tester
            // (will be resolved on next hit test)
            let doc_id = crate::desktop::wr_translate2::wr_translate_document_id(self.document_id);
            let hit_tester_request = self.render_api.request_hit_tester(doc_id);
            self.hit_tester =
                crate::desktop::wr_translate2::AsyncHitTester::Requested(hit_tester_request);
        }

        self.frame_needs_regeneration = false;
    }

    /// Get the current HiDPI scale factor from the NSWindow's screen
    ///
    /// This queries the actual backing scale factor from the screen,
    /// which can change when the window moves between displays.
    pub fn get_hidpi_factor(&self) -> DpiScaleFactor {
        use azul_css::props::basic::FloatValue;
        DpiScaleFactor {
            inner: FloatValue::new(unsafe {
                self.window
                    .screen()
                    .map(|screen| screen.backingScaleFactor() as f32)
                    .unwrap_or(1.0)
            }),
        }
    }

    /// Get the raw window handle for this window
    pub fn get_raw_window_handle(&self) -> RawWindowHandle {
        let ns_window_ptr = &*self.window as *const NSWindow as *mut std::ffi::c_void;
        let ns_view_ptr = if let Some(ref gl_view) = self.gl_view {
            &**gl_view as *const GLView as *mut std::ffi::c_void
        } else if let Some(ref cpu_view) = self.cpu_view {
            &**cpu_view as *const CPUView as *mut std::ffi::c_void
        } else {
            std::ptr::null_mut()
        };

        RawWindowHandle::MacOS(MacOSHandle {
            ns_window: ns_window_ptr,
            ns_view: ns_view_ptr,
        })
    }

    /// Handle DPI change notification
    ///
    /// This is called when NSWindowDidChangeBackingPropertiesNotification is received,
    /// indicating the window moved to a display with different DPI or monitor.
    pub fn handle_dpi_change(&mut self) -> Result<(), String> {
        let new_hidpi = self.get_hidpi_factor();
        let old_hidpi = self.current_window_state.size.get_hidpi_factor();

        // Check if monitor changed (detect current monitor)
        let old_display_id = self.current_display_id;
        self.detect_current_monitor();
        let new_display_id = self.current_display_id;

        // If display changed, we may need to recreate CVDisplayLink
        if old_display_id != new_display_id {
            log_debug!(
                LogCategory::Window,
                "[DPI Change] Display changed: {:?} -> {:?}",
                old_display_id,
                new_display_id
            );

            // Stop old display link
            if let Some(old_link) = self.display_link.take() {
                if old_link.is_running() {
                    old_link.stop();
                }
                // DisplayLink will be dropped here
            }

            // Recreate display link for new display
            if let Err(e) = self.initialize_display_link() {
                log_warn!(
                    LogCategory::Rendering,
                    "[DPI Change] Failed to recreate CVDisplayLink: {}",
                    e
                );
                // Not fatal - continue without display link
            }
        }

        // Only process if DPI actually changed
        if (new_hidpi.inner.get() - old_hidpi.inner.get()).abs() < 0.001 {
            return Ok(());
        }

        log_debug!(
            LogCategory::Window,
            "[DPI Change] {} -> {}",
            old_hidpi.inner.get(),
            new_hidpi.inner.get()
        );

        // Update window state with new DPI
        self.current_window_state.size.dpi = (new_hidpi.inner.get() * 96.0) as u32;

        // Regenerate layout with new DPI
        self.regenerate_layout()?;

        Ok(())
    }

    /// Perform GPU scrolling - updates scroll transforms without full relayout
    pub fn gpu_scroll(
        &mut self,
        dom_id: DomId,
        node_id: NodeId,
        delta_x: f32,
        delta_y: f32,
    ) -> Result<(), String> {
        use std::time::Duration;

        use azul_core::{
            events::{EasingFunction, EventSource},
            geom::LogicalPosition,
        };
        use azul_layout::managers::scroll_state::ScrollEvent;

        let layout_window = self.layout_window.as_mut().ok_or("No layout window")?;

        // 1. Create scroll event and process it
        let scroll_event = ScrollEvent {
            dom_id,
            node_id,
            delta: LogicalPosition::new(delta_x, delta_y),
            source: EventSource::User,
            duration: None, // Instant scroll
            easing: EasingFunction::Linear,
        };

        let external = azul_layout::callbacks::ExternalSystemCallbacks::rust_internal();

        // Apply scroll using scroll_by instead of apply_scroll_event
        layout_window.scroll_manager.scroll_by(
            scroll_event.dom_id,
            scroll_event.node_id,
            scroll_event.delta,
            scroll_event
                .duration
                .unwrap_or(azul_core::task::Duration::System(
                    azul_core::task::SystemTimeDiff { secs: 0, nanos: 0 },
                )),
            scroll_event.easing,
            (external.get_system_time_fn.cb)(),
        );

        // 2. Recalculate scrollbar states after scroll update
        // This updates scrollbar thumb positions based on new scroll offsets
        layout_window.scroll_manager.calculate_scrollbar_states();

        // 3. Update WebRender scroll layers and GPU transforms
        let mut txn = crate::desktop::wr_translate2::WrTransaction::new();

        // Scroll all nodes in the scroll manager to WebRender
        // This updates external scroll IDs with new offsets
        crate::desktop::wr_translate2::scroll_all_nodes(layout_window, &mut txn);

        // Synchronize GPU-animated values (transforms, opacities, scrollbar positions)
        // Note: We need mutable access for gpu_state_manager updates
        crate::desktop::wr_translate2::synchronize_gpu_values(layout_window, &mut txn);

        // Generate frame (without rebuilding display list)
        crate::desktop::wr_translate2::generate_frame(
            &mut txn,
            layout_window,
            &mut self.render_api,
            false, // Display list not rebuilt, just transforms updated
        );

        // Send transaction
        self.render_api.send_transaction(
            crate::desktop::wr_translate2::wr_translate_document_id(self.document_id),
            txn,
        );

        Ok(())
    }

    fn sync_window_state(&mut self) {
        // Get copies of previous and current state to avoid borrow checker issues
        let (previous, current) = match &self.previous_window_state {
            Some(prev) => (prev.clone(), self.current_window_state.clone()),
            None => return, // First frame, nothing to sync
        };

        // Close requested?
        if !previous.flags.close_requested && current.flags.close_requested {
            self.close_window();
            return; // Don't sync other state if closing
        }

        // Title changed?
        if previous.title != current.title {
            let title = NSString::from_str(&current.title);
            self.window.setTitle(&title);
        }

        // Size changed?
        if previous.size.dimensions != current.size.dimensions {
            let size = NSSize::new(
                current.size.dimensions.width as f64,
                current.size.dimensions.height as f64,
            );
            unsafe {
                self.window.setContentSize(size);
            }
        }

        // Position changed?
        if previous.position != current.position {
            match current.position {
                WindowPosition::Initialized(pos) => {
                    let origin = NSPoint::new(pos.x as f64, pos.y as f64);
                    unsafe {
                        self.window.setFrameTopLeftPoint(origin);
                    }
                }
                WindowPosition::Uninitialized => {}
            }
        }

        // Window flags changed?
        if previous.flags != current.flags {
            // Check decorations
            if previous.flags.decorations != current.flags.decorations {
                self.apply_decorations(current.flags.decorations);
            }

            // Check resizable
            if previous.flags.is_resizable != current.flags.is_resizable {
                self.apply_resizable(current.flags.is_resizable);
            }

            // Check background material
            if previous.flags.background_material != current.flags.background_material {
                self.apply_background_material(current.flags.background_material);
            }
        }

        // Visibility changed?
        if previous.flags.is_visible != current.flags.is_visible {
            if current.flags.is_visible {
                self.window.makeKeyAndOrderFront(None);
            } else {
                self.window.orderOut(None);
            }
        }

        // is_top_level flag changed?
        if previous.flags.is_top_level != current.flags.is_top_level {
            if let Err(e) = self.set_is_top_level(current.flags.is_top_level) {
                log_error!(
                    LogCategory::Platform,
                    "[macOS] Failed to set is_top_level: {}",
                    e
                );
            }
        }

        // prevent_system_sleep flag changed?
        if previous.flags.prevent_system_sleep != current.flags.prevent_system_sleep {
            if let Err(e) = self.set_prevent_system_sleep(current.flags.prevent_system_sleep) {
                log_error!(
                    LogCategory::Platform,
                    "[macOS] Failed to set prevent_system_sleep: {}",
                    e
                );
            }
        }

        // Mouse cursor synchronization - compute from current hit test
        use azul_layout::managers::hover::InputPointId;
        if let Some(layout_window) = self.layout_window.as_ref() {
            if let Some(hit_test) = layout_window
                .hover_manager
                .get_current(&InputPointId::Mouse)
            {
                let cursor_test = layout_window.compute_cursor_type_hit_test(hit_test);
                let cursor_name = self.map_cursor_type_to_macos(cursor_test.cursor_icon);
                self.set_cursor(cursor_name);
            }
        }
    }

    /// Map MouseCursorType to macOS cursor name
    fn map_cursor_type_to_macos(&self, cursor_type: MouseCursorType) -> &'static str {
        match cursor_type {
            MouseCursorType::Default | MouseCursorType::Arrow => "arrow",
            MouseCursorType::Crosshair => "crosshair",
            MouseCursorType::Hand => "pointing_hand",
            MouseCursorType::Move => "open_hand",
            MouseCursorType::Text => "ibeam",
            MouseCursorType::Wait | MouseCursorType::Progress => "arrow",
            MouseCursorType::Help => "arrow",
            MouseCursorType::NotAllowed | MouseCursorType::NoDrop => "operation_not_allowed",
            MouseCursorType::ContextMenu => "arrow",
            MouseCursorType::Cell => "crosshair",
            MouseCursorType::VerticalText => "ibeam",
            MouseCursorType::Alias => "drag_link",
            MouseCursorType::Copy => "drag_copy",
            MouseCursorType::Grab => "open_hand",
            MouseCursorType::Grabbing => "closed_hand",
            MouseCursorType::AllScroll => "open_hand",
            MouseCursorType::ZoomIn | MouseCursorType::ZoomOut => "arrow",
            MouseCursorType::EResize
            | MouseCursorType::WResize
            | MouseCursorType::EwResize
            | MouseCursorType::ColResize => "resize_left_right",
            MouseCursorType::NResize
            | MouseCursorType::SResize
            | MouseCursorType::NsResize
            | MouseCursorType::RowResize => "resize_up_down",
            MouseCursorType::NeResize
            | MouseCursorType::NwResize
            | MouseCursorType::SeResize
            | MouseCursorType::SwResize
            | MouseCursorType::NeswResize
            | MouseCursorType::NwseResize => "arrow",
        }
    }

    /// Update window state at the end of each frame (before rendering)
    ///
    /// This should be called after all callbacks have been processed but before
    /// `present()` is called. It prepares for the next frame by moving current
    /// state to previous state.
    pub fn update_window_state(&mut self, new_state: FullWindowState) {
        // Save current state as previous for next frame's diff
        self.previous_window_state = Some(self.current_window_state.clone());

        // Update current state with the new full state
        self.current_window_state = new_state;

        // Synchronize with OS
        self.sync_window_state();
    }

    /// Handle windowShouldClose delegate callback
    ///
    /// This is called synchronously when the user clicks the close button.
    /// It invokes the close callback and returns whether the window should close.
    ///
    /// Returns: Ok(true) if window should close, Ok(false) if close was prevented
    fn handle_window_should_close(&mut self) -> Result<bool, String> {
        log_debug!(LogCategory::Window, "[handle_window_should_close] START");

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Set close_requested flag
        self.current_window_state.flags.close_requested = true;

        // Invoke close callback if it exists
        // This uses the V2 event system to detect CloseRequested and dispatch callbacks
        let result = self.process_window_events_recursive_v2(0);

        // Process the result - regenerate layout if callback modified DOM
        match result {
            azul_core::events::ProcessEventResult::ShouldRegenerateDomCurrentWindow => {
                log_debug!(
                    LogCategory::Callbacks,
                    "[handle_window_should_close] Callback requested DOM regeneration"
                );
                if let Err(e) = self.regenerate_layout() {
                    log_warn!(
                        LogCategory::Layout,
                        "[handle_window_should_close] Layout regeneration failed: {}",
                        e
                    );
                    // Continue anyway - don't block close on layout errors
                }
            }
            azul_core::events::ProcessEventResult::ShouldReRenderCurrentWindow => {
                log_debug!(
                    LogCategory::Callbacks,
                    "[handle_window_should_close] Callback requested re-render"
                );
                self.frame_needs_regeneration = true;
            }
            _ => {}
        }

        // Check if callback cleared the flag (preventing close)
        let should_close = self.current_window_state.flags.close_requested;

        if should_close {
            log_debug!(
                LogCategory::Window,
                "[handle_window_should_close] Close confirmed"
            );
            // Mark window as closed so is_open() returns false
            self.is_open = false;
        } else {
            log_debug!(
                LogCategory::Window,
                "[handle_window_should_close] Close prevented by callback"
            );
        }

        Ok(should_close)
    }

    /// Handle close request from WindowDelegate
    fn handle_close_request(&mut self) {
        log_debug!(
            LogCategory::Window,
            "[MacOSWindow] Processing close request"
        );

        // Save previous state BEFORE making changes
        self.previous_window_state = Some(self.current_window_state.clone());

        // Set close_requested flag in current state
        self.current_window_state.flags.close_requested = true;

        // Use V2 event system to detect CloseRequested and dispatch callbacks
        // This allows callbacks to modify DOM or prevent close by clearing the flag
        let result = self.process_window_events_recursive_v2(0);

        // Process the result - regenerate layout if needed
        match result {
            azul_core::events::ProcessEventResult::ShouldRegenerateDomCurrentWindow => {
                if let Err(e) = self.regenerate_layout() {
                    log_warn!(
                        LogCategory::Layout,
                        "[MacOSWindow] Layout regeneration failed after close callback: {}",
                        e
                    );
                }
            }
            azul_core::events::ProcessEventResult::ShouldReRenderCurrentWindow => {
                self.frame_needs_regeneration = true;
            }
            _ => {}
        }

        // Check if callback cleared the flag (preventing close)
        if self.current_window_state.flags.close_requested {
            log_debug!(
                LogCategory::Window,
                "[MacOSWindow] Close confirmed, closing window"
            );
            self.close_window();
        } else {
            log_debug!(
                LogCategory::Window,
                "[MacOSWindow] Close cancelled by callback"
            );
        }
    }

    /// Actually close the window
    /// Start the thread polling timer (16ms interval for ~60 FPS)
    pub fn start_thread_tick_timer(&mut self) {
        use block2::RcBlock;
        if self.thread_timer_running.is_none() {
            // Create a timer that fires every 16ms (60 FPS)
            // Using scheduledTimerWithTimeInterval for simplicity
            let timer: Retained<NSTimer> = unsafe {
                let interval: f64 = 0.016; // 16ms
                msg_send_id![
                    NSTimer::class(),
                    scheduledTimerWithTimeInterval: interval,
                    repeats: true,
                    block: &*RcBlock::new(|| {
                        // Thread tick callback - poll thread messages
                        // This will be called every 16ms
                    })
                ]
            };

            self.thread_timer_running = Some(timer);
        }
    }

    /// Stop the thread polling timer
    pub fn stop_thread_tick_timer(&mut self) {
        if let Some(timer) = self.thread_timer_running.take() {
            unsafe {
                timer.invalidate();
            }
        }
    }

    fn close_window(&mut self) {
        // Unregister from global window registry before closing
        let ns_window = self.get_ns_window_ptr();
        registry::unregister_window(ns_window);

        unsafe {
            self.window.close();
        }
        self.is_open = false;
    }

    /// Check if the window is still open
    pub fn is_open(&self) -> bool {
        self.is_open
    }

    /// Get the NSWindow pointer for registry identification
    ///
    /// Returns a raw pointer to the NSWindow object, which is used as a unique
    /// identifier in the window registry for multi-window support.
    pub fn get_ns_window_ptr(&self) -> *mut objc2::runtime::AnyObject {
        Retained::as_ptr(&self.window) as *mut objc2::runtime::AnyObject
    }

    /// Apply window decorations changes
    fn apply_decorations(&mut self, decorations: WindowDecorations) {
        let mut style_mask = self.window.styleMask();

        match decorations {
            WindowDecorations::Normal => {
                // Full decorations with title and controls
                style_mask.insert(NSWindowStyleMask::Titled);
                style_mask.insert(NSWindowStyleMask::Closable);
                style_mask.insert(NSWindowStyleMask::Miniaturizable);
                style_mask.insert(NSWindowStyleMask::Resizable);
                unsafe {
                    self.window.setTitlebarAppearsTransparent(false);
                    self.window
                        .setTitleVisibility(NSWindowTitleVisibility::Visible);
                }
            }
            WindowDecorations::NoTitle => {
                // Extended frame: controls visible but no title
                style_mask.insert(NSWindowStyleMask::Titled);
                style_mask.insert(NSWindowStyleMask::Closable);
                style_mask.insert(NSWindowStyleMask::Miniaturizable);
                style_mask.insert(NSWindowStyleMask::Resizable);
                style_mask.insert(NSWindowStyleMask::FullSizeContentView);
                unsafe {
                    self.window.setTitlebarAppearsTransparent(true);
                    self.window
                        .setTitleVisibility(NSWindowTitleVisibility::Hidden);
                }
            }
            WindowDecorations::NoControls => {
                // Title bar but no controls
                style_mask.insert(NSWindowStyleMask::Titled);
                style_mask.remove(NSWindowStyleMask::Closable);
                style_mask.remove(NSWindowStyleMask::Miniaturizable);
                unsafe {
                    self.window.setTitlebarAppearsTransparent(false);
                    self.window
                        .setTitleVisibility(NSWindowTitleVisibility::Visible);
                }
            }
            WindowDecorations::None => {
                // Borderless window
                style_mask.remove(NSWindowStyleMask::Titled);
                style_mask.remove(NSWindowStyleMask::Closable);
                style_mask.remove(NSWindowStyleMask::Miniaturizable);
                style_mask.remove(NSWindowStyleMask::Resizable);
            }
        }

        self.window.setStyleMask(style_mask);
    }

    /// Apply window visibility
    fn apply_visibility(&mut self, visible: bool) {
        if visible {
            unsafe {
                self.window.makeKeyAndOrderFront(None);
            }
        } else {
            unsafe {
                self.window.orderOut(None);
            }
        }
    }

    /// Apply window resizable state
    fn apply_resizable(&mut self, resizable: bool) {
        let mut style_mask = self.window.styleMask();
        if resizable {
            style_mask.insert(NSWindowStyleMask::Resizable);
        } else {
            style_mask.remove(NSWindowStyleMask::Resizable);
        }
        self.window.setStyleMask(style_mask);
    }

    /// Apply window background material
    fn apply_background_material(&mut self, material: WindowBackgroundMaterial) {
        use objc2_app_kit::{
            NSVisualEffectBlendingMode, NSVisualEffectMaterial, NSVisualEffectState,
            NSVisualEffectView,
        };

        match material {
            WindowBackgroundMaterial::Opaque => {
                // Remove any effect view and restore normal window
                if let Some(content_view) = self.window.contentView() {
                    // Check if content view is an effect view
                    unsafe {
                        let content_ptr = Retained::as_ptr(&content_view);
                        let is_effect_view: bool =
                            msg_send![content_ptr, isKindOfClass: NSVisualEffectView::class()];

                        if is_effect_view {
                            // Get the original view (first subview)
                            let subviews = content_view.subviews();
                            if subviews.count() > 0 {
                                let original_view = subviews.objectAtIndex(0);
                                self.window.setContentView(Some(&original_view));
                            }
                        }

                        self.window.setOpaque(true);
                        self.window.setBackgroundColor(None);
                        self.window.setTitlebarAppearsTransparent(false);
                    }
                }
            }
            WindowBackgroundMaterial::Transparent => {
                // Transparent window without blur
                unsafe {
                    self.window.setOpaque(false);
                    self.window.setBackgroundColor(Some(&NSColor::clearColor()));
                }
            }
            WindowBackgroundMaterial::Sidebar
            | WindowBackgroundMaterial::Menu
            | WindowBackgroundMaterial::HUD
            | WindowBackgroundMaterial::Titlebar
            | WindowBackgroundMaterial::MicaAlt => {
                // Create or update NSVisualEffectView
                let content_view = match self.window.contentView() {
                    Some(view) => view,
                    None => return,
                };

                let ns_material = match material {
                    WindowBackgroundMaterial::Sidebar => NSVisualEffectMaterial::Sidebar,
                    WindowBackgroundMaterial::Menu => NSVisualEffectMaterial::Menu,
                    WindowBackgroundMaterial::HUD => NSVisualEffectMaterial::HUDWindow,
                    WindowBackgroundMaterial::Titlebar => NSVisualEffectMaterial::Titlebar,
                    WindowBackgroundMaterial::MicaAlt => NSVisualEffectMaterial::Titlebar, /* Closest match on macOS */
                    _ => unreachable!(),
                };

                unsafe {
                    let content_ptr = Retained::as_ptr(&content_view);
                    let is_effect_view: bool =
                        msg_send![content_ptr, isKindOfClass: NSVisualEffectView::class()];

                    if is_effect_view {
                        // Update existing effect view
                        let effect_view: *const NSVisualEffectView =
                            content_ptr as *const NSVisualEffectView;
                        (*effect_view).setMaterial(ns_material);
                    } else {
                        // Create new effect view
                        let frame = content_view.frame();
                        let effect_view: Option<Retained<NSVisualEffectView>> =
                            msg_send_id![NSVisualEffectView::alloc(self.mtm), initWithFrame: frame];

                        if let Some(effect_view) = effect_view {
                            effect_view.setMaterial(ns_material);
                            effect_view.setBlendingMode(NSVisualEffectBlendingMode::BehindWindow);
                            effect_view.setState(NSVisualEffectState::Active);

                            // Add original view as subview
                            effect_view.addSubview(&content_view);

                            // Set effect view as content view
                            let effect_view_ptr = Retained::as_ptr(&effect_view) as *const NSView;
                            let effect_view_ref = &*effect_view_ptr;
                            self.window.setContentView(Some(effect_view_ref));
                        }
                    }

                    self.window.setOpaque(false);
                    self.window.setBackgroundColor(Some(&NSColor::clearColor()));
                    self.window.setTitlebarAppearsTransparent(true);
                }
            }
        }
    }

    /// Handle a menu action from a menu item click
    fn handle_menu_action(&mut self, tag: isize) {
        log_trace!(
            LogCategory::Callbacks,
            "[MacOSWindow] Handling menu action for tag: {}",
            tag
        );

        // Look up callback from tag
        let callback = match self.menu_state.get_callback_for_tag(tag as i64) {
            Some(cb) => cb.clone(),
            None => {
                log_warn!(
                    LogCategory::Callbacks,
                    "[MacOSWindow] No callback found for tag: {}",
                    tag
                );
                return;
            }
        };

        log_debug!(
            LogCategory::Callbacks,
            "[MacOSWindow] Menu item clicked (tag {})",
            tag
        );

        // Convert CoreMenuCallback to layout MenuCallback
        use azul_layout::callbacks::{Callback, MenuCallback};

        let layout_callback = Callback::from_core(callback.callback);
        let mut menu_callback = MenuCallback {
            callback: layout_callback,
            refany: callback.refany,
        };

        // Get layout window to create callback info
        let layout_window = match self.layout_window.as_mut() {
            Some(lw) => lw,
            None => {
                log_warn!(
                    LogCategory::Callbacks,
                    "[MacOSWindow] No layout window available"
                );
                return;
            }
        };

        use std::ptr;

        use azul_core::window::RawWindowHandle;

        let raw_handle = RawWindowHandle::MacOS(azul_core::window::MacOSHandle {
            ns_window: Retained::as_ptr(&self.window) as *mut _,
            ns_view: ptr::null_mut(), // Not needed for menu callbacks
        });

        // Clone fc_cache (cheap Arc clone) since invoke_single_callback needs &mut
        let mut fc_cache_clone = (*self.fc_cache).clone();

        // Use LayoutWindow::invoke_single_callback which handles all the borrow complexity
        let callback_result = layout_window.invoke_single_callback(
            &mut menu_callback.callback,
            &mut menu_callback.refany,
            &raw_handle,
            &self.gl_context_ptr,
            &mut self.image_cache,
            &mut fc_cache_clone,
            self.system_style.clone(),
            &azul_layout::callbacks::ExternalSystemCallbacks::rust_internal(),
            &self.previous_window_state,
            &self.current_window_state,
            &self.renderer_resources,
        );

        // Process callback result using the V2 unified system
        // This handles timers, threads, window state changes, and Update
        use crate::desktop::shell2::common::event_v2::PlatformWindowV2;
        self.previous_window_state = Some(self.current_window_state.clone());
        let event_result = self.process_callback_result_v2(&callback_result);
        // Sync window state to OS (handles close_requested, title, size, etc.)
        self.sync_window_state();

        // Handle the event result
        use azul_core::events::ProcessEventResult;
        match event_result {
            ProcessEventResult::ShouldRegenerateDomCurrentWindow
            | ProcessEventResult::ShouldRegenerateDomAllWindows
            | ProcessEventResult::ShouldReRenderCurrentWindow
            | ProcessEventResult::ShouldUpdateDisplayListCurrentWindow
            | ProcessEventResult::UpdateHitTesterAndProcessAgain => {
                self.frame_needs_regeneration = true;
                self.request_redraw();
            }
            ProcessEventResult::DoNothing => {
                // No action needed
            }
        }
    }

    /// Synchronize window size from content view bounds
    ///
    /// This ensures the window state always reflects the actual view size,
    /// which is important for proper HiDPI rendering and layout.
    /// Should be called before rendering to catch any size changes.
    fn sync_window_size_from_content_view(&mut self) {
        let content_view = match unsafe { self.window.contentView() } {
            Some(view) => view,
            None => return,
        };

        let bounds = unsafe { content_view.bounds() };
        let new_logical_width = bounds.size.width as f32;
        let new_logical_height = bounds.size.height as f32;

        let old_dims = self.current_window_state.size.dimensions;

        // Only update if dimensions actually changed (with small tolerance for float comparison)
        if (old_dims.width - new_logical_width).abs() > 0.5
            || (old_dims.height - new_logical_height).abs() > 0.5
        {
            self.current_window_state.size.dimensions = azul_core::geom::LogicalSize {
                width: new_logical_width,
                height: new_logical_height,
            };

            // Also update the DPI in case it changed (e.g., window moved to different display)
            let scale_factor = unsafe {
                self.window
                    .screen()
                    .map(|screen| screen.backingScaleFactor() as f32)
                    .unwrap_or(1.0)
            };
            self.current_window_state.size.dpi = (scale_factor * 96.0) as u32;

            // Mark frame as needing regeneration
            self.frame_needs_regeneration = true;

            log_debug!(
                LogCategory::Window,
                "[sync_window_size_from_content_view] Size updated: {}x{} -> {}x{} (dpi={})",
                old_dims.width,
                old_dims.height,
                new_logical_width,
                new_logical_height,
                self.current_window_state.size.dpi
            );
        }
    }

    /// Check if window is maximized by comparing frame to screen size
    ///
    /// Updates the window frame state based on the actual window and screen dimensions.
    /// Should be called after resize events.
    fn check_maximized_state(&mut self) {
        // Skip check if in fullscreen mode
        if self.current_window_state.flags.frame == WindowFrame::Fullscreen {
            return;
        }

        let window_frame = self.window.frame();

        // Get the visible frame of the screen (excludes menu bar and dock)
        let screen_frame = unsafe {
            if let Some(screen) = self.window.screen() {
                screen.visibleFrame()
            } else {
                // No screen available, can't determine maximized state
                return;
            }
        };

        // Consider window maximized if it matches the screen's visible frame
        // Allow small tolerance for rounding errors
        let tolerance = 5.0;
        let is_maximized = (window_frame.origin.x - screen_frame.origin.x).abs() < tolerance
            && (window_frame.origin.y - screen_frame.origin.y).abs() < tolerance
            && (window_frame.size.width - screen_frame.size.width).abs() < tolerance
            && (window_frame.size.height - screen_frame.size.height).abs() < tolerance;

        let new_frame = if is_maximized {
            WindowFrame::Maximized
        } else {
            WindowFrame::Normal
        };

        if new_frame != self.current_window_state.flags.frame {
            self.current_window_state.flags.frame = new_frame;
            log_debug!(
                LogCategory::Window,
                "[MacOSWindow] Window frame changed to: {:?}",
                new_frame
            );
        }
    }

    /// Set the application menu
    ///
    /// Updates the macOS menu bar with the provided menu structure.
    /// Uses hash-based diffing to avoid unnecessary menu recreation.
    pub fn set_application_menu(&mut self, menu: &azul_core::menu::Menu) {
        if self.menu_state.update_if_changed(menu, self.mtm) {
            log_debug!(
                LogCategory::Platform,
                "[MacOSWindow] Application menu updated"
            );
            if let Some(ns_menu) = self.menu_state.get_nsmenu() {
                let app = NSApplication::sharedApplication(self.mtm);
                app.setMainMenu(Some(ns_menu));
            }
        }
    }

    /// Show a tooltip with the given text at the specified position
    ///
    /// Position is in logical coordinates. The tooltip will be created on first use.
    pub fn show_tooltip(
        &mut self,
        text: &str,
        position: azul_core::geom::LogicalPosition,
    ) -> Result<(), String> {
        // Lazily create tooltip if needed
        if self.tooltip.is_none() {
            self.tooltip = Some(tooltip::TooltipWindow::new(self.mtm)?);
        }

        let dpi_factor = DpiScaleFactor::new(unsafe {
            self.window
                .screen()
                .map(|screen| screen.backingScaleFactor() as f32)
                .unwrap_or(1.0)
        });

        if let Some(ref mut tooltip) = self.tooltip {
            tooltip.show(text, position, dpi_factor)?;
        }

        Ok(())
    }

    /// Hide the currently displayed tooltip
    ///
    /// Does nothing if no tooltip is shown.
    pub fn hide_tooltip(&mut self) -> Result<(), String> {
        if let Some(ref mut tooltip) = self.tooltip {
            tooltip.hide()?;
        }
        Ok(())
    }

    /// Set the window to be always on top (or not)
    ///
    /// Uses setLevel with NSFloatingWindowLevel or NSNormalWindowLevel.
    pub fn set_is_top_level(&mut self, is_top_level: bool) -> Result<(), String> {
        unsafe {
            if is_top_level {
                self.window.setLevel(objc2_app_kit::NSFloatingWindowLevel);
            } else {
                self.window.setLevel(objc2_app_kit::NSNormalWindowLevel);
            }
        }
        Ok(())
    }

    /// Prevent the system from sleeping (or allow it to sleep)
    ///
    /// Uses IOPMAssertionCreateWithName to create a power assertion.
    pub fn set_prevent_system_sleep(&mut self, prevent: bool) -> Result<(), String> {
        unsafe {
            if prevent {
                // Already have an assertion?
                if self.pm_assertion_id.is_some() {
                    return Ok(());
                }

                // Create assertion
                let assertion_type = NSString::from_str(kIOPMAssertionTypeNoDisplaySleep);
                let assertion_name = NSString::from_str("Azul GUI - Video Playback");
                let mut assertion_id: IOPMAssertionID = 0;

                let result = IOPMAssertionCreateWithName(
                    assertion_type.as_ref(),
                    kIOPMAssertionLevelOn,
                    assertion_name.as_ref(),
                    &mut assertion_id,
                );

                if result == kIOReturnSuccess {
                    self.pm_assertion_id = Some(assertion_id);
                    log_debug!(
                        LogCategory::Platform,
                        "[macOS] System sleep prevented (assertion: {})",
                        assertion_id
                    );
                    Ok(())
                } else {
                    Err(format!("IOPMAssertionCreateWithName failed: {}", result))
                }
            } else {
                // Release assertion
                if let Some(assertion_id) = self.pm_assertion_id.take() {
                    let result = IOPMAssertionRelease(assertion_id);
                    if result == kIOReturnSuccess {
                        log_debug!(
                            LogCategory::Platform,
                            "[macOS] System sleep allowed (assertion: {})",
                            assertion_id
                        );
                        Ok(())
                    } else {
                        Err(format!("IOPMAssertionRelease failed: {}", result))
                    }
                } else {
                    Ok(()) // No assertion to release
                }
            }
        }
    }

    /// Show a native NSMenu at the given position (without NSEvent)
    ///
    /// This is used for menus opened from callbacks (info.open_menu()).
    /// Unlike context menus which need the NSEvent for proper positioning,
    /// this version shows the menu at an absolute position.
    fn show_native_menu_at_position(
        &mut self,
        menu: &azul_core::menu::Menu,
        position: azul_core::geom::LogicalPosition,
    ) {
        use objc2_app_kit::{NSMenu, NSMenuItem};
        use objc2_foundation::{MainThreadMarker, NSPoint, NSString};

        let mtm = match MainThreadMarker::new() {
            Some(m) => m,
            None => {
                log_warn!(
                    LogCategory::Platform,
                    "[Menu] Not on main thread, cannot show menu"
                );
                return;
            }
        };

        let ns_menu = NSMenu::new(mtm);

        // Build menu items recursively from Azul menu structure
        // Call the public(crate) associated function
        MacOSWindow::recursive_build_nsmenu(
            &ns_menu,
            menu.items.as_slice(),
            &mtm,
            &mut self.menu_state,
        );

        // Show the menu at the specified position
        let view_point = NSPoint {
            x: position.x as f64,
            y: position.y as f64,
        };

        let view = if let Some(ref gl_view) = self.gl_view {
            Some(&**gl_view as &objc2::runtime::AnyObject)
        } else if let Some(ref cpu_view) = self.cpu_view {
            Some(&**cpu_view as &objc2::runtime::AnyObject)
        } else {
            None
        };

        if let Some(view) = view {
            log_debug!(
                LogCategory::Platform,
                "[Menu] Showing native menu at position ({}, {}) with {} items",
                position.x,
                position.y,
                menu.items.as_slice().len()
            );

            unsafe {
                use objc2::{msg_send_id, rc::Retained, runtime::AnyObject, sel};

                let _: () = msg_send_id![
                    &ns_menu,
                    popUpMenuPositioningItem: Option::<&AnyObject>::None,
                    atLocation: view_point,
                    inView: view
                ];
            }
        }
    }

    /// Show a fallback window-based menu at the given position
    ///
    /// This uses the same unified menu system as regular menus but for callback-triggered menus.
    fn show_fallback_menu(
        &mut self,
        menu: &azul_core::menu::Menu,
        position: azul_core::geom::LogicalPosition,
    ) {
        // Get parent window position
        let parent_pos = match self.current_window_state.position {
            azul_core::window::WindowPosition::Initialized(pos) => {
                azul_core::geom::LogicalPosition::new(pos.x as f32, pos.y as f32)
            }
            _ => azul_core::geom::LogicalPosition::new(0.0, 0.0),
        };

        // Create menu window options using the unified menu system
        let menu_options = crate::desktop::menu::show_menu(
            menu.clone(),
            self.system_style.clone(),
            parent_pos,
            None,           // No trigger rect for callback menus
            Some(position), // Position for menu
            None,           // No parent menu
        );

        // Queue window creation request
        log_debug!(
            LogCategory::Platform,
            "[macOS] Queuing fallback menu window at screen ({}, {}) - will be created in event \
             loop",
            position.x,
            position.y
        );

        self.pending_window_creates.push(menu_options);
    }

    /// Process an NSEvent and dispatch to appropriate handler
    /// 
    /// NOTE: Mouse events (mouseDown, mouseUp, mouseMoved, etc.) are NOT processed here.
    /// They are handled by the NSView subclass (GLView/CPUView) via Cocoa's responder chain.
    /// Calling sendEvent() forwards the event to the view, which then calls our handlers.
    /// Processing mouse events here would result in DOUBLE processing.
    pub fn process_event(&mut self, event: &NSEvent, macos_event: &MacOSEvent) {
        use azul_core::events::MouseButton;

        let event_type = event.r#type();

        match event_type {
            // Mouse events are handled by NSView's responder methods (mouseDown:, etc.)
            // They will be dispatched to our handlers via sendEvent() -> NSView -> handle_mouse_*
            // Do NOT process them here to avoid double-processing.
            NSEventType::LeftMouseDown
            | NSEventType::LeftMouseUp
            | NSEventType::RightMouseDown
            | NSEventType::RightMouseUp
            | NSEventType::OtherMouseDown
            | NSEventType::OtherMouseUp
            | NSEventType::MouseMoved
            | NSEventType::LeftMouseDragged
            | NSEventType::RightMouseDragged
            | NSEventType::MouseEntered
            | NSEventType::MouseExited
            | NSEventType::ScrollWheel => {
                // These events are processed by the NSView responder chain
                // via app.sendEvent() -> NSView.mouseDown:/mouseUp:/etc.
            }
            NSEventType::KeyDown => {
                use crate::desktop::shell2::macos::events::EventProcessResult;
                let result = self.handle_key_down(event);
                if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                    self.frame_needs_regeneration = true;
                }
            }
            NSEventType::KeyUp => {
                use crate::desktop::shell2::macos::events::EventProcessResult;
                let result = self.handle_key_up(event);
                if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                    self.frame_needs_regeneration = true;
                }
            }
            NSEventType::FlagsChanged => {
                use crate::desktop::shell2::macos::events::EventProcessResult;
                let result = self.handle_flags_changed(event);
                if matches!(result, EventProcessResult::RegenerateDisplayList | EventProcessResult::RequestRedraw) {
                    self.frame_needs_regeneration = true;
                }
            }
            _ => {
                // Other events not handled yet
            }
        }

        // After processing event, just request a redraw if needed
        // The atomic transaction will be built in drawRect
        if self.frame_needs_regeneration {
            log_trace!(
                LogCategory::EventLoop,
                "[handle_event] Frame needs regeneration, requesting redraw"
            );
            self.request_redraw();
            self.frame_needs_regeneration = false;
        }
    }

    /// Set the mouse cursor to a specific system cursor
    ///
    /// # Cursor Types (macOS)
    /// - "arrow" - Standard arrow
    /// - "ibeam" - I-beam text cursor
    /// - "crosshair" - Crosshair
    /// - "pointing_hand" - Pointing hand (link cursor)
    /// - "resize_left_right" - Horizontal resize
    /// - "resize_up_down" - Vertical resize
    /// - "open_hand" - Open hand (grab)
    /// - "closed_hand" - Closed hand (grabbing)
    /// - "disappearing_item" - Disappearing item (poof)
    pub fn set_cursor(&self, cursor_type: &str) {
        use objc2_app_kit::NSCursor;

        unsafe {
            let cursor = match cursor_type {
                "arrow" => NSCursor::arrowCursor(),
                "ibeam" | "text" => NSCursor::IBeamCursor(),
                "crosshair" => NSCursor::crosshairCursor(),
                "pointing_hand" | "pointer" | "hand" => NSCursor::pointingHandCursor(),
                "resize_left_right" | "ew-resize" => NSCursor::resizeLeftRightCursor(),
                "resize_up_down" | "ns-resize" => NSCursor::resizeUpDownCursor(),
                "open_hand" | "grab" => NSCursor::openHandCursor(),
                "closed_hand" | "grabbing" => NSCursor::closedHandCursor(),
                "disappearing_item" | "no-drop" => NSCursor::disappearingItemCursor(),
                "drag_copy" | "copy" => NSCursor::dragCopyCursor(),
                "drag_link" | "alias" => NSCursor::dragLinkCursor(),
                "operation_not_allowed" | "not-allowed" => NSCursor::operationNotAllowedCursor(),
                _ => NSCursor::arrowCursor(), // Default fallback
            };
            cursor.set();
        }
    }

    /// Hide the mouse cursor
    pub fn hide_cursor(&self) {
        use objc2_app_kit::NSCursor;
        unsafe {
            NSCursor::hide();
        }
    }

    /// Show the mouse cursor
    pub fn show_cursor(&self) {
        use objc2_app_kit::NSCursor;
        unsafe {
            NSCursor::unhide();
        }
    }

    /// Reset cursor to default arrow
    pub fn reset_cursor(&self) {
        self.set_cursor("arrow");
    }

    // RENDERING METHODS - macOS Drawing Model Integration

    /// Set up the GLView's back-pointer to this MacOSWindow.
    ///
    /// This MUST be called after window construction to enable drawRect: to find
    /// the window and call render_and_present_in_draw_rect().
    ///
    /// SAFETY: This creates a self-referential pointer. The caller must ensure:
    /// - The window is not moved in memory (use Box/Arc or keep it on the stack)
    /// - The view is owned by the window and doesn't outlive it
    pub unsafe fn setup_gl_view_back_pointer(&mut self) {
        // Get the window pointer first, before borrowing gl_view
        let window_ptr = self as *mut MacOSWindow as *mut std::ffi::c_void;

        if let Some(ref gl_view) = self.gl_view {
            gl_view.set_window_ptr(window_ptr);
            log_trace!(
                LogCategory::Platform,
                "[setup_gl_view_back_pointer] GLView back pointer set"
            );
        }
    }

    /// Finalize the delegate's back-pointer to this window.
    ///
    /// MUST be called AFTER the window is in its final memory location.
    /// Do NOT call this from the constructor, as the window will be moved after creation.
    ///
    /// SAFETY:
    /// - The window must not be moved in memory after this call
    /// - The delegate is owned by the window and doesn't outlive it
    pub unsafe fn finalize_delegate_pointer(&mut self) {
        let window_ptr = self as *mut MacOSWindow as *mut std::ffi::c_void;
        let delegate_ptr = &*self.window_delegate as *const WindowDelegate;
        (*delegate_ptr).set_window_ptr(window_ptr);
        log_trace!(
            LogCategory::Platform,
            "[finalize_delegate_pointer] WindowDelegate back pointer set"
        );
    }

    /// This is the MAIN rendering entry point, called ONLY from GLView::drawRect:
    ///
    /// This method follows the idiomatic macOS drawing pattern where all rendering
    /// happens inside drawRect:. It:
    /// 1. Makes the GL context current and updates it
    /// 2. Sets the viewport
    /// 3. Calls renderer.update() and renderer.render() to composite WebRender's scene
    /// 4. Swaps buffers via flushBuffer()
    ///
    /// IMPORTANT: This should NEVER be called directly from Rust code. It's only
    /// called by the Objective-C drawRect: method when macOS schedules a redraw.
    pub fn render_and_present_in_draw_rect(&mut self) -> Result<(), WindowError> {
        use super::common::event_v2::PlatformWindowV2;
        use azul_core::callbacks::Update;

        log_trace!(LogCategory::Rendering, "[render_and_present] START");

        // CRITICAL: Invoke expired timer callbacks FIRST, before any rendering
        // This allows timer callbacks (like the debug server timer) to run
        let timer_results = self.invoke_expired_timers();
        if !timer_results.is_empty() {
            log_trace!(
                LogCategory::Timer,
                "[render_and_present] Invoked {} timer callbacks",
                timer_results.len()
            );

            // Process each callback result to handle window state modifications
            // and queued_window_states (for debug server click simulation)
            for result in &timer_results {
                if result.modified_window_state.is_some() || !result.queued_window_states.is_empty()
                {
                    // Save previous state BEFORE applying changes (for sync_window_state diff)
                    self.previous_window_state = Some(self.current_window_state.clone());
                    let _ = self.process_callback_result_v2(result);
                    // Synchronize window state with OS immediately after change
                    self.sync_window_state();
                }
                // Check if redraw needed
                if matches!(
                    result.callbacks_update_screen,
                    Update::RefreshDom | Update::RefreshDomAllWindows
                ) {
                    self.frame_needs_regeneration = true;
                }
            }
        }

        // CRITICAL: Poll threads for completed work and invoke writeback callbacks
        // This processes ThreadWriteBackMsg from background threads
        if let Some(thread_result) = self.invoke_thread_callbacks() {
            // ALWAYS process thread callback result to handle threads_removed, new timers, etc.
            self.previous_window_state = Some(self.current_window_state.clone());
            let _ = self.process_callback_result_v2(&thread_result);
            
            // Check if redraw needed
            if matches!(
                thread_result.callbacks_update_screen,
                Update::RefreshDom | Update::RefreshDomAllWindows
            ) {
                self.frame_needs_regeneration = true;
            }
        }

        // Step 0: Update window size from current content view bounds
        // This ensures we always have the latest size, even if resize notifications were missed
        self.sync_window_size_from_content_view();

        // Step 1: Prepare OpenGL context (if using OpenGL backend)
        if self.backend == RenderBackend::OpenGL {
            let gl_context = self
                .gl_context
                .as_ref()
                .ok_or_else(|| WindowError::PlatformError("OpenGL context is missing".into()))?;

            let gl_fns = self
                .gl_functions
                .as_ref()
                .ok_or_else(|| WindowError::PlatformError("OpenGL functions are missing".into()))?;

            unsafe {
                log_trace!(LogCategory::Rendering, "[GL] makeCurrentContext()");
                // Make context current before any GL operations
                gl_context.makeCurrentContext();

                log_trace!(LogCategory::Rendering, "[GL] context.update()");
                // CRITICAL: Synchronize context with the view's drawable surface
                // This must be called every frame to handle window moves/resizes
                gl_context.update(self.mtm);

                // CRITICAL: Set the viewport to the physical size of the window
                let physical_size = self.current_window_state.size.get_physical_size();
                log_trace!(
                    LogCategory::Rendering,
                    "[GL] glViewport(0, 0, {}, {})",
                    physical_size.width,
                    physical_size.height
                );
                gl_fns.functions.viewport(
                    0,
                    0,
                    physical_size.width as i32,
                    physical_size.height as i32,
                );
            }
        }

        // Step 1.5: CRITICAL - Create, build, and send WebRender transaction ATOMICALLY
        // This is the ONLY place where Transaction::new() should be called!
        // This matches the working WebRender example pattern: ONE transaction per frame
        log_trace!(
            LogCategory::Rendering,
            "[WebRender] Creating atomic transaction"
        );

        let mut txn = WrTransaction::new();

        // Build everything into this transaction (resources, display lists, etc.)

        log_trace!(LogCategory::Rendering, "[build_atomic_txn] START");

        // NOTE: Timer callbacks are now invoked in render_and_present_in_draw_rect()
        // before this method is called, via invoke_expired_timers()

        // CRITICAL: Regenerate layout FIRST if needed
        // Layout must be current before building display lists
        if self.frame_needs_regeneration {
            log_trace!(
                LogCategory::Layout,
                "[build_atomic_txn] Regenerating layout"
            );
            if let Err(e) = self.regenerate_layout() {
                log_error!(
                    LogCategory::Layout,
                    "[build_atomic_txn] Layout failed: {}",
                    e
                );
                return Err(WindowError::PlatformError(
                    format!("Layout failed: {}", e).into(),
                ));
            }
            self.frame_needs_regeneration = false;
        }

        // Get layout_window
        let layout_window = self
            .layout_window
            .as_mut()
            .ok_or_else(|| WindowError::PlatformError("No layout window".into()))?;

        // CRITICAL: Synchronize window state to layout_window before building transaction
        // This ensures WebRender gets the current window size after resize
        layout_window.current_window_state = self.current_window_state.clone();

        log_trace!(
            LogCategory::Rendering,
            "[build_atomic_txn] Building transaction"
        );
        // Build everything into this transaction using helper functions
        crate::desktop::wr_translate2::build_webrender_transaction(
            &mut txn,
            layout_window,
            &mut self.render_api,
            &self.image_cache,
        )
        .map_err(|e| {
            WindowError::PlatformError(format!("Failed to build transaction: {}", e).into())
        })?;

        log_trace!(LogCategory::Rendering, "[build_atomic_txn] COMPLETE");

        // Send the complete atomic transaction
        if let Some(layout_window) = self.layout_window.as_ref() {
            let doc_id = wr_translate_document_id(layout_window.document_id);
            log_trace!(
                LogCategory::Rendering,
                "[WebRender] send_transaction({:?})",
                doc_id
            );
            self.render_api.send_transaction(doc_id, txn);
            self.render_api.flush_scene_builder();
        }
        log_trace!(LogCategory::Rendering, "[WebRender] Transaction sent");

        // Step 2: Call WebRender to composite the scene
        if let Some(ref mut renderer) = self.renderer {
            log_trace!(LogCategory::Rendering, "[WebRender] renderer.update()");
            renderer.update();

            let physical_size = self.current_window_state.size.get_physical_size();
            let device_size = webrender::api::units::DeviceIntSize::new(
                physical_size.width as i32,
                physical_size.height as i32,
            );

            log_trace!(
                LogCategory::Rendering,
                "[WebRender] renderer.render({:?})",
                device_size
            );

            match renderer.render(device_size, 0) {
                Ok(results) => {
                    log_trace!(
                        LogCategory::Rendering,
                        "[WebRender] Render successful: {:?}",
                        results.stats
                    );

                    // Update hit tester after render - WebRender now has valid scene data
                    if let Some(layout_window) = self.layout_window.as_ref() {
                        let doc_id = wr_translate_document_id(layout_window.document_id);
                        let new_hit_tester = self.render_api.request_hit_tester(doc_id).resolve();
                        self.hit_tester =
                            crate::desktop::wr_translate2::AsyncHitTester::Resolved(new_hit_tester);
                        log_trace!(
                            LogCategory::Rendering,
                            "[WebRender] Hit tester updated after render"
                        );
                    }
                }
                Err(errors) => {
                    log_error!(
                        LogCategory::Rendering,
                        "[WebRender] Render errors: {:?}",
                        errors
                    );
                    return Err(WindowError::PlatformError(
                        format!("WebRender render failed: {:?}", errors).into(),
                    ));
                }
            }
        } else {
            log_warn!(
                LogCategory::Rendering,
                "[render_and_present] No renderer available!"
            );
            return Ok(());
        }

        // Step 3: Swap buffers to show the rendered frame
        match self.backend {
            RenderBackend::OpenGL => {
                if let Some(ref gl_context) = self.gl_context {
                    log_trace!(LogCategory::Rendering, "[GL] flushBuffer()");
                    unsafe {
                        gl_context.flushBuffer();
                    }
                }
            }
            RenderBackend::CPU => {
                // CPU backend doesn't need explicit buffer swap
                // The drawRect: itself updates the view
            }
        }

        log_trace!(
            LogCategory::Rendering,
            "[render_and_present] FRAME COMPLETE"
        );

        // CI testing: Exit successfully after first frame render if env var is set
        if std::env::var("AZUL_EXIT_SUCCESS_AFTER_FRAME_RENDER").is_ok() {
            log_info!(
                LogCategory::General,
                "[CI] AZUL_EXIT_SUCCESS_AFTER_FRAME_RENDER set - exiting"
            );
            std::process::exit(0);
        }

        Ok(())
    }
}

impl Drop for MacOSWindow {
    fn drop(&mut self) {
        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::drop] Cleaning up window resources"
        );

        // Stop and release CVDisplayLink if active
        if let Some(ref display_link) = self.display_link {
            if display_link.is_running() {
                log_trace!(
                    LogCategory::Window,
                    "[MacOSWindow::drop] Stopping CVDisplayLink"
                );
                display_link.stop();
            }
            // DisplayLink will be dropped automatically, calling release
        }

        // Release power management assertion if active
        if let Some(assertion_id) = self.pm_assertion_id.take() {
            log_trace!(
                LogCategory::Window,
                "[MacOSWindow::drop] Releasing IOPMAssertion"
            );
            unsafe {
                IOPMAssertionRelease(assertion_id);
            }
        }

        // Invalidate all active timers
        for (_, timer) in self.timers.drain() {
            unsafe {
                timer.invalidate();
            }
        }

        // Invalidate thread poll timer
        if let Some(timer) = self.thread_timer_running.take() {
            unsafe {
                timer.invalidate();
            }
        }

        log_trace!(
            LogCategory::Window,
            "[MacOSWindow::drop] Window cleanup complete"
        );
    }
}

impl PlatformWindow for MacOSWindow {
    type EventType = MacOSEvent;

    fn new(options: WindowCreateOptions, app_data: RefAny) -> Result<Self, WindowError>
    where
        Self: Sized,
    {
        let mtm = MainThreadMarker::new()
            .ok_or_else(|| WindowError::PlatformError("Not on main thread".into()))?;

        // Use default config when called via the generic PlatformWindow trait
        // Create a default SharedIconProvider for this case
        let default_config = azul_core::resources::AppConfig::default();
        let shared_icon_provider = azul_core::icon::SharedIconProvider::from_handle(default_config.icon_provider.clone());
        Self::new_with_options(options, app_data, default_config, shared_icon_provider, mtm)
    }

    fn get_state(&self) -> FullWindowState {
        // Return the stored current_window_state (which is kept in sync with OS)
        // instead of creating a new WindowState from scratch
        self.current_window_state.clone()
    }

    fn set_properties(&mut self, props: WindowProperties) -> Result<(), WindowError> {
        // Update current_window_state based on properties
        if let Some(title) = props.title {
            self.current_window_state.title = title.into();
        }

        if let Some(size) = props.size {
            use azul_core::geom::LogicalSize;
            // Get actual DPI scale from window
            let scale_factor = unsafe {
                self.window
                    .screen()
                    .map(|screen| screen.backingScaleFactor())
                    .unwrap_or(1.0)
            };

            // Convert PhysicalSize to LogicalSize using actual DPI
            self.current_window_state.size.dimensions = LogicalSize {
                width: (size.width as f64 / scale_factor) as f32,
                height: (size.height as f64 / scale_factor) as f32,
            };
        }

        if let Some(visible) = props.visible {
            self.current_window_state.flags.is_visible = visible;
        }

        // Synchronize changes with the OS
        self.sync_window_state();

        Ok(())
    }

    fn poll_event(&mut self) -> Option<Self::EventType> {
        // Check if a frame is ready without blocking
        let frame_ready = {
            let &(ref lock, _) = &*self.new_frame_ready;
            let mut ready_guard = lock.lock().unwrap();
            if *ready_guard {
                *ready_guard = false; // Consume the signal
                true
            } else {
                false
            }
        };

        if frame_ready {
            log_trace!(
                LogCategory::Rendering,
                "[poll_event] Frame ready signal - requesting redraw"
            );
            // A frame is ready in WebRender's backbuffer.
            // Tell macOS to schedule a drawRect: call, which will display it.
            self.request_redraw();
        }

        // Check for close request from WindowDelegate
        if self.current_window_state.flags.close_requested {
            self.current_window_state.flags.close_requested = false;
            self.handle_close_request();
        }

        // Process pending menu actions
        let pending_actions = menu::take_pending_menu_actions();
        for tag in pending_actions {
            self.handle_menu_action(tag);
        }

        let app = NSApplication::sharedApplication(self.mtm);

        // Poll event (non-blocking)
        let event = unsafe {
            app.nextEventMatchingMask_untilDate_inMode_dequeue(
                NSEventMask::Any,
                None, // No wait time = non-blocking
                objc2_foundation::NSDefaultRunLoopMode,
                true,
            )
        };

        if let Some(event) = event {
            // Convert and process event
            let macos_event = MacOSEvent::from_nsevent(&event);

            // Dispatch event to handlers
            self.process_event(&event, &macos_event);

            // Check for maximized state after processing events
            // This handles window resize/zoom events
            self.check_maximized_state();

            // Forward event to system
            unsafe {
                app.sendEvent(&event);
            }

            // Atomic transaction will be built in drawRect if needed
            // Just request redraw here if layout changed
            if self.frame_needs_regeneration {
                self.request_redraw();
                self.frame_needs_regeneration = false;
            }

            Some(macos_event)
        } else {
            None
        }
    }

    fn get_render_context(&self) -> RenderContext {
        match self.backend {
            RenderBackend::OpenGL => {
                let context_ptr = self
                    .gl_context
                    .as_ref()
                    .map(|ctx| Retained::as_ptr(ctx) as *mut _)
                    .unwrap_or(std::ptr::null_mut());

                RenderContext::OpenGL {
                    context: context_ptr,
                }
            }
            RenderBackend::CPU => RenderContext::CPU,
        }
    }

    fn present(&mut self) -> Result<(), WindowError> {
        // For macOS, presentation is handled by the compositor/NSOpenGLContext
        // The present() method is called by the rendering backend (WebRender)
        // or directly after CPU rendering
        match &self.backend {
            RenderBackend::OpenGL => {
                // For GPU rendering, flush the OpenGL context
                if let Some(ref gl_context) = self.gl_context {
                    unsafe {
                        let _: () = msg_send![gl_context, flushBuffer];
                    }
                }
            }
            RenderBackend::CPU => {
                // For CPU rendering, present is handled by drawRect:
                // Nothing to do here as the bitmap was already drawn
            }
        }
        Ok(())
    }

    fn is_open(&self) -> bool {
        self.is_open
    }

    fn close(&mut self) {
        // Release power management assertion if active
        if let Some(assertion_id) = self.pm_assertion_id.take() {
            unsafe {
                IOPMAssertionRelease(assertion_id);
            }
            log_trace!(
                LogCategory::Platform,
                "[macOS] Released power assertion on window close"
            );
        }

        self.window.close();
        self.is_open = false;
    }

    /// Request a redraw of the window.
    ///
    /// This is the idiomatic macOS way to trigger rendering: we call setNeedsDisplay(true)
    /// on the content view, which tells macOS to schedule a drawRect: call on the next
    /// display refresh cycle.
    ///
    /// This decouples our asynchronous rendering backend (WebRender) from the synchronous
    /// OS drawing model.
    fn request_redraw(&mut self) {
        log_trace!(
            LogCategory::Rendering,
            "[request_redraw] Marking view as needing display"
        );

        // Tell macOS to schedule a drawRect: call
        if let Some(view) = unsafe { self.window.contentView() } {
            unsafe {
                view.setNeedsDisplay(true);
            }
        }

        self.frame_needs_regeneration = true;
    }

    fn sync_clipboard(
        &mut self,
        clipboard_manager: &mut azul_layout::managers::clipboard::ClipboardManager,
    ) {
        clipboard::sync_clipboard(clipboard_manager);
    }
}

/// macOS event type.
#[derive(Debug, Clone, Copy)]
pub enum MacOSEvent {
    /// Window close requested
    Close,
    /// Window resized
    Resize { width: u32, height: u32 },
    /// Mouse moved
    MouseMove { x: f64, y: f64 },
    /// Mouse button pressed
    MouseDown { button: u8, x: f64, y: f64 },
    /// Mouse button released
    MouseUp { button: u8, x: f64, y: f64 },
    /// Key pressed
    KeyDown { key_code: u16 },
    /// Key released
    KeyUp { key_code: u16 },
    /// Other event
    Other,
}

impl MacOSEvent {
    /// Convert NSEvent to MacOSEvent.
    pub fn from_nsevent(event: &NSEvent) -> Self {
        match event.r#type() {
            NSEventType::LeftMouseDown => {
                let loc = event.locationInWindow();
                MacOSEvent::MouseDown {
                    button: 0,
                    x: loc.x,
                    y: loc.y,
                }
            }
            NSEventType::LeftMouseUp => {
                let loc = event.locationInWindow();
                MacOSEvent::MouseUp {
                    button: 0,
                    x: loc.x,
                    y: loc.y,
                }
            }
            NSEventType::RightMouseDown => {
                let loc = event.locationInWindow();
                MacOSEvent::MouseDown {
                    button: 1,
                    x: loc.x,
                    y: loc.y,
                }
            }
            NSEventType::RightMouseUp => {
                let loc = event.locationInWindow();
                MacOSEvent::MouseUp {
                    button: 1,
                    x: loc.x,
                    y: loc.y,
                }
            }
            NSEventType::MouseMoved => {
                let loc = event.locationInWindow();
                MacOSEvent::MouseMove { x: loc.x, y: loc.y }
            }
            NSEventType::KeyDown => MacOSEvent::KeyDown {
                key_code: event.keyCode(),
            },
            NSEventType::KeyUp => MacOSEvent::KeyUp {
                key_code: event.keyCode(),
            },
            _ => MacOSEvent::Other,
        }
    }
}

impl MacOSWindow {
    // NSResponder Undo/Redo Integration (macOS Native)

    /// Perform undo operation (called by NSResponder undo: selector)
    pub fn perform_undo(&mut self) {
        // Get focused node for undo context
        let focused_node = if let Some(layout_window) = self.layout_window.as_ref() {
            layout_window.focus_manager.get_focused_node().copied()
        } else {
            return;
        };

        let target = match focused_node {
            Some(node) => node,
            None => return, // No focused node
        };

        // Get layout window
        let layout_window = match self.layout_window.as_mut() {
            Some(lw) => lw,
            None => return,
        };

        // Convert DomNodeId to NodeId using proper decoding
        let node_id = match target.node.into_crate_internal() {
            Some(id) => id,
            None => return,
        };

        // Pop from undo stack
        if let Some(operation) = layout_window.undo_redo_manager.pop_undo(node_id) {
            // Apply the revert - restore pre-state text
            if let Some(node_id_internal) = target.node.into_crate_internal() {
                // Create InlineContent from pre-state text
                use std::sync::Arc;

                use azul_layout::text3::cache::{InlineContent, StyleProperties, StyledRun};

                let new_content = vec![InlineContent::Text(StyledRun {
                    text: operation.pre_state.text_content.as_str().to_string(),
                    style: Arc::new(StyleProperties::default()),
                    logical_start_byte: 0,
                    source_node_id: None, // Undo operation - node context not available
                })];

                // Update text cache with pre-state content
                layout_window.update_text_cache_after_edit(
                    target.dom,
                    node_id_internal,
                    new_content,
                );

                // Restore cursor position
                if let Some(cursor) = operation.pre_state.cursor_position.into_option() {
                    layout_window.cursor_manager.move_cursor_to(
                        cursor,
                        target.dom,
                        node_id_internal,
                    );
                }
            }

            // Push to redo stack after successful undo
            layout_window.undo_redo_manager.push_redo(operation);

            // Mark window for redraw
            unsafe {
                use objc2::msg_send;
                let _: () = msg_send![&*self.window, setViewsNeedDisplay: true];
            }
        }
    }

    /// Perform redo operation (called by NSResponder redo: selector)
    pub fn perform_redo(&mut self) {
        // Get focused node for redo context
        let focused_node = if let Some(layout_window) = self.layout_window.as_ref() {
            layout_window.focus_manager.get_focused_node().copied()
        } else {
            return;
        };

        let target = match focused_node {
            Some(node) => node,
            None => return, // No focused node
        };

        // Get layout window
        let layout_window = match self.layout_window.as_mut() {
            Some(lw) => lw,
            None => return,
        };

        // Convert DomNodeId to NodeId using proper decoding
        let node_id = match target.node.into_crate_internal() {
            Some(id) => id,
            None => return,
        };

        // Pop from redo stack
        if let Some(operation) = layout_window.undo_redo_manager.pop_redo(node_id) {
            // Re-apply the original operation via text input
            let node_id_internal = target.node.into_crate_internal();
            if let Some(_node_id_internal) = node_id_internal {
                use azul_layout::managers::changeset::TextOperation;

                match &operation.changeset.operation {
                    TextOperation::InsertText(op) => {
                        // Re-insert the text
                        let _ = layout_window.process_text_input(&op.text);
                    }
                    _ => {
                        // Other operations not yet fully supported
                    }
                }
            }

            // Push to undo stack after successful redo
            layout_window.undo_redo_manager.push_undo(operation);

            // Mark window for redraw
            unsafe {
                use objc2::msg_send;
                let _: () = msg_send![&*self.window, setViewsNeedDisplay: true];
            }
        }
    }

    /// Check if undo is available (for menu validation)
    pub fn can_undo(&self) -> bool {
        if let Some(layout_window) = self.layout_window.as_ref() {
            if let Some(focused_node) = layout_window.focus_manager.get_focused_node() {
                if let Some(node_id) = focused_node.node.into_crate_internal() {
                    return layout_window.undo_redo_manager.can_undo(node_id);
                }
            }
        }
        false
    }

    /// Check if redo is available (for menu validation)
    pub fn can_redo(&self) -> bool {
        if let Some(layout_window) = self.layout_window.as_ref() {
            if let Some(focused_node) = layout_window.focus_manager.get_focused_node() {
                if let Some(node_id) = focused_node.node.into_crate_internal() {
                    return layout_window.undo_redo_manager.can_redo(node_id);
                }
            }
        }
        false
    }

    // Accessibility Support

    /// Initialize accessibility support for the window
    ///
    /// This should be called once after the first layout pass to set up
    /// the accesskit adapter with the initial accessibility tree.
    #[cfg(feature = "a11y")]
    fn init_accessibility(&mut self) {
        if self.accessibility_adapter.is_some() {
            return; // Already initialized
        }

        let layout_window = match self.layout_window.as_ref() {
            Some(lw) => lw,
            None => {
                log_warn!(
                    LogCategory::Platform,
                    "[a11y] Cannot initialize: no layout window"
                );
                return;
            }
        };

        // Get the root NSView (either GL or CPU view)
        let view_ptr = if let Some(gl_view) = self.gl_view.as_ref() {
            Retained::<GLView>::as_ptr(gl_view) as *mut std::ffi::c_void
        } else if let Some(cpu_view) = self.cpu_view.as_ref() {
            Retained::<CPUView>::as_ptr(cpu_view) as *mut std::ffi::c_void
        } else {
            log_warn!(
                LogCategory::Platform,
                "[a11y] Cannot initialize: no view available"
            );
            return;
        };

        // Create the adapter
        let adapter = accessibility::MacOSAccessibilityAdapter::new(view_ptr);
        self.accessibility_adapter = Some(adapter);

        // Update with initial tree
        self.update_accessibility();

        log_debug!(
            LogCategory::Platform,
            "[a11y] Accessibility adapter initialized"
        );
    }

    /// Update accessibility tree after layout changes
    ///
    /// This should be called after regenerate_layout() to keep the
    /// accessibility tree synchronized with the visual representation.
    #[cfg(feature = "a11y")]
    fn update_accessibility(&mut self) {
        let adapter = match self.accessibility_adapter.as_mut() {
            Some(a) => a,
            None => return, // Not initialized yet
        };

        let layout_window = match self.layout_window.as_ref() {
            Some(lw) => lw,
            None => return,
        };

        // Generate tree update from current layout
        let tree_update = azul_layout::managers::a11y::A11yManager::update_tree(
            layout_window.a11y_manager.root_id,
            &layout_window.layout_results,
            &self.current_window_state.title,
            self.current_window_state.size.dimensions,
        );

        // Submit to OS
        adapter.update_tree(tree_update);
    }

    /// Poll for accessibility action requests from assistive technologies
    ///
    /// This should be called in the event loop to check if screen readers
    /// have requested any actions (focus, click, scroll, etc.)
    #[cfg(feature = "a11y")]
    pub fn poll_accessibility_actions(
        &mut self,
    ) -> Vec<(
        DomId,
        azul_core::dom::NodeId,
        azul_core::dom::AccessibilityAction,
    )> {
        let adapter = match self.accessibility_adapter.as_ref() {
            Some(a) => a,
            None => return Vec::new(),
        };

        let mut actions = Vec::new();
        while let Some(action) = adapter.poll_action() {
            actions.push(action);
        }
        actions
    }

    /// Inject a menu bar into the window
    ///
    /// On macOS, this creates a native NSMenu hierarchy attached to the application.
    /// Menu callbacks are wired up to trigger when menu items are clicked.
    ///
    /// # Implementation
    /// This method is deprecated in favor of `set_application_menu()` which provides
    /// a complete NSMenu implementation with callback integration.
    ///
    /// # Returns
    /// * `Ok(())` if menu injection succeeded
    /// * `Err(String)` if menu injection failed
    pub fn inject_menu_bar(&mut self) -> Result<(), String> {
        // Native macOS menu integration is fully implemented via set_application_menu()
        // See menu.rs for AzulMenuTarget bridge and MenuState implementation
        log_debug!(
            LogCategory::Window,
            "[inject_menu_bar] Use set_application_menu() for native macOS menus"
        );
        Ok(())
    }

    /// Gets information about the screen the window is currently on.
    pub fn get_screen_info(&self) -> Option<objc2::rc::Retained<objc2_app_kit::NSScreen>> {
        self.window.screen()
    }

    /// Returns the frame of the window in screen coordinates.
    pub fn get_window_frame(&self) -> objc2_foundation::NSRect {
        self.window.frame()
    }

    /// Returns the DPI scale factor for the window.
    pub fn get_backing_scale_factor(&self) -> f64 {
        self.window.backingScaleFactor()
    }

    /// Get display information for the screen this window is on
    pub fn get_window_display_info(&self) -> Option<crate::desktop::display::DisplayInfo> {
        use azul_core::geom::{LogicalPosition, LogicalRect, LogicalSize};

        let screen = self.get_screen_info()?;
        let frame = screen.frame();
        let visible_frame = screen.visibleFrame();
        let scale = screen.backingScaleFactor();

        let bounds = LogicalRect::new(
            LogicalPosition::new(frame.origin.x as f32, frame.origin.y as f32),
            LogicalSize::new(frame.size.width as f32, frame.size.height as f32),
        );

        let work_area = LogicalRect::new(
            LogicalPosition::new(visible_frame.origin.x as f32, visible_frame.origin.y as f32),
            LogicalSize::new(
                visible_frame.size.width as f32,
                visible_frame.size.height as f32,
            ),
        );

        // Get refresh rate from NSScreen (macOS 10.15+)
        let refresh_rate = unsafe {
            use objc2::msg_send;
            let fps: f64 = msg_send![&**screen, maximumFramesPerSecond];
            if fps > 0.0 {
                fps as u16
            } else {
                60
            }
        };

        Some(crate::desktop::display::DisplayInfo {
            name: screen.localizedName().to_string(),
            bounds,
            work_area,
            scale_factor: scale as f32,
            is_primary: false, // Would need to check if this is the main screen
            video_modes: vec![azul_core::window::VideoMode {
                size: azul_css::props::basic::LayoutSize::new(
                    bounds.size.width as isize,
                    bounds.size.height as isize,
                ),
                bit_depth: 32,
                refresh_rate,
            }],
        })
    }
}

/// Position window on requested monitor, or center on primary monitor
fn position_window_on_monitor(
    window: &Retained<NSWindow>,
    monitor_id: azul_core::window::MonitorId,
    position: azul_core::window::WindowPosition,
    size: azul_core::window::WindowSize,
    mtm: MainThreadMarker,
) {
    use azul_core::window::WindowPosition;
    use objc2_app_kit::NSScreen;

    use crate::desktop::display::get_monitors;

    // Get all available monitors
    let monitors = get_monitors();
    if monitors.len() == 0 {
        unsafe {
            window.center();
        }
        return; // No monitors available, use default centering
    }

    // Get all NSScreens
    let screens = unsafe { NSScreen::screens(mtm) };
    if screens.len() == 0 {
        unsafe {
            window.center();
        }
        return;
    }

    // Determine target monitor
    let target_monitor = monitors
        .as_slice()
        .iter()
        .find(|m| m.monitor_id.index == monitor_id.index)
        .or_else(|| {
            monitors
                .as_slice()
                .iter()
                .find(|m| m.monitor_id.hash == monitor_id.hash && monitor_id.hash != 0)
        })
        .unwrap_or(&monitors.as_slice()[0]); // Fallback to primary

    // Find matching NSScreen by bounds
    let target_screen = unsafe {
        screens
            .iter()
            .find(|screen| {
                let frame = screen.frame();
                (frame.origin.x as isize - target_monitor.position.x).abs() < 10
                    && (frame.origin.y as isize - target_monitor.position.y).abs() < 10
            })
            .unwrap_or_else(|| screens.objectAtIndex(0))
    };

    // Calculate window position
    let screen_frame = unsafe { target_screen.frame() };
    let window_frame = unsafe { window.frame() };

    let (x, y) = match position {
        WindowPosition::Initialized(pos) => {
            // Explicit position requested - use it relative to monitor
            // Note: macOS y-axis is flipped (0 at bottom)
            (
                screen_frame.origin.x + pos.x as f64,
                screen_frame.origin.y + pos.y as f64,
            )
        }
        WindowPosition::Uninitialized => {
            // No explicit position - center on target monitor
            let center_x =
                screen_frame.origin.x + (screen_frame.size.width - window_frame.size.width) / 2.0;
            let center_y =
                screen_frame.origin.y + (screen_frame.size.height - window_frame.size.height) / 2.0;
            (center_x, center_y)
        }
    };

    // Set window frame with new position
    use objc2_foundation::NSRect;
    let new_frame = NSRect {
        origin: objc2_foundation::NSPoint { x, y },
        size: window_frame.size,
    };

    unsafe {
        window.setFrame_display(new_frame, false);
    }
}

// IME Position Management

impl MacOSWindow {
    /// Sync ime_position from window state to OS
    /// On macOS, the IME position is provided via firstRectForCharacterRange,
    /// which is called by the system when needed. We just need to ensure
    /// ime_position is set in window state, and the NSTextInputClient
    /// protocol implementation will return it.
    pub fn sync_ime_position_to_os(&self) {
        use azul_core::window::ImePosition;

        // On macOS, no explicit API call needed
        // The system will call firstRectForCharacterRange: when it needs
        // the IME candidate window position, and we return ime_position there

        // However, we can invalidate the marked text to trigger a refresh
        // if we want to force the IME window to update immediately
        if matches!(
            self.current_window_state.ime_position,
            ImePosition::Initialized(_)
        ) {
            // TODO: Could call invalidateMarkable or similar if needed
            // For now, passive approach is sufficient
        }
    }
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/registry.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! Window registry for multi-window support on macOS
//!
//! This module provides a centralized registry for managing multiple macOS windows.
//! Uses thread-local storage for simplicity and to avoid complex Rc<RefCell> patterns.
//! Based on the Windows registry implementation.

use std::{cell::RefCell, collections::BTreeMap};

use objc2::runtime::AnyObject;

use super::super::common::debug_server::LogCategory;
use crate::{log_debug, log_error, log_info, log_trace, log_warn};

thread_local! {
    /// Thread-local registry of all active windows (NSWindow -> raw pointer)
    ///
    /// SAFETY: Pointers are valid for the lifetime of the window.
    /// Windows are created and destroyed on the same thread (main thread).
    static WINDOW_REGISTRY: RefCell<WindowRegistry> = RefCell::new(WindowRegistry::new());
}

/// Window ID wrapper for type safety
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct WindowId {
    /// Pointer to NSWindow object (used as unique identifier)
    pub ns_window: *mut AnyObject,
}

impl WindowId {
    pub fn from_ns_window(ns_window: *mut AnyObject) -> Self {
        Self { ns_window }
    }

    pub fn as_i64(&self) -> i64 {
        self.ns_window as i64
    }
}

/// Registry of active windows for the current thread (main thread)
struct WindowRegistry {
    /// Map of NSWindow pointer to raw MacOSWindow pointer
    /// SAFETY: Pointers must remain valid while in the map
    windows: BTreeMap<*mut AnyObject, *mut super::MacOSWindow>,
}

impl WindowRegistry {
    fn new() -> Self {
        Self {
            windows: BTreeMap::new(),
        }
    }

    fn add(&mut self, ns_window: *mut AnyObject, window_ptr: *mut super::MacOSWindow) {
        self.windows.insert(ns_window, window_ptr);
    }

    fn remove(&mut self, ns_window: *mut AnyObject) -> Option<*mut super::MacOSWindow> {
        self.windows.remove(&ns_window)
    }

    fn get(&self, ns_window: *mut AnyObject) -> Option<*mut super::MacOSWindow> {
        self.windows.get(&ns_window).copied()
    }

    fn get_all_ns_windows(&self) -> Vec<*mut AnyObject> {
        self.windows.keys().copied().collect()
    }

    fn get_all_window_ptrs(&self) -> Vec<*mut super::MacOSWindow> {
        self.windows.values().copied().collect()
    }

    fn is_empty(&self) -> bool {
        self.windows.is_empty()
    }

    fn len(&self) -> usize {
        self.windows.len()
    }
}

/// Add a window to the global registry
///
/// SAFETY: window_ptr must be valid for the lifetime of the window
pub unsafe fn register_window(ns_window: *mut AnyObject, window_ptr: *mut super::MacOSWindow) {
    WINDOW_REGISTRY.with(|registry| {
        registry.borrow_mut().add(ns_window, window_ptr);
    });
    log_debug!(
        LogCategory::Window,
        "[macOS Registry] Registered window {:p} -> {:p} (total: {})",
        ns_window,
        window_ptr,
        window_count()
    );
}

/// Remove a window from the global registry
pub fn unregister_window(ns_window: *mut AnyObject) -> Option<*mut super::MacOSWindow> {
    let result = WINDOW_REGISTRY.with(|registry| registry.borrow_mut().remove(ns_window));
    log_debug!(
        LogCategory::Window,
        "[macOS Registry] Unregistered window {:p} (total: {})",
        ns_window,
        window_count()
    );
    result
}

/// Get a window pointer from the registry
///
/// Returns None if window is not registered
pub fn get_window(ns_window: *mut AnyObject) -> Option<*mut super::MacOSWindow> {
    WINDOW_REGISTRY.with(|registry| registry.borrow().get(ns_window))
}

/// Get all registered NSWindow pointers
pub fn get_all_ns_window_handles() -> Vec<*mut AnyObject> {
    WINDOW_REGISTRY.with(|registry| registry.borrow().get_all_ns_windows())
}

/// Get all registered MacOSWindow pointers
pub fn get_all_window_ptrs() -> Vec<*mut super::MacOSWindow> {
    WINDOW_REGISTRY.with(|registry| registry.borrow().get_all_window_ptrs())
}

/// Check if registry is empty
pub fn is_empty() -> bool {
    WINDOW_REGISTRY.with(|registry| registry.borrow().is_empty())
}

/// Get number of registered windows
pub fn window_count() -> usize {
    WINDOW_REGISTRY.with(|registry| registry.borrow().len())
}

```

================================================================================
## FILE: dll/src/desktop/shell2/macos/tooltip.rs
## Description: macOS window, events, NSTextInputClient
================================================================================
```
//! macOS tooltip implementation using NSPanel.
//!
//! This module provides a native macOS tooltip system using NSPanel
//! with NSTextField for displaying tooltip text. The tooltip follows
//! the macOS style guidelines with proper shadow and appearance.
//!
//! Architecture:
//! - TooltipWindow: Wrapper around NSPanel and NSTextField
//! - Lifecycle: Create once, show/hide as needed
//! - Positioning: Uses NSWindow setFrameTopLeftPoint for absolute positioning

use azul_core::{geom::LogicalPosition, resources::DpiScaleFactor};
use objc2::{msg_send_id, rc::Retained, runtime::ProtocolObject, sel};
use objc2_app_kit::{
    NSBorderlessWindowMask, NSColor, NSPanel, NSTextField, NSUtilityWindowMask, NSView, NSWindow,
    NSWindowStyleMask,
};
use objc2_foundation::{MainThreadMarker, NSPoint, NSRect, NSSize, NSString};

/// Wrapper for a macOS tooltip panel
pub struct TooltipWindow {
    /// Tooltip panel (borderless utility window)
    panel: Retained<NSPanel>,
    /// Text field for displaying tooltip text
    text_field: Retained<NSTextField>,
    /// Main thread marker for AppKit operations
    mtm: MainThreadMarker,
    /// Is tooltip currently visible
    is_visible: bool,
}

impl TooltipWindow {
    /// Create a new tooltip window
    ///
    /// Creates an NSPanel with NSTextField for tooltip display.
    /// The panel is initially hidden and can be shown with `show()`.
    pub fn new(mtm: MainThreadMarker) -> Result<Self, String> {
        unsafe {
            // Create panel with utility window style and no title bar
            let style_mask = NSBorderlessWindowMask.0 | NSUtilityWindowMask.0;

            let panel = NSPanel::initWithContentRect_styleMask_backing_defer(
                mtm.alloc(),
                NSRect::new(NSPoint::new(0.0, 0.0), NSSize::new(200.0, 30.0)),
                NSWindowStyleMask(style_mask),
                objc2_app_kit::NSBackingStoreType::Buffered,
                false,
            );

            // Configure panel appearance
            panel.setFloatingPanel(true);
            panel.setHidesOnDeactivate(false);
            panel.setOpaque(false);
            panel.setHasShadow(true);
            panel.setLevel(objc2_app_kit::NSPopUpMenuWindowLevel);

            // Set background color to tooltip yellow
            let bg_color = NSColor::colorWithRed_green_blue_alpha(
                1.0,  // Red
                1.0,  // Green
                0.85, // Blue (slightly yellow)
                0.95, // Alpha
            );
            panel.setBackgroundColor(Some(&bg_color));

            // Create text field for tooltip text
            let text_field = NSTextField::initWithFrame(
                mtm.alloc(),
                NSRect::new(NSPoint::new(5.0, 5.0), NSSize::new(190.0, 20.0)),
            );
            text_field.setBezeled(false);
            text_field.setDrawsBackground(false);
            text_field.setEditable(false);
            text_field.setSelectable(false);

            // Set text color to black
            let text_color = NSColor::blackColor();
            text_field.setTextColor(Some(&text_color));

            // Add text field to panel's content view
            if let Some(content_view) = panel.contentView() {
                content_view.addSubview(&text_field);
            }

            Ok(Self {
                panel,
                text_field,
                mtm,
                is_visible: false,
            })
        }
    }

    /// Show tooltip with text at the given position
    ///
    /// If tooltip is already visible, updates text and position.
    /// Position is in logical coordinates (will be converted to screen coordinates).
    pub fn show(
        &mut self,
        text: &str,
        position: LogicalPosition,
        dpi_factor: DpiScaleFactor,
    ) -> Result<(), String> {
        unsafe {
            // Convert text to NSString
            let ns_text = NSString::from_str(text);
            self.text_field.setStringValue(&ns_text);

            // Calculate text size for proper panel sizing
            let text_width = text.len() as f64 * 7.0 + 10.0; // Rough estimate: 7px per char
            let text_width = text_width.min(400.0).max(50.0); // Clamp between 50-400px
            let text_height = 25.0;

            // Update panel and text field sizes
            let panel_frame =
                NSRect::new(NSPoint::new(0.0, 0.0), NSSize::new(text_width, text_height));
            self.panel.setFrame_display(panel_frame, false);

            let text_field_frame = NSRect::new(
                NSPoint::new(5.0, 2.0),
                NSSize::new(text_width - 10.0, text_height - 4.0),
            );
            self.text_field.setFrame(text_field_frame);

            // Convert position to screen coordinates
            // macOS uses bottom-left origin, so we need to flip Y
            let screen_height =
                if let Some(main_screen) = objc2_app_kit::NSScreen::mainScreen(self.mtm) {
                    main_screen.frame().size.height
                } else {
                    1080.0 // Fallback
                };

            let physical_pos = position.to_physical(dpi_factor.inner.get());
            let screen_x = physical_pos.x as f64;
            let screen_y = screen_height - physical_pos.y as f64 - text_height;

            // Set panel position (top-left point)
            self.panel
                .setFrameTopLeftPoint(NSPoint::new(screen_x, screen_y + text_height));

            // Show panel
            self.panel.orderFront(None);
            self.is_visible = true;

            Ok(())
        }
    }

    /// Hide the tooltip
    ///
    /// Removes the tooltip panel from screen without destroying it.
    /// Can be shown again with `show()`.
    pub fn hide(&mut self) -> Result<(), String> {
        if !self.is_visible {
            return Ok(());
        }

        unsafe {
            self.panel.orderOut(None);
            self.is_visible = false;
        }

        Ok(())
    }

    /// Check if tooltip is currently visible
    pub fn is_visible(&self) -> bool {
        self.is_visible
    }
}

impl Drop for TooltipWindow {
    fn drop(&mut self) {
        unsafe {
            self.panel.close();
        }
    }
}

```

### PLATFORM WINDOW ABSTRACTION

### EVENT HANDLING

### LAYOUT WINDOW

================================================================================
## FILE: layout/src/window.rs
## Description: Window with focus/cursor management
================================================================================
```
//! Window layout management for solver3/text3
//!
//! This module provides the high-level API for managing layout
//! state across frames, including caching, incremental updates,
//! and display list generation.
//!
//! The main entry point is `LayoutWindow`, which encapsulates all
//! the state needed to perform layout and maintain consistency
//! across window resizes and DOM updates.

use std::{
    collections::{BTreeMap, BTreeSet},
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
};

use azul_core::{
    animation::UpdateImageType,
    callbacks::{FocusTarget, HidpiAdjustedBounds, IFrameCallbackReason, Update},
    dom::{
        AccessibilityAction, AttributeType, Dom, DomId, DomIdVec, DomNodeId, NodeId, NodeType, On,
    },
    events::{EasingFunction, EventFilter, FocusEventFilter, HoverEventFilter},
    geom::{LogicalPosition, LogicalRect, LogicalSize, OptionLogicalPosition},
    gl::OptionGlContextPtr,
    gpu::{GpuScrollbarOpacityEvent, GpuValueCache},
    hit_test::{DocumentId, ScrollPosition, ScrollbarHitId},
    refany::{OptionRefAny, RefAny},
    resources::{
        Epoch, FontKey, GlTextureCache, IdNamespace, ImageCache, ImageMask, ImageRef, ImageRefHash,
        OpacityKey, RendererResources,
    },
    selection::{
        CursorAffinity, GraphemeClusterId, Selection, SelectionAnchor, SelectionFocus,
        SelectionRange, SelectionState, TextCursor, TextSelection,
    },
    styled_dom::{
        collect_nodes_in_document_order, is_before_in_document_order, NodeHierarchyItemId,
        StyledDom,
    },
    task::{
        Duration, Instant, SystemTickDiff, SystemTimeDiff, TerminateTimer, ThreadId, ThreadIdVec,
        ThreadSendMsg, TimerId, TimerIdVec,
    },
    window::{CursorPosition, RawWindowHandle, RendererType},
    FastBTreeSet, FastHashMap,
};
use azul_css::{
    css::Css,
    props::{
        basic::FontRef,
        property::{CssProperty, CssPropertyVec},
    },
    AzString, LayoutDebugMessage, OptionString,
};
use rust_fontconfig::FcFontCache;

#[cfg(feature = "icu")]
use crate::icu::IcuLocalizerHandle;
use crate::{
    callbacks::{
        CallCallbacksResult, Callback, ExternalSystemCallbacks, FocusUpdateRequest, MenuCallback,
    },
    managers::{
        gpu_state::GpuStateManager,
        iframe::IFrameManager,
        scroll_state::{ScrollManager, ScrollStates},
    },
    solver3::{
        self, cache::LayoutCache as Solver3LayoutCache, display_list::DisplayList,
        layout_tree::LayoutTree,
    },
    text3::{
        cache::{
            FontManager, FontSelector, FontStyle, InlineContent, LayoutCache as TextLayoutCache,
            LayoutError, ShapedItem, StyleProperties, StyledRun, TextBoundary, UnifiedConstraints,
            UnifiedLayout,
        },
        default::PathLoader,
    },
    thread::{OptionThreadReceiveMsg, Thread, ThreadReceiveMsg, ThreadWriteBackMsg},
    timer::Timer,
    window_state::{FullWindowState, WindowCreateOptions},
};

// Global atomic counters for generating unique IDs
static DOCUMENT_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
static ID_NAMESPACE_COUNTER: AtomicUsize = AtomicUsize::new(0);

/// Helper function to create a unique DocumentId
fn new_document_id() -> DocumentId {
    let namespace_id = new_id_namespace();
    let id = DOCUMENT_ID_COUNTER.fetch_add(1, Ordering::Relaxed) as u32;
    DocumentId { namespace_id, id }
}

/// Direction for cursor navigation
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum CursorNavigationDirection {
    /// Move cursor up one line
    Up,
    /// Move cursor down one line
    Down,
    /// Move cursor left one character
    Left,
    /// Move cursor right one character
    Right,
    /// Move cursor to start of current line
    LineStart,
    /// Move cursor to end of current line
    LineEnd,
    /// Move cursor to start of document
    DocumentStart,
    /// Move cursor to end of document
    DocumentEnd,
}

/// Result of a cursor movement operation
#[derive(Debug, Clone)]
pub enum CursorMovementResult {
    /// Cursor moved within the same text node
    MovedWithinNode(TextCursor),
    /// Cursor moved to a different text node
    MovedToNode {
        dom_id: DomId,
        node_id: NodeId,
        cursor: TextCursor,
    },
    /// Cursor is at a boundary and cannot move further
    AtBoundary {
        boundary: TextBoundary,
        cursor: TextCursor,
    },
}

/// Error when no cursor destination is available
#[derive(Debug, Clone)]
pub struct NoCursorDestination {
    pub reason: String,
}

/// Action to take for the cursor blink timer when focus changes
///
/// This enum is returned by `LayoutWindow::handle_focus_change_for_cursor_blink()`
/// to tell the platform layer what timer action to take.
#[derive(Debug, Clone)]
pub enum CursorBlinkTimerAction {
    /// Start the cursor blink timer with the given timer configuration
    Start(crate::timer::Timer),
    /// Stop the cursor blink timer
    Stop,
    /// No change needed (timer already in correct state)
    NoChange,
}

/// Helper function to create a unique IdNamespace
fn new_id_namespace() -> IdNamespace {
    let id = ID_NAMESPACE_COUNTER.fetch_add(1, Ordering::Relaxed) as u32;
    IdNamespace(id)
}

// ============================================================================
// Cursor Blink Timer Callback
// ============================================================================

/// Destructor for cursor blink timer RefAny (no-op since we use null pointer)
extern "C" fn cursor_blink_timer_destructor(_: RefAny) {
    // No cleanup needed - we use a null pointer RefAny
}

/// Callback for the cursor blink timer
///
/// This function is called every ~530ms to toggle cursor visibility.
/// It checks if enough time has passed since the last user input before blinking,
/// to avoid blinking while the user is actively typing.
///
/// The callback returns:
/// - `TerminateTimer::Continue` + `Update::RefreshDom` if cursor toggled
/// - `TerminateTimer::Terminate` if focus is no longer on a contenteditable element
pub extern "C" fn cursor_blink_timer_callback(
    _data: RefAny,
    mut info: crate::timer::TimerCallbackInfo,
) -> azul_core::callbacks::TimerCallbackReturn {
    use azul_core::callbacks::{TimerCallbackReturn, Update};
    use azul_core::task::TerminateTimer;
    
    // Get current time
    let now = info.get_current_time();
    
    // We need to access the LayoutWindow through the info
    // The timer callback needs to:
    // 1. Check if focus is still on a contenteditable element
    // 2. Check time since last input
    // 3. Toggle visibility or keep solid
    
    // For now, we'll queue changes via the CallbackInfo system
    // The actual state modification happens in apply_callback_changes
    
    // Check if we should blink or stay solid
    // This is done by checking CursorManager.should_blink(now) in the layout window
    
    // Since we can't access LayoutWindow directly here (it's not passed to timer callbacks),
    // we use a different approach: the timer callback always toggles, and the visibility
    // check is done in display_list.rs based on CursorManager state.
    
    // Simply toggle cursor visibility
    info.set_cursor_visibility_toggle();
    
    // Continue the timer and request a redraw
    TimerCallbackReturn {
        should_update: Update::RefreshDom,
        should_terminate: TerminateTimer::Continue,
    }
}

/// Result of a layout pass for a single DOM, before display list generation
#[derive(Debug)]
pub struct DomLayoutResult {
    /// The styled DOM that was laid out
    pub styled_dom: StyledDom,
    /// The layout tree with computed sizes and positions
    pub layout_tree: LayoutTree,
    /// Absolute positions of all nodes
    pub calculated_positions: BTreeMap<usize, LogicalPosition>,
    /// The viewport used for this layout
    pub viewport: LogicalRect,
    /// The generated display list for this DOM.
    pub display_list: DisplayList,
    /// Stable scroll IDs computed from node_data_hash
    /// Maps layout node index -> external scroll ID
    pub scroll_ids: BTreeMap<usize, u64>,
    /// Mapping from scroll IDs to DOM NodeIds for hit testing
    /// This allows us to map WebRender scroll IDs back to DOM nodes
    pub scroll_id_to_node_id: BTreeMap<u64, NodeId>,
}

/// State for tracking scrollbar drag interaction
#[derive(Debug, Clone)]
pub struct ScrollbarDragState {
    pub hit_id: ScrollbarHitId,
    pub initial_mouse_pos: LogicalPosition,
    pub initial_scroll_offset: LogicalPosition,
}

/// Information about the last text edit operation
/// Allows callbacks to query what changed during text input
// Re-export PendingTextEdit from text_input manager
pub use crate::managers::text_input::PendingTextEdit;

/// Cached text layout constraints for a node
/// These are the layout parameters that were used to shape the text
#[derive(Debug, Clone)]
pub struct TextConstraintsCache {
    /// Map from (dom_id, node_id) to their layout constraints
    pub constraints: BTreeMap<(DomId, NodeId), UnifiedConstraints>,
}

impl Default for TextConstraintsCache {
    fn default() -> Self {
        Self {
            constraints: BTreeMap::new(),
        }
    }
}

/// A text node that has been edited since the last full layout.
/// This allows us to perform lightweight relayout without rebuilding the entire DOM.
#[derive(Debug, Clone)]
pub struct DirtyTextNode {
    /// The new inline content (text + images) after editing
    pub content: Vec<InlineContent>,
    /// The new cursor position after editing
    pub cursor: Option<TextCursor>,
    /// Whether this edit requires ancestor relayout (e.g., text grew taller)
    pub needs_ancestor_relayout: bool,
}

/// Result of applying callback changes
///
/// This struct consolidates all the outputs from `apply_callback_changes()`,
/// eliminating the need for 18+ mutable reference parameters.
#[derive(Debug, Default)]
pub struct CallbackChangeResult {
    /// Timers to add
    pub timers: FastHashMap<TimerId, crate::timer::Timer>,
    /// Threads to add  
    pub threads: FastHashMap<ThreadId, crate::thread::Thread>,
    /// Timers to remove
    pub timers_removed: FastBTreeSet<TimerId>,
    /// Threads to remove
    pub threads_removed: FastBTreeSet<ThreadId>,
    /// New windows to create
    pub windows_created: Vec<crate::window_state::WindowCreateOptions>,
    /// Menus to open
    pub menus_to_open: Vec<(azul_core::menu::Menu, Option<LogicalPosition>)>,
    /// Tooltips to show
    pub tooltips_to_show: Vec<(AzString, LogicalPosition)>,
    /// Whether to hide tooltip
    pub hide_tooltip: bool,
    /// Whether stopPropagation() was called
    pub stop_propagation: bool,
    /// Whether preventDefault() was called
    pub prevent_default: bool,
    /// Focus target change
    pub focus_target: Option<FocusTarget>,
    /// Text changes that don't require full relayout
    pub words_changed: BTreeMap<DomId, BTreeMap<NodeId, AzString>>,
    /// Image changes (for animated images/video)
    pub images_changed: BTreeMap<DomId, BTreeMap<NodeId, (ImageRef, UpdateImageType)>>,
    /// Image callback nodes that need to be re-rendered (for resize/animations)
    /// Unlike images_changed, this triggers a callback re-invocation
    pub image_callbacks_changed: BTreeMap<DomId, FastBTreeSet<NodeId>>,
    /// IFrame nodes that need to be re-rendered (for content updates)
    /// This triggers the IFrame callback to be called with DomRecreated reason
    pub iframes_to_update: BTreeMap<DomId, FastBTreeSet<NodeId>>,
    /// Clip mask changes (for vector animations)
    pub image_masks_changed: BTreeMap<DomId, BTreeMap<NodeId, ImageMask>>,
    /// CSS property changes from callbacks
    pub css_properties_changed: BTreeMap<DomId, BTreeMap<NodeId, CssPropertyVec>>,
    /// Scroll position changes from callbacks
    pub nodes_scrolled: BTreeMap<DomId, BTreeMap<NodeHierarchyItemId, LogicalPosition>>,
    /// Modified window state
    pub modified_window_state: FullWindowState,
    /// Queued window states to apply in sequence (for simulating clicks, etc.)
    /// Each state will trigger separate event processing to detect state changes.
    pub queued_window_states: Vec<FullWindowState>,
    /// Hit test update requested at this position (for Debug API)
    /// When set, the shell layer should perform a hit test update before processing events
    pub hit_test_update_requested: Option<LogicalPosition>,
    /// Text input events triggered by CreateTextInput
    /// These need to be processed by the recursive event loop to invoke user callbacks
    pub text_input_triggered: Vec<(azul_core::dom::DomNodeId, Vec<azul_core::events::EventFilter>)>,
}

/// A window-level layout manager that encapsulates all layout state and caching.
///
/// This struct owns the layout and text caches, and provides methods dir_to:
/// - Perform initial layout
/// - Incrementally update layout on DOM changes
/// - Generate display lists for rendering
/// - Handle window resizes efficiently
/// - Manage multiple DOMs (for IFrames)
pub struct LayoutWindow {
    /// Fragmentation context for this window (continuous for screen, paged for print)
    #[cfg(feature = "pdf")]
    pub fragmentation_context: crate::paged::FragmentationContext,
    /// Layout cache for solver3 (incremental layout tree) - for the root DOM
    pub layout_cache: Solver3LayoutCache,
    /// Text layout cache for text3 (shaped glyphs, line breaks, etc.)
    pub text_cache: TextLayoutCache,
    /// Font manager for loading and caching fonts
    pub font_manager: FontManager<FontRef>,
    /// Cache to store decoded images
    pub image_cache: ImageCache,
    /// Cached layout results for all DOMs (root + iframes)
    pub layout_results: BTreeMap<DomId, DomLayoutResult>,
    /// Scroll state manager for all nodes across all DOMs
    pub scroll_manager: ScrollManager,
    /// Gesture and drag manager for multi-frame interactions (moved from FullWindowState)
    pub gesture_drag_manager: crate::managers::gesture::GestureAndDragManager,
    /// Focus manager for keyboard focus and tab navigation
    pub focus_manager: crate::managers::focus_cursor::FocusManager,
    /// Cursor manager for text cursor position and rendering
    pub cursor_manager: crate::managers::cursor::CursorManager,
    /// File drop manager for cursor state and file drag-drop
    pub file_drop_manager: crate::managers::file_drop::FileDropManager,
    /// Selection manager for text selections across all DOMs
    pub selection_manager: crate::managers::selection::SelectionManager,
    /// Clipboard manager for system clipboard integration
    pub clipboard_manager: crate::managers::clipboard::ClipboardManager,
    /// Drag-drop manager for node and file dragging operations
    pub drag_drop_manager: crate::managers::drag_drop::DragDropManager,
    /// Hover manager for tracking hit test history over multiple frames
    pub hover_manager: crate::managers::hover::HoverManager,
    /// IFrame manager for all nodes across all DOMs
    pub iframe_manager: IFrameManager,
    /// GPU state manager for all nodes across all DOMs
    pub gpu_state_manager: GpuStateManager,
    /// Accessibility manager for screen reader support
    pub a11y_manager: crate::managers::a11y::A11yManager,
    /// Timers associated with this window
    pub timers: BTreeMap<TimerId, Timer>,
    /// Threads running in the background for this window
    pub threads: BTreeMap<ThreadId, Thread>,
    /// Currently loaded fonts and images present in this renderer (window)
    pub renderer_resources: RendererResources,
    /// Renderer type: Hardware-with-software-fallback, pure software or pure hardware renderer?
    pub renderer_type: Option<RendererType>,
    /// Windows state of the window of (current frame - 1): initialized to None on startup
    pub previous_window_state: Option<FullWindowState>,
    /// Window state of this current window (current frame): initialized to the state of
    /// WindowCreateOptions
    pub current_window_state: FullWindowState,
    /// A "document" in WebRender usually corresponds to one tab (i.e. in Azuls case, the whole
    /// window).
    pub document_id: DocumentId,
    /// ID namespace under which every font / image for this window is registered
    pub id_namespace: IdNamespace,
    /// The "epoch" is a frame counter, to remove outdated images, fonts and OpenGL textures when
    /// they're not in use anymore.
    pub epoch: Epoch,
    /// Currently GL textures inside the active CachedDisplayList
    pub gl_texture_cache: GlTextureCache,
    /// State for tracking scrollbar drag interaction
    currently_dragging_thumb: Option<ScrollbarDragState>,
    /// Text input manager - centralizes all text editing logic
    pub text_input_manager: crate::managers::text_input::TextInputManager,
    /// Undo/Redo manager for text editing operations
    pub undo_redo_manager: crate::managers::undo_redo::UndoRedoManager,
    /// Cached text layout constraints for each node
    /// This allows us to re-layout text with the same constraints after edits
    text_constraints_cache: TextConstraintsCache,
    /// Tracks which nodes have been edited since last full layout.
    /// Key: (DomId, NodeId of IFC root)
    /// Value: The edited inline content that should be used for relayout
    dirty_text_nodes: BTreeMap<(DomId, NodeId), DirtyTextNode>,
    /// Pending IFrame updates from callbacks (processed in next frame)
    /// Map of DomId -> Set of NodeIds that need re-rendering
    pub pending_iframe_updates: BTreeMap<DomId, FastBTreeSet<NodeId>>,
    /// ICU4X localizer handle for internationalized formatting (numbers, dates, lists, plurals)
    /// Initialized from system language at startup, can be overridden
    #[cfg(feature = "icu")]
    pub icu_localizer: IcuLocalizerHandle,
}

fn default_duration_500ms() -> Duration {
    Duration::System(SystemTimeDiff::from_millis(500))
}

fn default_duration_200ms() -> Duration {
    Duration::System(SystemTimeDiff::from_millis(200))
}

/// Helper function to convert Duration to milliseconds
///
/// Duration is an enum with System (std::time::Duration) and Tick variants.
/// We need to handle both cases for proper time calculations.
fn duration_to_millis(duration: Duration) -> u64 {
    match duration {
        #[cfg(feature = "std")]
        Duration::System(system_diff) => {
            let std_duration: std::time::Duration = system_diff.into();
            std_duration.as_millis() as u64
        }
        #[cfg(not(feature = "std"))]
        Duration::System(system_diff) => {
            // Manual calculation: secs * 1000 + nanos / 1_000_000
            system_diff.secs * 1000 + (system_diff.nanos / 1_000_000) as u64
        }
        Duration::Tick(tick_diff) => {
            // Assume tick = 1ms for simplicity (platform-specific)
            tick_diff.tick_diff
        }
    }
}

impl LayoutWindow {
    /// Create a new layout window with empty caches.
    ///
    /// For full initialization with WindowInternal compatibility, use `new_full()`.
    pub fn new(fc_cache: FcFontCache) -> Result<Self, crate::solver3::LayoutError> {
        Ok(Self {
            // Default width, will be updated on first layout
            #[cfg(feature = "pdf")]
            fragmentation_context: crate::paged::FragmentationContext::new_continuous(800.0),
            layout_cache: Solver3LayoutCache {
                tree: None,
                calculated_positions: BTreeMap::new(),
                viewport: None,
                scroll_ids: BTreeMap::new(),
                scroll_id_to_node_id: BTreeMap::new(),
                counters: BTreeMap::new(),
                float_cache: BTreeMap::new(),
            },
            text_cache: TextLayoutCache::new(),
            font_manager: FontManager::new(fc_cache)?,
            image_cache: ImageCache::default(),
            layout_results: BTreeMap::new(),
            scroll_manager: ScrollManager::new(),
            gesture_drag_manager: crate::managers::gesture::GestureAndDragManager::new(),
            focus_manager: crate::managers::focus_cursor::FocusManager::new(),
            cursor_manager: crate::managers::cursor::CursorManager::new(),
            file_drop_manager: crate::managers::file_drop::FileDropManager::new(),
            selection_manager: crate::managers::selection::SelectionManager::new(),
            clipboard_manager: crate::managers::clipboard::ClipboardManager::new(),
            drag_drop_manager: crate::managers::drag_drop::DragDropManager::new(),
            hover_manager: crate::managers::hover::HoverManager::new(),
            iframe_manager: IFrameManager::new(),
            gpu_state_manager: GpuStateManager::new(
                default_duration_500ms(),
                default_duration_200ms(),
            ),
            a11y_manager: crate::managers::a11y::A11yManager::new(),
            timers: BTreeMap::new(),
            threads: BTreeMap::new(),
            renderer_resources: RendererResources::default(),
            renderer_type: None,
            previous_window_state: None,
            current_window_state: FullWindowState::default(),
            document_id: new_document_id(),
            id_namespace: new_id_namespace(),
            epoch: Epoch::new(),
            gl_texture_cache: GlTextureCache::default(),
            currently_dragging_thumb: None,
            text_input_manager: crate::managers::text_input::TextInputManager::new(),
            undo_redo_manager: crate::managers::undo_redo::UndoRedoManager::new(),
            text_constraints_cache: TextConstraintsCache {
                constraints: BTreeMap::new(),
            },
            dirty_text_nodes: BTreeMap::new(),
            pending_iframe_updates: BTreeMap::new(),
            #[cfg(feature = "icu")]
            icu_localizer: IcuLocalizerHandle::default(),
        })
    }

    /// Create a new layout window for paged media (PDF generation).
    ///
    /// This constructor initializes the layout window with a paged fragmentation context,
    /// which will cause content to flow across multiple pages instead of a single continuous
    /// scrollable container.
    ///
    /// # Arguments
    /// - `fc_cache`: Font configuration cache for font loading
    /// - `page_size`: The logical size of each page
    ///
    /// # Returns
    /// A new `LayoutWindow` configured for paged output, or an error if initialization fails.
    #[cfg(feature = "pdf")]
    pub fn new_paged(
        fc_cache: FcFontCache,
        page_size: LogicalSize,
    ) -> Result<Self, crate::solver3::LayoutError> {
        Ok(Self {
            fragmentation_context: crate::paged::FragmentationContext::new_paged(page_size),
            layout_cache: Solver3LayoutCache {
                tree: None,
                calculated_positions: BTreeMap::new(),
                viewport: None,
                scroll_ids: BTreeMap::new(),
                scroll_id_to_node_id: BTreeMap::new(),
                counters: BTreeMap::new(),
                float_cache: BTreeMap::new(),
            },
            text_cache: TextLayoutCache::new(),
            font_manager: FontManager::new(fc_cache)?,
            image_cache: ImageCache::default(),
            layout_results: BTreeMap::new(),
            scroll_manager: ScrollManager::new(),
            gesture_drag_manager: crate::managers::gesture::GestureAndDragManager::new(),
            focus_manager: crate::managers::focus_cursor::FocusManager::new(),
            cursor_manager: crate::managers::cursor::CursorManager::new(),
            file_drop_manager: crate::managers::file_drop::FileDropManager::new(),
            selection_manager: crate::managers::selection::SelectionManager::new(),
            clipboard_manager: crate::managers::clipboard::ClipboardManager::new(),
            drag_drop_manager: crate::managers::drag_drop::DragDropManager::new(),
            hover_manager: crate::managers::hover::HoverManager::new(),
            iframe_manager: IFrameManager::new(),
            gpu_state_manager: GpuStateManager::new(
                default_duration_500ms(),
                default_duration_200ms(),
            ),
            a11y_manager: crate::managers::a11y::A11yManager::new(),
            timers: BTreeMap::new(),
            threads: BTreeMap::new(),
            renderer_resources: RendererResources::default(),
            renderer_type: None,
            previous_window_state: None,
            current_window_state: FullWindowState::default(),
            document_id: new_document_id(),
            id_namespace: new_id_namespace(),
            epoch: Epoch::new(),
            gl_texture_cache: GlTextureCache::default(),
            currently_dragging_thumb: None,
            text_input_manager: crate::managers::text_input::TextInputManager::new(),
            undo_redo_manager: crate::managers::undo_redo::UndoRedoManager::new(),
            text_constraints_cache: TextConstraintsCache {
                constraints: BTreeMap::new(),
            },
            dirty_text_nodes: BTreeMap::new(),
            pending_iframe_updates: BTreeMap::new(),
            #[cfg(feature = "icu")]
            icu_localizer: IcuLocalizerHandle::default(),
        })
    }

    /// Perform layout on a styled DOM and generate a display list.
    ///
    /// This is the main entry point for layout. It handles:
    /// - Incremental layout updates using the cached layout tree
    /// - Text shaping and line breaking
    /// - IFrame callback invocation and recursive layout
    /// - Display list generation for rendering
    /// - Accessibility tree synchronization
    ///
    /// # Arguments
    /// - `styled_dom`: The styled DOM to layout
    /// - `window_state`: Current window dimensions and state
    /// - `renderer_resources`: Resources for image sizing etc.
    /// - `debug_messages`: Optional vector to collect debug/warning messages
    ///
    /// # Returns
    /// The display list ready for rendering, or an error if layout fails.
    pub fn layout_and_generate_display_list(
        &mut self,
        root_dom: StyledDom,
        window_state: &FullWindowState,
        renderer_resources: &RendererResources,
        system_callbacks: &ExternalSystemCallbacks,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<(), solver3::LayoutError> {
        // Clear previous results for a full relayout
        self.layout_results.clear();

        if let Some(msgs) = debug_messages.as_mut() {
            msgs.push(LayoutDebugMessage::info(format!(
                "[layout_and_generate_display_list] Starting layout for DOM with {} nodes",
                root_dom.node_data.len()
            )));
        }

        // Start recursive layout from the root DOM
        let result = self.layout_dom_recursive(
            root_dom,
            window_state,
            renderer_resources,
            system_callbacks,
            debug_messages,
        );

        if let Err(ref e) = result {
            if let Some(msgs) = debug_messages.as_mut() {
                msgs.push(LayoutDebugMessage::error(format!(
                    "[layout_and_generate_display_list] Layout FAILED: {:?}",
                    e
                )));
            }
            eprintln!("[layout_and_generate_display_list] Layout FAILED: {:?}", e);
        } else {
            if let Some(msgs) = debug_messages.as_mut() {
                msgs.push(LayoutDebugMessage::info(format!(
                    "[layout_and_generate_display_list] Layout SUCCESS, layout_results count: {}",
                    self.layout_results.len()
                )));
            }
        }

        // After successful layout, update the accessibility tree
        // Note: This is wrapped in catch_unwind to prevent a11y issues from crashing the app
        #[cfg(feature = "a11y")]
        if result.is_ok() {
            // Use catch_unwind to prevent a11y panics from crashing the main application
            let a11y_result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                crate::managers::a11y::A11yManager::update_tree(
                    self.a11y_manager.root_id,
                    &self.layout_results,
                    &self.current_window_state.title,
                    self.current_window_state.size.dimensions,
                )
            }));

            match a11y_result {
                Ok(tree_update) => {
                    // Store the tree_update for platform adapter to consume
                    self.a11y_manager.last_tree_update = Some(tree_update);
                }
                Err(_) => {
                    // A11y update failed - log and continue without a11y
                }
            }
        }

        // After layout, automatically scroll cursor into view if there's a focused text input
        if result.is_ok() {
            self.scroll_focused_cursor_into_view();
        }

        result
    }

    fn layout_dom_recursive(
        &mut self,
        mut styled_dom: StyledDom,
        window_state: &FullWindowState,
        renderer_resources: &RendererResources,
        system_callbacks: &ExternalSystemCallbacks,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<(), solver3::LayoutError> {
        if styled_dom.dom_id.inner == 0 {
            styled_dom.dom_id = DomId::ROOT_ID;
        }
        let dom_id = styled_dom.dom_id;

        let viewport = LogicalRect {
            origin: LogicalPosition::zero(),
            size: window_state.size.dimensions,
        };

        // Font Resolution And Loading
        // This must happen BEFORE layout_document() is called
        {
            use crate::{
                solver3::getters::{
                    collect_and_resolve_font_chains, collect_font_ids_from_chains,
                    compute_fonts_to_load, load_fonts_from_disk, register_embedded_fonts_from_styled_dom,
                },
                text3::default::PathLoader,
            };

            if let Some(msgs) = debug_messages.as_mut() {
                msgs.push(LayoutDebugMessage::info(
                    "[FontLoading] Starting font resolution for DOM".to_string(),
                ));
            }

            // Step 0: Register embedded FontRefs (e.g. Material Icons)
            // These fonts bypass fontconfig and are used directly
            register_embedded_fonts_from_styled_dom(&styled_dom, &self.font_manager);

            // Step 1: Resolve font chains (cached by FontChainKey)
            let chains = collect_and_resolve_font_chains(&styled_dom, &self.font_manager.fc_cache);
            if let Some(msgs) = debug_messages.as_mut() {
                msgs.push(LayoutDebugMessage::info(format!(
                    "[FontLoading] Resolved {} font chains",
                    chains.len()
                )));
            }

            // Step 2: Get required font IDs from chains
            let required_fonts = collect_font_ids_from_chains(&chains);
            if let Some(msgs) = debug_messages.as_mut() {
                msgs.push(LayoutDebugMessage::info(format!(
                    "[FontLoading] Required fonts: {} unique fonts",
                    required_fonts.len()
                )));
            }

            // Step 3: Compute which fonts need to be loaded (diff with already loaded)
            let already_loaded = self.font_manager.get_loaded_font_ids();
            let fonts_to_load = compute_fonts_to_load(&required_fonts, &already_loaded);
            if let Some(msgs) = debug_messages.as_mut() {
                msgs.push(LayoutDebugMessage::info(format!(
                    "[FontLoading] Already loaded: {}, need to load: {}",
                    already_loaded.len(),
                    fonts_to_load.len()
                )));
            }

            // Step 4: Load missing fonts
            if !fonts_to_load.is_empty() {
                if let Some(msgs) = debug_messages.as_mut() {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[FontLoading] Loading {} fonts from disk...",
                        fonts_to_load.len()
                    )));
                }
                let loader = PathLoader::new();
                let load_result = load_fonts_from_disk(
                    &fonts_to_load,
                    &self.font_manager.fc_cache,
                    |bytes, index| loader.load_font(bytes, index),
                );

                if let Some(msgs) = debug_messages.as_mut() {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "[FontLoading] Loaded {} fonts, {} failed",
                        load_result.loaded.len(),
                        load_result.failed.len()
                    )));
                }

                // Insert loaded fonts into the font manager
                self.font_manager.insert_fonts(load_result.loaded);

                // Log any failures
                for (font_id, error) in &load_result.failed {
                    if let Some(msgs) = debug_messages.as_mut() {
                        msgs.push(LayoutDebugMessage::warning(format!(
                            "[FontLoading] Failed to load font {:?}: {}",
                            font_id, error
                        )));
                    }
                }
            }

            // Step 5: Update font chain cache
            self.font_manager.set_font_chain_cache(chains.into_fontconfig_chains());
        }

        let scroll_offsets = self.scroll_manager.get_scroll_states_for_dom(dom_id);
        let styled_dom_clone = styled_dom.clone();
        let gpu_cache = self.gpu_state_manager.get_or_create_cache(dom_id).clone();
        
        // Get cursor visibility from cursor manager for display list generation
        let cursor_is_visible = self.cursor_manager.should_draw_cursor();
        
        // Get cursor location from cursor manager for independent cursor rendering
        let cursor_location = self.cursor_manager.get_cursor_location().and_then(|loc| {
            self.cursor_manager.get_cursor().map(|cursor| {
                (loc.dom_id, loc.node_id, cursor.clone())
            })
        });

        let mut display_list = solver3::layout_document(
            &mut self.layout_cache,
            &mut self.text_cache,
            styled_dom,
            viewport,
            &self.font_manager,
            &scroll_offsets,
            &self.selection_manager.selections,
            &self.selection_manager.text_selections,
            debug_messages,
            Some(&gpu_cache),
            &self.renderer_resources,
            self.id_namespace,
            dom_id,
            cursor_is_visible,
            cursor_location,
        )?;

        let tree = self
            .layout_cache
            .tree
            .clone()
            .ok_or(solver3::LayoutError::InvalidTree)?;

        // Get scroll IDs from cache (they were computed during layout_document)
        let scroll_ids = self.layout_cache.scroll_ids.clone();
        let scroll_id_to_node_id = self.layout_cache.scroll_id_to_node_id.clone();

        // Synchronize scrollbar transforms AFTER layout
        self.gpu_state_manager
            .update_scrollbar_transforms(dom_id, &self.scroll_manager, &tree);

        // Scan for IFrames *after* the initial layout pass
        let iframes = self.scan_for_iframes(dom_id, &tree, &self.layout_cache.calculated_positions);

        for (node_id, bounds) in iframes {
            if let Some(child_dom_id) = self.invoke_iframe_callback(
                dom_id,
                node_id,
                bounds,
                window_state,
                renderer_resources,
                system_callbacks,
                debug_messages,
            ) {
                // Insert an IFrame primitive that the renderer will use
                display_list
                    .items
                    .push(crate::solver3::display_list::DisplayListItem::IFrame {
                        child_dom_id,
                        bounds,
                        clip_rect: bounds,
                    });
            }
        }

        // Store the final layout result for this DOM
        self.layout_results.insert(
            dom_id,
            DomLayoutResult {
                styled_dom: styled_dom_clone,
                layout_tree: tree,
                calculated_positions: self.layout_cache.calculated_positions.clone(),
                viewport,
                display_list,
                scroll_ids,
                scroll_id_to_node_id,
            },
        );

        Ok(())
    }

    fn scan_for_iframes(
        &self,
        dom_id: DomId,
        layout_tree: &LayoutTree,
        calculated_positions: &BTreeMap<usize, LogicalPosition>,
    ) -> Vec<(NodeId, LogicalRect)> {
        layout_tree
            .nodes
            .iter()
            .enumerate()
            .filter_map(|(idx, node)| {
                let node_dom_id = node.dom_node_id?;
                let layout_result = self.layout_results.get(&dom_id)?;
                let node_data = &layout_result.styled_dom.node_data.as_container()[node_dom_id];
                if matches!(node_data.get_node_type(), NodeType::IFrame(_)) {
                    let pos = calculated_positions.get(&idx).copied().unwrap_or_default();
                    let size = node.used_size.unwrap_or_default();
                    Some((node_dom_id, LogicalRect::new(pos, size)))
                } else {
                    None
                }
            })
            .collect()
    }

    /// Handle a window resize by updating the cached layout.
    ///
    /// This method leverages solver3's incremental layout system to efficiently
    /// relayout only the affected parts of the tree when the window size changes.
    ///
    /// Returns the new display list after the resize.
    pub fn resize_window(
        &mut self,
        styled_dom: StyledDom,
        new_size: LogicalSize,
        renderer_resources: &RendererResources,
        system_callbacks: &ExternalSystemCallbacks,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Result<DisplayList, crate::solver3::LayoutError> {
        // Create a temporary FullWindowState with the new size
        let mut window_state = FullWindowState::default();
        window_state.size.dimensions = new_size;

        let dom_id = styled_dom.dom_id;

        // Reuse the main layout method - solver3 will detect the viewport
        // change and invalidate only what's necessary
        self.layout_and_generate_display_list(
            styled_dom,
            &window_state,
            renderer_resources,
            system_callbacks,
            debug_messages,
        )?;

        // Retrieve the display list from the layout result
        // We need to take ownership of the display list, so we replace it with an empty one
        self.layout_results
            .get_mut(&dom_id)
            .map(|result| std::mem::replace(&mut result.display_list, DisplayList::default()))
            .ok_or(solver3::LayoutError::InvalidTree)
    }

    /// Clear all caches (useful for testing or when switching documents).
    pub fn clear_caches(&mut self) {
        self.layout_cache = Solver3LayoutCache {
            tree: None,
            calculated_positions: BTreeMap::new(),
            viewport: None,
            scroll_ids: BTreeMap::new(),
            scroll_id_to_node_id: BTreeMap::new(),
            counters: BTreeMap::new(),
            float_cache: BTreeMap::new(),
        };
        self.text_cache = TextLayoutCache::new();
        self.layout_results.clear();
        self.scroll_manager = ScrollManager::new();
        self.selection_manager.clear_all();
    }

    /// Set scroll position for a node
    pub fn set_scroll_position(&mut self, dom_id: DomId, node_id: NodeId, scroll: ScrollPosition) {
        // Convert ScrollPosition to the internal representation
        #[cfg(feature = "std")]
        let now = Instant::System(std::time::Instant::now().into());
        #[cfg(not(feature = "std"))]
        let now = Instant::Tick(azul_core::task::SystemTick { tick_counter: 0 });

        self.scroll_manager.update_node_bounds(
            dom_id,
            node_id,
            scroll.parent_rect,
            scroll.children_rect,
            now.clone(),
        );
        self.scroll_manager
            .set_scroll_position(dom_id, node_id, scroll.children_rect.origin, now);
    }

    /// Get scroll position for a node
    pub fn get_scroll_position(&self, dom_id: DomId, node_id: NodeId) -> Option<ScrollPosition> {
        let states = self.scroll_manager.get_scroll_states_for_dom(dom_id);
        states.get(&node_id).cloned()
    }

    /// Set selection state for a DOM
    pub fn set_selection(&mut self, dom_id: DomId, selection: SelectionState) {
        self.selection_manager.set_selection(dom_id, selection);
    }

    /// Get selection state for a DOM
    pub fn get_selection(&self, dom_id: DomId) -> Option<&SelectionState> {
        self.selection_manager.get_selection(&dom_id)
    }

    /// Invoke an IFrame callback and perform layout on the returned DOM.
    ///
    /// This is the entry point that looks up the necessary `IFrameNode` data before
    /// delegating to the core implementation logic.
    fn invoke_iframe_callback(
        &mut self,
        parent_dom_id: DomId,
        node_id: NodeId,
        bounds: LogicalRect,
        window_state: &FullWindowState,
        renderer_resources: &RendererResources,
        system_callbacks: &ExternalSystemCallbacks,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Option<DomId> {
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "invoke_iframe_callback called for node {:?}",
                node_id
            )));
        }

        // Get the layout result for the parent DOM to access its styled_dom
        let layout_result = self.layout_results.get(&parent_dom_id)?;
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "Got layout result for parent DOM {:?}",
                parent_dom_id
            )));
        }

        // Get the node data for the IFrame element
        let node_data_container = layout_result.styled_dom.node_data.as_container();
        let node_data = node_data_container.get(node_id)?;
        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "Got node data at index {}",
                node_id.index()
            )));
        }

        // Extract the IFrame node, cloning it to avoid borrow checker issues
        let iframe_node = match node_data.get_node_type() {
            NodeType::IFrame(iframe) => {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info("Node is IFrame type".to_string()));
                }
                iframe.clone()
            }
            other => {
                if let Some(msgs) = debug_messages {
                    msgs.push(LayoutDebugMessage::info(format!(
                        "Node is NOT IFrame, type = {:?}",
                        other
                    )));
                }
                return None;
            }
        };

        // Call the actual implementation with all necessary data
        self.invoke_iframe_callback_impl(
            parent_dom_id,
            node_id,
            &iframe_node,
            bounds,
            window_state,
            renderer_resources,
            system_callbacks,
            debug_messages,
        )
    }

    /// Core implementation for invoking an IFrame callback and managing the recursive layout.
    ///
    /// This method implements the 5 conditional re-invocation rules by coordinating
    /// with the `IFrameManager` and `ScrollManager`.
    ///
    /// # Returns
    ///
    /// `Some(child_dom_id)` if the callback was invoked and the child DOM was laid out.
    /// The parent's display list generator will then use this ID to reference the child's
    /// display list. Returns `None` if the callback was not invoked.
    fn invoke_iframe_callback_impl(
        &mut self,
        parent_dom_id: DomId,
        node_id: NodeId,
        iframe_node: &azul_core::dom::IFrameNode,
        bounds: LogicalRect,
        window_state: &FullWindowState,
        renderer_resources: &RendererResources,
        system_callbacks: &ExternalSystemCallbacks,
        debug_messages: &mut Option<Vec<LayoutDebugMessage>>,
    ) -> Option<DomId> {
        // Get current time from system callbacks for state updates
        let now = (system_callbacks.get_system_time_fn.cb)();

        // Update node bounds in the scroll manager. This is necessary for the IFrameManager
        // to correctly detect edge scroll conditions.
        self.scroll_manager.update_node_bounds(
            parent_dom_id,
            node_id,
            bounds,
            LogicalRect::new(LogicalPosition::zero(), bounds.size), // Initial content_rect
            now.clone(),
        );

        // Check with the IFrameManager to see if re-invocation is necessary.
        // It handles all 5 conditional rules.
        let reason = match self.iframe_manager.check_reinvoke(
            parent_dom_id,
            node_id,
            &self.scroll_manager,
            bounds,
        ) {
            Some(r) => r,
            None => {
                // No re-invocation needed, but we still need the child_dom_id for the display list.
                return self
                    .iframe_manager
                    .get_nested_dom_id(parent_dom_id, node_id);
            }
        };

        if let Some(msgs) = debug_messages {
            msgs.push(LayoutDebugMessage::info(format!(
                "IFrame ({:?}, {:?}) - Reason: {:?}",
                parent_dom_id, node_id, reason
            )));
        }

        let scroll_offset = self
            .scroll_manager
            .get_current_offset(parent_dom_id, node_id)
            .unwrap_or_default();
        let hidpi_factor = window_state.size.get_hidpi_factor();

        // Create IFrameCallbackInfo with the most up-to-date state
        let mut callback_info = azul_core::callbacks::IFrameCallbackInfo::new(
            reason,
            &*self.font_manager.fc_cache,
            &self.image_cache,
            window_state.theme,
            azul_core::callbacks::HidpiAdjustedBounds {
                logical_size: bounds.size,
                hidpi_factor,
            },
            bounds.size,
            scroll_offset,
            bounds.size,
            LogicalPosition::zero(),
        );

        // Clone the user data for the callback
        let callback_data = iframe_node.refany.clone();

        // Invoke the user's IFrame callback
        let callback_return = (iframe_node.callback.cb)(callback_data, callback_info);

        // Mark the IFrame as invoked to prevent duplicate InitialRender calls
        self.iframe_manager
            .mark_invoked(parent_dom_id, node_id, reason);

        // Get the child StyledDom from the callback's return value
        let mut child_styled_dom = match callback_return.dom {
            azul_core::styled_dom::OptionStyledDom::Some(dom) => dom,
            azul_core::styled_dom::OptionStyledDom::None => {
                // If the callback returns None, it's an optimization hint.
                if reason == IFrameCallbackReason::InitialRender {
                    // For the very first render, create an empty div as a fallback.
                    let mut empty_dom = Dom::create_div();
                    let empty_css = Css::empty();
                    empty_dom.style(empty_css)
                } else {
                    // For subsequent calls, returning None means "keep the old DOM".
                    // We just need to update the scroll info and return the existing child ID.
                    self.iframe_manager.update_iframe_info(
                        parent_dom_id,
                        node_id,
                        callback_return.scroll_size,
                        callback_return.virtual_scroll_size,
                    );
                    return self
                        .iframe_manager
                        .get_nested_dom_id(parent_dom_id, node_id);
                }
            }
        };

        // Get or create a unique DomId for the IFrame's content
        let child_dom_id = self
            .iframe_manager
            .get_or_create_nested_dom_id(parent_dom_id, node_id);
        child_styled_dom.dom_id = child_dom_id;

        // Update the IFrameManager with the new scroll sizes from the callback
        self.iframe_manager.update_iframe_info(
            parent_dom_id,
            node_id,
            callback_return.scroll_size,
            callback_return.virtual_scroll_size,
        );

        // **RECURSIVE LAYOUT STEP**
        // Perform a full layout pass on the child DOM. This will recursively handle
        // any IFrames within this IFrame.
        self.layout_dom_recursive(
            child_styled_dom,
            window_state,
            renderer_resources,
            system_callbacks,
            debug_messages,
        )
        .ok()?;

        Some(child_dom_id)
    }

    // Query methods for callbacks

    /// Get the size of a laid-out node
    pub fn get_node_size(&self, node_id: DomNodeId) -> Option<LogicalSize> {
        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;
        // Use dom_to_layout mapping since layout tree indices differ from DOM indices
        let layout_indices = layout_result.layout_tree.dom_to_layout.get(&nid)?;
        let layout_index = *layout_indices.first()?;
        let layout_node = layout_result.layout_tree.get(layout_index)?;
        layout_node.used_size
    }

    /// Get the position of a laid-out node
    pub fn get_node_position(&self, node_id: DomNodeId) -> Option<LogicalPosition> {
        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;
        // Use dom_to_layout mapping since layout tree indices differ from DOM indices
        let layout_indices = layout_result.layout_tree.dom_to_layout.get(&nid)?;
        let layout_index = *layout_indices.first()?;
        let position = layout_result.calculated_positions.get(&layout_index)?;
        Some(*position)
    }

    /// Get the hit test bounds of a node from the display list
    ///
    /// This is more reliable than get_node_position + get_node_size because
    /// the display list always contains the correct final rendered positions,
    /// including for nodes that may not have entries in calculated_positions.
    pub fn get_node_hit_test_bounds(&self, node_id: DomNodeId) -> Option<LogicalRect> {
        use crate::solver3::display_list::DisplayListItem;

        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;

        // Get the actual tag_id from styled_nodes (matches what get_tag_id in display_list.rs uses)
        let styled_nodes = layout_result.styled_dom.styled_nodes.as_container();
        let tag_id = styled_nodes.get(nid)?.tag_id.into_option()?.inner;

        // Search the display list for a HitTestArea with matching tag
        // Note: tag is now (u64, u16) tuple where tag.0 is the TagId.inner
        for item in &layout_result.display_list.items {
            if let DisplayListItem::HitTestArea { bounds, tag } = item {
                if tag.0 == tag_id && bounds.size.width > 0.0 && bounds.size.height > 0.0 {
                    return Some(*bounds);
                }
            }
        }
        None
    }

    /// Get the parent of a node
    pub fn get_parent(&self, node_id: DomNodeId) -> Option<DomNodeId> {
        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;
        let parent_id = layout_result
            .styled_dom
            .node_hierarchy
            .as_container()
            .get(nid)?
            .parent_id()?;
        Some(DomNodeId {
            dom: node_id.dom,
            node: NodeHierarchyItemId::from_crate_internal(Some(parent_id)),
        })
    }

    /// Get the first child of a node
    pub fn get_first_child(&self, node_id: DomNodeId) -> Option<DomNodeId> {
        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;
        let node_hierarchy = layout_result.styled_dom.node_hierarchy.as_container();
        let hierarchy_item = node_hierarchy.get(nid)?;
        let first_child_id = hierarchy_item.first_child_id(nid)?;
        Some(DomNodeId {
            dom: node_id.dom,
            node: NodeHierarchyItemId::from_crate_internal(Some(first_child_id)),
        })
    }

    /// Get the next sibling of a node
    pub fn get_next_sibling(&self, node_id: DomNodeId) -> Option<DomNodeId> {
        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;
        let next_sibling_id = layout_result
            .styled_dom
            .node_hierarchy
            .as_container()
            .get(nid)?
            .next_sibling_id()?;
        Some(DomNodeId {
            dom: node_id.dom,
            node: NodeHierarchyItemId::from_crate_internal(Some(next_sibling_id)),
        })
    }

    /// Get the previous sibling of a node
    pub fn get_previous_sibling(&self, node_id: DomNodeId) -> Option<DomNodeId> {
        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;
        let prev_sibling_id = layout_result
            .styled_dom
            .node_hierarchy
            .as_container()
            .get(nid)?
            .previous_sibling_id()?;
        Some(DomNodeId {
            dom: node_id.dom,
            node: NodeHierarchyItemId::from_crate_internal(Some(prev_sibling_id)),
        })
    }

    /// Get the last child of a node
    pub fn get_last_child(&self, node_id: DomNodeId) -> Option<DomNodeId> {
        let layout_result = self.layout_results.get(&node_id.dom)?;
        let nid = node_id.node.into_crate_internal()?;
        let last_child_id = layout_result
            .styled_dom
            .node_hierarchy
            .as_container()
            .get(nid)?
            .last_child_id()?;
        Some(DomNodeId {
            dom: node_id.dom,
            node: NodeHierarchyItemId::from_crate_internal(Some(last_child_id)),
        })
    }

    /// Scan all fonts used in this LayoutWindow (for resource GC)
    pub fn scan_used_fonts(&self) -> BTreeSet<FontKey> {
        let mut fonts = BTreeSet::new();
        for (_dom_id, layout_result) in &self.layout_results {
            // TODO: Scan styled_dom for font references
            // This requires accessing the CSS property cache and finding all font-family properties
        }
        fonts
    }

    /// Scan all images used in this LayoutWindow (for resource GC)
    pub fn scan_used_images(&self, _css_image_cache: &ImageCache) -> BTreeSet<ImageRefHash> {
        let mut images = BTreeSet::new();
        for (_dom_id, layout_result) in &self.layout_results {
            // TODO: Scan styled_dom for image references
            // This requires scanning background-image and content properties
        }
        images
    }

    /// Helper function to convert ScrollStates to nested format for CallbackInfo
    fn get_nested_scroll_states(
        &self,
        dom_id: DomId,
    ) -> BTreeMap<DomId, BTreeMap<NodeHierarchyItemId, ScrollPosition>> {
        let mut nested = BTreeMap::new();
        let scroll_states = self.scroll_manager.get_scroll_states_for_dom(dom_id);
        let mut inner = BTreeMap::new();
        for (node_id, scroll_pos) in scroll_states {
            inner.insert(
                NodeHierarchyItemId::from_crate_internal(Some(node_id)),
                scroll_pos,
            );
        }
        nested.insert(dom_id, inner);
        nested
    }

    // Scroll Into View
    
    /// Scroll a DOM node into view
    ///
    /// This is the main API for scrolling elements into view. It handles:
    /// - Finding scroll ancestors
    /// - Calculating scroll deltas
    /// - Applying scroll animations
    ///
    /// # Arguments
    ///
    /// * `node_id` - The DOM node to scroll into view
    /// * `options` - Scroll alignment and animation options
    /// * `now` - Current timestamp for animations
    ///
    /// # Returns
    ///
    /// A vector of scroll adjustments that were applied
    pub fn scroll_node_into_view(
        &mut self,
        node_id: DomNodeId,
        options: crate::managers::scroll_into_view::ScrollIntoViewOptions,
        now: azul_core::task::Instant,
    ) -> Vec<crate::managers::scroll_into_view::ScrollAdjustment> {
        crate::managers::scroll_into_view::scroll_node_into_view(
            node_id,
            &self.layout_results,
            &mut self.scroll_manager,
            options,
            now,
        )
    }
    
    /// Scroll a text cursor into view
    ///
    /// Used when the cursor moves within a contenteditable element.
    /// The cursor rect should be in node-local coordinates.
    pub fn scroll_cursor_into_view(
        &mut self,
        cursor_rect: LogicalRect,
        node_id: DomNodeId,
        options: crate::managers::scroll_into_view::ScrollIntoViewOptions,
        now: azul_core::task::Instant,
    ) -> Vec<crate::managers::scroll_into_view::ScrollAdjustment> {
        crate::managers::scroll_into_view::scroll_cursor_into_view(
            cursor_rect,
            node_id,
            &self.layout_results,
            &mut self.scroll_manager,
            options,
            now,
        )
    }

    // Timer Management

    /// Add a timer to this window
    pub fn add_timer(&mut self, timer_id: TimerId, timer: Timer) {
        self.timers.insert(timer_id, timer);
    }

    /// Remove a timer from this window
    pub fn remove_timer(&mut self, timer_id: &TimerId) -> Option<Timer> {
        self.timers.remove(timer_id)
    }

    /// Get a reference to a timer
    pub fn get_timer(&self, timer_id: &TimerId) -> Option<&Timer> {
        self.timers.get(timer_id)
    }

    /// Get a mutable reference to a timer
    pub fn get_timer_mut(&mut self, timer_id: &TimerId) -> Option<&mut Timer> {
        self.timers.get_mut(timer_id)
    }

    /// Get all timer IDs
    pub fn get_timer_ids(&self) -> TimerIdVec {
        self.timers.keys().copied().collect::<Vec<_>>().into()
    }

    /// Tick all timers (called once per frame)
    /// Returns a list of timer IDs that are ready to run
    pub fn tick_timers(&mut self, current_time: azul_core::task::Instant) -> Vec<TimerId> {
        let mut ready_timers = Vec::new();

        for (timer_id, timer) in &mut self.timers {
            // Check if timer is ready to run
            // This logic should match the timer's internal state
            // For now, we'll just collect all timer IDs
            // The actual readiness check will be done when invoking
            ready_timers.push(*timer_id);
        }

        ready_timers
    }

    /// Calculate milliseconds until the next timer needs to fire.
    ///
    /// Returns `None` if there are no timers, meaning the caller can block indefinitely.
    /// Returns `Some(0)` if a timer is already overdue.
    /// Otherwise returns the minimum time in milliseconds until any timer fires.
    ///
    /// This is used by Linux (X11/Wayland) to set an efficient poll/select timeout
    /// instead of always polling every 16ms.
    pub fn time_until_next_timer_ms(
        &self,
        get_system_time_fn: &azul_core::task::GetSystemTimeCallback,
    ) -> Option<u64> {
        if self.timers.is_empty() {
            return None; // No timers - can block indefinitely
        }

        let now = (get_system_time_fn.cb)();
        let mut min_ms: Option<u64> = None;

        for timer in self.timers.values() {
            let next_run = timer.instant_of_next_run();

            // Calculate time difference in milliseconds
            let ms_until = if next_run < now {
                0 // Timer is overdue
            } else {
                duration_to_millis(next_run.duration_since(&now))
            };

            min_ms = Some(match min_ms {
                Some(current_min) => current_min.min(ms_until),
                None => ms_until,
            });
        }

        min_ms
    }

    // Thread Management

    /// Add a thread to this window
    pub fn add_thread(&mut self, thread_id: ThreadId, thread: Thread) {
        self.threads.insert(thread_id, thread);
    }

    /// Remove a thread from this window
    pub fn remove_thread(&mut self, thread_id: &ThreadId) -> Option<Thread> {
        self.threads.remove(thread_id)
    }

    /// Get a reference to a thread
    pub fn get_thread(&self, thread_id: &ThreadId) -> Option<&Thread> {
        self.threads.get(thread_id)
    }

    /// Get a mutable reference to a thread
    pub fn get_thread_mut(&mut self, thread_id: &ThreadId) -> Option<&mut Thread> {
        self.threads.get_mut(thread_id)
    }

    /// Get all thread IDs
    pub fn get_thread_ids(&self) -> ThreadIdVec {
        self.threads.keys().copied().collect::<Vec<_>>().into()
    }
    
    // Cursor Blinking Timer
    
    /// Create the cursor blink timer
    ///
    /// This timer toggles cursor visibility at ~530ms intervals.
    /// It checks if enough time has passed since the last user input before blinking,
    /// to avoid blinking while the user is actively typing.
    pub fn create_cursor_blink_timer(&self, _window_state: &FullWindowState) -> crate::timer::Timer {
        use azul_core::task::{Duration, SystemTimeDiff};
        use crate::timer::{Timer, TimerCallback};
        use azul_core::refany::RefAny;
        
        let interval_ms = crate::managers::cursor::CURSOR_BLINK_INTERVAL_MS;
        
        // Create a RefAny with a unit type - the timer callback doesn't need any data
        // The actual cursor state is in LayoutWindow.cursor_manager
        let refany = RefAny::new(());
        
        Timer {
            refany,
            node_id: None.into(),
            created: azul_core::task::Instant::now(),
            run_count: 0,
            last_run: azul_core::task::OptionInstant::None,
            delay: azul_core::task::OptionDuration::None,
            interval: azul_core::task::OptionDuration::Some(Duration::System(SystemTimeDiff::from_millis(interval_ms))),
            timeout: azul_core::task::OptionDuration::None,
            callback: TimerCallback::create(cursor_blink_timer_callback),
        }
    }
    
    /// Scroll the active text cursor into view within its scrollable container
    ///
    /// This finds the focused contenteditable node, gets the cursor rectangle,
    /// and scrolls any scrollable ancestor to ensure the cursor is visible.
    pub fn scroll_active_cursor_into_view(&mut self, result: &mut CallbackChangeResult) {
        use crate::managers::scroll_into_view;
        
        // Get the focused node
        let focused_node = match self.focus_manager.get_focused_node() {
            Some(node) => *node,
            None => return,
        };
        
        let Some(node_id_internal) = focused_node.node.into_crate_internal() else {
            return;
        };
        
        // Check if node is contenteditable
        if !self.is_node_contenteditable_internal(focused_node.dom, node_id_internal) {
            return;
        }
        
        // Get the cursor location
        let cursor_location = match self.cursor_manager.get_cursor_location() {
            Some(loc) if loc.dom_id == focused_node.dom && loc.node_id == node_id_internal => loc,
            _ => return,
        };
        
        // Get the cursor position
        let cursor = match self.cursor_manager.get_cursor() {
            Some(c) => c.clone(),
            None => return,
        };
        
        // Get the inline layout to find the cursor rectangle
        let layout = match self.get_inline_layout_for_node(focused_node.dom, node_id_internal) {
            Some(l) => l,
            None => return,
        };
        
        // Get cursor rectangle (node-local coordinates)
        let cursor_rect = match layout.get_cursor_rect(&cursor) {
            Some(r) => r,
            None => return,
        };
        
        // Use scroll_into_view to scroll the cursor rect into view
        let now = azul_core::task::Instant::now();
        let options = scroll_into_view::ScrollIntoViewOptions::nearest();
        
        // Calculate scroll adjustments
        let adjustments = scroll_into_view::scroll_rect_into_view(
            cursor_rect,
            focused_node.dom,
            node_id_internal,
            &self.layout_results,
            &mut self.scroll_manager,
            options,
            now,
        );
        
        // Record the scroll changes
        for adj in adjustments {
            let current_pos = self.scroll_manager
                .get_current_offset(adj.scroll_container_dom_id, adj.scroll_container_node_id)
                .unwrap_or(LogicalPosition::zero());
            
            let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(adj.scroll_container_node_id));
            result
                .nodes_scrolled
                .entry(adj.scroll_container_dom_id)
                .or_insert_with(BTreeMap::new)
                .insert(hierarchy_id, current_pos);
        }
    }
    
    /// Check if a node is contenteditable (internal version using NodeId)
    fn is_node_contenteditable_internal(&self, dom_id: DomId, node_id: NodeId) -> bool {
        use crate::solver3::getters::is_node_contenteditable;
        
        let Some(layout_result) = self.layout_results.get(&dom_id) else {
            return false;
        };
        
        is_node_contenteditable(&layout_result.styled_dom, node_id)
    }
    
    /// Check if a node is contenteditable with W3C-conformant inheritance.
    ///
    /// This traverses up the DOM tree to check if the node or any ancestor
    /// has `contenteditable="true"` set, respecting `contenteditable="false"`
    /// to stop inheritance.
    fn is_node_contenteditable_inherited_internal(&self, dom_id: DomId, node_id: NodeId) -> bool {
        use crate::solver3::getters::is_node_contenteditable_inherited;
        
        let Some(layout_result) = self.layout_results.get(&dom_id) else {
            return false;
        };
        
        is_node_contenteditable_inherited(&layout_result.styled_dom, node_id)
    }
    
    /// Handle focus change for cursor blink timer management (W3C "flag and defer" pattern)
    ///
    /// This method implements the W3C focus/selection model:
    /// 1. Focus change is handled immediately (timer start/stop)
    /// 2. Cursor initialization is DEFERRED until after layout (via flag)
    ///
    /// The cursor is NOT initialized here because text layout may not be available
    /// during focus event handling. Instead, we set a flag that is consumed by
    /// `finalize_pending_focus_changes()` after the layout pass.
    ///
    /// # Parameters
    ///
    /// * `new_focus` - The newly focused node (None if focus is being cleared)
    /// * `current_window_state` - Current window state for timer creation
    ///
    /// # Returns
    ///
    /// A `CursorBlinkTimerAction` indicating what timer action the platform
    /// layer should take.
    pub fn handle_focus_change_for_cursor_blink(
        &mut self,
        new_focus: Option<azul_core::dom::DomNodeId>,
        current_window_state: &FullWindowState,
    ) -> CursorBlinkTimerAction {
        // Check if the new focus is on a contenteditable element
        // Use the inherited check for W3C conformance
        let contenteditable_info = match new_focus {
            Some(focus_node) => {
                if let Some(node_id) = focus_node.node.into_crate_internal() {
                    // Check if this node or any ancestor is contenteditable
                    if self.is_node_contenteditable_inherited_internal(focus_node.dom, node_id) {
                        // Find the text node where the cursor should be placed
                        let text_node_id = self.find_last_text_child(focus_node.dom, node_id)
                            .unwrap_or(node_id);
                        Some((focus_node.dom, node_id, text_node_id))
                    } else {
                        None
                    }
                } else {
                    None
                }
            }
            None => None,
        };
        
        // Determine the action based on current state and new focus
        let timer_was_active = self.cursor_manager.is_blink_timer_active();
        
        if let Some((dom_id, container_node_id, text_node_id)) = contenteditable_info {
            
            // W3C "flag and defer" pattern:
            // Set flag for cursor initialization AFTER layout pass
            self.focus_manager.set_pending_contenteditable_focus(
                dom_id,
                container_node_id,
                text_node_id,
            );
            
            // Make cursor visible and record current time (even before actual initialization)
            let now = azul_core::task::Instant::now();
            self.cursor_manager.reset_blink_on_input(now);
            self.cursor_manager.set_blink_timer_active(true);
            
            if !timer_was_active {
                // Need to start the timer
                let timer = self.create_cursor_blink_timer(current_window_state);
                return CursorBlinkTimerAction::Start(timer);
            } else {
                // Timer already active, just continue
                return CursorBlinkTimerAction::NoChange;
            }
        } else {
            // Focus is moving away from contenteditable or being cleared
            
            // Clear the cursor AND the pending focus flag
            self.cursor_manager.clear();
            self.focus_manager.clear_pending_contenteditable_focus();
            
            if timer_was_active {
                // Need to stop the timer
                self.cursor_manager.set_blink_timer_active(false);
                return CursorBlinkTimerAction::Stop;
            } else {
                return CursorBlinkTimerAction::NoChange;
            }
        }
    }
    
    /// Finalize pending focus changes after layout pass (W3C "flag and defer" pattern)
    ///
    /// This method should be called AFTER the layout pass completes. It checks if
    /// there's a pending contenteditable focus and initializes the cursor now that
    /// text layout information is available.
    ///
    /// # W3C Conformance
    ///
    /// In the W3C model:
    /// 1. Focus event fires during event handling (layout may not be ready)
    /// 2. Selection/cursor placement happens after layout is computed
    /// 3. The cursor is drawn at the position specified by the Selection
    ///
    /// This function implements step 2+3 by:
    /// - Checking the `cursor_needs_initialization` flag
    /// - Getting the (now available) text layout
    /// - Initializing the cursor at the correct position
    ///
    /// # Returns
    ///
    /// `true` if cursor was initialized, `false` if no pending focus or initialization failed.
    pub fn finalize_pending_focus_changes(&mut self) -> bool {
        // Take the pending focus info (this clears the flag)
        let pending = match self.focus_manager.take_pending_contenteditable_focus() {
            Some(p) => p,
            None => return false,
        };
        
        // Now we can safely get the text layout (layout pass has completed)
        let text_layout = self.get_inline_layout_for_node(pending.dom_id, pending.text_node_id).cloned();
        
        // Initialize cursor at end of text
        self.cursor_manager.initialize_cursor_at_end(
            pending.dom_id,
            pending.text_node_id,
            text_layout.as_ref(),
        )
    }

    // CallbackChange Processing

    /// Apply callback changes that were collected during callback execution
    ///
    /// This method processes all changes accumulated in the CallbackChange vector
    /// and applies them to the appropriate state. This is called after a callback
    /// returns to ensure atomic application of all changes.
    ///
    /// Returns a `CallbackChangeResult` containing all the changes to be applied.
    pub fn apply_callback_changes(
        &mut self,
        changes: Vec<crate::callbacks::CallbackChange>,
        current_window_state: &FullWindowState,
        image_cache: &mut ImageCache,
        system_fonts: &mut FcFontCache,
    ) -> CallbackChangeResult {
        use crate::callbacks::CallbackChange;

        let mut result = CallbackChangeResult {
            modified_window_state: current_window_state.clone(),
            ..Default::default()
        };
        for change in changes {
            match change {
                CallbackChange::ModifyWindowState { state } => {
                    result.modified_window_state = state;
                }
                CallbackChange::QueueWindowStateSequence { states } => {
                    // Queue the states to be processed in sequence.
                    // The first state is applied immediately, subsequent states
                    // are stored for processing in future frames.
                    result.queued_window_states.extend(states);
                }
                CallbackChange::CreateNewWindow { options } => {
                    result.windows_created.push(options);
                }
                CallbackChange::CloseWindow => {
                    // Set the close_requested flag to trigger window close
                    result.modified_window_state.flags.close_requested = true;
                }
                CallbackChange::SetFocusTarget { target } => {
                    result.focus_target = Some(target);
                }
                CallbackChange::StopPropagation => {
                    result.stop_propagation = true;
                }
                CallbackChange::PreventDefault => {
                    result.prevent_default = true;
                }
                CallbackChange::AddTimer { timer_id, timer } => {
                    result.timers.insert(timer_id, timer);
                }
                CallbackChange::RemoveTimer { timer_id } => {
                    result.timers_removed.insert(timer_id);
                }
                CallbackChange::AddThread { thread_id, thread } => {
                    result.threads.insert(thread_id, thread);
                }
                CallbackChange::RemoveThread { thread_id } => {
                    result.threads_removed.insert(thread_id);
                }
                CallbackChange::ChangeNodeText { node_id, text } => {
                    let dom_id = node_id.dom;
                    let internal_node_id = match node_id.node.into_crate_internal() {
                        Some(id) => id,
                        None => continue,
                    };
                    result
                        .words_changed
                        .entry(dom_id)
                        .or_insert_with(BTreeMap::new)
                        .insert(internal_node_id, text);
                }
                CallbackChange::ChangeNodeImage {
                    dom_id,
                    node_id,
                    image,
                    update_type,
                } => {
                    result
                        .images_changed
                        .entry(dom_id)
                        .or_insert_with(BTreeMap::new)
                        .insert(node_id, (image, update_type));
                }
                CallbackChange::UpdateImageCallback { dom_id, node_id } => {
                    result
                        .image_callbacks_changed
                        .entry(dom_id)
                        .or_insert_with(FastBTreeSet::new)
                        .insert(node_id);
                }
                CallbackChange::UpdateIFrame { dom_id, node_id } => {
                    result
                        .iframes_to_update
                        .entry(dom_id)
                        .or_insert_with(FastBTreeSet::new)
                        .insert(node_id);
                }
                CallbackChange::ChangeNodeImageMask {
                    dom_id,
                    node_id,
                    mask,
                } => {
                    result
                        .image_masks_changed
                        .entry(dom_id)
                        .or_insert_with(BTreeMap::new)
                        .insert(node_id, mask);
                }
                CallbackChange::ChangeNodeCssProperties {
                    dom_id,
                    node_id,
                    properties,
                } => {
                    result
                        .css_properties_changed
                        .entry(dom_id)
                        .or_insert_with(BTreeMap::new)
                        .insert(node_id, properties);
                }
                CallbackChange::ScrollTo {
                    dom_id,
                    node_id,
                    position,
                } => {
                    result
                        .nodes_scrolled
                        .entry(dom_id)
                        .or_insert_with(BTreeMap::new)
                        .insert(node_id, position);
                }
                CallbackChange::ScrollIntoView { node_id, options } => {
                    // Use the scroll_into_view module to calculate and apply scroll adjustments
                    use crate::managers::scroll_into_view;
                    let now = azul_core::task::Instant::now();
                    let adjustments = scroll_into_view::scroll_node_into_view(
                        node_id,
                        &self.layout_results,
                        &mut self.scroll_manager,
                        options,
                        now,
                    );
                    // Record the scroll changes in nodes_scrolled
                    // The scroll_manager was already updated by scroll_node_into_view,
                    // but we need to report the new absolute positions for event processing
                    for adj in adjustments {
                        // Get the current scroll position from scroll_manager (now updated)
                        let current_pos = self.scroll_manager
                            .get_current_offset(adj.scroll_container_dom_id, adj.scroll_container_node_id)
                            .unwrap_or(LogicalPosition::zero());
                        
                        let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(adj.scroll_container_node_id));
                        result
                            .nodes_scrolled
                            .entry(adj.scroll_container_dom_id)
                            .or_insert_with(BTreeMap::new)
                            .insert(hierarchy_id, current_pos);
                    }
                }
                CallbackChange::AddImageToCache { id, image } => {
                    image_cache.add_css_image_id(id, image);
                }
                CallbackChange::RemoveImageFromCache { id } => {
                    image_cache.delete_css_image_id(&id);
                }
                CallbackChange::ReloadSystemFonts => {
                    *system_fonts = FcFontCache::build();
                }
                CallbackChange::OpenMenu { menu, position } => {
                    result.menus_to_open.push((menu, position));
                }
                CallbackChange::ShowTooltip { text, position } => {
                    result.tooltips_to_show.push((text, position));
                }
                CallbackChange::HideTooltip => {
                    result.hide_tooltip = true;
                }
                CallbackChange::InsertText {
                    dom_id,
                    node_id,
                    text,
                } => {
                    // Record text input for the node
                    let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                    let dom_node_id = DomNodeId {
                        dom: dom_id,
                        node: hierarchy_id,
                    };

                    // Get old text from node
                    let old_inline_content = self.get_text_before_textinput(dom_id, node_id);
                    let old_text = self.extract_text_from_inline_content(&old_inline_content);

                    // Record the text input
                    use crate::managers::text_input::TextInputSource;
                    self.text_input_manager.record_input(
                        dom_node_id,
                        text.to_string(),
                        old_text,
                        TextInputSource::Programmatic,
                    );
                }
                CallbackChange::DeleteBackward { dom_id, node_id } => {
                    // Get current cursor/selection
                    if let Some(cursor) = self.cursor_manager.get_cursor() {
                        // Get current content
                        let content = self.get_text_before_textinput(dom_id, node_id);

                        // Apply delete backward using text3::edit

                        use crate::text3::edit::{delete_backward, TextEdit};
                        let mut new_content = content.clone();
                        let (updated_content, new_cursor) =
                            delete_backward(&mut new_content, cursor);

                        // Update cursor position
                        self.cursor_manager
                            .move_cursor_to(new_cursor, dom_id, node_id);

                        // Update text cache
                        self.update_text_cache_after_edit(dom_id, node_id, updated_content);

                        // Mark node as dirty
                        let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                        let dom_node_id = DomNodeId {
                            dom: dom_id,
                            node: hierarchy_id,
                        };
                        // Note: Dirty marking happens in the caller
                    }
                }
                CallbackChange::DeleteForward { dom_id, node_id } => {
                    // Get current cursor/selection
                    if let Some(cursor) = self.cursor_manager.get_cursor() {
                        // Get current content
                        let content = self.get_text_before_textinput(dom_id, node_id);

                        // Apply delete forward using text3::edit

                        use crate::text3::edit::{delete_forward, TextEdit};
                        let mut new_content = content.clone();
                        let (updated_content, new_cursor) =
                            delete_forward(&mut new_content, cursor);

                        // Update cursor position
                        self.cursor_manager
                            .move_cursor_to(new_cursor, dom_id, node_id);

                        // Update text cache
                        self.update_text_cache_after_edit(dom_id, node_id, updated_content);
                    }
                }
                CallbackChange::MoveCursor {
                    dom_id,
                    node_id,
                    cursor,
                } => {
                    // Update cursor position in CursorManager
                    self.cursor_manager.move_cursor_to(cursor, dom_id, node_id);
                }
                CallbackChange::SetSelection {
                    dom_id,
                    node_id,
                    selection,
                } => {
                    // Update selection in SelectionManager
                    let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                    let dom_node_id = DomNodeId {
                        dom: dom_id,
                        node: hierarchy_id,
                    };

                    match selection {
                        Selection::Cursor(cursor) => {
                            self.cursor_manager.move_cursor_to(cursor, dom_id, node_id);
                            self.selection_manager.clear_all();
                        }
                        Selection::Range(range) => {
                            self.cursor_manager
                                .move_cursor_to(range.start, dom_id, node_id);
                            // TODO: Set selection range in SelectionManager
                            // self.selection_manager.set_selection(dom_node_id, range);
                        }
                    }
                }
                CallbackChange::SetTextChangeset { changeset } => {
                    // Override the current text input changeset
                    // This allows user callbacks to modify what text will be inserted
                    self.text_input_manager.pending_changeset = Some(changeset);
                }
                // Cursor Movement Operations
                CallbackChange::MoveCursorLeft {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    if let Some(new_cursor) =
                        self.move_cursor_in_node(dom_id, node_id, |layout, cursor| {
                            layout.move_cursor_left(*cursor, &mut None)
                        })
                    {
                        self.handle_cursor_movement(dom_id, node_id, new_cursor, extend_selection);
                    }
                }
                CallbackChange::MoveCursorRight {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    if let Some(new_cursor) =
                        self.move_cursor_in_node(dom_id, node_id, |layout, cursor| {
                            layout.move_cursor_right(*cursor, &mut None)
                        })
                    {
                        self.handle_cursor_movement(dom_id, node_id, new_cursor, extend_selection);
                    }
                }
                CallbackChange::MoveCursorUp {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    if let Some(new_cursor) =
                        self.move_cursor_in_node(dom_id, node_id, |layout, cursor| {
                            layout.move_cursor_up(*cursor, &mut None, &mut None)
                        })
                    {
                        self.handle_cursor_movement(dom_id, node_id, new_cursor, extend_selection);
                    }
                }
                CallbackChange::MoveCursorDown {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    if let Some(new_cursor) =
                        self.move_cursor_in_node(dom_id, node_id, |layout, cursor| {
                            layout.move_cursor_down(*cursor, &mut None, &mut None)
                        })
                    {
                        self.handle_cursor_movement(dom_id, node_id, new_cursor, extend_selection);
                    }
                }
                CallbackChange::MoveCursorToLineStart {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    if let Some(new_cursor) =
                        self.move_cursor_in_node(dom_id, node_id, |layout, cursor| {
                            layout.move_cursor_to_line_start(*cursor, &mut None)
                        })
                    {
                        self.handle_cursor_movement(dom_id, node_id, new_cursor, extend_selection);
                    }
                }
                CallbackChange::MoveCursorToLineEnd {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    if let Some(new_cursor) =
                        self.move_cursor_in_node(dom_id, node_id, |layout, cursor| {
                            layout.move_cursor_to_line_end(*cursor, &mut None)
                        })
                    {
                        self.handle_cursor_movement(dom_id, node_id, new_cursor, extend_selection);
                    }
                }
                CallbackChange::MoveCursorToDocumentStart {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    // Document start is the first cluster in the layout
                    if let Some(new_cursor) = self.get_inline_layout_for_node(dom_id, node_id) {
                        if let Some(first_cluster) = new_cursor
                            .items
                            .first()
                            .and_then(|item| item.item.as_cluster())
                        {
                            let doc_start_cursor = TextCursor {
                                cluster_id: first_cluster.source_cluster_id,
                                affinity: CursorAffinity::Leading,
                            };
                            self.handle_cursor_movement(
                                dom_id,
                                node_id,
                                doc_start_cursor,
                                extend_selection,
                            );
                        }
                    }
                }
                CallbackChange::MoveCursorToDocumentEnd {
                    dom_id,
                    node_id,
                    extend_selection,
                } => {
                    // Document end is the last cluster in the layout
                    if let Some(layout) = self.get_inline_layout_for_node(dom_id, node_id) {
                        if let Some(last_cluster) =
                            layout.items.last().and_then(|item| item.item.as_cluster())
                        {
                            let doc_end_cursor = TextCursor {
                                cluster_id: last_cluster.source_cluster_id,
                                affinity: CursorAffinity::Trailing,
                            };
                            self.handle_cursor_movement(
                                dom_id,
                                node_id,
                                doc_end_cursor,
                                extend_selection,
                            );
                        }
                    }
                }
                // Clipboard Operations (Override)
                CallbackChange::SetCopyContent { target, content } => {
                    // Store clipboard content to be written to system clipboard
                    // This will be picked up by the platform's sync_clipboard() method
                    self.clipboard_manager.set_copy_content(content);
                }
                CallbackChange::SetCutContent { target, content } => {
                    // Same as copy, but the deletion is handled separately
                    self.clipboard_manager.set_copy_content(content);
                }
                CallbackChange::SetSelectAllRange { target, range } => {
                    // Override selection range for select-all operation
                    // Convert DomNodeId back to internal NodeId
                    if let Some(node_id_internal) = target.node.into_crate_internal() {
                        let dom_node_id = azul_core::dom::DomNodeId {
                            dom: target.dom,
                            node: target.node,
                        };
                        self.selection_manager
                            .set_range(target.dom, dom_node_id, range);
                    }
                }
                CallbackChange::RequestHitTestUpdate { position } => {
                    // Mark that a hit test update is requested
                    // This will be processed by the shell layer which has access to WebRender
                    result.hit_test_update_requested = Some(position);
                }
                CallbackChange::ProcessTextSelectionClick { position, time_ms } => {
                    // Process text selection click at position
                    // This is used by the Debug API to trigger text selection directly
                    // The selection update will cause the display list to be regenerated
                    let _ = self.process_mouse_click_for_selection(position, time_ms);
                }
                CallbackChange::SetCursorVisibility { visible: _ } => {
                    // Timer callback sets visibility - check if we should blink or stay solid
                    let now = azul_core::task::Instant::now();
                    if self.cursor_manager.should_blink(&now) {
                        // Enough time has passed since last input - toggle visibility
                        self.cursor_manager.toggle_visibility();
                    } else {
                        // User is actively typing - keep cursor visible
                        self.cursor_manager.set_visibility(true);
                    }
                }
                CallbackChange::ResetCursorBlink => {
                    // Reset cursor blink state on user input
                    let now = azul_core::task::Instant::now();
                    self.cursor_manager.reset_blink_on_input(now);
                }
                CallbackChange::StartCursorBlinkTimer => {
                    // Start the cursor blink timer if not already active
                    if !self.cursor_manager.is_blink_timer_active() {
                        let timer = self.create_cursor_blink_timer(current_window_state);
                        result.timers.insert(azul_core::task::CURSOR_BLINK_TIMER_ID, timer);
                        self.cursor_manager.set_blink_timer_active(true);
                    }
                }
                CallbackChange::StopCursorBlinkTimer => {
                    // Stop the cursor blink timer
                    if self.cursor_manager.is_blink_timer_active() {
                        result.timers_removed.insert(azul_core::task::CURSOR_BLINK_TIMER_ID);
                        self.cursor_manager.set_blink_timer_active(false);
                    }
                }
                CallbackChange::ScrollActiveCursorIntoView => {
                    // Scroll the active text cursor into view
                    self.scroll_active_cursor_into_view(&mut result);
                }
                CallbackChange::CreateTextInput { text } => {
                    // Create a synthetic text input event
                    // This simulates receiving text input from the OS
                    println!("[CreateTextInput] Processing text: '{}'", text.as_str());
                    
                    // Process the text input - this records the changeset in TextInputManager
                    let affected_nodes = self.process_text_input(text.as_str());
                    println!("[CreateTextInput] process_text_input returned {} affected nodes", affected_nodes.len());
                    
                    // Mark that we need to trigger text input callbacks
                    // The affected nodes and their events will be processed by the recursive event loop
                    for (node, (events, _)) in affected_nodes {
                        result.text_input_triggered.push((node, events));
                    }
                }
            }
        }

        // Sync cursor to selection manager for rendering
        // This must happen after all cursor updates
        self.sync_cursor_to_selection_manager();

        result
    }

    /// Helper: Get inline layout for a node
    /// 
    /// For text nodes that participate in an IFC, the inline layout is stored
    /// on the IFC root node (the block container), not on the text node itself.
    /// This method handles both cases:
    /// 1. The node has its own `inline_layout_result` (IFC root)
    /// 2. The node has `ifc_membership` pointing to the IFC root
    ///
    /// This is a thin wrapper around `LayoutTree::get_inline_layout_for_node`.
    fn get_inline_layout_for_node(
        &self,
        dom_id: DomId,
        node_id: NodeId,
    ) -> Option<&Arc<UnifiedLayout>> {
        let layout_result = self.layout_results.get(&dom_id)?;

        let layout_indices = layout_result.layout_tree.dom_to_layout.get(&node_id)?;
        let layout_index = *layout_indices.first()?;

        // Use the centralized LayoutTree method that handles IFC membership
        layout_result.layout_tree.get_inline_layout_for_node(layout_index)
    }

    /// Helper: Move cursor using a movement function and return the new cursor if it changed
    fn move_cursor_in_node<F>(
        &self,
        dom_id: DomId,
        node_id: NodeId,
        movement_fn: F,
    ) -> Option<TextCursor>
    where
        F: FnOnce(&UnifiedLayout, &TextCursor) -> TextCursor,
    {
        let current_cursor = self.cursor_manager.get_cursor()?;
        let layout = self.get_inline_layout_for_node(dom_id, node_id)?;

        let new_cursor = movement_fn(layout, current_cursor);

        // Only return if cursor actually moved
        if new_cursor != *current_cursor {
            Some(new_cursor)
        } else {
            None
        }
    }

    /// Helper: Handle cursor movement with optional selection extension
    fn handle_cursor_movement(
        &mut self,
        dom_id: DomId,
        node_id: NodeId,
        new_cursor: TextCursor,
        extend_selection: bool,
    ) {
        if extend_selection {
            // Get the current cursor as the selection anchor
            if let Some(old_cursor) = self.cursor_manager.get_cursor() {
                // Create DomNodeId for the selection
                let dom_node_id = azul_core::dom::DomNodeId {
                    dom: dom_id,
                    node: NodeHierarchyItemId::from_crate_internal(Some(node_id)),
                };

                // Create a selection range from old cursor to new cursor
                let selection_range = if new_cursor.cluster_id.start_byte_in_run
                    < old_cursor.cluster_id.start_byte_in_run
                {
                    // Moving backwards
                    SelectionRange {
                        start: new_cursor,
                        end: *old_cursor,
                    }
                } else {
                    // Moving forwards
                    SelectionRange {
                        start: *old_cursor,
                        end: new_cursor,
                    }
                };

                // Set the selection range in SelectionManager
                self.selection_manager
                    .set_range(dom_id, dom_node_id, selection_range);
            }

            // Move cursor to new position
            self.cursor_manager
                .move_cursor_to(new_cursor, dom_id, node_id);
        } else {
            // Just move cursor without extending selection
            self.cursor_manager
                .move_cursor_to(new_cursor, dom_id, node_id);

            // Clear any existing selection
            self.selection_manager.clear_selection(&dom_id);
        }
    }

    // Gpu Value Cache Management

    /// Get the GPU value cache for a specific DOM
    pub fn get_gpu_cache(&self, dom_id: &DomId) -> Option<&GpuValueCache> {
        self.gpu_state_manager.caches.get(dom_id)
    }

    /// Get a mutable reference to the GPU value cache for a specific DOM
    pub fn get_gpu_cache_mut(&mut self, dom_id: &DomId) -> Option<&mut GpuValueCache> {
        self.gpu_state_manager.caches.get_mut(dom_id)
    }

    /// Get or create a GPU value cache for a specific DOM
    pub fn get_or_create_gpu_cache(&mut self, dom_id: DomId) -> &mut GpuValueCache {
        self.gpu_state_manager
            .caches
            .entry(dom_id)
            .or_insert_with(GpuValueCache::default)
    }

    // Layout Result Access

    /// Get a layout result for a specific DOM
    pub fn get_layout_result(&self, dom_id: &DomId) -> Option<&DomLayoutResult> {
        self.layout_results.get(dom_id)
    }

    /// Get a mutable layout result for a specific DOM
    pub fn get_layout_result_mut(&mut self, dom_id: &DomId) -> Option<&mut DomLayoutResult> {
        self.layout_results.get_mut(dom_id)
    }

    /// Get all DOM IDs that have layout results
    pub fn get_dom_ids(&self) -> DomIdVec {
        self.layout_results
            .keys()
            .copied()
            .collect::<Vec<_>>()
            .into()
    }

    // Hit-Test Computation

    /// Compute the cursor type hit-test from a full hit-test
    ///
    /// This determines which mouse cursor to display based on the CSS cursor
    /// properties of the hovered nodes.
    pub fn compute_cursor_type_hit_test(
        &self,
        hit_test: &crate::hit_test::FullHitTest,
    ) -> crate::hit_test::CursorTypeHitTest {
        crate::hit_test::CursorTypeHitTest::new(hit_test, self)
    }

    // TODO: Implement compute_hit_test() once we have the actual hit-testing logic
    // This would involve:
    // 1. Converting screen coordinates to layout coordinates
    // 2. Traversing the layout tree to find nodes under the cursor
    // 3. Handling z-index and stacking contexts
    // 4. Building the FullHitTest structure

    /// Synchronize scrollbar opacity values with the GPU value cache.
    ///
    /// This method updates GPU opacity keys for all scrollbars based on scroll activity
    /// tracked by the ScrollManager. It enables smooth scrollbar fading without
    /// requiring display list regeneration.
    ///
    /// # Arguments
    ///
    /// * `dom_id` - The DOM to synchronize scrollbar opacity for
    /// * `layout_tree` - The layout tree containing scrollbar information
    /// * `now` - Current timestamp for calculating fade progress
    /// * `fade_delay` - Delay before scrollbar starts fading (e.g., 500ms)
    /// * `fade_duration` - Duration of the fade animation (e.g., 200ms)
    ///
    /// # Returns
    ///
    /// A vector of GPU scrollbar opacity change events

    /// Helper function to calculate scrollbar opacity based on activity time
    fn calculate_scrollbar_opacity(
        last_activity: Option<Instant>,
        now: Instant,
        fade_delay: Duration,
        fade_duration: Duration,
    ) -> f32 {
        let Some(last_activity) = last_activity else {
            return 0.0;
        };

        let time_since_activity = now.duration_since(&last_activity);

        // Phase 1: Scrollbar stays fully visible during fade_delay
        if time_since_activity.div(&fade_delay) < 1.0 {
            return 1.0;
        }

        // Phase 2: Fade out over fade_duration
        let time_into_fade_ms = time_since_activity.div(&fade_delay) - 1.0;
        let fade_progress = (time_into_fade_ms * fade_duration.div(&fade_duration)).min(1.0);

        // Phase 3: Fully faded
        (1.0 - fade_progress).max(0.0)
    }

    /// Synchronize scrollbar opacity values with the GPU value cache.
    ///
    /// Static method that takes individual components instead of &mut self to avoid borrow
    /// conflicts.
    pub fn synchronize_scrollbar_opacity(
        gpu_state_manager: &mut GpuStateManager,
        scroll_manager: &ScrollManager,
        dom_id: DomId,
        layout_tree: &LayoutTree,
        system_callbacks: &ExternalSystemCallbacks,
        fade_delay: azul_core::task::Duration,
        fade_duration: azul_core::task::Duration,
    ) -> Vec<azul_core::gpu::GpuScrollbarOpacityEvent> {
        let mut events = Vec::new();
        let gpu_cache = gpu_state_manager.caches.entry(dom_id).or_default();

        // Get current time from system callbacks
        let now = (system_callbacks.get_system_time_fn.cb)();

        // Iterate over all nodes with scrollbar info
        for (node_idx, node) in layout_tree.nodes.iter().enumerate() {
            // Check if node needs scrollbars
            let scrollbar_info = match &node.scrollbar_info {
                Some(info) => info,
                None => continue,
            };

            let node_id = match node.dom_node_id {
                Some(nid) => nid,
                None => continue, // Skip anonymous boxes
            };

            // Calculate current opacity from ScrollManager
            let vertical_opacity = if scrollbar_info.needs_vertical {
                Self::calculate_scrollbar_opacity(
                    scroll_manager.get_last_activity_time(dom_id, node_id),
                    now.clone(),
                    fade_delay,
                    fade_duration,
                )
            } else {
                0.0
            };

            let horizontal_opacity = if scrollbar_info.needs_horizontal {
                Self::calculate_scrollbar_opacity(
                    scroll_manager.get_last_activity_time(dom_id, node_id),
                    now.clone(),
                    fade_delay,
                    fade_duration,
                )
            } else {
                0.0
            };

            // Handle vertical scrollbar
            if scrollbar_info.needs_vertical && vertical_opacity > 0.001 {
                let key = (dom_id, node_id);
                let existing = gpu_cache.scrollbar_v_opacity_values.get(&key);

                match existing {
                    None => {
                        let opacity_key = OpacityKey::unique();
                        gpu_cache.scrollbar_v_opacity_keys.insert(key, opacity_key);
                        gpu_cache
                            .scrollbar_v_opacity_values
                            .insert(key, vertical_opacity);
                        events.push(GpuScrollbarOpacityEvent::VerticalAdded(
                            dom_id,
                            node_id,
                            opacity_key,
                            vertical_opacity,
                        ));
                    }
                    Some(&old_opacity) if (old_opacity - vertical_opacity).abs() > 0.001 => {
                        let opacity_key = gpu_cache.scrollbar_v_opacity_keys[&key];
                        gpu_cache
                            .scrollbar_v_opacity_values
                            .insert(key, vertical_opacity);
                        events.push(GpuScrollbarOpacityEvent::VerticalChanged(
                            dom_id,
                            node_id,
                            opacity_key,
                            old_opacity,
                            vertical_opacity,
                        ));
                    }
                    _ => {}
                }
            } else {
                // Remove if scrollbar no longer needed or fully transparent
                let key = (dom_id, node_id);
                if let Some(opacity_key) = gpu_cache.scrollbar_v_opacity_keys.remove(&key) {
                    gpu_cache.scrollbar_v_opacity_values.remove(&key);
                    events.push(GpuScrollbarOpacityEvent::VerticalRemoved(
                        dom_id,
                        node_id,
                        opacity_key,
                    ));
                }
            }

            // Handle horizontal scrollbar (same logic)
            if scrollbar_info.needs_horizontal && horizontal_opacity > 0.001 {
                let key = (dom_id, node_id);
                let existing = gpu_cache.scrollbar_h_opacity_values.get(&key);

                match existing {
                    None => {
                        let opacity_key = OpacityKey::unique();
                        gpu_cache.scrollbar_h_opacity_keys.insert(key, opacity_key);
                        gpu_cache
                            .scrollbar_h_opacity_values
                            .insert(key, horizontal_opacity);
                        events.push(GpuScrollbarOpacityEvent::HorizontalAdded(
                            dom_id,
                            node_id,
                            opacity_key,
                            horizontal_opacity,
                        ));
                    }
                    Some(&old_opacity) if (old_opacity - horizontal_opacity).abs() > 0.001 => {
                        let opacity_key = gpu_cache.scrollbar_h_opacity_keys[&key];
                        gpu_cache
                            .scrollbar_h_opacity_values
                            .insert(key, horizontal_opacity);
                        events.push(GpuScrollbarOpacityEvent::HorizontalChanged(
                            dom_id,
                            node_id,
                            opacity_key,
                            old_opacity,
                            horizontal_opacity,
                        ));
                    }
                    _ => {}
                }
            } else {
                // Remove if scrollbar no longer needed or fully transparent
                let key = (dom_id, node_id);
                if let Some(opacity_key) = gpu_cache.scrollbar_h_opacity_keys.remove(&key) {
                    gpu_cache.scrollbar_h_opacity_values.remove(&key);
                    events.push(GpuScrollbarOpacityEvent::HorizontalRemoved(
                        dom_id,
                        node_id,
                        opacity_key,
                    ));
                }
            }
        }

        events
    }

    /// Compute stable scroll IDs for all scrollable nodes in a layout tree
    ///
    /// This should be called after layout but before display list generation.
    /// It creates stable IDs based on node_data_hash that persist across frames.
    ///
    /// Returns:
    /// - scroll_ids: Map from layout node index -> external scroll ID
    /// - scroll_id_to_node_id: Map from scroll ID -> DOM NodeId (for hit testing)
    pub fn compute_scroll_ids(
        layout_tree: &LayoutTree,
        styled_dom: &azul_core::styled_dom::StyledDom,
    ) -> (BTreeMap<usize, u64>, BTreeMap<u64, NodeId>) {
        use azul_css::props::layout::LayoutOverflow;

        use crate::solver3::getters::{get_overflow_x, get_overflow_y};

        let mut scroll_ids = BTreeMap::new();
        let mut scroll_id_to_node_id = BTreeMap::new();

        // Iterate through all layout nodes
        for (layout_idx, node) in layout_tree.nodes.iter().enumerate() {
            let Some(dom_node_id) = node.dom_node_id else {
                continue;
            };

            // Get the node state
            let styled_node_state = styled_dom
                .styled_nodes
                .as_container()
                .get(dom_node_id)
                .map(|n| n.styled_node_state.clone())
                .unwrap_or_default();

            // Check if this node has scroll overflow
            let overflow_x = get_overflow_x(styled_dom, dom_node_id, &styled_node_state);
            let overflow_y = get_overflow_y(styled_dom, dom_node_id, &styled_node_state);

            let is_scrollable = overflow_x.is_scroll() || overflow_y.is_scroll();

            if !is_scrollable {
                continue;
            }

            // Generate stable scroll ID from node_data_hash
            // Use node_data_hash to create a stable ID that persists across frames
            let scroll_id = node.node_data_hash;

            scroll_ids.insert(layout_idx, scroll_id);
            scroll_id_to_node_id.insert(scroll_id, dom_node_id);
        }

        (scroll_ids, scroll_id_to_node_id)
    }

    /// Get the layout rectangle for a specific DOM node in logical coordinates
    ///
    /// This is useful in callbacks to get the position and size of the hit node
    /// for positioning menus, tooltips, or other overlays.
    ///
    /// Returns None if the node is not currently laid out (e.g., display:none)
    pub fn get_node_layout_rect(
        &self,
        node_id: azul_core::dom::DomNodeId,
    ) -> Option<azul_core::geom::LogicalRect> {
        // Get the layout tree from cache
        let layout_tree = self.layout_cache.tree.as_ref()?;

        // Find the layout node index corresponding to this DOM node
        // Convert NodeHierarchyItemId to Option<NodeId> for comparison
        let target_node_id = node_id.node.into_crate_internal();
        let layout_idx = layout_tree
            .nodes
            .iter()
            .position(|node| node.dom_node_id == target_node_id)?;

        // Get the calculated layout position from cache (already in logical units)
        let calc_pos = self.layout_cache.calculated_positions.get(&layout_idx)?;

        // Get the layout node for size information
        let layout_node = layout_tree.nodes.get(layout_idx)?;

        // Get the used size (the actual laid-out size)
        let used_size = layout_node.used_size?;

        // Convert size to logical coordinates
        let hidpi_factor = self
            .current_window_state
            .size
            .get_hidpi_factor()
            .inner
            .get();

        Some(LogicalRect::new(
            LogicalPosition::new(calc_pos.x as f32, calc_pos.y as f32),
            LogicalSize::new(
                used_size.width / hidpi_factor,
                used_size.height / hidpi_factor,
            ),
        ))
    }

    /// Get the cursor rect for the currently focused text input node in ABSOLUTE coordinates.
    ///
    /// This returns the cursor position in absolute window coordinates (not accounting for
    /// scroll offsets). This is used for scroll-into-view calculations where you need to
    /// compare the cursor position with the scrollable container's bounds.
    ///
    /// Returns None if:
    /// - No node is focused
    /// - Focused node has no text cursor
    /// - Focused node has no layout
    /// - Text cache cannot find cursor position
    ///
    /// For IME positioning (viewport-relative coordinates), use
    /// `get_focused_cursor_rect_viewport()`.
    pub fn get_focused_cursor_rect(&self) -> Option<azul_core::geom::LogicalRect> {
        // Get the focused node
        let focused_node = self.focus_manager.focused_node?;

        // Get the text cursor
        let cursor = self.cursor_manager.get_cursor()?;

        // Get the layout tree from cache
        let layout_tree = self.layout_cache.tree.as_ref()?;

        // Find the layout node index corresponding to the focused DOM node
        let target_node_id = focused_node.node.into_crate_internal();
        let layout_idx = layout_tree
            .nodes
            .iter()
            .position(|node| node.dom_node_id == target_node_id)?;

        // Get the layout node
        let layout_node = layout_tree.nodes.get(layout_idx)?;

        // Get the text layout result for this node
        let cached_layout = layout_node.inline_layout_result.as_ref()?;
        let inline_layout = &cached_layout.layout;

        // Get the cursor rect in node-relative coordinates
        let mut cursor_rect = inline_layout.get_cursor_rect(cursor)?;

        // Get the calculated layout position from cache (already in logical units)
        let calc_pos = self.layout_cache.calculated_positions.get(&layout_idx)?;

        // Add layout position to cursor rect (both already in logical units)
        cursor_rect.origin.x += calc_pos.x as f32;
        cursor_rect.origin.y += calc_pos.y as f32;

        // Return ABSOLUTE position (no scroll correction)
        Some(cursor_rect)
    }

    /// Get the cursor rect for the currently focused text input node in VIEWPORT coordinates.
    ///
    /// This returns the cursor position accounting for:
    /// 1. Scroll offsets from all scrollable ancestors
    /// 2. GPU transforms (CSS transforms, animations) from all transformed ancestors
    ///
    /// The returned position is viewport-relative (what the user actually sees on screen).
    /// This is used for IME window positioning, where the IME popup needs to appear at the
    /// visible cursor location, not the absolute layout position.
    ///
    /// Returns None if:
    /// - No node is focused
    /// - Focused node has no text cursor
    /// - Focused node has no layout
    /// - Text cache cannot find cursor position
    ///
    /// For scroll-into-view calculations (absolute coordinates), use `get_focused_cursor_rect()`.
    pub fn get_focused_cursor_rect_viewport(&self) -> Option<azul_core::geom::LogicalRect> {
        // Start with absolute position
        let mut cursor_rect = self.get_focused_cursor_rect()?;

        // Get the focused node
        let focused_node = self.focus_manager.focused_node?;

        // Get the layout tree from cache
        let layout_tree = self.layout_cache.tree.as_ref()?;

        // Find the layout node index corresponding to the focused DOM node
        let target_node_id = focused_node.node.into_crate_internal();
        let layout_idx = layout_tree
            .nodes
            .iter()
            .position(|node| node.dom_node_id == target_node_id)?;

        // Get the GPU cache for this DOM (if it exists)
        let gpu_cache = self.gpu_state_manager.caches.get(&focused_node.dom);

        // CRITICAL STEP 1: Apply scroll offsets from all scrollable ancestors
        // CRITICAL STEP 2: Apply inverse GPU transforms from all transformed ancestors
        // Walk up the tree and apply both corrections
        let mut current_layout_idx = layout_idx;

        while let Some(parent_idx) = layout_tree.nodes.get(current_layout_idx)?.parent {
            // Get the DOM node ID of the parent (if it's not anonymous)
            if let Some(parent_dom_node_id) = layout_tree.nodes.get(parent_idx)?.dom_node_id {
                // STEP 1: Check if this parent is scrollable and has scroll state
                if let Some(scroll_state) = self
                    .scroll_manager
                    .get_scroll_state(focused_node.dom, parent_dom_node_id)
                {
                    // Subtract scroll offset (scrolling down = positive offset, moves content up)
                    cursor_rect.origin.x -= scroll_state.current_offset.x;
                    cursor_rect.origin.y -= scroll_state.current_offset.y;
                }

                // STEP 2: Check if this parent has a GPU transform applied
                if let Some(cache) = gpu_cache {
                    if let Some(transform) = cache.current_transform_values.get(&parent_dom_node_id)
                    {
                        // Apply the INVERSE transform to get back to viewport coordinates
                        // The transform moves the element, so we need to reverse it for the cursor
                        let inverse = transform.inverse();
                        if let Some(transformed_origin) =
                            inverse.transform_point2d(cursor_rect.origin)
                        {
                            cursor_rect.origin = transformed_origin;
                        }
                        // Note: We don't transform the size, only the position
                    }
                }
            }

            // Move to parent for next iteration
            current_layout_idx = parent_idx;
        }

        Some(cursor_rect)
    }

    /// Find the nearest scrollable ancestor for a given node
    /// Returns (DomId, NodeId) of the scrollable container, or None if no scrollable ancestor
    /// exists
    pub fn find_scrollable_ancestor(
        &self,
        mut node_id: azul_core::dom::DomNodeId,
    ) -> Option<azul_core::dom::DomNodeId> {
        // Get the layout tree
        let layout_tree = self.layout_cache.tree.as_ref()?;

        // Convert to internal NodeId
        let mut current_node_id = node_id.node.into_crate_internal();

        // Walk up the tree looking for a scrollable node
        loop {
            // Find layout node index
            let layout_idx = layout_tree
                .nodes
                .iter()
                .position(|node| node.dom_node_id == current_node_id)?;

            let layout_node = layout_tree.nodes.get(layout_idx)?;

            // Check if this node has scrollbar info (meaning it's scrollable)
            if layout_node.scrollbar_info.is_some() {
                // Check if it actually has a scroll state registered
                let check_node_id = current_node_id?;
                if self
                    .scroll_manager
                    .get_scroll_state(node_id.dom, check_node_id)
                    .is_some()
                {
                    // Found a scrollable ancestor
                    return Some(azul_core::dom::DomNodeId {
                        dom: node_id.dom,
                        node: azul_core::styled_dom::NodeHierarchyItemId::from_crate_internal(
                            Some(check_node_id),
                        ),
                    });
                }
            }

            // Move to parent
            let parent_idx = layout_node.parent?;
            let parent_node = layout_tree.nodes.get(parent_idx)?;
            current_node_id = parent_node.dom_node_id;
        }
    }

    /// Scroll selection or cursor into view with distance-based acceleration.
    ///
    /// **Unified Scroll System**: This method handles both cursor (0-size selection)
    /// and full selection scrolling with a single implementation. For drag-to-scroll,
    /// scroll speed increases with distance from container edge.
    ///
    /// ## Algorithm
    /// 1. Get bounds to scroll (cursor rect, selection rect, or mouse position)
    /// 2. Find scrollable ancestor container
    /// 3. Calculate distance from bounds to container edges
    /// 4. Compute scroll delta (instant with padding, or accelerated with zones)
    /// 5. Apply scroll with appropriate animation
    ///
    /// ## Distance-Based Acceleration (ScrollMode::Accelerated)
    /// ```text
    /// Distance from edge:  Scroll speed per frame:
    /// 0-20px              Dead zone (no scroll)
    /// 20-50px             Slow (2px/frame)
    /// 50-100px            Medium (4px/frame)
    /// 100-200px           Fast (8px/frame)
    /// 200+px              Very fast (16px/frame)
    /// ```
    ///
    /// ## Returns
    /// `true` if scrolling was applied, `false` if already visible
    pub fn scroll_selection_into_view(
        &mut self,
        scroll_type: SelectionScrollType,
        scroll_mode: ScrollMode,
    ) -> bool {
        // Get bounds to scroll into view
        let bounds = match scroll_type {
            SelectionScrollType::Cursor => {
                // Cursor is 0-size selection at insertion point
                match self.get_focused_cursor_rect() {
                    Some(rect) => rect,
                    None => return false, // No cursor to scroll
                }
            }
            SelectionScrollType::Selection => {
                // Get selection range(s) and compute bounding rect
                // For now, treat as cursor until we implement calculate_selection_bounding_rect
                match self.get_focused_cursor_rect() {
                    Some(rect) => rect,
                    None => return false, // No selection to scroll
                }
                // TODO: Implement calculate_selection_bounding_rect
                // let ranges = self.selection_manager.get_selection();
                // if ranges.is_empty() {
                //     return false;
                // }
                // self.calculate_selection_bounding_rect(ranges)?
            }
            SelectionScrollType::DragSelection { mouse_position } => {
                // For drag: use mouse position to determine scroll direction/speed
                LogicalRect::new(mouse_position, LogicalSize::zero())
            }
        };

        // Get the focused node (or bail if no focus)
        let focused_node = match self.focus_manager.focused_node {
            Some(node) => node,
            None => return false,
        };

        // Find scrollable ancestor
        let scroll_container = match self.find_scrollable_ancestor(focused_node) {
            Some(node) => node,
            None => return false, // No scrollable ancestor
        };

        // Get container bounds and current scroll state
        let layout_tree = match self.layout_cache.tree.as_ref() {
            Some(tree) => tree,
            None => return false,
        };

        let scrollable_node_internal = match scroll_container.node.into_crate_internal() {
            Some(id) => id,
            None => return false,
        };

        let layout_idx = match layout_tree
            .nodes
            .iter()
            .position(|n| n.dom_node_id == Some(scrollable_node_internal))
        {
            Some(idx) => idx,
            None => return false,
        };

        let scrollable_layout_node = match layout_tree.nodes.get(layout_idx) {
            Some(node) => node,
            None => return false,
        };

        let container_pos = self
            .layout_cache
            .calculated_positions
            .get(&layout_idx)
            .copied()
            .unwrap_or_default();

        let container_size = scrollable_layout_node.used_size.unwrap_or_default();

        let container_rect = LogicalRect {
            origin: container_pos,
            size: container_size,
        };

        // Get current scroll state
        let scroll_state = match self
            .scroll_manager
            .get_scroll_state(scroll_container.dom, scrollable_node_internal)
        {
            Some(state) => state,
            None => return false,
        };

        // Calculate visible area (container rect adjusted by scroll offset)
        let visible_area = LogicalRect::new(
            LogicalPosition::new(
                container_rect.origin.x + scroll_state.current_offset.x,
                container_rect.origin.y + scroll_state.current_offset.y,
            ),
            container_rect.size,
        );

        // Calculate scroll delta based on mode
        let scroll_delta = match scroll_mode {
            ScrollMode::Instant => {
                // For typing/clicking: instant scroll with fixed padding
                calculate_instant_scroll_delta(bounds, visible_area)
            }
            ScrollMode::Accelerated => {
                // For drag: accelerated scroll based on distance from edge
                let distance = calculate_edge_distance(bounds, visible_area);
                calculate_accelerated_scroll_delta(distance)
            }
        };

        // Apply scroll if needed
        if scroll_delta.x != 0.0 || scroll_delta.y != 0.0 {
            let duration = match scroll_mode {
                ScrollMode::Instant => Duration::System(SystemTimeDiff { secs: 0, nanos: 0 }),
                ScrollMode::Accelerated => Duration::System(SystemTimeDiff {
                    secs: 0,
                    nanos: 16_666_667,
                }), // 60fps
            };

            let external = ExternalSystemCallbacks::rust_internal();
            let now = (external.get_system_time_fn.cb)();

            // Calculate new scroll target
            let new_target = LogicalPosition {
                x: scroll_state.current_offset.x + scroll_delta.x,
                y: scroll_state.current_offset.y + scroll_delta.y,
            };

            self.scroll_manager.scroll_to(
                scroll_container.dom,
                scrollable_node_internal,
                new_target,
                duration,
                EasingFunction::Linear,
                now.into(),
            );

            true // Scrolled
        } else {
            false // Already visible
        }
    }

    /// Automatically scrolls the focused cursor into view after layout.
    ///
    /// **DEPRECATED**: Use `scroll_selection_into_view(SelectionScrollType::Cursor,
    /// ScrollMode::Instant)` instead. This method is kept for compatibility but redirects to
    /// the unified scroll system.
    ///
    /// This is called after `layout_and_generate_display_list()` to ensure that
    /// text cursors remain visible after text input or cursor movement.
    ///
    /// Algorithm:
    /// 1. Get the focused cursor rect (if any)
    /// 2. Find the scrollable ancestor container
    /// 3. Calculate scroll delta to bring cursor into view
    /// 4. Apply instant scroll (no animation for text input responsiveness)
    fn scroll_focused_cursor_into_view(&mut self) {
        // Redirect to unified scroll system
        self.scroll_selection_into_view(SelectionScrollType::Cursor, ScrollMode::Instant);
    }
}

/// Type of selection bounds to scroll into view
#[derive(Debug, Clone, Copy)]
pub enum SelectionScrollType {
    /// Scroll cursor (0-size selection) into view
    Cursor,
    /// Scroll current selection bounds into view
    Selection,
    /// Scroll for drag selection (use mouse position for direction/speed)
    DragSelection { mouse_position: LogicalPosition },
}

/// Scroll animation mode
#[derive(Debug, Clone, Copy)]
pub enum ScrollMode {
    /// Instant scroll with fixed padding (for typing, arrow keys)
    Instant,
    /// Accelerated scroll based on distance from edge (for drag-to-scroll)
    Accelerated,
}

/// Distance from rect edges to container edges (for acceleration calculation)
#[derive(Debug, Clone, Copy)]
struct EdgeDistance {
    left: f32,
    right: f32,
    top: f32,
    bottom: f32,
}

/// Calculate distance from rect to container edges
fn calculate_edge_distance(rect: LogicalRect, container: LogicalRect) -> EdgeDistance {
    EdgeDistance {
        // Distance from rect's left edge to container's left edge
        left: (rect.origin.x - container.origin.x).max(0.0),
        // Distance from container's right edge to rect's right edge
        right: ((container.origin.x + container.size.width) - (rect.origin.x + rect.size.width))
            .max(0.0),
        // Distance from rect's top edge to container's top edge
        top: (rect.origin.y - container.origin.y).max(0.0),
        // Distance from container's bottom edge to rect's bottom edge
        bottom: ((container.origin.y + container.size.height) - (rect.origin.y + rect.size.height))
            .max(0.0),
    }
}

/// Calculate scroll delta with fixed padding (instant scroll mode)
fn calculate_instant_scroll_delta(
    bounds: LogicalRect,
    visible_area: LogicalRect,
) -> LogicalPosition {
    const PADDING: f32 = 5.0;
    let mut delta = LogicalPosition::zero();

    // Horizontal scrolling
    if bounds.origin.x < visible_area.origin.x + PADDING {
        delta.x = bounds.origin.x - visible_area.origin.x - PADDING;
    } else if bounds.origin.x + bounds.size.width
        > visible_area.origin.x + visible_area.size.width - PADDING
    {
        delta.x = (bounds.origin.x + bounds.size.width)
            - (visible_area.origin.x + visible_area.size.width)
            + PADDING;
    }

    // Vertical scrolling
    if bounds.origin.y < visible_area.origin.y + PADDING {
        delta.y = bounds.origin.y - visible_area.origin.y - PADDING;
    } else if bounds.origin.y + bounds.size.height
        > visible_area.origin.y + visible_area.size.height - PADDING
    {
        delta.y = (bounds.origin.y + bounds.size.height)
            - (visible_area.origin.y + visible_area.size.height)
            + PADDING;
    }

    delta
}

/// Calculate scroll delta with distance-based acceleration (drag-to-scroll mode)
fn calculate_accelerated_scroll_delta(distance: EdgeDistance) -> LogicalPosition {
    // Acceleration zones (in pixels from edge)
    const DEAD_ZONE: f32 = 20.0;
    const SLOW_ZONE: f32 = 50.0;
    const MEDIUM_ZONE: f32 = 100.0;
    const FAST_ZONE: f32 = 200.0;

    // Scroll speeds (pixels per frame at 60fps)
    const SLOW_SPEED: f32 = 2.0;
    const MEDIUM_SPEED: f32 = 4.0;
    const FAST_SPEED: f32 = 8.0;
    const VERY_FAST_SPEED: f32 = 16.0;

    // Helper to calculate speed for one direction
    let speed_for_distance = |dist: f32| -> f32 {
        if dist < DEAD_ZONE {
            0.0
        } else if dist < SLOW_ZONE {
            SLOW_SPEED
        } else if dist < MEDIUM_ZONE {
            MEDIUM_SPEED
        } else if dist < FAST_ZONE {
            FAST_SPEED
        } else {
            VERY_FAST_SPEED
        }
    };

    // Calculate horizontal scroll (left vs right)
    let scroll_x = if distance.left < distance.right {
        // Closer to left edge - scroll left
        -speed_for_distance(distance.left)
    } else {
        // Closer to right edge - scroll right
        speed_for_distance(distance.right)
    };

    // Calculate vertical scroll (top vs bottom)
    let scroll_y = if distance.top < distance.bottom {
        // Closer to top edge - scroll up
        -speed_for_distance(distance.top)
    } else {
        // Closer to bottom edge - scroll down
        speed_for_distance(distance.bottom)
    };

    LogicalPosition::new(scroll_x, scroll_y)
}

/// Result of a layout operation
pub struct LayoutResult {
    pub display_list: DisplayList,
    pub warnings: Vec<String>,
}

impl LayoutResult {
    pub fn new(display_list: DisplayList, warnings: Vec<String>) -> Self {
        Self {
            display_list,
            warnings,
        }
    }
}

impl LayoutWindow {
    /// Runs a single timer, similar to CallbacksOfHitTest.call()
    ///
    /// NOTE: The timer has to be selected first by the calling code and verified
    /// that it is ready to run
    #[cfg(feature = "std")]
    pub fn run_single_timer(
        &mut self,
        timer_id: usize,
        frame_start: Instant,
        current_window_handle: &RawWindowHandle,
        gl_context: &OptionGlContextPtr,
        image_cache: &mut ImageCache,
        system_fonts: &mut FcFontCache,
        system_style: std::sync::Arc<azul_css::system::SystemStyle>,
        system_callbacks: &ExternalSystemCallbacks,
        previous_window_state: &Option<FullWindowState>,
        current_window_state: &FullWindowState,
        renderer_resources: &RendererResources,
    ) -> CallCallbacksResult {
        use std::collections::BTreeMap;

        use crate::callbacks::{CallCallbacksResult, CallbackInfo};

        let mut ret = CallCallbacksResult {
            should_scroll_render: false,
            callbacks_update_screen: Update::DoNothing,
            modified_window_state: None,
            css_properties_changed: None,
            words_changed: None,
            images_changed: None,
            image_masks_changed: None,
            image_callbacks_changed: None,
            nodes_scrolled_in_callbacks: None,
            update_focused_node: FocusUpdateRequest::NoChange,
            timers: None,
            threads: None,
            timers_removed: None,
            threads_removed: None,
            windows_created: Vec::new(),
            menus_to_open: Vec::new(),
            tooltips_to_show: Vec::new(),
            hide_tooltip: false,
            cursor_changed: false,
            stop_propagation: false,
            prevent_default: false,
            hit_test_update_requested: None,
            queued_window_states: Vec::new(),
            text_input_triggered: Vec::new(),
        };

        let mut should_terminate = TerminateTimer::Continue;

        let current_scroll_states_nested = self.get_nested_scroll_states(DomId::ROOT_ID);

        // Check if timer exists and get node_id before borrowing self mutably
        let timer_exists = self.timers.contains_key(&TimerId { id: timer_id });
        let timer_node_id = self
            .timers
            .get(&TimerId { id: timer_id })
            .and_then(|t| t.node_id.into_option());

        if timer_exists {
            // TODO: store the hit DOM of the timer?
            let hit_dom_node = match timer_node_id {
                Some(s) => s,
                None => DomNodeId {
                    dom: DomId::ROOT_ID,
                    node: NodeHierarchyItemId::from_crate_internal(None),
                },
            };
            let cursor_relative_to_item = OptionLogicalPosition::None;
            let cursor_in_viewport = OptionLogicalPosition::None;

            // Create changes container for callback transaction system
            // Uses Arc<Mutex> so that cloned CallbackInfo (e.g., in timer callbacks)
            // still push to the same collection
            let callback_changes = std::sync::Arc::new(std::sync::Mutex::new(Vec::new()));

            // Create reference data container (syntax sugar to reduce parameter count)
            // First get the ctx from the timer's callback before we borrow timer again
            let timer_ctx = self
                .timers
                .get(&TimerId { id: timer_id })
                .map(|t| t.callback.ctx.clone())
                .unwrap_or(OptionRefAny::None);

            let ref_data = crate::callbacks::CallbackInfoRefData {
                layout_window: self,
                renderer_resources,
                previous_window_state,
                current_window_state,
                gl_context,
                current_scroll_manager: &current_scroll_states_nested,
                current_window_handle,
                system_callbacks,
                system_style,
                #[cfg(feature = "icu")]
                icu_localizer: self.icu_localizer.clone(),
                ctx: timer_ctx,
            };

            let callback_info = CallbackInfo::new(
                &ref_data,
                &callback_changes,
                hit_dom_node,
                cursor_relative_to_item,
                cursor_in_viewport,
            ); // Now we can borrow the timer mutably
            let timer = self.timers.get_mut(&TimerId { id: timer_id }).unwrap();
            let tcr = timer.invoke(&callback_info, &system_callbacks.get_system_time_fn);

            ret.callbacks_update_screen = tcr.should_update;
            should_terminate = tcr.should_terminate;

            // Extract changes from the Arc<Mutex> - they may have been pushed by
            // cloned CallbackInfo instances (e.g., in timer callbacks)
            let collected_changes = callback_changes
                .lock()
                .map(|mut guard| core::mem::take(&mut *guard))
                .unwrap_or_default();

            // Apply callback changes collected during timer execution
            let change_result = self.apply_callback_changes(
                collected_changes,
                current_window_state,
                image_cache,
                system_fonts,
            );

            // Queue IFrame updates for next frame
            if !change_result.iframes_to_update.is_empty() {
                self.queue_iframe_updates(change_result.iframes_to_update.clone());
            }

            // Transfer results from CallbackChangeResult to CallCallbacksResult
            ret.stop_propagation = change_result.stop_propagation;
            ret.prevent_default = change_result.prevent_default;
            ret.tooltips_to_show = change_result.tooltips_to_show;
            ret.hide_tooltip = change_result.hide_tooltip;

            if !change_result.timers.is_empty() {
                ret.timers = Some(change_result.timers);
            }
            if !change_result.threads.is_empty() {
                ret.threads = Some(change_result.threads);
            }
            if change_result.modified_window_state != *current_window_state {
                ret.modified_window_state = Some(change_result.modified_window_state);
            }
            if !change_result.threads_removed.is_empty() {
                ret.threads_removed = Some(change_result.threads_removed);
            }
            if !change_result.timers_removed.is_empty() {
                ret.timers_removed = Some(change_result.timers_removed);
            }
            if !change_result.words_changed.is_empty() {
                ret.words_changed = Some(change_result.words_changed);
            }
            if !change_result.images_changed.is_empty() {
                ret.images_changed = Some(change_result.images_changed);
            }
            if !change_result.image_masks_changed.is_empty() {
                ret.image_masks_changed = Some(change_result.image_masks_changed);
            }
            if !change_result.css_properties_changed.is_empty() {
                ret.css_properties_changed = Some(change_result.css_properties_changed);
            }
            if !change_result.image_callbacks_changed.is_empty() {
                ret.image_callbacks_changed = Some(change_result.image_callbacks_changed);
            }
            if !change_result.nodes_scrolled.is_empty() {
                ret.nodes_scrolled_in_callbacks = Some(change_result.nodes_scrolled);
            }

            // Forward hit test update request to shell layer
            if change_result.hit_test_update_requested.is_some() {
                ret.hit_test_update_requested = change_result.hit_test_update_requested;
            }

            // Forward queued window states to shell layer for sequential processing
            if !change_result.queued_window_states.is_empty() {
                ret.queued_window_states = change_result.queued_window_states;
            }

            // Forward text_input_triggered to shell layer for recursive callback processing
            if !change_result.text_input_triggered.is_empty() {
                println!("[run_single_timer] Forwarding {} text_input_triggered events", change_result.text_input_triggered.len());
                ret.text_input_triggered = change_result.text_input_triggered;
            }

            // Handle focus target outside the timer block so it's available later
            if let Some(ft) = change_result.focus_target {
                if let Ok(new_focus_node) = crate::managers::focus_cursor::resolve_focus_target(
                    &ft,
                    &self.layout_results,
                    self.focus_manager.get_focused_node().copied(),
                ) {
                    ret.update_focused_node = match new_focus_node {
                        Some(node) => FocusUpdateRequest::FocusNode(node),
                        None => FocusUpdateRequest::ClearFocus,
                    };
                }
            }
        }

        if should_terminate == TerminateTimer::Terminate {
            ret.timers_removed
                .get_or_insert_with(|| std::collections::BTreeSet::new())
                .insert(TimerId { id: timer_id });
        }

        return ret;
    }

    #[cfg(feature = "std")]
    pub fn run_all_threads(
        &mut self,
        data: &mut RefAny,
        current_window_handle: &RawWindowHandle,
        gl_context: &OptionGlContextPtr,
        image_cache: &mut ImageCache,
        system_fonts: &mut FcFontCache,
        system_style: std::sync::Arc<azul_css::system::SystemStyle>,
        system_callbacks: &ExternalSystemCallbacks,
        previous_window_state: &Option<FullWindowState>,
        current_window_state: &FullWindowState,
        renderer_resources: &RendererResources,
    ) -> CallCallbacksResult {
        use std::collections::BTreeSet;

        use crate::{
            callbacks::{CallCallbacksResult, CallbackInfo},
            thread::{OptionThreadReceiveMsg, ThreadReceiveMsg, ThreadWriteBackMsg},
        };

        let mut ret = CallCallbacksResult {
            should_scroll_render: false,
            callbacks_update_screen: Update::DoNothing,
            modified_window_state: None,
            css_properties_changed: None,
            words_changed: None,
            images_changed: None,
            image_masks_changed: None,
            image_callbacks_changed: None,
            nodes_scrolled_in_callbacks: None,
            update_focused_node: FocusUpdateRequest::NoChange,
            timers: None,
            threads: None,
            timers_removed: None,
            threads_removed: None,
            windows_created: Vec::new(),
            menus_to_open: Vec::new(),
            tooltips_to_show: Vec::new(),
            hide_tooltip: false,
            cursor_changed: false,
            stop_propagation: false,
            prevent_default: false,
            hit_test_update_requested: None,
            queued_window_states: Vec::new(),
            text_input_triggered: Vec::new(),
        };

        let mut ret_modified_window_state = current_window_state.clone();
        let ret_window_state = ret_modified_window_state.clone();
        let mut ret_timers = FastHashMap::new();
        let mut ret_timers_removed = FastBTreeSet::new();
        let mut ret_threads = FastHashMap::new();
        let mut ret_threads_removed = FastBTreeSet::new();
        let mut ret_words_changed = BTreeMap::new();
        let mut ret_images_changed = BTreeMap::new();
        let mut ret_image_masks_changed = BTreeMap::new();
        let mut ret_css_properties_changed = BTreeMap::new();
        let mut ret_nodes_scrolled_in_callbacks = BTreeMap::new();
        let mut new_focus_target = None;
        let mut stop_propagation = false;
        let current_scroll_states = self.get_nested_scroll_states(DomId::ROOT_ID);

        // Collect thread IDs first to avoid borrowing self.threads while accessing self
        let thread_ids: Vec<ThreadId> = self.threads.keys().copied().collect();

        for thread_id in thread_ids {
            let thread = match self.threads.get_mut(&thread_id) {
                Some(t) => t,
                None => continue,
            };

            let hit_dom_node = DomNodeId {
                dom: DomId::ROOT_ID,
                node: NodeHierarchyItemId::from_crate_internal(None),
            };
            let cursor_relative_to_item = OptionLogicalPosition::None;
            let cursor_in_viewport = OptionLogicalPosition::None;

            // Lock the mutex, extract data, then drop the guard before creating CallbackInfo
            let (msg, writeback_data_ptr, is_finished) = {
                let thread_inner = &mut *match thread.ptr.lock().ok() {
                    Some(s) => s,
                    None => {
                        ret.threads_removed
                            .get_or_insert_with(|| BTreeSet::default())
                            .insert(thread_id);
                        continue;
                    }
                };

                let _ = thread_inner.sender_send(ThreadSendMsg::Tick);
                let update = thread_inner.receiver_try_recv();
                let msg = match update {
                    OptionThreadReceiveMsg::None => continue,
                    OptionThreadReceiveMsg::Some(s) => s,
                };

                let writeback_data_ptr: *mut RefAny = &mut thread_inner.writeback_data as *mut _;
                let is_finished = thread_inner.is_finished();

                (msg, writeback_data_ptr, is_finished)
                // MutexGuard is dropped here
            };

            let ThreadWriteBackMsg {
                refany: mut data,
                callback,
            } = match msg {
                ThreadReceiveMsg::Update(update_screen) => {
                    ret.callbacks_update_screen.max_self(update_screen);
                    continue;
                }
                ThreadReceiveMsg::WriteBack(t) => t,
            };

            // Create changes container for callback transaction system
            let callback_changes = std::sync::Arc::new(std::sync::Mutex::new(Vec::new()));

            // Create reference data container (syntax sugar to reduce parameter count)
            let ref_data = crate::callbacks::CallbackInfoRefData {
                layout_window: self,
                renderer_resources,
                previous_window_state,
                current_window_state,
                gl_context,
                current_scroll_manager: &current_scroll_states,
                current_window_handle,
                system_callbacks,
                system_style: system_style.clone(),
                #[cfg(feature = "icu")]
                icu_localizer: self.icu_localizer.clone(),
                ctx: callback.ctx.clone(),
            };

            let callback_info = CallbackInfo::new(
                &ref_data,
                &callback_changes,
                hit_dom_node,
                cursor_relative_to_item,
                cursor_in_viewport,
            );
            let callback_update = (callback.cb)(
                unsafe { (*writeback_data_ptr).clone() },
                data.clone(),
                callback_info,
            );
            ret.callbacks_update_screen.max_self(callback_update);

            // Extract changes from the Arc<Mutex>
            let collected_changes = callback_changes
                .lock()
                .map(|mut guard| core::mem::take(&mut *guard))
                .unwrap_or_default();

            // Apply callback changes collected during thread writeback
            let change_result = self.apply_callback_changes(
                collected_changes,
                current_window_state,
                image_cache,
                system_fonts,
            );

            // Queue any IFrame updates from this callback
            self.queue_iframe_updates(change_result.iframes_to_update);

            ret.stop_propagation = ret.stop_propagation || change_result.stop_propagation;
            ret.prevent_default = ret.prevent_default || change_result.prevent_default;
            ret.tooltips_to_show.extend(change_result.tooltips_to_show);
            ret.hide_tooltip = ret.hide_tooltip || change_result.hide_tooltip;

            // Forward hit test update request
            if change_result.hit_test_update_requested.is_some() {
                ret.hit_test_update_requested = change_result.hit_test_update_requested;
            }

            // Merge changes into accumulated results
            ret_timers.extend(change_result.timers);
            ret_threads.extend(change_result.threads);
            ret_timers_removed.extend(change_result.timers_removed);
            ret_threads_removed.extend(change_result.threads_removed);

            for (dom_id, nodes) in change_result.words_changed {
                ret_words_changed
                    .entry(dom_id)
                    .or_insert_with(BTreeMap::new)
                    .extend(nodes);
            }
            for (dom_id, nodes) in change_result.images_changed {
                ret_images_changed
                    .entry(dom_id)
                    .or_insert_with(BTreeMap::new)
                    .extend(nodes);
            }
            for (dom_id, nodes) in change_result.image_masks_changed {
                ret_image_masks_changed
                    .entry(dom_id)
                    .or_insert_with(BTreeMap::new)
                    .extend(nodes);
            }
            for (dom_id, nodes) in change_result.css_properties_changed {
                ret_css_properties_changed
                    .entry(dom_id)
                    .or_insert_with(BTreeMap::new)
                    .extend(nodes);
            }
            for (dom_id, nodes) in change_result.nodes_scrolled {
                ret_nodes_scrolled_in_callbacks
                    .entry(dom_id)
                    .or_insert_with(BTreeMap::new)
                    .extend(nodes);
            }

            if change_result.modified_window_state != *current_window_state {
                ret_modified_window_state = change_result.modified_window_state;
            }

            if let Some(ft) = change_result.focus_target {
                new_focus_target = Some(ft);
            }

            if is_finished {
                ret.threads_removed
                    .get_or_insert_with(|| BTreeSet::default())
                    .insert(thread_id);
            }
        }

        if !ret_timers.is_empty() {
            ret.timers = Some(ret_timers);
        }
        if !ret_threads.is_empty() {
            ret.threads = Some(ret_threads);
        }
        if ret_modified_window_state != ret_window_state {
            ret.modified_window_state = Some(ret_modified_window_state);
        }
        if !ret_threads_removed.is_empty() {
            ret.threads_removed = Some(ret_threads_removed);
        }
        if !ret_timers_removed.is_empty() {
            ret.timers_removed = Some(ret_timers_removed);
        }
        if !ret_words_changed.is_empty() {
            ret.words_changed = Some(ret_words_changed);
        }
        if !ret_images_changed.is_empty() {
            ret.images_changed = Some(ret_images_changed);
        }
        if !ret_image_masks_changed.is_empty() {
            ret.image_masks_changed = Some(ret_image_masks_changed);
        }
        if !ret_css_properties_changed.is_empty() {
            ret.css_properties_changed = Some(ret_css_properties_changed);
        }
        if !ret_nodes_scrolled_in_callbacks.is_empty() {
            ret.nodes_scrolled_in_callbacks = Some(ret_nodes_scrolled_in_callbacks);
        }

        if let Some(ft) = new_focus_target {
            if let Ok(new_focus_node) = crate::managers::focus_cursor::resolve_focus_target(
                &ft,
                &self.layout_results,
                self.focus_manager.get_focused_node().copied(),
            ) {
                ret.update_focused_node = match new_focus_node {
                    Some(node) => FocusUpdateRequest::FocusNode(node),
                    None => FocusUpdateRequest::ClearFocus,
                };
            }
        }

        return ret;
    }

    /// Invokes a single callback (used for on_window_create, on_window_shutdown, etc.)
    pub fn invoke_single_callback(
        &mut self,
        callback: &mut Callback,
        data: &mut RefAny,
        current_window_handle: &RawWindowHandle,
        gl_context: &OptionGlContextPtr,
        image_cache: &mut ImageCache,
        system_fonts: &mut FcFontCache,
        system_style: std::sync::Arc<azul_css::system::SystemStyle>,
        system_callbacks: &ExternalSystemCallbacks,
        previous_window_state: &Option<FullWindowState>,
        current_window_state: &FullWindowState,
        renderer_resources: &RendererResources,
    ) -> CallCallbacksResult {
        use crate::callbacks::{CallCallbacksResult, Callback, CallbackInfo};

        let hit_dom_node = DomNodeId {
            dom: DomId::ROOT_ID,
            node: NodeHierarchyItemId::from_crate_internal(None),
        };

        let mut ret = CallCallbacksResult {
            should_scroll_render: false,
            callbacks_update_screen: Update::DoNothing,
            modified_window_state: None,
            css_properties_changed: None,
            words_changed: None,
            images_changed: None,
            image_masks_changed: None,
            image_callbacks_changed: None,
            nodes_scrolled_in_callbacks: None,
            update_focused_node: FocusUpdateRequest::NoChange,
            timers: None,
            threads: None,
            timers_removed: None,
            threads_removed: None,
            windows_created: Vec::new(),
            menus_to_open: Vec::new(),
            tooltips_to_show: Vec::new(),
            hide_tooltip: false,
            cursor_changed: false,
            stop_propagation: false,
            prevent_default: false,
            hit_test_update_requested: None,
            queued_window_states: Vec::new(),
            text_input_triggered: Vec::new(),
        };

        let mut ret_modified_window_state = current_window_state.clone();
        let ret_window_state = ret_modified_window_state.clone();
        let mut ret_timers = FastHashMap::new();
        let mut ret_timers_removed = FastBTreeSet::new();
        let mut ret_threads = FastHashMap::new();
        let mut ret_threads_removed = FastBTreeSet::new();
        let mut ret_words_changed = BTreeMap::new();
        let mut ret_images_changed = BTreeMap::new();
        let mut ret_image_masks_changed = BTreeMap::new();
        let mut ret_css_properties_changed = BTreeMap::new();
        let mut ret_nodes_scrolled_in_callbacks = BTreeMap::new();
        let mut new_focus_target = None;
        let mut stop_propagation = false;
        let current_scroll_states = self.get_nested_scroll_states(DomId::ROOT_ID);

        let cursor_relative_to_item = OptionLogicalPosition::None;
        let cursor_in_viewport = OptionLogicalPosition::None;

        // Create changes container for callback transaction system
        let callback_changes = std::sync::Arc::new(std::sync::Mutex::new(Vec::new()));

        // Create reference data container (syntax sugar to reduce parameter count)
        let ref_data = crate::callbacks::CallbackInfoRefData {
            layout_window: self,
            renderer_resources,
            previous_window_state,
            current_window_state,
            gl_context,
            current_scroll_manager: &current_scroll_states,
            current_window_handle,
            system_callbacks,
            system_style,
            #[cfg(feature = "icu")]
            icu_localizer: self.icu_localizer.clone(),
            ctx: OptionRefAny::None,
        };

        let callback_info = CallbackInfo::new(
            &ref_data,
            &callback_changes,
            hit_dom_node,
            cursor_relative_to_item,
            cursor_in_viewport,
        );

        ret.callbacks_update_screen = (callback.cb)(data.clone(), callback_info);

        // Extract changes from the Arc<Mutex>
        let collected_changes = callback_changes
            .lock()
            .map(|mut guard| core::mem::take(&mut *guard))
            .unwrap_or_default();

        // Apply callback changes collected during callback execution
        let change_result = self.apply_callback_changes(
            collected_changes,
            current_window_state,
            image_cache,
            system_fonts,
        );

        // Queue any IFrame updates from this callback
        self.queue_iframe_updates(change_result.iframes_to_update);

        ret.stop_propagation = change_result.stop_propagation;
        ret.prevent_default = change_result.prevent_default;
        ret.tooltips_to_show = change_result.tooltips_to_show;
        ret.hide_tooltip = change_result.hide_tooltip;

        // Forward hit test update request (invoke_single_callback)
        if change_result.hit_test_update_requested.is_some() {
            ret.hit_test_update_requested = change_result.hit_test_update_requested;
        }

        ret_timers.extend(change_result.timers);
        ret_threads.extend(change_result.threads);
        ret_timers_removed.extend(change_result.timers_removed);
        ret_threads_removed.extend(change_result.threads_removed);
        ret_words_changed.extend(change_result.words_changed);
        ret_images_changed.extend(change_result.images_changed);
        ret_image_masks_changed.extend(change_result.image_masks_changed);
        ret_css_properties_changed.extend(change_result.css_properties_changed);
        ret_nodes_scrolled_in_callbacks.append(&mut change_result.nodes_scrolled.clone());

        if change_result.modified_window_state != *current_window_state {
            ret_modified_window_state = change_result.modified_window_state;
        }

        new_focus_target = change_result.focus_target.or(new_focus_target);

        if !ret_timers.is_empty() {
            ret.timers = Some(ret_timers);
        }
        if !ret_threads.is_empty() {
            ret.threads = Some(ret_threads);
        }
        if ret_modified_window_state != ret_window_state {
            ret.modified_window_state = Some(ret_modified_window_state);
        }
        if !ret_threads_removed.is_empty() {
            ret.threads_removed = Some(ret_threads_removed);
        }
        if !ret_timers_removed.is_empty() {
            ret.timers_removed = Some(ret_timers_removed);
        }
        if !ret_words_changed.is_empty() {
            ret.words_changed = Some(ret_words_changed);
        }
        if !ret_images_changed.is_empty() {
            ret.images_changed = Some(ret_images_changed);
        }
        if !ret_image_masks_changed.is_empty() {
            ret.image_masks_changed = Some(ret_image_masks_changed);
        }
        if !ret_css_properties_changed.is_empty() {
            ret.css_properties_changed = Some(ret_css_properties_changed);
        }
        if !ret_nodes_scrolled_in_callbacks.is_empty() {
            ret.nodes_scrolled_in_callbacks = Some(ret_nodes_scrolled_in_callbacks);
        }

        if let Some(ft) = new_focus_target {
            if let Ok(new_focus_node) = crate::managers::focus_cursor::resolve_focus_target(
                &ft,
                &self.layout_results,
                self.focus_manager.get_focused_node().copied(),
            ) {
                ret.update_focused_node = match new_focus_node {
                    Some(node) => FocusUpdateRequest::FocusNode(node),
                    None => FocusUpdateRequest::ClearFocus,
                };
            }
        }

        return ret;
    }

    /// Invokes a menu callback
    pub fn invoke_menu_callback(
        &mut self,
        menu_callback: &mut MenuCallback,
        hit_dom_node: DomNodeId,
        current_window_handle: &RawWindowHandle,
        gl_context: &OptionGlContextPtr,
        image_cache: &mut ImageCache,
        system_fonts: &mut FcFontCache,
        system_style: std::sync::Arc<azul_css::system::SystemStyle>,
        system_callbacks: &ExternalSystemCallbacks,
        previous_window_state: &Option<FullWindowState>,
        current_window_state: &FullWindowState,
        renderer_resources: &RendererResources,
    ) -> CallCallbacksResult {
        use crate::callbacks::{CallCallbacksResult, CallbackInfo, MenuCallback};

        let mut ret = CallCallbacksResult {
            should_scroll_render: false,
            callbacks_update_screen: Update::DoNothing,
            modified_window_state: None,
            css_properties_changed: None,
            words_changed: None,
            images_changed: None,
            image_masks_changed: None,
            image_callbacks_changed: None,
            nodes_scrolled_in_callbacks: None,
            update_focused_node: FocusUpdateRequest::NoChange,
            timers: None,
            threads: None,
            timers_removed: None,
            threads_removed: None,
            windows_created: Vec::new(),
            menus_to_open: Vec::new(),
            tooltips_to_show: Vec::new(),
            hide_tooltip: false,
            cursor_changed: false,
            stop_propagation: false,
            prevent_default: false,
            hit_test_update_requested: None,
            queued_window_states: Vec::new(),
            text_input_triggered: Vec::new(),
        };

        let mut ret_modified_window_state = current_window_state.clone();
        let ret_window_state = ret_modified_window_state.clone();
        let mut ret_timers = FastHashMap::new();
        let mut ret_timers_removed = FastBTreeSet::new();
        let mut ret_threads = FastHashMap::new();
        let mut ret_threads_removed = FastBTreeSet::new();
        let mut ret_words_changed = BTreeMap::new();
        let mut ret_images_changed = BTreeMap::new();
        let mut ret_image_masks_changed = BTreeMap::new();
        let mut ret_css_properties_changed = BTreeMap::new();
        let mut ret_nodes_scrolled_in_callbacks = BTreeMap::new();
        let mut new_focus_target = None;
        let mut stop_propagation = false;
        let current_scroll_states = self.get_nested_scroll_states(DomId::ROOT_ID);

        let cursor_relative_to_item = OptionLogicalPosition::None;
        let cursor_in_viewport = OptionLogicalPosition::None;

        // Create changes container for callback transaction system
        let callback_changes = std::sync::Arc::new(std::sync::Mutex::new(Vec::new()));

        // Create reference data container (syntax sugar to reduce parameter count)
        let ref_data = crate::callbacks::CallbackInfoRefData {
            layout_window: self,
            renderer_resources,
            previous_window_state,
            current_window_state,
            gl_context,
            current_scroll_manager: &current_scroll_states,
            current_window_handle,
            system_callbacks,
            system_style,
            #[cfg(feature = "icu")]
            icu_localizer: self.icu_localizer.clone(),
            ctx: OptionRefAny::None,
        };

        let callback_info = CallbackInfo::new(
            &ref_data,
            &callback_changes,
            hit_dom_node,
            cursor_relative_to_item,
            cursor_in_viewport,
        );

        ret.callbacks_update_screen =
            (menu_callback.callback.cb)(menu_callback.refany.clone(), callback_info);

        // Extract changes from the Arc<Mutex>
        let collected_changes = callback_changes
            .lock()
            .map(|mut guard| core::mem::take(&mut *guard))
            .unwrap_or_default();

        // Apply callback changes collected during menu callback execution
        let change_result = self.apply_callback_changes(
            collected_changes,
            current_window_state,
            image_cache,
            system_fonts,
        );

        // Queue any IFrame updates from this callback
        self.queue_iframe_updates(change_result.iframes_to_update);

        ret.stop_propagation = change_result.stop_propagation;
        ret.prevent_default = change_result.prevent_default;
        ret.tooltips_to_show = change_result.tooltips_to_show;
        ret.hide_tooltip = change_result.hide_tooltip;

        // Forward hit test update request (invoke_menu_callback)
        if change_result.hit_test_update_requested.is_some() {
            ret.hit_test_update_requested = change_result.hit_test_update_requested;
        }

        ret_timers.extend(change_result.timers);
        ret_threads.extend(change_result.threads);
        ret_timers_removed.extend(change_result.timers_removed);
        ret_threads_removed.extend(change_result.threads_removed);
        ret_words_changed.extend(change_result.words_changed);
        ret_images_changed.extend(change_result.images_changed);
        ret_image_masks_changed.extend(change_result.image_masks_changed);
        ret_css_properties_changed.extend(change_result.css_properties_changed);
        ret_nodes_scrolled_in_callbacks.append(&mut change_result.nodes_scrolled.clone());

        if change_result.modified_window_state != *current_window_state {
            ret_modified_window_state = change_result.modified_window_state;
        }

        new_focus_target = change_result.focus_target.or(new_focus_target);

        if !ret_timers.is_empty() {
            ret.timers = Some(ret_timers);
        }
        if !ret_threads.is_empty() {
            ret.threads = Some(ret_threads);
        }
        if ret_modified_window_state != ret_window_state {
            ret.modified_window_state = Some(ret_modified_window_state);
        }
        if !ret_threads_removed.is_empty() {
            ret.threads_removed = Some(ret_threads_removed);
        }
        if !ret_timers_removed.is_empty() {
            ret.timers_removed = Some(ret_timers_removed);
        }
        if !ret_words_changed.is_empty() {
            ret.words_changed = Some(ret_words_changed);
        }
        if !ret_images_changed.is_empty() {
            ret.images_changed = Some(ret_images_changed);
        }
        if !ret_image_masks_changed.is_empty() {
            ret.image_masks_changed = Some(ret_image_masks_changed);
        }
        if !ret_css_properties_changed.is_empty() {
            ret.css_properties_changed = Some(ret_css_properties_changed);
        }
        if !ret_nodes_scrolled_in_callbacks.is_empty() {
            ret.nodes_scrolled_in_callbacks = Some(ret_nodes_scrolled_in_callbacks);
        }

        if let Some(ft) = new_focus_target {
            if let Ok(new_focus_node) = crate::managers::focus_cursor::resolve_focus_target(
                &ft,
                &self.layout_results,
                self.focus_manager.get_focused_node().copied(),
            ) {
                ret.update_focused_node = match new_focus_node {
                    Some(node) => FocusUpdateRequest::FocusNode(node),
                    None => FocusUpdateRequest::ClearFocus,
                };
            }
        }

        return ret;
    }
}

// --- ICU4X Internationalization API ---

#[cfg(feature = "icu")]
impl LayoutWindow {
    /// Initialize the ICU localizer with the system's detected language.
    ///
    /// This should be called during window initialization, passing the language
    /// from `SystemStyle::language`.
    ///
    /// # Arguments
    /// * `locale` - The BCP 47 language tag (e.g., "en-US", "de-DE")
    pub fn set_icu_locale(&mut self, locale: &str) {
        self.icu_localizer.set_locale(locale);
    }

    /// Initialize the ICU localizer from a SystemStyle.
    ///
    /// This is a convenience method that extracts the language from the system style.
    pub fn init_icu_from_system_style(&mut self, system_style: &azul_css::system::SystemStyle) {
        self.icu_localizer = IcuLocalizerHandle::from_system_language(&system_style.language);
    }

    /// Get a clone of the ICU localizer handle.
    ///
    /// This can be used to perform locale-aware formatting outside of callbacks.
    pub fn get_icu_localizer(&self) -> IcuLocalizerHandle {
        self.icu_localizer.clone()
    }

    /// Load additional ICU locale data from a binary blob.
    ///
    /// The blob should be generated using `icu4x-datagen` with the `--format blob` flag.
    /// This allows supporting locales that aren't compiled into the binary.
    pub fn load_icu_data_blob(&mut self, data: Vec<u8>) -> bool {
        self.icu_localizer.load_data_blob(&data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{thread::Thread, timer::Timer};

    #[test]
    fn test_timer_add_remove() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let timer_id = TimerId { id: 1 };
        let timer = Timer::default();

        // Add timer
        window.add_timer(timer_id, timer);
        assert!(window.get_timer(&timer_id).is_some());
        assert_eq!(window.get_timer_ids().len(), 1);

        // Remove timer
        let removed = window.remove_timer(&timer_id);
        assert!(removed.is_some());
        assert!(window.get_timer(&timer_id).is_none());
        assert_eq!(window.get_timer_ids().len(), 0);
    }

    #[test]
    fn test_timer_get_mut() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let timer_id = TimerId { id: 1 };
        let timer = Timer::default();

        window.add_timer(timer_id, timer);

        // Get mutable reference
        let timer_mut = window.get_timer_mut(&timer_id);
        assert!(timer_mut.is_some());
    }

    #[test]
    fn test_multiple_timers() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let timer1 = TimerId { id: 1 };
        let timer2 = TimerId { id: 2 };
        let timer3 = TimerId { id: 3 };

        window.add_timer(timer1, Timer::default());
        window.add_timer(timer2, Timer::default());
        window.add_timer(timer3, Timer::default());

        assert_eq!(window.get_timer_ids().len(), 3);

        window.remove_timer(&timer2);
        assert_eq!(window.get_timer_ids().len(), 2);
        assert!(window.get_timer(&timer1).is_some());
        assert!(window.get_timer(&timer2).is_none());
        assert!(window.get_timer(&timer3).is_some());
    }

    // Thread management tests removed - Thread::default() not available
    // and threads require complex setup. Thread management is tested
    // through integration tests instead.

    #[test]
    fn test_gpu_cache_management() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let dom_id = DomId { inner: 0 };

        // Initially empty
        assert!(window.get_gpu_cache(&dom_id).is_none());

        // Get or create
        let cache = window.get_or_create_gpu_cache(dom_id);
        assert!(cache.transform_keys.is_empty());

        // Now exists
        assert!(window.get_gpu_cache(&dom_id).is_some());

        // Can get mutable reference
        let cache_mut = window.get_gpu_cache_mut(&dom_id);
        assert!(cache_mut.is_some());
    }

    #[test]
    fn test_gpu_cache_multiple_doms() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let dom1 = DomId { inner: 0 };
        let dom2 = DomId { inner: 1 };

        window.get_or_create_gpu_cache(dom1);
        window.get_or_create_gpu_cache(dom2);

        assert!(window.get_gpu_cache(&dom1).is_some());
        assert!(window.get_gpu_cache(&dom2).is_some());
    }

    #[test]
    fn test_compute_cursor_type_empty_hit_test() {
        use crate::hit_test::FullHitTest;

        let fc_cache = FcFontCache::default();
        let window = LayoutWindow::new(fc_cache).unwrap();

        let empty_hit = FullHitTest::empty(None);
        let cursor_test = window.compute_cursor_type_hit_test(&empty_hit);

        // Empty hit test should result in default cursor
        assert_eq!(
            cursor_test.cursor_icon,
            azul_core::window::MouseCursorType::Default
        );
        assert!(cursor_test.cursor_node.is_none());
    }

    #[test]
    fn test_layout_result_access() {
        let fc_cache = FcFontCache::default();
        let window = LayoutWindow::new(fc_cache).unwrap();

        let dom_id = DomId { inner: 0 };

        // Initially no layout results
        assert!(window.get_layout_result(&dom_id).is_none());
        assert_eq!(window.get_dom_ids().len(), 0);
    }

    // ScrollManager and IFrame Integration Tests

    #[test]
    fn test_scroll_manager_initialization() {
        let fc_cache = FcFontCache::default();
        let window = LayoutWindow::new(fc_cache).unwrap();

        let dom_id = DomId::ROOT_ID;
        let node_id = NodeId::new(0);

        // Initially no scroll states
        let scroll_offsets = window.scroll_manager.get_scroll_states_for_dom(dom_id);
        assert!(scroll_offsets.is_empty());

        // No current offset
        let offset = window.scroll_manager.get_current_offset(dom_id, node_id);
        assert_eq!(offset, None);
    }

    #[test]
    fn test_scroll_manager_tick_updates_activity() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let dom_id = DomId::ROOT_ID;
        let node_id = NodeId::new(0);

        // Create a scroll event
        let scroll_event = crate::managers::scroll_state::ScrollEvent {
            dom_id,
            node_id,
            delta: LogicalPosition::new(10.0, 20.0),
            source: azul_core::events::EventSource::User,
            duration: None,
            easing: EasingFunction::Linear,
        };

        #[cfg(feature = "std")]
        let now = Instant::System(std::time::Instant::now().into());
        #[cfg(not(feature = "std"))]
        let now = Instant::Tick(azul_core::task::SystemTick { tick_counter: 0 });

        let did_scroll = window
            .scroll_manager
            .process_scroll_event(scroll_event, now.clone());

        // process_scroll_event should return true for successful scroll
        assert!(did_scroll);
    }

    #[test]
    fn test_scroll_manager_programmatic_scroll() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let dom_id = DomId::ROOT_ID;
        let node_id = NodeId::new(0);

        #[cfg(feature = "std")]
        let now = Instant::System(std::time::Instant::now().into());
        #[cfg(not(feature = "std"))]
        let now = Instant::Tick(azul_core::task::SystemTick { tick_counter: 0 });

        // Programmatic scroll with animation
        window.scroll_manager.scroll_to(
            dom_id,
            node_id,
            LogicalPosition::new(100.0, 200.0),
            Duration::System(SystemTimeDiff::from_millis(300)),
            EasingFunction::EaseOut,
            now.clone(),
        );

        let tick_result = window.scroll_manager.tick(now);

        // Programmatic scroll should start animation
        assert!(tick_result.needs_repaint);
    }

    #[test]
    fn test_scroll_manager_iframe_edge_detection() {
        // Note: This test is disabled because the new IFrame architecture
        // moved edge detection logic to IFrameManager. The old ScrollManager
        // API (update_iframe_scroll_info, iframes_to_update) no longer exists.
        // Edge detection is now tested through IFrameManager::check_reinvoke.

        // TODO: Rewrite this test to use the new IFrameManager API once
        // we have a proper test setup for IFrames.
    }

    #[test]
    fn test_scroll_manager_iframe_invocation_tracking() {
        // Note: This test is disabled because IFrame invocation tracking
        // moved to IFrameManager. The ScrollManager no longer tracks
        // which IFrames have been invoked.

        // TODO: Rewrite this test to use IFrameManager::mark_invoked
        // and IFrameManager::check_reinvoke.
    }

    #[test]
    fn test_scrollbar_opacity_fading() {
        // Note: This test is disabled because scrollbar opacity calculation
        // is now done through a helper function in LayoutWindow, not
        // through ScrollManager.get_scrollbar_opacity().

        // The new architecture separates scroll state from opacity calculation.
        // ScrollManager tracks last_activity_time, and LayoutWindow has a
        // calculate_scrollbar_opacity() helper that computes fade based on time.

        // TODO: Rewrite this test to use LayoutWindow::calculate_scrollbar_opacity
        // with ScrollManager::get_last_activity_time.
    }

    #[test]
    fn test_iframe_callback_reason_initial_render() {
        // Note: This test is disabled because the frame lifecycle API
        // (begin_frame, end_frame, had_new_doms) was removed from ScrollManager.

        // IFrame callback reasons are now determined by IFrameManager::check_reinvoke
        // which checks if an IFrame has been invoked before.

        // TODO: Rewrite to test IFrameManager::check_reinvoke with InitialRender.
    }

    #[test]
    fn test_gpu_cache_scrollbar_opacity_keys() {
        let fc_cache = FcFontCache::default();
        let mut window = LayoutWindow::new(fc_cache).unwrap();

        let dom_id = DomId::ROOT_ID;
        let node_id = NodeId::new(0);

        // Get or create GPU cache
        let gpu_cache = window.get_or_create_gpu_cache(dom_id);

        // Initially no scrollbar opacity keys
        assert!(gpu_cache.scrollbar_v_opacity_keys.is_empty());
        assert!(gpu_cache.scrollbar_h_opacity_keys.is_empty());

        // Add a vertical scrollbar opacity key
        let opacity_key = azul_core::resources::OpacityKey::unique();
        gpu_cache
            .scrollbar_v_opacity_keys
            .insert((dom_id, node_id), opacity_key);
        gpu_cache
            .scrollbar_v_opacity_values
            .insert((dom_id, node_id), 1.0);

        // Verify it was added
        assert_eq!(gpu_cache.scrollbar_v_opacity_keys.len(), 1);
        assert_eq!(
            gpu_cache.scrollbar_v_opacity_values.get(&(dom_id, node_id)),
            Some(&1.0)
        );
    }

    #[test]
    fn test_frame_lifecycle_begin_end() {
        // Note: This test is disabled because begin_frame/end_frame API
        // was removed from ScrollManager. Frame lifecycle is now managed
        // at a higher level.

        // The new ScrollManager focuses purely on scroll state and animations.
        // Frame tracking (had_scroll_activity, had_programmatic_scroll) was
        // removed as it's no longer needed with the new architecture.

        // TODO: If frame lifecycle tracking is needed, it should be
        // implemented at the LayoutWindow level, not in ScrollManager.
    }
}

// --- Cross-Paragraph Cursor Navigation API ---
impl LayoutWindow {
    /// Finds the next text node in the DOM tree after the given node.
    ///
    /// This function performs a depth-first traversal to find the next node
    /// that contains text content and is selectable (user-select != none).
    ///
    /// # Arguments
    /// * `dom_id` - The ID of the DOM containing the current node
    /// * `current_node` - The current node ID to start searching from
    ///
    /// # Returns
    /// * `Some((DomId, NodeId))` - The next text node if found
    /// * `None` - If no next text node exists
    pub fn find_next_text_node(
        &self,
        dom_id: &DomId,
        current_node: NodeId,
    ) -> Option<(DomId, NodeId)> {
        let layout_result = self.get_layout_result(dom_id)?;
        let styled_dom = &layout_result.styled_dom;

        // Start from the next node in document order
        let start_idx = current_node.index() + 1;
        let node_hierarchy = &styled_dom.node_hierarchy;

        for i in start_idx..node_hierarchy.len() {
            let node_id = NodeId::new(i);

            // Check if node has text content
            if self.node_has_text_content(styled_dom, node_id) {
                // Check if text is selectable
                if self.is_text_selectable(styled_dom, node_id) {
                    return Some((*dom_id, node_id));
                }
            }
        }

        None
    }

    /// Finds the previous text node in the DOM tree before the given node.
    ///
    /// This function performs a reverse depth-first traversal to find the previous node
    /// that contains text content and is selectable.
    ///
    /// # Arguments
    /// * `dom_id` - The ID of the DOM containing the current node
    /// * `current_node` - The current node ID to start searching from
    ///
    /// # Returns
    /// * `Some((DomId, NodeId))` - The previous text node if found
    /// * `None` - If no previous text node exists
    pub fn find_prev_text_node(
        &self,
        dom_id: &DomId,
        current_node: NodeId,
    ) -> Option<(DomId, NodeId)> {
        let layout_result = self.get_layout_result(dom_id)?;
        let styled_dom = &layout_result.styled_dom;

        // Start from the previous node in reverse document order
        let current_idx = current_node.index();

        for i in (0..current_idx).rev() {
            let node_id = NodeId::new(i);

            // Check if node has text content
            if self.node_has_text_content(styled_dom, node_id) {
                // Check if text is selectable
                if self.is_text_selectable(styled_dom, node_id) {
                    return Some((*dom_id, node_id));
                }
            }
        }

        None
    }

    /// Find the last text child node of a given node.
    /// 
    /// For contenteditable elements, the text is usually in a child Text node,
    /// not the contenteditable div itself. This function finds the last Text node
    /// so the cursor defaults to the end position.
    fn find_last_text_child(&self, dom_id: DomId, parent_node_id: NodeId) -> Option<NodeId> {
        let layout_result = self.layout_results.get(&dom_id)?;
        let styled_dom = &layout_result.styled_dom;
        let node_data_container = styled_dom.node_data.as_container();
        let hierarchy_container = styled_dom.node_hierarchy.as_container();
        
        // Check if parent itself is a text node
        let parent_type = node_data_container[parent_node_id].get_node_type();
        if matches!(parent_type, NodeType::Text(_)) {
            return Some(parent_node_id);
        }
        
        // Find the last text child by iterating through all children
        let parent_item = &hierarchy_container[parent_node_id];
        let mut last_text_child: Option<NodeId> = None;
        let mut current_child = parent_item.first_child_id(parent_node_id);
        while let Some(child_id) = current_child {
            let child_type = node_data_container[child_id].get_node_type();
            if matches!(child_type, NodeType::Text(_)) {
                last_text_child = Some(child_id);
            }
            current_child = hierarchy_container[child_id].next_sibling_id();
        }
        
        last_text_child
    }

    /// Checks if a node has text content.
    fn node_has_text_content(&self, styled_dom: &StyledDom, node_id: NodeId) -> bool {
        // Check if node itself is a text node
        let node_data_container = styled_dom.node_data.as_container();
        let node_type = node_data_container[node_id].get_node_type();
        if matches!(node_type, NodeType::Text(_)) {
            return true;
        }

        // Check if node has text children
        let hierarchy_container = styled_dom.node_hierarchy.as_container();
        let node_item = &hierarchy_container[node_id];

        // Iterate through children
        let mut current_child = node_item.first_child_id(node_id);
        while let Some(child_id) = current_child {
            let child_type = node_data_container[child_id].get_node_type();
            if matches!(child_type, NodeType::Text(_)) {
                return true;
            }

            // Move to next sibling
            current_child = hierarchy_container[child_id].next_sibling_id();
        }

        false
    }

    /// Checks if text in a node is selectable based on CSS user-select property.
    fn is_text_selectable(&self, styled_dom: &StyledDom, node_id: NodeId) -> bool {
        let node_state = &styled_dom.styled_nodes.as_container()[node_id].styled_node_state;
        crate::solver3::getters::is_text_selectable(styled_dom, node_id, node_state)
    }

    /// Process an accessibility action from an assistive technology.
    ///
    /// This method dispatches actions to the appropriate managers (scroll, focus, etc.)
    /// and returns information about which nodes were affected and how.
    ///
    /// # Arguments
    /// * `dom_id` - The DOM containing the target node
    /// * `node_id` - The target node for the action
    /// * `action` - The accessibility action to perform
    /// * `now` - Current timestamp for animations
    ///
    /// # Returns
    /// A BTreeMap of affected nodes with:
    /// - Key: DomNodeId that was affected
    /// - Value: (Vec<EventFilter> synthetic events to dispatch, bool indicating if node needs
    ///   re-layout)
    ///
    /// Empty map = action was not applicable or nothing changed
    #[cfg(feature = "a11y")]
    pub fn process_accessibility_action(
        &mut self,
        dom_id: DomId,
        node_id: NodeId,
        action: azul_core::dom::AccessibilityAction,
        now: std::time::Instant,
    ) -> BTreeMap<DomNodeId, (Vec<azul_core::events::EventFilter>, bool)> {
        use crate::managers::text_input::TextInputSource;

        let mut affected_nodes = BTreeMap::new();

        match action {
            // Focus actions
            AccessibilityAction::Focus => {
                let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                let dom_node_id = DomNodeId {
                    dom: dom_id,
                    node: hierarchy_id,
                };
                self.focus_manager.set_focused_node(Some(dom_node_id));

                // Check if node is contenteditable - if so, initialize cursor at end of text
                if let Some(layout_result) = self.layout_results.get(&dom_id) {
                    if let Some(styled_node) = layout_result
                        .styled_dom
                        .node_data
                        .as_ref()
                        .get(node_id.index())
                    {
                        let is_contenteditable =
                            styled_node.attributes.as_ref().iter().any(|attr| {
                                matches!(attr, azul_core::dom::AttributeType::ContentEditable(_))
                            });

                        if is_contenteditable {
                            // Initialize cursor at end of text using CursorManager
                            let inline_layout = self.get_node_inline_layout(dom_id, node_id);
                            self.cursor_manager.initialize_cursor_at_end(
                                dom_id,
                                node_id,
                                inline_layout.as_ref(),
                            );

                            // Scroll cursor into view if necessary
                            self.scroll_cursor_into_view_if_needed(dom_id, node_id, now);
                        } else {
                            // Not editable - clear cursor
                            self.cursor_manager.clear();
                        }
                    }
                }

                // Optionally scroll into view
                self.scroll_to_node_if_needed(dom_id, node_id, now);
            }
            AccessibilityAction::Blur => {
                self.focus_manager.clear_focus();
                self.cursor_manager.clear();
            }
            AccessibilityAction::SetSequentialFocusNavigationStartingPoint => {
                let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                let dom_node_id = DomNodeId {
                    dom: dom_id,
                    node: hierarchy_id,
                };
                self.focus_manager.set_focused_node(Some(dom_node_id));
                // Clear cursor for focus navigation
                self.cursor_manager.clear();
            }

            // Scroll actions
            AccessibilityAction::ScrollIntoView => {
                self.scroll_to_node_if_needed(dom_id, node_id, now);
            }
            AccessibilityAction::ScrollUp => {
                self.scroll_manager.scroll_by(
                    dom_id,
                    node_id,
                    LogicalPosition { x: 0.0, y: -100.0 },
                    std::time::Duration::from_millis(200).into(),
                    azul_core::events::EasingFunction::EaseOut,
                    now.into(),
                );
            }
            AccessibilityAction::ScrollDown => {
                self.scroll_manager.scroll_by(
                    dom_id,
                    node_id,
                    LogicalPosition { x: 0.0, y: 100.0 },
                    std::time::Duration::from_millis(200).into(),
                    azul_core::events::EasingFunction::EaseOut,
                    now.into(),
                );
            }
            AccessibilityAction::ScrollLeft => {
                self.scroll_manager.scroll_by(
                    dom_id,
                    node_id,
                    LogicalPosition { x: -100.0, y: 0.0 },
                    std::time::Duration::from_millis(200).into(),
                    azul_core::events::EasingFunction::EaseOut,
                    now.into(),
                );
            }
            AccessibilityAction::ScrollRight => {
                self.scroll_manager.scroll_by(
                    dom_id,
                    node_id,
                    LogicalPosition { x: 100.0, y: 0.0 },
                    std::time::Duration::from_millis(200).into(),
                    azul_core::events::EasingFunction::EaseOut,
                    now.into(),
                );
            }
            AccessibilityAction::ScrollUp => {
                // Scroll up by default amount (could use page size for page up)
                if let Some(size) = self.get_node_used_size_a11y(dom_id, node_id) {
                    let scroll_amount = size.height.min(100.0); // Scroll by 100px or page height
                    self.scroll_manager.scroll_by(
                        dom_id,
                        node_id,
                        LogicalPosition {
                            x: 0.0,
                            y: -scroll_amount,
                        },
                        std::time::Duration::from_millis(300).into(),
                        azul_core::events::EasingFunction::EaseInOut,
                        now.into(),
                    );
                }
            }
            AccessibilityAction::ScrollDown => {
                // Scroll down by default amount (could use page size for page down)
                if let Some(size) = self.get_node_used_size_a11y(dom_id, node_id) {
                    let scroll_amount = size.height.min(100.0); // Scroll by 100px or page height
                    self.scroll_manager.scroll_by(
                        dom_id,
                        node_id,
                        LogicalPosition {
                            x: 0.0,
                            y: scroll_amount,
                        },
                        std::time::Duration::from_millis(300).into(),
                        azul_core::events::EasingFunction::EaseInOut,
                        now.into(),
                    );
                }
            }
            AccessibilityAction::SetScrollOffset(pos) => {
                self.scroll_manager.scroll_to(
                    dom_id,
                    node_id,
                    pos,
                    std::time::Duration::from_millis(0).into(),
                    azul_core::events::EasingFunction::Linear,
                    now.into(),
                );
            }
            AccessibilityAction::ScrollToPoint(pos) => {
                self.scroll_manager.scroll_to(
                    dom_id,
                    node_id,
                    pos,
                    std::time::Duration::from_millis(300).into(),
                    azul_core::events::EasingFunction::EaseInOut,
                    now.into(),
                );
            }

            // Actions that should trigger element callbacks if they exist
            // These generate synthetic EventFilters that go through the normal
            // callback system
            AccessibilityAction::Default => {
                // Default action → synthetic Click event
                let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                let dom_node_id = DomNodeId {
                    dom: dom_id,
                    node: hierarchy_id,
                };

                // Check if node has a Default callback, otherwise fallback to Click
                let event_filter = if let Some(layout_result) = self.layout_results.get(&dom_id) {
                    if let Some(styled_node) = layout_result
                        .styled_dom
                        .node_data
                        .as_ref()
                        .get(node_id.index())
                    {
                        let has_default_callback =
                            styled_node.callbacks.as_ref().iter().any(|cb| {
                                // On::Default converts to HoverEventFilter::MouseUp
                                matches!(cb.event, EventFilter::Hover(HoverEventFilter::MouseUp))
                            });

                        if has_default_callback {
                            EventFilter::Hover(HoverEventFilter::MouseUp)
                        } else {
                            EventFilter::Hover(HoverEventFilter::MouseUp)
                        }
                    } else {
                        EventFilter::Hover(HoverEventFilter::MouseUp)
                    }
                } else {
                    EventFilter::Hover(HoverEventFilter::MouseUp)
                };

                affected_nodes.insert(dom_node_id, (vec![event_filter], false));
            }

            AccessibilityAction::Increment | AccessibilityAction::Decrement => {
                // Increment/Decrement work by:
                // 1. Reading the current value (from "value" attribute or text content)
                // 2. Parsing it as a number
                // 3. Incrementing/decrementing by 1
                // 4. Converting back to string
                // 5. Recording as text input (fires TextInput event)
                //
                // This allows user callbacks to intercept via On::TextInput

                let is_increment = matches!(action, AccessibilityAction::Increment);

                // Get the current value
                let current_value = if let Some(layout_result) = self.layout_results.get(&dom_id) {
                    if let Some(styled_node) = layout_result
                        .styled_dom
                        .node_data
                        .as_ref()
                        .get(node_id.index())
                    {
                        // Try "value" attribute first
                        styled_node
                            .attributes
                            .as_ref()
                            .iter()
                            .find_map(|attr| {
                                if let AttributeType::Value(v) = attr {
                                    Some(v.as_str().to_string())
                                } else {
                                    None
                                }
                            })
                            .or_else(|| {
                                // Fallback to text content
                                if let NodeType::Text(text) = styled_node.get_node_type() {
                                    Some(text.as_str().to_string())
                                } else {
                                    None
                                }
                            })
                    } else {
                        None
                    }
                } else {
                    None
                };

                // Parse as number, increment/decrement, convert back to string
                if let Some(value_str) = current_value {
                    let parsed: Result<f64, _> = value_str.trim().parse();

                    let new_value_str = if let Ok(num) = parsed {
                        // Successfully parsed as number
                        let new_num = if is_increment { num + 1.0 } else { num - 1.0 };
                        // Format with same precision as input if possible
                        if num.fract() == 0.0 {
                            format!("{}", new_num as i64)
                        } else {
                            format!("{}", new_num)
                        }
                    } else {
                        // Not a number - treat as 0 and increment/decrement
                        if is_increment {
                            "1".to_string()
                        } else {
                            "-1".to_string()
                        }
                    };

                    // Record as text input (will fire On::TextInput callbacks)
                    let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                    let dom_node_id = DomNodeId {
                        dom: dom_id,
                        node: hierarchy_id,
                    };

                    // Get old text for changeset
                    let old_inline_content = self.get_text_before_textinput(dom_id, node_id);
                    let old_text = self.extract_text_from_inline_content(&old_inline_content);

                    // Record the text input
                    self.text_input_manager.record_input(
                        dom_node_id,
                        new_value_str,
                        old_text,
                        TextInputSource::Accessibility,
                    );

                    // Add TextInput event to affected nodes
                    affected_nodes.insert(
                        dom_node_id,
                        (vec![EventFilter::Focus(FocusEventFilter::TextInput)], false),
                    );
                }
            }

            AccessibilityAction::Collapse | AccessibilityAction::Expand => {
                // Map to corresponding On:: events
                let event_type = match action {
                    AccessibilityAction::Collapse => On::Collapse,
                    AccessibilityAction::Expand => On::Expand,
                    _ => unreachable!(),
                };

                // Check if node has a callback for this event type
                if let Some(layout_result) = self.layout_results.get(&dom_id) {
                    if let Some(styled_node) = layout_result
                        .styled_dom
                        .node_data
                        .as_ref()
                        .get(node_id.index())
                    {
                        // Check if any callback matches this event type
                        let has_callback = styled_node
                            .callbacks
                            .as_ref()
                            .iter()
                            .any(|cb| cb.event == event_type.into());

                        let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                        let dom_node_id = DomNodeId {
                            dom: dom_id,
                            node: hierarchy_id,
                        };

                        if has_callback {
                            // Generate EventFilter for this specific callback
                            affected_nodes.insert(dom_node_id, (vec![event_type.into()], false));
                        } else {
                            // No specific callback - fallback to regular Click
                            affected_nodes.insert(
                                dom_node_id,
                                (vec![EventFilter::Hover(HoverEventFilter::MouseUp)], false),
                            );
                        }
                    }
                }
            }

            // Context menu - check if node has a menu and trigger right-click event
            AccessibilityAction::ShowContextMenu => {
                // Check if the node has a context menu attached
                let layout_result = match self.layout_results.get(&dom_id) {
                    Some(lr) => lr,
                    None => {
                        return affected_nodes;
                    }
                };

                // Get the node from the styled DOM
                let styled_node = match layout_result
                    .styled_dom
                    .node_data
                    .as_ref()
                    .get(node_id.index())
                {
                    Some(node) => node,
                    None => {
                        return affected_nodes;
                    }
                };

                // Check if node has context menu
                let has_context_menu = styled_node.get_context_menu().is_some();

                if has_context_menu {
                    // TODO: Generate synthetic right-click event to trigger context menu
                    // This requires access to the event system which is not available here
                } else {
                    // No context menu attached to node - silently ignore
                }
            }

            // Text editing actions - use text3/edit.rs
            AccessibilityAction::ReplaceSelectedText(ref text) => {
                let nodes = self.edit_text_node(
                    dom_id,
                    node_id,
                    TextEditType::ReplaceSelection(text.as_str().to_string()),
                );
                for node in nodes {
                    affected_nodes.insert(node, (Vec::new(), true)); // true = needs re-layout
                }
            }
            AccessibilityAction::SetValue(ref text) => {
                let nodes = self.edit_text_node(
                    dom_id,
                    node_id,
                    TextEditType::SetValue(text.as_str().to_string()),
                );
                for node in nodes {
                    affected_nodes.insert(node, (Vec::new(), true));
                }
            }
            AccessibilityAction::SetNumericValue(value) => {
                let nodes = self.edit_text_node(
                    dom_id,
                    node_id,
                    TextEditType::SetNumericValue(value.get() as f64),
                );
                for node in nodes {
                    affected_nodes.insert(node, (Vec::new(), true));
                }
            }
            AccessibilityAction::SetTextSelection(selection) => {
                // Get the text layout for this node from the layout tree
                let text_layout = self.get_node_inline_layout(dom_id, node_id);

                if let Some(inline_layout) = text_layout {
                    // Convert byte offsets to TextCursor positions
                    let start_cursor = self.byte_offset_to_cursor(
                        inline_layout.as_ref(),
                        selection.selection_start as u32,
                    );
                    let end_cursor = self.byte_offset_to_cursor(
                        inline_layout.as_ref(),
                        selection.selection_end as u32,
                    );

                    if let (Some(start), Some(end)) = (start_cursor, end_cursor) {
                        let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
                        let dom_node_id = DomNodeId {
                            dom: dom_id,
                            node: hierarchy_id,
                        };

                        if start == end {
                            // Same position - just set cursor
                            self.cursor_manager.move_cursor_to(start, dom_id, node_id);

                            // Clear any existing selections
                            self.selection_manager.clear_selection(&dom_id);
                        } else {
                            // Different positions - create selection range
                            let selection = Selection::Range(SelectionRange { start, end });

                            let selection_state = SelectionState {
                                selections: vec![selection].into(),
                                node_id: dom_node_id,
                            };

                            // Set selection in SelectionManager
                            self.selection_manager
                                .set_selection(dom_id, selection_state);

                            // Also set cursor to start of selection
                            self.cursor_manager.move_cursor_to(start, dom_id, node_id);
                        }
                    } else {
                        // Could not convert byte offsets to cursors - silently ignore
                    }
                } else {
                    // No text layout available for node - silently ignore
                }
            }

            // Tooltip actions
            AccessibilityAction::ShowTooltip | AccessibilityAction::HideTooltip => {
                // TODO: Integrate with tooltip manager when implemented
            }

            AccessibilityAction::CustomAction(_id) => {
                // TODO: Allow custom action handlers
            }
        }

        // Sync cursor to selection manager for rendering
        self.sync_cursor_to_selection_manager();

        affected_nodes
    }

    /// Process text input from keyboard using cursor/selection/focus managers.
    ///
    /// This is the new unified text input handling. The framework manages text editing
    /// internally using managers, then fires callbacks (On::TextInput, On::Changed)
    /// after the internal state is already updated.
    ///
    /// ## Workflow
    /// 1. Check if focus manager has a focused contenteditable node
    /// 2. Get cursor/selection from managers
    /// 3. Call edit_text_node to apply the edit and update cache
    /// 4. Collect affected nodes that need dirty marking
    /// 5. Return map for re-layout triggering
    ///
    /// ## Parameters
    /// * `text_input` - The text that was typed (can be multiple chars for IME)
    ///
    /// ## Returns
    /// BTreeMap of affected nodes with:
    /// - Key: DomNodeId that was affected
    /// - Value: (Vec<EventFilter> synthetic events, bool needs_relayout)
    /// - Empty map = no focused contenteditable node
    pub fn record_text_input(
        &mut self,
        text_input: &str,
    ) -> BTreeMap<azul_core::dom::DomNodeId, (Vec<azul_core::events::EventFilter>, bool)> {
        use std::collections::BTreeMap;

        use crate::managers::text_input::TextInputSource;

        println!("[record_text_input] Called with text: '{}'", text_input);

        let mut affected_nodes = BTreeMap::new();

        if text_input.is_empty() {
            println!("[record_text_input] Empty text, returning empty");
            return affected_nodes;
        }

        // Get focused node
        let focused_node = match self.focus_manager.get_focused_node().copied() {
            Some(node) => {
                println!("[record_text_input] Focused node: {:?}", node);
                node
            },
            None => {
                println!("[record_text_input] ERROR: No focused node!");
                return affected_nodes;
            }
        };

        let node_id = match focused_node.node.into_crate_internal() {
            Some(id) => {
                println!("[record_text_input] Node ID: {:?}", id);
                id
            },
            None => {
                println!("[record_text_input] ERROR: Invalid node ID");
                return affected_nodes;
            }
        };

        // Get the OLD text before any changes
        let old_inline_content = self.get_text_before_textinput(focused_node.dom, node_id);
        let old_text = self.extract_text_from_inline_content(&old_inline_content);
        println!("[record_text_input] Old text: '{}' ({} bytes)", old_text, old_text.len());

        // Record the changeset in TextInputManager (but DON'T apply changes yet)
        println!("[record_text_input] Recording input in TextInputManager...");
        self.text_input_manager.record_input(
            focused_node,
            text_input.to_string(),
            old_text,
            TextInputSource::Keyboard, // Assuming keyboard for now
        );
        println!("[record_text_input] Input recorded successfully");

        // Return affected nodes with TextInput event so callbacks can be invoked
        let text_input_event = vec![EventFilter::Focus(FocusEventFilter::TextInput)];

        affected_nodes.insert(focused_node, (text_input_event, false)); // false = no re-layout yet
        println!("[record_text_input] Returning {} affected nodes", affected_nodes.len());

        affected_nodes
    }

    /// Apply the recorded text changeset to the text cache
    ///
    /// This is called AFTER user callbacks, if preventDefault was not set.
    /// This is where we actually compute the new text and update the cache.
    ///
    /// Also updates the cursor position to reflect the edit.
    ///
    /// Returns the nodes that need to be marked dirty for re-layout.
    pub fn apply_text_changeset(&mut self) -> Vec<azul_core::dom::DomNodeId> {
        println!("[apply_text_changeset] Starting...");
        
        // Get the changeset from TextInputManager
        let changeset = match self.text_input_manager.get_pending_changeset() {
            Some(cs) => {
                println!("[apply_text_changeset] Got changeset for node {:?}, inserted='{}', old_len={}", 
                    cs.node, cs.inserted_text.as_str(), cs.old_text.as_str().len());
                cs.clone()
            },
            None => {
                println!("[apply_text_changeset] ERROR: No pending changeset!");
                return Vec::new();
            }
        };

        let node_id = match changeset.node.node.into_crate_internal() {
            Some(id) => {
                println!("[apply_text_changeset] Node ID: {:?}", id);
                id
            },
            None => {
                println!("[apply_text_changeset] ERROR: Invalid node ID");
                self.text_input_manager.clear_changeset();
                return Vec::new();
            }
        };

        let dom_id = changeset.node.dom;
        println!("[apply_text_changeset] DOM ID: {:?}", dom_id);

        // Check if node is contenteditable
        let layout_result = match self.layout_results.get(&dom_id) {
            Some(lr) => lr,
            None => {
                println!("[apply_text_changeset] ERROR: No layout result for DOM {:?}", dom_id);
                self.text_input_manager.clear_changeset();
                return Vec::new();
            }
        };

        let styled_node = match layout_result
            .styled_dom
            .node_data
            .as_ref()
            .get(node_id.index())
        {
            Some(node) => node,
            None => {
                println!("[apply_text_changeset] ERROR: No styled node at index {}", node_id.index());
                self.text_input_manager.clear_changeset();
                return Vec::new();
            }
        };

        let is_contenteditable = styled_node
            .attributes
            .as_ref()
            .iter()
            .any(|attr| matches!(attr, azul_core::dom::AttributeType::ContentEditable(_)));

        if !is_contenteditable {
            self.text_input_manager.clear_changeset();
            return Vec::new();
        }

        // Get the current inline content from cache
        let content = self.get_text_before_textinput(dom_id, node_id);
        println!("[apply_text_changeset] Got content, {} inline items", content.len());

        // Get current cursor/selection from cursor manager
        let current_selection = if let Some(cursor) = self.cursor_manager.get_cursor() {
            println!("[apply_text_changeset] Cursor: run={}, byte={}", 
                cursor.cluster_id.source_run, cursor.cluster_id.start_byte_in_run);
            vec![Selection::Cursor(cursor.clone())]
        } else {
            println!("[apply_text_changeset] No cursor, creating at position 0");
            // No cursor - create one at start of text
            vec![Selection::Cursor(TextCursor {
                cluster_id: GraphemeClusterId {
                    source_run: 0,
                    start_byte_in_run: 0,
                },
                affinity: CursorAffinity::Leading,
            })]
        };

        // Capture pre-state for undo/redo BEFORE mutation
        let old_text = self.extract_text_from_inline_content(&content);
        let old_cursor = current_selection.first().and_then(|sel| {
            if let Selection::Cursor(c) = sel {
                Some(c.clone())
            } else {
                None
            }
        });
        let old_selection_range = current_selection.first().and_then(|sel| {
            if let Selection::Range(r) = sel {
                Some(*r)
            } else {
                None
            }
        });

        let pre_state = crate::managers::undo_redo::NodeStateSnapshot {
            node_id: azul_core::id::NodeId::new(node_id.index()),
            text_content: old_text.into(),
            cursor_position: old_cursor.into(),
            selection_range: old_selection_range.into(),
            timestamp: azul_core::task::Instant::System(std::time::Instant::now().into()),
        };

        // Apply the edit using text3::edit - this is a pure function
        use crate::text3::edit::{edit_text, TextEdit};
        let text_edit = TextEdit::Insert(changeset.inserted_text.as_str().to_string());
        println!("[apply_text_changeset] Calling edit_text() with Insert('{}')", changeset.inserted_text.as_str());
        let (new_content, new_selections) = edit_text(&content, &current_selection, &text_edit);
        println!("[apply_text_changeset] edit_text returned {} inline items, {} selections", 
            new_content.len(), new_selections.len());

        // Update the cursor/selection in cursor manager
        // This happens lazily, only when we actually apply the changes
        if let Some(Selection::Cursor(new_cursor)) = new_selections.first() {
            println!("[apply_text_changeset] Updating cursor to run={}, byte={}", 
                new_cursor.cluster_id.source_run, new_cursor.cluster_id.start_byte_in_run);
            self.cursor_manager
                .move_cursor_to(new_cursor.clone(), dom_id, node_id);
        }

        // Update the text cache with the new inline content
        println!("[apply_text_changeset] Calling update_text_cache_after_edit()");
        self.update_text_cache_after_edit(dom_id, node_id, new_content);
        println!("[apply_text_changeset] Text cache updated successfully");

        // Record this operation to the undo/redo manager AFTER successful mutation

        use crate::managers::changeset::{TextChangeset, TextOpInsertText, TextOperation};

        // Get the new cursor position after edit
        let new_cursor = new_selections
            .first()
            .and_then(|sel| {
                if let Selection::Cursor(c) = sel {
                    // Convert TextCursor to CursorPosition
                    // For now, we use InWindow with approximate coordinates
                    // TODO: Calculate proper screen coordinates from TextCursor
                    Some(CursorPosition::InWindow(
                        azul_core::geom::LogicalPosition::new(0.0, 0.0),
                    ))
                } else {
                    None
                }
            })
            .unwrap_or(CursorPosition::Uninitialized);

        let old_cursor_pos = old_cursor
            .as_ref()
            .map(|_| {
                // Convert TextCursor to CursorPosition
                CursorPosition::InWindow(azul_core::geom::LogicalPosition::new(0.0, 0.0))
            })
            .unwrap_or(CursorPosition::Uninitialized);

        // Generate a unique changeset ID
        static CHANGESET_COUNTER: std::sync::atomic::AtomicUsize =
            std::sync::atomic::AtomicUsize::new(0);
        let changeset_id = CHANGESET_COUNTER.fetch_add(1, std::sync::atomic::Ordering::SeqCst);

        let undo_changeset = TextChangeset {
            id: changeset_id,
            target: changeset.node,
            operation: TextOperation::InsertText(TextOpInsertText {
                text: changeset.inserted_text.clone(),
                position: old_cursor_pos,
                new_cursor,
            }),
            timestamp: azul_core::task::Instant::System(std::time::Instant::now().into()),
        };
        self.undo_redo_manager
            .record_operation(undo_changeset, pre_state);

        // Clear the changeset now that it's been applied
        self.text_input_manager.clear_changeset();
        println!("[apply_text_changeset] Changeset cleared");

        // Return nodes that need dirty marking
        let dirty_nodes = self.determine_dirty_text_nodes(dom_id, node_id);
        println!("[apply_text_changeset] Dirty nodes: {:?}", dirty_nodes);
        dirty_nodes
    }

    /// Determine which nodes need to be marked dirty after a text edit
    ///
    /// Returns the edited node + its parent (if it exists)
    fn determine_dirty_text_nodes(
        &self,
        dom_id: DomId,
        node_id: NodeId,
    ) -> Vec<azul_core::dom::DomNodeId> {
        let layout_result = match self.layout_results.get(&dom_id) {
            Some(lr) => lr,
            None => return Vec::new(),
        };

        let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
        let node_dom_id = azul_core::dom::DomNodeId {
            dom: dom_id,
            node: hierarchy_id,
        };

        // Get parent node ID
        let parent_id = layout_result
            .styled_dom
            .node_hierarchy
            .as_container()
            .get(node_id)
            .and_then(|item| item.parent_id())
            .map(|parent_node_id| {
                let parent_hierarchy_id =
                    NodeHierarchyItemId::from_crate_internal(Some(parent_node_id));
                azul_core::dom::DomNodeId {
                    dom: dom_id,
                    node: parent_hierarchy_id,
                }
            });

        // Return node + parent (if exists)
        if let Some(parent) = parent_id {
            vec![node_dom_id, parent]
        } else {
            vec![node_dom_id]
        }
    }

    /// Legacy name for backward compatibility
    #[inline]
    pub fn process_text_input(
        &mut self,
        text_input: &str,
    ) -> BTreeMap<azul_core::dom::DomNodeId, (Vec<azul_core::events::EventFilter>, bool)> {
        println!("[process_text_input] Called with text: '{}'", text_input);
        let result = self.record_text_input(text_input);
        println!("[process_text_input] record_text_input returned {} affected nodes", result.len());
        for (node, (filters, has_text)) in &result {
            println!("[process_text_input]   Node {:?}: {} filters, has_text={}", node, filters.len(), has_text);
        }
        result
    }

    /// Get the last text changeset (what was changed in the last text input)
    pub fn get_last_text_changeset(&self) -> Option<&PendingTextEdit> {
        self.text_input_manager.get_pending_changeset()
    }

    /// Get the current inline content (text before text input is applied)
    ///
    /// This is a query function that retrieves the current text state from the node.
    /// Returns InlineContent vector if the node has text.
    ///
    /// # Implementation Note
    /// This function FIRST checks `dirty_text_nodes` for optimistic state (edits not yet
    /// committed to StyledDom), then falls back to the StyledDom. This is critical for
    /// correct text input handling - without this, each keystroke would read stale state.
    pub fn get_text_before_textinput(&self, dom_id: DomId, node_id: NodeId) -> Vec<InlineContent> {
        // CRITICAL FIX: Check dirty_text_nodes first!
        // If the node has been edited since last full layout, its most up-to-date
        // content is in dirty_text_nodes, NOT in the StyledDom.
        // Without this check, every keystroke reads the ORIGINAL text instead of
        // the accumulated edits, causing bugs like double-input and wrong node affected.
        if let Some(dirty_node) = self.dirty_text_nodes.get(&(dom_id, node_id)) {
            #[cfg(feature = "std")]
            eprintln!("[get_text_before_textinput] Using dirty_text_nodes content for ({:?}, {:?})", dom_id, node_id);
            return dirty_node.content.clone();
        }

        // Fallback to committed state from StyledDom
        // Get the layout result for this DOM
        let layout_result = match self.layout_results.get(&dom_id) {
            Some(lr) => lr,
            None => return Vec::new(),
        };

        // Get the node data
        let node_data = match layout_result
            .styled_dom
            .node_data
            .as_ref()
            .get(node_id.index())
        {
            Some(nd) => nd,
            None => return Vec::new(),
        };

        // Extract text content from the node
        match node_data.get_node_type() {
            NodeType::Text(text) => {
                // Simple text node - create a single StyledRun
                let style = self.get_text_style_for_node(dom_id, node_id);

                vec![InlineContent::Text(StyledRun {
                    text: text.as_str().to_string(),
                    style,
                    logical_start_byte: 0,
                    source_node_id: Some(node_id),
                })]
            }
            NodeType::Div | NodeType::Body | NodeType::IFrame(_) => {
                // Container nodes - recursively collect text from children
                self.collect_text_from_children(dom_id, node_id)
            }
            _ => {
                // Other node types (Image, etc.) don't contribute text
                Vec::new()
            }
        }
    }

    /// Get the font style for a text node from CSS
    fn get_text_style_for_node(
        &self,
        dom_id: DomId,
        node_id: NodeId,
    ) -> alloc::sync::Arc<StyleProperties> {
        use alloc::sync::Arc;

        let layout_result = match self.layout_results.get(&dom_id) {
            Some(lr) => lr,
            None => return Arc::new(Default::default()),
        };

        // Try to get font from styled DOM
        let styled_nodes = layout_result.styled_dom.styled_nodes.as_ref();
        let _styled_node = match styled_nodes.get(node_id.index()) {
            Some(sn) => sn,
            None => return Arc::new(Default::default()),
        };

        // Extract font properties from computed style
        // For now, use default - full implementation would query CSS property cache
        // TODO: Query CSS property cache for font-family, font-size, font-weight, etc.
        Arc::new(Default::default())
    }

    /// Recursively collect text content from child nodes
    fn collect_text_from_children(
        &self,
        dom_id: DomId,
        parent_node_id: NodeId,
    ) -> Vec<InlineContent> {
        let layout_result = match self.layout_results.get(&dom_id) {
            Some(lr) => lr,
            None => return Vec::new(),
        };

        let node_hierarchy = layout_result.styled_dom.node_hierarchy.as_ref();
        let parent_item = match node_hierarchy.get(parent_node_id.index()) {
            Some(item) => item,
            None => return Vec::new(),
        };

        let mut result = Vec::new();

        // Traverse all children
        let mut current_child = parent_item.first_child_id(parent_node_id);
        while let Some(child_id) = current_child {
            // Get content from this child (recursive)
            let child_content = self.get_text_before_textinput(dom_id, child_id);
            result.extend(child_content);

            // Move to next sibling
            let child_item = match node_hierarchy.get(child_id.index()) {
                Some(item) => item,
                None => break,
            };
            current_child = child_item.next_sibling_id();
        }

        result
    }

    /// Extract plain text string from inline content
    ///
    /// This is a helper for building the changeset's resulting_text field.
    pub fn extract_text_from_inline_content(&self, content: &[InlineContent]) -> String {
        let mut result = String::new();

        for item in content {
            match item {
                InlineContent::Text(text_run) => {
                    result.push_str(&text_run.text);
                }
                InlineContent::Space(_) => {
                    result.push(' ');
                }
                InlineContent::LineBreak(_) => {
                    result.push('\n');
                }
                InlineContent::Tab => {
                    result.push('\t');
                }
                InlineContent::Ruby { base, .. } => {
                    // For Ruby annotations, include the base text
                    result.push_str(&self.extract_text_from_inline_content(base));
                }
                InlineContent::Marker { run, .. } => {
                    // Markers contribute their text
                    result.push_str(&run.text);
                }
                // Images and shapes don't contribute to plain text
                InlineContent::Image(_) | InlineContent::Shape(_) => {}
            }
        }

        result
    }

    /// Update the text cache after a text edit
    ///
    /// This is the ONLY place where we mutate the text cache.
    /// All other functions are pure queries or transformations.
    ///
    /// This function:
    /// 1. Stores the new content in `dirty_text_nodes` for tracking
    /// 2. Re-runs the text3 layout pipeline (create_logical_items -> reorder -> shape -> fragment)
    /// 3. Updates the inline_layout_result on the IFC root node in the layout tree
    pub fn update_text_cache_after_edit(
        &mut self,
        dom_id: DomId,
        node_id: NodeId,
        new_inline_content: Vec<InlineContent>,
    ) {
        use crate::solver3::layout_tree::CachedInlineLayout;

        println!("[update_text_cache_after_edit] Starting for DOM {:?}, node {:?}", dom_id, node_id);
        println!("[update_text_cache_after_edit] New content has {} inline items", new_inline_content.len());
        for (i, item) in new_inline_content.iter().enumerate() {
            match item {
                crate::text3::cache::InlineContent::Text(run) => {
                    println!("[update_text_cache_after_edit]   Item {}: Text('{}')", i, run.text);
                }
                _ => {
                    println!("[update_text_cache_after_edit]   Item {}: Non-text", i);
                }
            }
        }

        // 1. Store the new content in dirty_text_nodes for tracking
        let cursor = self.cursor_manager.get_cursor().cloned();
        self.dirty_text_nodes.insert(
            (dom_id, node_id),
            DirtyTextNode {
                content: new_inline_content.clone(),
                cursor,
                needs_ancestor_relayout: false, // Will be set if size changes
            },
        );
        println!("[update_text_cache_after_edit] Stored in dirty_text_nodes");

        // 2. Get the cached constraints from the existing inline layout result
        // We need to find the IFC root node and extract its constraints
        let constraints = {
            let layout_result = match self.layout_results.get(&dom_id) {
                Some(r) => r,
                None => {
                    println!("[update_text_cache_after_edit] ERROR: No layout result for DOM");
                    return;
                }
            };
            
            let layout_node = match layout_result.layout_tree.get(node_id.index()) {
                Some(n) => n,
                None => {
                    println!("[update_text_cache_after_edit] ERROR: Node {} not found in layout tree", node_id.index());
                    return;
                }
            };
            
            let cached_layout = match &layout_node.inline_layout_result {
                Some(c) => c,
                None => {
                    println!("[update_text_cache_after_edit] ERROR: No inline layout cached for node");
                    return;
                }
            };
            
            match &cached_layout.constraints {
                Some(c) => {
                    println!("[update_text_cache_after_edit] Got cached constraints");
                    c.clone()
                },
                None => {
                    println!("[update_text_cache_after_edit] ERROR: No constraints cached");
                    return;
                }
            }
        };

        // 3. Re-run the text3 layout pipeline
        println!("[update_text_cache_after_edit] Re-running text3 layout pipeline...");
        let new_layout = self.relayout_text_node_internal(&new_inline_content, &constraints);

        let Some(new_layout) = new_layout else {
            println!("[update_text_cache_after_edit] ERROR: relayout_text_node_internal returned None");
            return;
        };
        println!("[update_text_cache_after_edit] Text3 layout complete, {} items", new_layout.items.len());

        // 4. Update the layout cache with the new layout
        // Find the IFC root node in the layout tree and update its inline_layout_result
        if let Some(layout_result) = self.layout_results.get_mut(&dom_id) {
            // Find the node in the layout tree
            if let Some(layout_node) = layout_result.layout_tree.get_mut(node_id.index()) {
                // Check if size changed (needs repaint)
                let old_size = layout_node.used_size;
                let new_bounds = new_layout.bounds();
                let new_size = Some(LogicalSize {
                    width: new_bounds.width,
                    height: new_bounds.height,
                });
                println!("[update_text_cache_after_edit] Old size: {:?}, new size: {:?}", old_size, new_size);

                // Check if we need to propagate layout shift
                if let (Some(old), Some(new)) = (old_size, new_size) {
                    if (old.height - new.height).abs() > 0.5 || (old.width - new.width).abs() > 0.5 {
                        // Mark that ancestor relayout is needed
                        println!("[update_text_cache_after_edit] Size changed, marking for ancestor relayout");
                        if let Some(dirty_node) = self.dirty_text_nodes.get_mut(&(dom_id, node_id)) {
                            dirty_node.needs_ancestor_relayout = true;
                        }
                    }
                }

                // Update the inline layout result with the new layout but preserve constraints
                layout_node.inline_layout_result = Some(CachedInlineLayout::new_with_constraints(
                    Arc::new(new_layout),
                    constraints.available_width,
                    false, // No floats in quick relayout
                    constraints,
                ));
                println!("[update_text_cache_after_edit] Layout cache updated successfully");
            } else {
                println!("[update_text_cache_after_edit] ERROR: Layout node {} not found for update", node_id.index());
            }
        } else {
            println!("[update_text_cache_after_edit] ERROR: Layout result not found for update");
        }
    }

    /// Internal helper to re-run the text3 layout pipeline on new content
    fn relayout_text_node_internal(
        &self,
        content: &[InlineContent],
        constraints: &UnifiedConstraints,
    ) -> Option<UnifiedLayout> {
        use crate::text3::cache::{
            create_logical_items, perform_fragment_layout, reorder_logical_items,
            shape_visual_items, BidiDirection, BreakCursor,
        };

        // Stage 1: Create logical items from InlineContent
        let logical_items = create_logical_items(content, &[], &mut None);

        if logical_items.is_empty() {
            // Empty text - return empty layout
            return Some(UnifiedLayout {
                items: Vec::new(),
                overflow: crate::text3::cache::OverflowInfo::default(),
            });
        }

        // Stage 2: Bidi reordering
        let base_direction = constraints.direction.unwrap_or(BidiDirection::Ltr);
        let visual_items = reorder_logical_items(&logical_items, base_direction, &mut None).ok()?;

        // Stage 3: Shape text (resolve fonts, create glyphs)
        let loaded_fonts = self.font_manager.get_loaded_fonts();
        let shaped_items = shape_visual_items(
            &visual_items,
            self.font_manager.get_font_chain_cache(),
            &self.font_manager.fc_cache,
            &loaded_fonts,
            &mut None,
        )
        .ok()?;

        // Stage 4: Fragment layout (line breaking, positioning)
        let mut cursor = BreakCursor::new(&shaped_items);
        perform_fragment_layout(&mut cursor, &logical_items, constraints, &mut None, &loaded_fonts)
            .ok()
    }

    /// Helper to get node used_size for accessibility actions
    #[cfg(feature = "a11y")]
    fn get_node_used_size_a11y(
        &self,
        dom_id: DomId,
        node_id: NodeId,
    ) -> Option<azul_core::geom::LogicalSize> {
        let layout_result = self.layout_results.get(&dom_id)?;
        let node = layout_result.layout_tree.get(node_id.index())?;
        node.used_size
    }

    /// Get the layout bounds (position and size) of a specific node
    fn get_node_bounds(
        &self,
        dom_id: DomId,
        node_id: NodeId,
    ) -> Option<azul_css::props::basic::LayoutRect> {
        use azul_css::props::basic::LayoutRect;

        let layout_result = self.layout_results.get(&dom_id)?;
        let node = layout_result.layout_tree.get(node_id.index())?;

        // Get size from used_size
        let size = node.used_size?;

        // Get position from calculated_positions map
        let position = layout_result.calculated_positions.get(&node_id.index())?;

        Some(LayoutRect {
            origin: azul_css::props::basic::LayoutPoint {
                x: position.x as f32 as isize,
                y: position.y as f32 as isize,
            },
            size: azul_css::props::basic::LayoutSize {
                width: size.width as isize,
                height: size.height as isize,
            },
        })
    }

    /// Scroll a node into view if it's not currently visible in the viewport
    #[cfg(feature = "a11y")]
    fn scroll_to_node_if_needed(
        &mut self,
        dom_id: DomId,
        node_id: NodeId,
        now: std::time::Instant,
    ) {
        // TODO: This should:
        // 1. Check if node is currently visible in viewport
        // 2. Find the nearest scrollable ancestor
        // 3. Calculate the scroll offset needed to make the node visible
        // 4. Animate the scroll

        // For now, just ensure the node's scroll state is at origin
        if self.get_node_bounds(dom_id, node_id).is_some() {
            self.scroll_manager.scroll_to(
                dom_id,
                node_id,
                LogicalPosition { x: 0.0, y: 0.0 },
                std::time::Duration::from_millis(300).into(),
                azul_core::events::EasingFunction::EaseOut,
                now.into(),
            );
        }
    }

    /// Scroll the cursor into view if it's not currently visible
    ///
    /// This is automatically called when:
    /// - Focus lands on a contenteditable element
    /// - Cursor is moved programmatically
    /// - Text is inserted/deleted
    ///
    /// The function:
    /// 1. Gets the cursor rectangle from the text layout
    /// 2. Checks if the cursor is visible in the current viewport
    /// 3. If not, calculates the minimum scroll offset needed
    /// 4. Animates the scroll to bring the cursor into view
    fn scroll_cursor_into_view_if_needed(
        &mut self,
        dom_id: DomId,
        node_id: NodeId,
        now: std::time::Instant,
    ) {
        // Get the cursor from CursorManager
        let Some(cursor) = self.cursor_manager.get_cursor() else {
            return;
        };

        // Get the inline layout for this node
        let Some(inline_layout) = self.get_node_inline_layout(dom_id, node_id) else {
            return;
        };

        // Get the cursor rectangle from the text layout
        let Some(cursor_rect) = inline_layout.get_cursor_rect(cursor) else {
            return;
        };

        // Get the node bounds
        let Some(node_bounds) = self.get_node_bounds(dom_id, node_id) else {
            return;
        };

        // Calculate the cursor's absolute position
        let cursor_abs_x = node_bounds.origin.x as f32 + cursor_rect.origin.x;
        let cursor_abs_y = node_bounds.origin.y as f32 + cursor_rect.origin.y;

        // Find the nearest scrollable ancestor
        // For now, just use the node itself if it's scrollable
        // TODO: Walk up the DOM tree to find scrollable ancestor

        // Get current scroll position
        let current_scroll = self
            .scroll_manager
            .get_current_offset(dom_id, node_id)
            .unwrap_or_default();

        // Calculate visible viewport
        let viewport_x = node_bounds.origin.x as f32 + current_scroll.x;
        let viewport_y = node_bounds.origin.y as f32 + current_scroll.y;
        let viewport_width = node_bounds.size.width as f32;
        let viewport_height = node_bounds.size.height as f32;

        // Check if cursor is visible
        let cursor_visible_x = (cursor_abs_x as f32) >= viewport_x
            && (cursor_abs_x as f32) <= viewport_x + viewport_width;
        let cursor_visible_y = (cursor_abs_y as f32) >= viewport_y
            && (cursor_abs_y as f32) <= viewport_y + viewport_height;

        if cursor_visible_x && cursor_visible_y {
            // Cursor is already visible
            return;
        }

        // Calculate scroll offset to make cursor visible
        let mut target_scroll_x = current_scroll.x;
        let mut target_scroll_y = current_scroll.y;

        // Adjust horizontal scroll if needed
        if (cursor_abs_x as f32) < viewport_x {
            // Cursor is to the left of viewport - scroll left
            target_scroll_x = cursor_abs_x as f32 - node_bounds.origin.x as f32;
        } else if (cursor_abs_x as f32) > viewport_x + viewport_width {
            // Cursor is to the right of viewport - scroll right
            target_scroll_x = cursor_abs_x as f32 - node_bounds.origin.x as f32 - viewport_width
                + cursor_rect.size.width;
        }

        // Adjust vertical scroll if needed
        if (cursor_abs_y as f32) < viewport_y {
            // Cursor is above viewport - scroll up
            target_scroll_y = cursor_abs_y as f32 - node_bounds.origin.y as f32;
        } else if (cursor_abs_y as f32) > viewport_y + viewport_height {
            // Cursor is below viewport - scroll down
            target_scroll_y = cursor_abs_y as f32 - node_bounds.origin.y as f32 - viewport_height
                + cursor_rect.size.height;
        }

        // Animate scroll to bring cursor into view
        self.scroll_manager.scroll_to(
            dom_id,
            node_id,
            LogicalPosition {
                x: target_scroll_x,
                y: target_scroll_y,
            },
            std::time::Duration::from_millis(200).into(),
            azul_core::events::EasingFunction::EaseOut,
            now.into(),
        );
    }

    /// Convert a byte offset in the text to a TextCursor position
    ///
    /// This is used for accessibility SetTextSelection action, which provides
    /// byte offsets rather than grapheme cluster IDs.
    ///
    /// # Arguments
    ///
    /// * `text_layout` - The text layout containing the shaped runs
    /// * `byte_offset` - The byte offset in the UTF-8 text
    ///
    /// # Returns
    ///
    /// A TextCursor positioned at the given byte offset, or None if the offset
    /// is out of bounds.
    fn byte_offset_to_cursor(
        &self,
        text_layout: &UnifiedLayout,
        byte_offset: u32,
    ) -> Option<TextCursor> {
        // Handle offset 0 as special case (start of text)
        if byte_offset == 0 {
            // Find first cluster in items
            for item in &text_layout.items {
                if let ShapedItem::Cluster(cluster) = &item.item {
                    return Some(TextCursor {
                        cluster_id: cluster.source_cluster_id,
                        affinity: CursorAffinity::Trailing,
                    });
                }
            }
            // No clusters found - return default
            return Some(TextCursor {
                cluster_id: GraphemeClusterId {
                    source_run: 0,
                    start_byte_in_run: 0,
                },
                affinity: CursorAffinity::Trailing,
            });
        }

        // Iterate through items to find which cluster contains this byte offset
        let mut current_byte_offset = 0u32;

        for item in &text_layout.items {
            if let ShapedItem::Cluster(cluster) = &item.item {
                // Calculate byte length of this cluster from its text
                let cluster_byte_length = cluster.text.len() as u32;
                let cluster_end_byte = current_byte_offset + cluster_byte_length;

                // Check if our target byte offset falls within this cluster
                if byte_offset >= current_byte_offset && byte_offset <= cluster_end_byte {
                    // Found the cluster
                    return Some(TextCursor {
                        cluster_id: cluster.source_cluster_id,
                        affinity: CursorAffinity::Trailing,
                    });
                }

                current_byte_offset = cluster_end_byte;
            }
        }

        // Offset is beyond the end of all text - return cursor at end of last cluster
        for item in text_layout.items.iter().rev() {
            if let ShapedItem::Cluster(cluster) = &item.item {
                return Some(TextCursor {
                    cluster_id: cluster.source_cluster_id,
                    affinity: CursorAffinity::Trailing,
                });
            }
        }

        // No clusters at all - return default position
        Some(TextCursor {
            cluster_id: GraphemeClusterId {
                source_run: 0,
                start_byte_in_run: 0,
            },
            affinity: CursorAffinity::Trailing,
        })
    }

    /// Get the inline layout result for a specific node
    ///
    /// This looks up the node in the layout tree and returns its inline layout result
    /// if it exists.
    fn get_node_inline_layout(
        &self,
        dom_id: DomId,
        node_id: NodeId,
    ) -> Option<alloc::sync::Arc<UnifiedLayout>> {
        // Get the layout tree from cache
        let layout_tree = self.layout_cache.tree.as_ref()?;

        // Find the layout node corresponding to the DOM node
        let layout_node = layout_tree
            .nodes
            .iter()
            .find(|node| node.dom_node_id == Some(node_id))?;

        // Return the inline layout result
        layout_node
            .inline_layout_result
            .as_ref()
            .map(|c| c.clone_layout())
    }

    /// Sync cursor from CursorManager to SelectionManager for rendering
    ///
    /// The renderer expects cursor and selection data from the SelectionManager,
    /// but we manage the cursor separately in the CursorManager for better separation
    /// of concerns. This function syncs the cursor state so it can be rendered.
    ///
    /// This should be called whenever the cursor changes.
    pub fn sync_cursor_to_selection_manager(&mut self) {
        if let Some(cursor) = self.cursor_manager.get_cursor() {
            if let Some(location) = self.cursor_manager.get_cursor_location() {
                // Convert cursor to Selection
                let selection = Selection::Cursor(cursor.clone());

                // Create SelectionState
                let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(location.node_id));
                let dom_node_id = DomNodeId {
                    dom: location.dom_id,
                    node: hierarchy_id,
                };

                let selection_state = SelectionState {
                    selections: vec![selection].into(),
                    node_id: dom_node_id,
                };

                // Set selection in SelectionManager
                self.selection_manager
                    .set_selection(location.dom_id, selection_state);
            }
        }
        // NOTE: We intentionally do NOT clear selections when there's no cursor.
        // Text selections from mouse clicks should persist independently of cursor state.
        // Only explicit user actions (clicking elsewhere, Escape, etc.) should clear selections.
    }

    /// Edit the text content of a node (used for text input actions)
    ///
    /// This function applies text edits to nodes that contain text content.
    /// The DOM node itself is NOT modified - instead, the text cache is updated
    /// with the new shaped text that reflects the edit, cursor, and selection.
    ///
    /// It handles:
    /// - ReplaceSelectedText: Replaces the current selection with new text
    /// - SetValue: Sets the entire text value
    /// - SetNumericValue: Converts number to string and sets value
    ///
    /// # Returns
    ///
    /// Returns a Vec of DomNodeIds (node + parent) that need to be marked dirty
    /// for re-layout. The caller MUST use this return value to trigger layout.
    #[must_use = "Returned nodes must be marked dirty for re-layout"]
    #[cfg(feature = "a11y")]
    pub fn edit_text_node(
        &mut self,
        dom_id: DomId,
        node_id: NodeId,
        edit_type: TextEditType,
    ) -> Vec<azul_core::dom::DomNodeId> {
        use crate::managers::text_input::TextInputSource;

        // Convert TextEditType to string
        let text_input = match &edit_type {
            TextEditType::ReplaceSelection(text) => text.clone(),
            TextEditType::SetValue(text) => text.clone(),
            TextEditType::SetNumericValue(value) => value.to_string(),
        };

        // Get the OLD text before any changes
        let old_inline_content = self.get_text_before_textinput(dom_id, node_id);
        let old_text = self.extract_text_from_inline_content(&old_inline_content);

        // Create DomNodeId
        let hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(node_id));
        let dom_node_id = azul_core::dom::DomNodeId {
            dom: dom_id,
            node: hierarchy_id,
        };

        // Record the changeset in TextInputManager
        self.text_input_manager.record_input(
            dom_node_id,
            text_input,
            old_text,
            TextInputSource::Accessibility, // A11y source
        );

        // Immediately apply the changeset (A11y doesn't go through callbacks)
        self.apply_text_changeset()
    }

    #[cfg(not(feature = "a11y"))]
    pub fn process_accessibility_action(
        &mut self,
        _dom_id: DomId,
        _node_id: NodeId,
        _action: azul_core::dom::AccessibilityAction,
        _now: std::time::Instant,
    ) -> BTreeMap<DomNodeId, (Vec<azul_core::events::EventFilter>, bool)> {
        // No-op when accessibility is disabled
        BTreeMap::new()
    }

    /// Process mouse click for text selection.
    ///
    /// This method handles:
    /// - Single click: Place cursor at click position
    /// - Double click: Select word at click position
    /// - Triple click: Select paragraph (line) at click position
    ///
    /// ## Workflow
    /// 1. Use HoverManager's hit test to find hit nodes
    /// 2. Find the IFC layout via `inline_layout_result` (IFC root) or `ifc_membership` (text node)
    /// 3. Use point_relative_to_item for local cursor position
    /// 4. Hit-test the text layout to get logical cursor
    /// 5. Apply appropriate selection based on click count
    /// 6. Update SelectionManager with new selection
    ///
    /// ## IFC Architecture
    /// Text nodes don't store `inline_layout_result` directly. Instead:
    /// - IFC root nodes (e.g., `<p>`) have `inline_layout_result` with the complete text layout
    /// - Text nodes have `ifc_membership` pointing back to their IFC root
    /// - This allows efficient lookup without iterating all nodes
    ///
    /// ## Parameters
    /// * `position` - Click position in logical coordinates (for click count tracking)
    /// * `time_ms` - Current time in milliseconds (for multi-click detection)
    ///
    /// ## Returns
    /// * `Option<Vec<DomNodeId>>` - Affected nodes that need re-rendering, None if click didn't hit text
    pub fn process_mouse_click_for_selection(
        &mut self,
        position: azul_core::geom::LogicalPosition,
        time_ms: u64,
    ) -> Option<Vec<azul_core::dom::DomNodeId>> {
        use crate::managers::hover::InputPointId;
        use crate::text3::selection::{select_paragraph_at_cursor, select_word_at_cursor};

        #[cfg(feature = "std")]
        eprintln!("[DEBUG] process_mouse_click_for_selection: position=({:.1},{:.1}), time_ms={}", 
            position.x, position.y, time_ms);

        // found_selection stores: (dom_id, ifc_root_node_id, selection_range, local_pos)
        // IMPORTANT: We always store the IFC root NodeId, not the text node NodeId,
        // because selections are rendered via inline_layout_result which lives on the IFC root.
        let mut found_selection: Option<(DomId, NodeId, SelectionRange, azul_core::geom::LogicalPosition)> = None;

        // Try to get hit test from HoverManager first (fast path, uses WebRender's point_relative_to_item)
        if let Some(hit_test) = self.hover_manager.get_current(&InputPointId::Mouse) {
            #[cfg(feature = "std")]
            eprintln!("[DEBUG] HoverManager has hit test with {} doms", hit_test.hovered_nodes.len());
            
            // Iterate through hit nodes from the HoverManager
            for (dom_id, hit) in &hit_test.hovered_nodes {
                let layout_result = match self.layout_results.get(dom_id) {
                    Some(lr) => lr,
                    None => continue,
                };
                // Use layout tree from layout_result, not layout_cache
                let tree = &layout_result.layout_tree;
                
                // Sort by DOM depth (deepest first) to prefer specific text nodes over containers.
                // We count the actual number of parents to determine DOM depth properly.
                // Secondary sort by NodeId for deterministic ordering within the same depth.
                let node_hierarchy = layout_result.styled_dom.node_hierarchy.as_container();
                let get_dom_depth = |node_id: &NodeId| -> usize {
                    let mut depth = 0;
                    let mut current = *node_id;
                    while let Some(parent) = node_hierarchy.get(current).and_then(|h| h.parent_id()) {
                        depth += 1;
                        current = parent;
                    }
                    depth
                };
                
                let mut sorted_hits: Vec<_> = hit.regular_hit_test_nodes.iter().collect();
                sorted_hits.sort_by(|(a_id, _), (b_id, _)| {
                    let depth_a = get_dom_depth(a_id);
                    let depth_b = get_dom_depth(b_id);
                    // Higher depth = deeper in DOM = should come first
                    // Then sort by NodeId for deterministic order within same depth
                    depth_b.cmp(&depth_a).then_with(|| a_id.index().cmp(&b_id.index()))
                });
                
                for (node_id, hit_item) in sorted_hits {
                    // Check if text is selectable
                    if !self.is_text_selectable(&layout_result.styled_dom, *node_id) {
                        continue;
                    }
                    
                    // Find the layout node for this DOM node
                    let layout_node_idx = tree.nodes.iter().position(|n| n.dom_node_id == Some(*node_id));
                    let layout_node_idx = match layout_node_idx {
                        Some(idx) => idx,
                        None => continue,
                    };
                    let layout_node = &tree.nodes[layout_node_idx];
                    
                    // Get the IFC layout and IFC root NodeId
                    // Selection must be stored on the IFC root, not on text nodes
                    let (cached_layout, ifc_root_node_id) = if let Some(ref cached) = layout_node.inline_layout_result {
                        // This node IS an IFC root - use its own NodeId
                        (cached, *node_id)
                    } else if let Some(ref membership) = layout_node.ifc_membership {
                        // This node participates in an IFC - get layout and NodeId from IFC root
                        match tree.nodes.get(membership.ifc_root_layout_index) {
                            Some(ifc_root) => match (ifc_root.inline_layout_result.as_ref(), ifc_root.dom_node_id) {
                                (Some(cached), Some(root_dom_id)) => (cached, root_dom_id),
                                _ => continue,
                            },
                            None => continue,
                        }
                    } else {
                        // No IFC involvement - not a text node
                        continue;
                    };
                    
                    let layout = &cached_layout.layout;
                    
                    // Use point_relative_to_item - this is the local position within the hit node
                    // provided by WebRender's hit test
                    let local_pos = hit_item.point_relative_to_item;
                    
                    // Hit-test the cursor in this text layout
                    if let Some(cursor) = layout.hittest_cursor(local_pos) {
                        // Store selection with IFC root NodeId, not the hit text node
                        found_selection = Some((*dom_id, ifc_root_node_id, SelectionRange {
                            start: cursor.clone(),
                            end: cursor,
                        }, local_pos));
                        break;
                    }
                }
                
                if found_selection.is_some() {
                    break;
                }
            }
        }

        // Fallback: If HoverManager has no hit test (e.g., debug server),
        // search through IFC roots using global position
        if found_selection.is_none() {
            #[cfg(feature = "std")]
            eprintln!("[DEBUG] Fallback path: layout_results count = {}", self.layout_results.len());
            
            for (dom_id, layout_result) in &self.layout_results {
                // Use the layout tree from layout_result, not layout_cache
                // layout_cache.tree is for the root DOM only; layout_result.layout_tree
                // is the correct tree for each DOM (including iframes)
                let tree = &layout_result.layout_tree;
                
                #[cfg(feature = "std")]
                {
                    let ifc_root_count = tree.nodes.iter()
                        .filter(|n| n.inline_layout_result.is_some())
                        .count();
                    eprintln!("[DEBUG] DOM {:?}: tree has {} nodes, {} IFC roots", 
                        dom_id, tree.nodes.len(), ifc_root_count);
                }
                
                // Only iterate IFC roots (nodes with inline_layout_result)
                for (node_idx, layout_node) in tree.nodes.iter().enumerate() {
                    let cached_layout = match layout_node.inline_layout_result.as_ref() {
                        Some(c) => c,
                        None => continue, // Skip non-IFC-root nodes
                    };
                    
                    let node_id = match layout_node.dom_node_id {
                        Some(n) => n,
                        None => continue,
                    };
                    
                    // Check if text is selectable
                    if !self.is_text_selectable(&layout_result.styled_dom, node_id) {
                        #[cfg(feature = "std")]
                        eprintln!("[DEBUG]   IFC root node_idx={} node_id={:?}: NOT selectable", node_idx, node_id);
                        continue;
                    }
                    
                    // Get the node's absolute position
                    // Use layout_result.calculated_positions for the correct DOM
                    let node_pos = layout_result.calculated_positions
                        .get(&node_idx)
                        .copied()
                        .unwrap_or_default();
                    
                    // Check if position is within node bounds
                    let node_size = layout_node.used_size.unwrap_or_else(|| {
                        let bounds = cached_layout.layout.bounds();
                        azul_core::geom::LogicalSize::new(bounds.width, bounds.height)
                    });
                    
                    #[cfg(feature = "std")]
                    eprintln!("[DEBUG]   IFC root node_idx={} node_id={:?}: pos=({:.1},{:.1}) size=({:.1},{:.1}), click=({:.1},{:.1})",
                        node_idx, node_id, node_pos.x, node_pos.y, node_size.width, node_size.height, position.x, position.y);
                    
                    if position.x < node_pos.x || position.x > node_pos.x + node_size.width ||
                       position.y < node_pos.y || position.y > node_pos.y + node_size.height {
                        #[cfg(feature = "std")]
                        eprintln!("[DEBUG]     -> OUT OF BOUNDS");
                        continue;
                    }
                    
                    // Convert global position to node-local coordinates
                    let local_pos = azul_core::geom::LogicalPosition {
                        x: position.x - node_pos.x,
                        y: position.y - node_pos.y,
                    };
                    
                    let layout = &cached_layout.layout;
                    
                    // Hit-test the cursor in this text layout
                    if let Some(cursor) = layout.hittest_cursor(local_pos) {
                        found_selection = Some((*dom_id, node_id, SelectionRange {
                            start: cursor.clone(),
                            end: cursor,
                        }, local_pos));
                        break;
                    }
                }
                
                if found_selection.is_some() {
                    break;
                }
            }
        }

        let (dom_id, ifc_root_node_id, initial_range, _local_pos) = found_selection?;

        // Create DomNodeId for click state tracking - use IFC root's NodeId
        // Selection state is keyed by IFC root because that's where inline_layout_result lives
        let node_hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(ifc_root_node_id));
        let dom_node_id = azul_core::dom::DomNodeId {
            dom: dom_id,
            node: node_hierarchy_id,
        };

        // Update click count to determine selection type
        let click_count = self
            .selection_manager
            .update_click_count(dom_node_id, position, time_ms);

        // Get the text layout again for word/paragraph selection
        let final_range = if click_count > 1 {
            // Use layout_results for the correct DOM's tree
            let layout_result = self.layout_results.get(&dom_id)?;
            let tree = &layout_result.layout_tree;
            
            // Find layout node - ifc_root_node_id is always the IFC root, so it has inline_layout_result
            let layout_node = tree.nodes.iter().find(|n| n.dom_node_id == Some(ifc_root_node_id))?;
            let cached_layout = layout_node.inline_layout_result.as_ref()?;
            let layout = &cached_layout.layout;
            
            match click_count {
                2 => select_word_at_cursor(&initial_range.start, layout.as_ref())
                    .unwrap_or(initial_range),
                3 => select_paragraph_at_cursor(&initial_range.start, layout.as_ref())
                    .unwrap_or(initial_range),
                _ => initial_range,
            }
        } else {
            initial_range
        };

        // Clear existing selections and set new one using the NEW anchor/focus model
        // First, get the cursor bounds for the anchor
        let char_bounds = {
            let layout_result = self.layout_results.get(&dom_id)?;
            let tree = &layout_result.layout_tree;
            let layout_node = tree.nodes.iter().find(|n| n.dom_node_id == Some(ifc_root_node_id))?;
            let cached_layout = layout_node.inline_layout_result.as_ref()?;
            cached_layout.layout.get_cursor_rect(&final_range.start)
                .unwrap_or(azul_core::geom::LogicalRect {
                    origin: position,
                    size: azul_core::geom::LogicalSize { width: 1.0, height: 16.0 },
                })
        };
        
        // Clear any existing text selection for this DOM
        self.selection_manager.clear_text_selection(&dom_id);
        
        // Start a new selection with the anchor at the clicked position
        self.selection_manager.start_selection(
            dom_id,
            ifc_root_node_id,
            final_range.start,
            char_bounds,
            position,
        );
        
        // Also update the legacy selection state for backward compatibility with rendering
        self.selection_manager.clear_selection(&dom_id);

        let state = SelectionState {
            selections: vec![Selection::Range(final_range)].into(),
            node_id: dom_node_id,
        };
        
        #[cfg(feature = "std")]
        eprintln!("[DEBUG] Setting selection on dom_id={:?}, node_id={:?}", dom_id, ifc_root_node_id);
        
        self.selection_manager.set_selection(dom_id, state);

        // CRITICAL FIX 1: Set focus on the clicked node
        // Without this, clicking on a contenteditable element shows a cursor but
        // text input doesn't work because record_text_input() checks focus_manager.get_focused_node()
        // and returns early if there's no focus.
        //
        // Check if the node OR ANY ANCESTOR is contenteditable before setting focus
        // The contenteditable attribute is typically on a parent div, not on the IFC root or text node
        let is_contenteditable = self.layout_results.get(&dom_id)
            .map(|lr| {
                let node_hierarchy = lr.styled_dom.node_hierarchy.as_container();
                let node_data = lr.styled_dom.node_data.as_ref();
                
                // Walk up the DOM tree to check if any ancestor has contenteditable
                let mut current_node = Some(ifc_root_node_id);
                while let Some(node_id) = current_node {
                    if let Some(styled_node) = node_data.get(node_id.index()) {
                        let has_contenteditable = styled_node.attributes.as_ref().iter().any(|attr| {
                            matches!(attr, azul_core::dom::AttributeType::ContentEditable(_))
                        });
                        if has_contenteditable {
                            #[cfg(feature = "std")]
                            eprintln!("[DEBUG] Found contenteditable on node {:?}", node_id);
                            return true;
                        }
                    }
                    // Move to parent
                    current_node = node_hierarchy.get(node_id).and_then(|h| h.parent_id());
                }
                false
            })
            .unwrap_or(false);
        
        // W3C conformance: contenteditable elements are implicitly focusable
        if is_contenteditable {
            self.focus_manager.set_focused_node(Some(dom_node_id));
            #[cfg(feature = "std")]
            eprintln!("[DEBUG] Set focus on contenteditable node {:?}", ifc_root_node_id);
        }

        // CRITICAL FIX 2: Initialize the CursorManager with the clicked position
        // Without this, clicking on a contenteditable element sets focus (blue outline)
        // but the text cursor doesn't appear because CursorManager is never told where to draw it.
        let now = azul_core::task::Instant::now();
        self.cursor_manager.move_cursor_to(
            final_range.start.clone(),
            dom_id,
            ifc_root_node_id,
        );
        // Reset the blink timer so the cursor is immediately visible
        self.cursor_manager.reset_blink_on_input(now);
        self.cursor_manager.set_blink_timer_active(true);
        
        #[cfg(feature = "std")]
        eprintln!("[DEBUG] Initialized cursor at {:?} for node {:?}", final_range.start, ifc_root_node_id);

        // Return the affected node for dirty tracking
        Some(vec![dom_node_id])
    }

    /// Process mouse drag for text selection extension.
    ///
    /// This method handles drag-to-select by extending the selection from
    /// the anchor (mousedown position) to the current focus (drag position).
    ///
    /// Uses the anchor/focus model:
    /// - Anchor is fixed at the initial click position (set by process_mouse_click_for_selection)
    /// - Focus moves with the mouse during drag
    /// - Affected nodes between anchor and focus are computed in DOM order
    ///
    /// ## Parameters
    /// * `start_position` - Initial click position in logical coordinates (unused, anchor is stored)
    /// * `current_position` - Current mouse position in logical coordinates
    ///
    /// ## Returns
    /// * `Option<Vec<DomNodeId>>` - Affected nodes that need re-rendering
    pub fn process_mouse_drag_for_selection(
        &mut self,
        _start_position: azul_core::geom::LogicalPosition,
        current_position: azul_core::geom::LogicalPosition,
    ) -> Option<Vec<azul_core::dom::DomNodeId>> {
        use crate::managers::hover::InputPointId;

        #[cfg(feature = "std")]
        eprintln!("[DEBUG] process_mouse_drag_for_selection: current=({:.1},{:.1})",
            current_position.x, current_position.y);

        // Find which DOM has an active text selection with an anchor
        let dom_id = self.selection_manager.get_all_text_selections()
            .keys()
            .next()
            .copied()?;
        
        // Get the existing anchor from the text selection
        let anchor = {
            let text_selection = self.selection_manager.get_text_selection(&dom_id)?;
            text_selection.anchor.clone()
        };
        
        #[cfg(feature = "std")]
        eprintln!("[DEBUG] Found anchor at IFC root {:?}, cursor {:?}", 
            anchor.ifc_root_node_id, anchor.cursor.cluster_id);

        // Get the current hit test from HoverManager
        let hit_test = self.hover_manager.get_current(&InputPointId::Mouse)?;

        // Find the focus position (current cursor under mouse)
        let mut focus_info: Option<(NodeId, TextCursor, azul_core::geom::LogicalPosition)> = None;
        
        for (hit_dom_id, hit) in &hit_test.hovered_nodes {
            if *hit_dom_id != dom_id {
                continue;
            }
            
            let layout_result = match self.layout_results.get(hit_dom_id) {
                Some(lr) => lr,
                None => continue,
            };
            let tree = &layout_result.layout_tree;
            
            for (node_id, hit_item) in &hit.regular_hit_test_nodes {
                if !self.is_text_selectable(&layout_result.styled_dom, *node_id) {
                    continue;
                }

                let layout_node_idx = tree.nodes.iter().position(|n| n.dom_node_id == Some(*node_id));
                let layout_node_idx = match layout_node_idx {
                    Some(idx) => idx,
                    None => continue,
                };
                let layout_node = &tree.nodes[layout_node_idx];
                
                // Get the IFC layout and IFC root NodeId
                let (cached_layout, ifc_root_node_id) = if let Some(ref cached) = layout_node.inline_layout_result {
                    (cached, *node_id)
                } else if let Some(ref membership) = layout_node.ifc_membership {
                    match tree.nodes.get(membership.ifc_root_layout_index) {
                        Some(ifc_root) => match (ifc_root.inline_layout_result.as_ref(), ifc_root.dom_node_id) {
                            (Some(cached), Some(root_dom_id)) => (cached, root_dom_id),
                            _ => continue,
                        },
                        None => continue,
                    }
                } else {
                    continue;
                };
                
                let local_pos = hit_item.point_relative_to_item;
                
                if let Some(cursor) = cached_layout.layout.hittest_cursor(local_pos) {
                    focus_info = Some((ifc_root_node_id, cursor, current_position));
                    break;
                }
            }
            
            if focus_info.is_some() {
                break;
            }
        }
        
        let (focus_ifc_root, focus_cursor, focus_mouse_pos) = focus_info?;
        
        #[cfg(feature = "std")]
        eprintln!("[DEBUG] Found focus at IFC root {:?}, cursor {:?}", 
            focus_ifc_root, focus_cursor.cluster_id);

        // Compute affected nodes between anchor and focus
        let layout_result = self.layout_results.get(&dom_id)?;
        let hierarchy = &layout_result.styled_dom.node_hierarchy;
        
        // Determine document order
        let is_forward = if anchor.ifc_root_node_id == focus_ifc_root {
            // Same IFC - compare cursors
            anchor.cursor <= focus_cursor
        } else {
            // Different IFCs - use document order
            is_before_in_document_order(hierarchy, anchor.ifc_root_node_id, focus_ifc_root)
        };
        
        let (start_node, end_node) = if is_forward {
            (anchor.ifc_root_node_id, focus_ifc_root)
        } else {
            (focus_ifc_root, anchor.ifc_root_node_id)
        };
        
        // Collect all IFC roots between start and end
        let nodes_in_range = collect_nodes_in_document_order(hierarchy, start_node, end_node);
        
        #[cfg(feature = "std")]
        eprintln!("[DEBUG] Nodes in range: {:?}, is_forward: {}", 
            nodes_in_range.iter().map(|n| n.index()).collect::<Vec<_>>(), is_forward);
        
        // Build the affected_nodes map with SelectionRanges for each IFC root
        let mut affected_nodes_map = std::collections::BTreeMap::new();
        let tree = &layout_result.layout_tree;
        
        for node_id in &nodes_in_range {
            // Check if this node is an IFC root (has inline_layout_result)
            let layout_node = tree.nodes.iter().find(|n| n.dom_node_id == Some(*node_id));
            let layout_node = match layout_node {
                Some(ln) if ln.inline_layout_result.is_some() => ln,
                _ => continue, // Skip non-IFC-root nodes
            };
            
            let cached_layout = layout_node.inline_layout_result.as_ref()?;
            let layout = &cached_layout.layout;
            
            let range = if *node_id == anchor.ifc_root_node_id && *node_id == focus_ifc_root {
                // Both anchor and focus in same IFC
                SelectionRange {
                    start: if is_forward { anchor.cursor } else { focus_cursor },
                    end: if is_forward { focus_cursor } else { anchor.cursor },
                }
            } else if *node_id == anchor.ifc_root_node_id {
                // Anchor node - select from anchor to end (if forward) or start to anchor (if backward)
                if is_forward {
                    let end_cursor = layout.get_last_cluster_cursor()
                        .unwrap_or(anchor.cursor);
                    SelectionRange { start: anchor.cursor, end: end_cursor }
                } else {
                    let start_cursor = layout.get_first_cluster_cursor()
                        .unwrap_or(anchor.cursor);
                    SelectionRange { start: start_cursor, end: anchor.cursor }
                }
            } else if *node_id == focus_ifc_root {
                // Focus node - select from start to focus (if forward) or focus to end (if backward)
                if is_forward {
                    let start_cursor = layout.get_first_cluster_cursor()
                        .unwrap_or(focus_cursor);
                    SelectionRange { start: start_cursor, end: focus_cursor }
                } else {
                    let end_cursor = layout.get_last_cluster_cursor()
                        .unwrap_or(focus_cursor);
                    SelectionRange { start: focus_cursor, end: end_cursor }
                }
            } else {
                // Middle node - fully selected
                let start_cursor = layout.get_first_cluster_cursor()?;
                let end_cursor = layout.get_last_cluster_cursor()?;
                SelectionRange { start: start_cursor, end: end_cursor }
            };
            
            affected_nodes_map.insert(*node_id, range);
        }
        
        #[cfg(feature = "std")]
        eprintln!("[DEBUG] Affected IFC roots: {:?}", 
            affected_nodes_map.keys().map(|n| n.index()).collect::<Vec<_>>());
        
        // Update the text selection with new focus and affected nodes
        // This does NOT clear the anchor!
        self.selection_manager.update_selection_focus(
            &dom_id,
            focus_ifc_root,
            focus_cursor,
            focus_mouse_pos,
            affected_nodes_map.clone(),
            is_forward,
        );
        
        // Also update the legacy selection state for backward compatibility with rendering
        // For now, we just update the anchor's IFC root with the visible range
        if let Some(anchor_range) = affected_nodes_map.get(&anchor.ifc_root_node_id) {
            let node_hierarchy_id = NodeHierarchyItemId::from_crate_internal(Some(anchor.ifc_root_node_id));
            let dom_node_id = azul_core::dom::DomNodeId {
                dom: dom_id,
                node: node_hierarchy_id,
            };
            
            let state = SelectionState {
                selections: vec![Selection::Range(*anchor_range)].into(),
                node_id: dom_node_id,
            };
            self.selection_manager.set_selection(dom_id, state);
        }

        // Return affected nodes for dirty tracking
        let affected_dom_nodes: Vec<azul_core::dom::DomNodeId> = affected_nodes_map.keys()
            .map(|node_id| azul_core::dom::DomNodeId {
                dom: dom_id,
                node: NodeHierarchyItemId::from_crate_internal(Some(*node_id)),
            })
            .collect();
        
        if affected_dom_nodes.is_empty() {
            None
        } else {
            Some(affected_dom_nodes)
        }
    }

    /// Delete the currently selected text
    ///
    /// Handles Backspace/Delete key when a selection exists. The selection is deleted
    /// and replaced with a single cursor at the deletion point.
    ///
    /// ## Arguments
    /// * `target` - The target node (focused contenteditable element)
    /// * `forward` - true for Delete key (forward), false for Backspace (backward)
    ///
    /// ## Returns
    /// * `Some(Vec<DomNodeId>)` - Affected nodes if selection was deleted
    /// * `None` - If no selection exists or deletion failed
    pub fn delete_selection(
        &mut self,
        target: azul_core::dom::DomNodeId,
        forward: bool,
    ) -> Option<Vec<azul_core::dom::DomNodeId>> {
        let dom_id = target.dom;

        // Get current selection ranges
        let ranges = self.selection_manager.get_ranges(&dom_id);
        if ranges.is_empty() {
            return None; // No selection to delete
        }

        // For each selection range, delete the selected text
        // Note: For now, we just clear the selection and place cursor at start
        // Full implementation would need to modify the underlying text content
        // via the changeset system

        // Find the earliest cursor position from all ranges
        let mut earliest_cursor = None;
        for range in &ranges {
            // Use the start position for backward deletion, end for forward
            let cursor = if forward { range.end } else { range.start };

            if earliest_cursor.is_none() {
                earliest_cursor = Some(cursor);
            } else if let Some(current) = earliest_cursor {
                // Compare cursor positions using cluster_id ordering
                // Earlier cluster_id means earlier position in text
                if cursor < current {
                    earliest_cursor = Some(cursor);
                }
            }
        }

        // Clear selection and place cursor at deletion point
        self.selection_manager.clear_selection(&dom_id);

        if let Some(cursor) = earliest_cursor {
            // Set cursor at deletion point
            let state = SelectionState {
                selections: vec![Selection::Range(SelectionRange {
                    start: cursor.clone(),
                    end: cursor,
                })]
                .into(),
                node_id: target,
            };
            self.selection_manager.set_selection(dom_id, state);
        }

        // Return affected nodes for dirty tracking
        Some(vec![target])
    }

    /// Extract clipboard content from the current selection
    ///
    /// This method extracts both plain text and styled text from the selection ranges.
    /// It iterates through all selected text, extracts the actual characters, and
    /// preserves styling information from the ShapedGlyph's StyleProperties.
    ///
    /// This is NOT reading from the system clipboard - use `clipboard_manager.get_paste_content()`
    /// for that. This extracts content FROM the selection TO be copied.
    ///
    /// ## Arguments
    /// * `dom_id` - The DOM to extract selection from
    ///
    /// ## Returns
    /// * `Some(ClipboardContent)` - If there is a selection with text
    /// * `None` - If no selection or no text layouts found
    pub fn get_selected_content_for_clipboard(
        &self,
        dom_id: &DomId,
    ) -> Option<crate::managers::selection::ClipboardContent> {
        use crate::{
            managers::selection::{ClipboardContent, StyledTextRun},
            text3::cache::ShapedItem,
        };

        // Get selection ranges for this DOM
        let ranges = self.selection_manager.get_ranges(dom_id);
        if ranges.is_empty() {
            return None;
        }

        let mut plain_text = String::new();
        let mut styled_runs = Vec::new();

        // Iterate through all text layouts to find selected content
        for cache_id in self.text_cache.get_all_layout_ids() {
            let layout = self.text_cache.get_layout(&cache_id)?;

            // Process each selection range
            for range in &ranges {
                // Iterate through positioned items in the layout
                for positioned_item in &layout.items {
                    match &positioned_item.item {
                        ShapedItem::Cluster(cluster) => {
                            // Check if this cluster is within the selection range
                            let cluster_id = cluster.source_cluster_id;

                            // Simple check: is this cluster between start and end?
                            let in_range = if range.start.cluster_id <= range.end.cluster_id {
                                cluster_id >= range.start.cluster_id
                                    && cluster_id <= range.end.cluster_id
                            } else {
                                cluster_id >= range.end.cluster_id
                                    && cluster_id <= range.start.cluster_id
                            };

                            if in_range {
                                // Extract text from cluster
                                plain_text.push_str(&cluster.text);

                                // Extract styling from first glyph (they share styling)
                                if let Some(first_glyph) = cluster.glyphs.first() {
                                    let style = &first_glyph.style;

                                    // Extract font family from font stack
                                    let default_font = FontSelector::default();
                                    let first_font = style.font_stack.first_selector()
                                        .unwrap_or(&default_font);
                                    let font_family: OptionString =
                                        Some(AzString::from(first_font.family.as_str())).into();

                                    // Check if bold/italic from font selector
                                    use rust_fontconfig::FcWeight;
                                    let is_bold = matches!(
                                        first_font.weight,
                                        FcWeight::Bold | FcWeight::ExtraBold | FcWeight::Black
                                    );
                                    let is_italic = matches!(
                                        first_font.style,
                                        FontStyle::Italic | FontStyle::Oblique
                                    );

                                    styled_runs.push(StyledTextRun {
                                        text: cluster.text.clone().into(),
                                        font_family,
                                        font_size_px: style.font_size_px,
                                        color: style.color,
                                        is_bold,
                                        is_italic,
                                    });
                                }
                            }
                        }
                        // For now, skip non-cluster items (objects, breaks, etc.)
                        _ => {}
                    }
                }
            }
        }

        if plain_text.is_empty() {
            None
        } else {
            Some(ClipboardContent {
                plain_text: plain_text.into(),
                styled_runs: styled_runs.into(),
            })
        }
    }

    /// Process image callback updates from CallbackChangeResult
    ///
    /// This function re-invokes image callbacks for nodes that requested updates
    /// (typically from timer callbacks or resize events). It returns the updated
    /// textures along with their metadata for the rendering pipeline to process.
    ///
    /// # Arguments
    ///
    /// * `image_callbacks_changed` - Map of DomId -> Set of NodeIds that need re-rendering
    /// * `gl_context` - OpenGL context pointer for rendering
    ///
    /// # Returns
    ///
    /// Vector of (DomId, NodeId, Texture) tuples for textures that were updated
    pub fn process_image_callback_updates(
        &mut self,
        image_callbacks_changed: &BTreeMap<DomId, FastBTreeSet<NodeId>>,
        gl_context: &OptionGlContextPtr,
    ) -> Vec<(DomId, NodeId, azul_core::gl::Texture)> {
        use crate::callbacks::{RenderImageCallback, RenderImageCallbackInfo};

        let mut updated_textures = Vec::new();

        for (dom_id, node_ids) in image_callbacks_changed {
            let layout_result = match self.layout_results.get_mut(dom_id) {
                Some(lr) => lr,
                None => continue,
            };

            for node_id in node_ids {
                // Get the node data - store container ref to extend lifetime
                let node_data_container = layout_result.styled_dom.node_data.as_container();
                let node_data = match node_data_container.get(*node_id) {
                    Some(nd) => nd,
                    None => continue,
                };

                // Check if this is an Image node with a callback
                let has_callback = matches!(node_data.get_node_type(), NodeType::Image(img_ref)
                    if img_ref.get_image_callback().is_some());

                if !has_callback {
                    continue;
                }

                // Get layout indices for this DOM node (can have multiple due to text splitting,
                // etc.)
                let layout_indices = match layout_result.layout_tree.dom_to_layout.get(node_id) {
                    Some(indices) if !indices.is_empty() => indices,
                    _ => continue,
                };

                // Use the first layout index (primary node)
                let layout_index = layout_indices[0];

                // Get the position from calculated_positions
                let position = match layout_result.calculated_positions.get(&layout_index) {
                    Some(pos) => *pos,
                    None => continue,
                };

                // Get the layout node to determine size
                let layout_node = match layout_result.layout_tree.get(layout_index) {
                    Some(ln) => ln,
                    None => continue,
                };

                // Get the size from the layout node (used_size is the computed size from layout)
                let (width, height) = match layout_node.used_size {
                    Some(size) => (size.width, size.height),
                    None => continue, // Node hasn't been laid out yet
                };

                let callback_domnode_id = DomNodeId {
                    dom: *dom_id,
                    node: azul_core::styled_dom::NodeHierarchyItemId::from_crate_internal(Some(
                        *node_id,
                    )),
                };

                let bounds = HidpiAdjustedBounds::from_bounds(
                    azul_css::props::basic::LayoutSize {
                        width: width as isize,
                        height: height as isize,
                    },
                    self.current_window_state.size.get_hidpi_factor(),
                );

                // Create callback info
                let mut gl_callback_info = RenderImageCallbackInfo::new(
                    callback_domnode_id,
                    bounds,
                    gl_context,
                    &self.image_cache,
                    &self.font_manager.fc_cache,
                );

                // Invoke the callback
                let new_image_ref = {
                    let mut node_data_mut = layout_result.styled_dom.node_data.as_container_mut();
                    match node_data_mut.get_mut(*node_id) {
                        Some(nd) => {
                            match &mut nd.node_type {
                                NodeType::Image(img_ref) => {
                                    img_ref.get_image_callback_mut().map(|core_callback| {
                                        // Convert from CoreImageCallback (cb: usize) to
                                        // RenderImageCallback (cb: fn pointer)
                                        let callback =
                                            RenderImageCallback::from_core(&core_callback.callback);
                                        (callback.cb)(
                                            core_callback.refany.clone(),
                                            gl_callback_info,
                                        )
                                    })
                                }
                                _ => None,
                            }
                        }
                        None => None,
                    }
                };

                // Reset GL state after callback
                #[cfg(feature = "gl_context_loader")]
                if let Some(gl) = gl_context.as_ref() {
                    use gl_context_loader::gl;
                    gl.bind_framebuffer(gl::FRAMEBUFFER, 0);
                    gl.disable(gl::FRAMEBUFFER_SRGB);
                    gl.disable(gl::MULTISAMPLE);
                }

                // Extract the texture from the returned ImageRef
                if let Some(image_ref) = new_image_ref {
                    if let Some(decoded_image) = image_ref.into_inner() {
                        if let azul_core::resources::DecodedImage::Gl(texture) = decoded_image {
                            updated_textures.push((*dom_id, *node_id, texture));
                        }
                    }
                }
            }
        }

        updated_textures
    }

    /// Process IFrame updates requested by callbacks
    ///
    /// This method handles manual IFrame re-rendering triggered by `trigger_iframe_rerender()`.
    /// It invokes the IFrame callback with `DomRecreated` reason and performs layout on the
    /// returned DOM, then submits a new display list to WebRender for that pipeline.
    ///
    /// # Arguments
    ///
    /// * `iframes_to_update` - Map of DomId -> Set of NodeIds that need re-rendering
    /// * `window_state` - Current window state
    /// * `renderer_resources` - Renderer resources
    /// * `system_callbacks` - External system callbacks
    ///
    /// # Returns
    ///
    /// Vector of (DomId, NodeId) tuples for IFrames that were successfully updated
    pub fn process_iframe_updates(
        &mut self,
        iframes_to_update: &BTreeMap<DomId, FastBTreeSet<NodeId>>,
        window_state: &FullWindowState,
        renderer_resources: &RendererResources,
        system_callbacks: &ExternalSystemCallbacks,
    ) -> Vec<(DomId, NodeId)> {
        let mut updated_iframes = Vec::new();

        for (dom_id, node_ids) in iframes_to_update {
            for node_id in node_ids {
                // Extract iframe bounds from layout result
                let bounds = match Self::get_iframe_bounds_from_layout(
                    &self.layout_results,
                    *dom_id,
                    *node_id,
                ) {
                    Some(b) => b,
                    None => continue,
                };

                // Force re-invocation by clearing the "was_invoked" flag
                self.iframe_manager.force_reinvoke(*dom_id, *node_id);

                // Invoke the IFrame callback
                if let Some(_child_dom_id) = self.invoke_iframe_callback(
                    *dom_id,
                    *node_id,
                    bounds,
                    window_state,
                    renderer_resources,
                    system_callbacks,
                    &mut None,
                ) {
                    updated_iframes.push((*dom_id, *node_id));
                }
            }
        }

        updated_iframes
    }

    /// Queue IFrame updates to be processed in the next frame
    ///
    /// This is called after callbacks to store the iframes_to_update from CallbackChangeResult
    pub fn queue_iframe_updates(
        &mut self,
        iframes_to_update: BTreeMap<DomId, FastBTreeSet<NodeId>>,
    ) {
        for (dom_id, node_ids) in iframes_to_update {
            self.pending_iframe_updates
                .entry(dom_id)
                .or_insert_with(FastBTreeSet::new)
                .extend(node_ids);
        }
    }

    /// Process and clear pending IFrame updates
    ///
    /// This is called during frame generation to re-render updated IFrames
    pub fn process_pending_iframe_updates(
        &mut self,
        window_state: &FullWindowState,
        renderer_resources: &RendererResources,
        system_callbacks: &ExternalSystemCallbacks,
    ) -> Vec<(DomId, NodeId)> {
        if self.pending_iframe_updates.is_empty() {
            return Vec::new();
        }

        // Take ownership of pending updates
        let iframes_to_update = core::mem::take(&mut self.pending_iframe_updates);

        // Process them
        self.process_iframe_updates(
            &iframes_to_update,
            window_state,
            renderer_resources,
            system_callbacks,
        )
    }

    /// Helper: Extract IFrame bounds from layout results
    ///
    /// Returns None if the node is not an IFrame or doesn't have layout info
    fn get_iframe_bounds_from_layout(
        layout_results: &BTreeMap<DomId, DomLayoutResult>,
        dom_id: DomId,
        node_id: NodeId,
    ) -> Option<LogicalRect> {
        let layout_result = layout_results.get(&dom_id)?;

        // Check if this is an IFrame node
        let node_data_container = layout_result.styled_dom.node_data.as_container();
        let node_data = node_data_container.get(node_id)?;

        if !matches!(node_data.get_node_type(), NodeType::IFrame(_)) {
            return None;
        }

        // Get layout indices
        let layout_indices = layout_result.layout_tree.dom_to_layout.get(&node_id)?;
        if layout_indices.is_empty() {
            return None;
        }

        let layout_index = layout_indices[0];

        // Get position
        let position = *layout_result.calculated_positions.get(&layout_index)?;

        // Get size
        let layout_node = layout_result.layout_tree.get(layout_index)?;
        let size = layout_node.used_size?;

        Some(LogicalRect::new(
            position,
            LogicalSize::new(size.width as f32, size.height as f32),
        ))
    }
}

#[cfg(feature = "a11y")]
#[derive(Debug, Clone)]
pub enum TextEditType {
    ReplaceSelection(String),
    SetValue(String),
    SetNumericValue(f64),
}

```

### LAYOUT MANAGERS

================================================================================
## FILE: layout/src/lib.rs
## Description: Layout lib root
================================================================================
```
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/azul_logo_full_min.svg.png",
    html_favicon_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/favicon.ico"
)]
#![allow(warnings)]

// #![no_std]

#[macro_use]
extern crate alloc;
extern crate core;

pub mod font_traits;
#[cfg(feature = "image_decoding")]
pub mod image;
#[cfg(feature = "text_layout")]
pub mod managers;
#[cfg(feature = "text_layout")]
pub mod solver3;

// String formatting utilities
#[cfg(feature = "strfmt")]
pub mod fmt;
#[cfg(feature = "strfmt")]
pub use fmt::{FmtArg, FmtArgVec, FmtArgVecDestructor, FmtValue, fmt_string};

// Widget modules (behind feature flags)
#[cfg(feature = "widgets")]
pub mod widgets;

// Extra APIs (dialogs, file operations)
#[cfg(feature = "extra")]
pub mod desktop;
#[cfg(feature = "extra")]
pub mod extra;

// ICU4X internationalization support
#[cfg(feature = "icu")]
pub mod icu;
#[cfg(feature = "icu")]
pub use icu::{
    DateTimeFieldSet, FormatLength, IcuDate, IcuDateTime, IcuError,
    IcuLocalizer, IcuLocalizerHandle, IcuResult, IcuStringVec, IcuTime,
    LayoutCallbackInfoIcuExt, ListType, PluralCategory,
};

// Project Fluent localization support
#[cfg(feature = "fluent")]
pub mod fluent;
#[cfg(feature = "fluent")]
pub use fluent::{
    check_fluent_syntax, check_fluent_syntax_bytes, create_fluent_zip,
    create_fluent_zip_from_strings, export_to_zip, FluentError,
    FluentLanguageInfo, FluentLanguageInfoVec,
    FluentLocalizerHandle, FluentResult, FluentSyntaxCheckResult,
    FluentSyntaxError, FluentZipLoadResult, LayoutCallbackInfoFluentExt,
};

// URL parsing support
#[cfg(feature = "http")]
pub mod url;
#[cfg(feature = "http")]
pub use url::{Url, UrlParseError, ResultUrlUrlParseError};

// File system operations (C-compatible wrapper for std::fs)
pub mod file;
pub use file::{
    dir_create, dir_create_all, dir_list, dir_delete, dir_delete_all,
    file_copy, path_exists, file_metadata, file_read, file_delete, file_rename, file_write,
    path_is_dir, path_is_file, path_join, temp_dir,
    DirEntry, DirEntryVec, DirEntryVecDestructor, DirEntryVecDestructorType,
    FileError, FileErrorKind, FileMetadata, FilePath, OptionFilePath,
};

// HTTP client support
#[cfg(feature = "http")]
pub mod http;
#[cfg(feature = "http")]
pub use http::{
    download_bytes, download_bytes_with_config, http_get,
    http_get_with_config, is_url_reachable, HttpError, HttpHeader,
    HttpRequestConfig, HttpResponse, HttpResponseTooLargeError, HttpResult,
    HttpStatusError,
};

// JSON parsing support
#[cfg(feature = "json")]
pub mod json;
#[cfg(feature = "json")]
pub use json::{
    json_parse, json_parse_bytes, json_stringify, json_stringify_pretty,
    Json, JsonInternal, JsonKeyValue, JsonKeyValueVec, JsonKeyValueVecDestructor, JsonKeyValueVecDestructorType,
    JsonParseError, JsonType, JsonVec,
    ResultJsonJsonParseError, OptionJson, OptionJsonVec, OptionJsonKeyValueVec,
};

// ZIP file manipulation support
#[cfg(feature = "zip_support")]
pub mod zip;
#[cfg(feature = "zip_support")]
pub use zip::{
    zip_create, zip_create_from_files, zip_extract_all, zip_list_contents,
    ZipFile, ZipFileEntry, ZipFileEntryVec, ZipPathEntry, ZipPathEntryVec,
    ZipReadConfig, ZipWriteConfig, ZipReadError, ZipWriteError,
};

// Icon provider support (always available)
pub mod icon;
pub use icon::{
    // Resolver
    default_icon_resolver,
    // Data types for RefAny
    ImageIconData, FontIconData,
    // Helpers
    create_default_icon_provider,
    register_material_icons,
    register_embedded_material_icons,
};
// Re-export core icon types
pub use azul_core::icon::{
    IconProviderHandle, IconResolverCallbackType,
    resolve_icons_in_styled_dom, OptionIconProviderHandle,
};

#[cfg(feature = "text_layout")]
pub mod callbacks;
#[cfg(feature = "cpurender")]
pub mod cpurender;
#[cfg(feature = "text_layout")]
pub mod default_actions;
#[cfg(feature = "text_layout")]
pub mod event_determination;
#[cfg(feature = "text_layout")]
pub mod font;
// Re-export allsorts types needed by printpdf
#[cfg(feature = "text_layout")]
pub use allsorts::subset::CmapTarget;
#[cfg(feature = "text_layout")]
pub use font::parsed::{
    FontParseWarning, FontParseWarningSeverity, FontType, OwnedGlyph, ParsedFont, PdfFontMetrics,
    SubsetFont,
};
// Re-export hyphenation for external crates (like printpdf)
#[cfg(feature = "text_layout_hyphenation")]
pub use hyphenation;
pub mod fragmentation;
#[cfg(feature = "text_layout")]
pub mod hit_test;
pub mod paged;
#[cfg(feature = "text_layout")]
pub mod text3;
#[cfg(feature = "text_layout")]
pub mod thread;
#[cfg(feature = "text_layout")]
pub mod timer;
#[cfg(feature = "text_layout")]
pub mod window;
#[cfg(feature = "text_layout")]
pub mod window_state;
#[cfg(feature = "xml")]
pub mod xml;

// Export the main layout function and window management
pub use fragmentation::{
    BoxBreakBehavior, BreakDecision, FragmentationDefaults, FragmentationLayoutContext,
    KeepTogetherPriority, PageCounter, PageFragment, PageMargins, PageNumberStyle, PageSlot,
    PageSlotContent, PageSlotPosition, PageTemplate,
};
#[cfg(feature = "text_layout")]
pub use hit_test::{CursorTypeHitTest, FullHitTest};
pub use paged::FragmentationState;
#[cfg(feature = "text_layout")]
pub use solver3::cache::LayoutCache as Solver3LayoutCache;
#[cfg(feature = "text_layout")]
pub use solver3::display_list::DisplayList as DisplayList3;
#[cfg(feature = "text_layout")]
pub use solver3::layout_document;
#[cfg(feature = "text_layout")]
pub use solver3::paged_layout::layout_document_paged;
#[cfg(feature = "text_layout")]
pub use solver3::{LayoutContext, LayoutError, Result as LayoutResult3};
#[cfg(feature = "text_layout")]
pub use text3::cache::{FontManager, LayoutCache as TextLayoutCache};
#[cfg(feature = "text_layout")]
pub use window::{CursorBlinkTimerAction, LayoutWindow, ScrollbarDragState};
#[cfg(feature = "text_layout")]
pub use managers::text_input::{PendingTextEdit, OptionPendingTextEdit};

// #[cfg(feature = "text_layout")]
// pub use solver::{callback_info_shape_text, do_the_layout, do_the_relayout};
#[cfg(feature = "text_layout")]
pub fn parse_font_fn(
    source: azul_core::resources::LoadedFontSource,
) -> Option<azul_css::props::basic::FontRef> {
    use core::ffi::c_void;

    use crate::font::parsed::ParsedFont;

    fn parsed_font_destructor(ptr: *mut c_void) {
        unsafe {
            let _ = Box::from_raw(ptr as *mut ParsedFont);
        }
    }

    ParsedFont::from_bytes(
        source.data.as_ref(),
        source.index as usize,
        &mut Vec::new(), // Ignore warnings for now
    )
    .map(|parsed_font| parsed_font_to_font_ref(parsed_font))
}

#[cfg(feature = "text_layout")]
pub fn parsed_font_to_font_ref(
    parsed_font: crate::font::parsed::ParsedFont,
) -> azul_css::props::basic::FontRef {
    use core::ffi::c_void;

    extern "C" fn parsed_font_destructor(ptr: *mut c_void) {
        unsafe {
            let _ = Box::from_raw(ptr as *mut crate::font::parsed::ParsedFont);
        }
    }

    let boxed = Box::new(parsed_font);
    let raw_ptr = Box::into_raw(boxed) as *const c_void;
    azul_css::props::basic::FontRef::new(raw_ptr, parsed_font_destructor)
}

#[cfg(feature = "text_layout")]
pub fn font_ref_to_parsed_font(
    font_ref: &azul_css::props::basic::FontRef,
) -> &crate::font::parsed::ParsedFont {
    unsafe { &*(font_ref.parsed as *const crate::font::parsed::ParsedFont) }
}

```

### DOM STRUCTURES

================================================================================
## FILE: core/src/dom.rs
## Description: DOM structures
================================================================================
```
//! Defines the core Document Object Model (DOM) structures.
//!
//! This module is responsible for representing the UI as a tree of nodes,
//! similar to the HTML DOM. It includes definitions for node types, event handling,
//! accessibility, and the main `Dom` and `CompactDom` structures.

#[cfg(not(feature = "std"))]
use alloc::string::ToString;
use alloc::{boxed::Box, collections::btree_map::BTreeMap, string::String, vec::Vec};
use core::{
    fmt,
    hash::{Hash, Hasher},
    iter::FromIterator,
    mem,
    sync::atomic::{AtomicUsize, Ordering},
};

use azul_css::{
    css::{Css, NodeTypeTag},
    format_rust_code::GetHash,
    props::{
        basic::{FloatValue, FontRef},
        layout::{LayoutDisplay, LayoutFloat, LayoutPosition},
        property::CssProperty,
    },
    AzString, OptionString,
};

// Re-export event filters from events module (moved in Phase 3.5)
pub use crate::events::{
    ApplicationEventFilter, ComponentEventFilter, EventFilter, FocusEventFilter, HoverEventFilter,
    NotEventFilter, WindowEventFilter,
};
pub use crate::id::{Node, NodeHierarchy, NodeId};
use crate::{
    callbacks::{
        CoreCallback, CoreCallbackData, CoreCallbackDataVec, CoreCallbackType, IFrameCallback,
        IFrameCallbackType,
    },
    geom::LogicalPosition,
    id::{NodeDataContainer, NodeDataContainerRef, NodeDataContainerRefMut},
    menu::Menu,
    prop_cache::{CssPropertyCache, CssPropertyCachePtr},
    refany::{OptionRefAny, RefAny},
    resources::{
        image_ref_get_hash, CoreImageCallback, ImageMask, ImageRef, ImageRefHash, RendererResources,
    },
    styled_dom::{
        CompactDom, NodeHierarchyItemId, StyleFontFamilyHash, StyledDom, StyledNode,
        StyledNodeState,
    },
    window::OptionVirtualKeyCodeCombo,
};
pub use azul_css::dynamic_selector::{CssPropertyWithConditions, CssPropertyWithConditionsVec};

static TAG_ID: AtomicUsize = AtomicUsize::new(1);

/// Strongly-typed input element types for HTML `<input>` elements.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub enum InputType {
    /// Text input (default)
    Text,
    /// Button
    Button,
    /// Checkbox
    Checkbox,
    /// Color picker
    Color,
    /// Date picker
    Date,
    /// Date and time picker
    Datetime,
    /// Date and time picker (local)
    DatetimeLocal,
    /// Email address input
    Email,
    /// File upload
    File,
    /// Hidden input
    Hidden,
    /// Image button
    Image,
    /// Month picker
    Month,
    /// Number input
    Number,
    /// Password input
    Password,
    /// Radio button
    Radio,
    /// Range slider
    Range,
    /// Reset button
    Reset,
    /// Search input
    Search,
    /// Submit button
    Submit,
    /// Telephone number input
    Tel,
    /// Time picker
    Time,
    /// URL input
    Url,
    /// Week picker
    Week,
}

impl InputType {
    /// Returns the HTML attribute value for this input type
    pub const fn as_str(&self) -> &'static str {
        match self {
            InputType::Text => "text",
            InputType::Button => "button",
            InputType::Checkbox => "checkbox",
            InputType::Color => "color",
            InputType::Date => "date",
            InputType::Datetime => "datetime",
            InputType::DatetimeLocal => "datetime-local",
            InputType::Email => "email",
            InputType::File => "file",
            InputType::Hidden => "hidden",
            InputType::Image => "image",
            InputType::Month => "month",
            InputType::Number => "number",
            InputType::Password => "password",
            InputType::Radio => "radio",
            InputType::Range => "range",
            InputType::Reset => "reset",
            InputType::Search => "search",
            InputType::Submit => "submit",
            InputType::Tel => "tel",
            InputType::Time => "time",
            InputType::Url => "url",
            InputType::Week => "week",
        }
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(C)]
pub struct TagId {
    pub inner: u64,
}

impl ::core::fmt::Display for TagId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("TagId").field("inner", &self.inner).finish()
    }
}

impl_option!(
    TagId,
    OptionTagId,
    [Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash]
);

impl TagId {
    pub const fn into_crate_internal(&self) -> TagId {
        TagId { inner: self.inner }
    }
    pub const fn from_crate_internal(t: TagId) -> Self {
        TagId { inner: t.inner }
    }

    /// Creates a new, unique hit-testing tag ID.
    pub fn unique() -> Self {
        TagId {
            inner: TAG_ID.fetch_add(1, Ordering::SeqCst) as u64,
        }
    }

    /// Resets the counter (usually done after each frame) so that we can
    /// track hit-testing Tag IDs of subsequent frames.
    pub fn reset() {
        TAG_ID.swap(1, Ordering::SeqCst);
    }
}

/// Same as the `TagId`, but only for scrollable nodes.
/// This provides a typed distinction for tags associated with scrolling containers.
#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]
#[repr(C)]
pub struct ScrollTagId {
    pub inner: TagId,
}

impl ::core::fmt::Display for ScrollTagId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("ScrollTagId")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ::core::fmt::Debug for ScrollTagId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self)
    }
}

impl ScrollTagId {
    /// Creates a new, unique scroll tag ID. Note that this should not
    /// be used for identifying nodes, use the `DomNodeHash` instead.
    pub fn unique() -> ScrollTagId {
        ScrollTagId {
            inner: TagId::unique(),
        }
    }
}

/// Orientation of a scrollbar.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub enum ScrollbarOrientation {
    Horizontal,
    Vertical,
}

/// Calculated hash of a DOM node, used for identifying identical DOM
/// nodes across frames for efficient diffing and state preservation.
#[derive(Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub struct DomNodeHash {
    pub inner: u64,
}

impl ::core::fmt::Debug for DomNodeHash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "DomNodeHash({})", self.inner)
    }
}

/// List of core DOM node types built into `azul`.
/// This enum defines the building blocks of the UI, similar to HTML tags.
#[derive(Debug, Clone, PartialEq, Hash, Eq, PartialOrd, Ord)]
#[repr(C, u8)]
pub enum NodeType {
    // Root and container elements
    /// Root HTML element.
    Html,
    /// Document head (metadata container).
    Head,
    /// Root element of the document body.
    Body,
    /// Generic block-level container.
    Div,
    /// Paragraph.
    P,
    /// Article content.
    Article,
    /// Section of a document.
    Section,
    /// Navigation links.
    Nav,
    /// Sidebar/tangential content.
    Aside,
    /// Header section.
    Header,
    /// Footer section.
    Footer,
    /// Main content.
    Main,
    /// Figure with optional caption.
    Figure,
    /// Caption for figure element.
    FigCaption,
    /// Headings.
    H1,
    H2,
    H3,
    H4,
    H5,
    H6,
    /// Line break.
    Br,
    /// Horizontal rule.
    Hr,
    /// Preformatted text.
    Pre,
    /// Block quote.
    BlockQuote,
    /// Address.
    Address,
    /// Details disclosure widget.
    Details,
    /// Summary for details element.
    Summary,
    /// Dialog box or window.
    Dialog,

    // List elements
    /// Unordered list.
    Ul,
    /// Ordered list.
    Ol,
    /// List item.
    Li,
    /// Definition list.
    Dl,
    /// Definition term.
    Dt,
    /// Definition description.
    Dd,
    /// Menu list.
    Menu,
    /// Menu item.
    MenuItem,
    /// Directory list (deprecated).
    Dir,

    // Table elements
    /// Table container.
    Table,
    /// Table caption.
    Caption,
    /// Table header.
    THead,
    /// Table body.
    TBody,
    /// Table footer.
    TFoot,
    /// Table row.
    Tr,
    /// Table header cell.
    Th,
    /// Table data cell.
    Td,
    /// Table column group.
    ColGroup,
    /// Table column.
    Col,

    // Form elements
    /// Form container.
    Form,
    /// Form fieldset.
    FieldSet,
    /// Fieldset legend.
    Legend,
    /// Label for form controls.
    Label,
    /// Input control.
    Input,
    /// Button control.
    Button,
    /// Select dropdown.
    Select,
    /// Option group.
    OptGroup,
    /// Select option.
    SelectOption,
    /// Multiline text input.
    TextArea,
    /// Form output element.
    Output,
    /// Progress indicator.
    Progress,
    /// Scalar measurement within a known range.
    Meter,
    /// List of predefined options for input.
    DataList,

    // Inline elements
    /// Generic inline container.
    Span,
    /// Anchor/hyperlink.
    A,
    /// Emphasized text.
    Em,
    /// Strongly emphasized text.
    Strong,
    /// Bold text (deprecated - use `Dom::create_strong()` for semantic importance).
    B,
    /// Italic text (deprecated - use `Dom::create_em()` for emphasis or `Dom::create_cite()` for citations).
    I,
    /// Underline text.
    U,
    /// Strikethrough text.
    S,
    /// Marked/highlighted text.
    Mark,
    /// Deleted text.
    Del,
    /// Inserted text.
    Ins,
    /// Code.
    Code,
    /// Sample output.
    Samp,
    /// Keyboard input.
    Kbd,
    /// Variable.
    Var,
    /// Citation.
    Cite,
    /// Defining instance of a term.
    Dfn,
    /// Abbreviation.
    Abbr,
    /// Acronym.
    Acronym,
    /// Inline quotation.
    Q,
    /// Date/time.
    Time,
    /// Subscript.
    Sub,
    /// Superscript.
    Sup,
    /// Small text (deprecated - use CSS `font-size` instead).
    Small,
    /// Big text (deprecated - use CSS `font-size` instead).
    Big,
    /// Bi-directional override.
    Bdo,
    /// Bi-directional isolate.
    Bdi,
    /// Word break opportunity.
    Wbr,
    /// Ruby annotation.
    Ruby,
    /// Ruby text.
    Rt,
    /// Ruby text container.
    Rtc,
    /// Ruby parenthesis.
    Rp,
    /// Machine-readable data.
    Data,

    // Embedded content
    /// Canvas for graphics.
    Canvas,
    /// Embedded object.
    Object,
    /// Embedded object parameter.
    Param,
    /// External resource embed.
    Embed,
    /// Audio content.
    Audio,
    /// Video content.
    Video,
    /// Media source.
    Source,
    /// Text track for media.
    Track,
    /// Image map.
    Map,
    /// Image map area.
    Area,
    /// SVG graphics.
    Svg,

    // Metadata elements
    /// Document title.
    Title,
    /// Metadata.
    Meta,
    /// External resource link.
    Link,
    /// Embedded or referenced script.
    Script,
    /// Style information.
    Style,
    /// Base URL for relative URLs.
    Base,

    // Pseudo-elements (transformed into real elements)
    /// ::before pseudo-element.
    Before,
    /// ::after pseudo-element.
    After,
    /// ::marker pseudo-element.
    Marker,
    /// ::placeholder pseudo-element.
    Placeholder,

    // Special content types
    /// Text content, ::text
    Text(AzString),
    /// Image element, ::image
    Image(ImageRef),
    /// IFrame (embedded content)
    IFrame(IFrameNode),
    /// Icon element - resolved to actual content by IconProvider
    /// The string is the icon name (e.g., "home", "settings", "search")
    Icon(AzString),
}

impl NodeType {
    fn into_library_owned_nodetype(&self) -> Self {
        use self::NodeType::*;
        match self {
            Html => Html,
            Head => Head,
            Body => Body,
            Div => Div,
            P => P,
            Article => Article,
            Section => Section,
            Nav => Nav,
            Aside => Aside,
            Header => Header,
            Footer => Footer,
            Main => Main,
            Figure => Figure,
            FigCaption => FigCaption,
            H1 => H1,
            H2 => H2,
            H3 => H3,
            H4 => H4,
            H5 => H5,
            H6 => H6,
            Br => Br,
            Hr => Hr,
            Pre => Pre,
            BlockQuote => BlockQuote,
            Address => Address,
            Details => Details,
            Summary => Summary,
            Dialog => Dialog,
            Ul => Ul,
            Ol => Ol,
            Li => Li,
            Dl => Dl,
            Dt => Dt,
            Dd => Dd,
            Menu => Menu,
            MenuItem => MenuItem,
            Dir => Dir,
            Table => Table,
            Caption => Caption,
            THead => THead,
            TBody => TBody,
            TFoot => TFoot,
            Tr => Tr,
            Th => Th,
            Td => Td,
            ColGroup => ColGroup,
            Col => Col,
            Form => Form,
            FieldSet => FieldSet,
            Legend => Legend,
            Label => Label,
            Input => Input,
            Button => Button,
            Select => Select,
            OptGroup => OptGroup,
            SelectOption => SelectOption,
            TextArea => TextArea,
            Output => Output,
            Progress => Progress,
            Meter => Meter,
            DataList => DataList,
            Span => Span,
            A => A,
            Em => Em,
            Strong => Strong,
            B => B,
            I => I,
            U => U,
            S => S,
            Mark => Mark,
            Del => Del,
            Ins => Ins,
            Code => Code,
            Samp => Samp,
            Kbd => Kbd,
            Var => Var,
            Cite => Cite,
            Dfn => Dfn,
            Abbr => Abbr,
            Acronym => Acronym,
            Q => Q,
            Time => Time,
            Sub => Sub,
            Sup => Sup,
            Small => Small,
            Big => Big,
            Bdo => Bdo,
            Bdi => Bdi,
            Wbr => Wbr,
            Ruby => Ruby,
            Rt => Rt,
            Rtc => Rtc,
            Rp => Rp,
            Data => Data,
            Canvas => Canvas,
            Object => Object,
            Param => Param,
            Embed => Embed,
            Audio => Audio,
            Video => Video,
            Source => Source,
            Track => Track,
            Map => Map,
            Area => Area,
            Svg => Svg,
            Title => Title,
            Meta => Meta,
            Link => Link,
            Script => Script,
            Style => Style,
            Base => Base,
            Before => Before,
            After => After,
            Marker => Marker,
            Placeholder => Placeholder,

            Text(s) => Text(s.clone_self()),
            Image(i) => Image(i.clone()), // note: shallow clone
            IFrame(i) => IFrame(IFrameNode {
                callback: i.callback.clone(),
                refany: i.refany.clone(),
            }),
            Icon(s) => Icon(s.clone_self()),
        }
    }

    pub fn format(&self) -> Option<String> {
        use self::NodeType::*;
        match self {
            Text(s) => Some(format!("{}", s)),
            Image(id) => Some(format!("image({:?})", id)),
            IFrame(i) => Some(format!("iframe({:?})", i)),
            Icon(s) => Some(format!("icon({})", s)),
            _ => None,
        }
    }

    /// Returns the NodeTypeTag for CSS selector matching.
    pub fn get_path(&self) -> NodeTypeTag {
        match self {
            Self::Html => NodeTypeTag::Html,
            Self::Head => NodeTypeTag::Head,
            Self::Body => NodeTypeTag::Body,
            Self::Div => NodeTypeTag::Div,
            Self::P => NodeTypeTag::P,
            Self::Article => NodeTypeTag::Article,
            Self::Section => NodeTypeTag::Section,
            Self::Nav => NodeTypeTag::Nav,
            Self::Aside => NodeTypeTag::Aside,
            Self::Header => NodeTypeTag::Header,
            Self::Footer => NodeTypeTag::Footer,
            Self::Main => NodeTypeTag::Main,
            Self::Figure => NodeTypeTag::Figure,
            Self::FigCaption => NodeTypeTag::FigCaption,
            Self::H1 => NodeTypeTag::H1,
            Self::H2 => NodeTypeTag::H2,
            Self::H3 => NodeTypeTag::H3,
            Self::H4 => NodeTypeTag::H4,
            Self::H5 => NodeTypeTag::H5,
            Self::H6 => NodeTypeTag::H6,
            Self::Br => NodeTypeTag::Br,
            Self::Hr => NodeTypeTag::Hr,
            Self::Pre => NodeTypeTag::Pre,
            Self::BlockQuote => NodeTypeTag::BlockQuote,
            Self::Address => NodeTypeTag::Address,
            Self::Details => NodeTypeTag::Details,
            Self::Summary => NodeTypeTag::Summary,
            Self::Dialog => NodeTypeTag::Dialog,
            Self::Ul => NodeTypeTag::Ul,
            Self::Ol => NodeTypeTag::Ol,
            Self::Li => NodeTypeTag::Li,
            Self::Dl => NodeTypeTag::Dl,
            Self::Dt => NodeTypeTag::Dt,
            Self::Dd => NodeTypeTag::Dd,
            Self::Menu => NodeTypeTag::Menu,
            Self::MenuItem => NodeTypeTag::MenuItem,
            Self::Dir => NodeTypeTag::Dir,
            Self::Table => NodeTypeTag::Table,
            Self::Caption => NodeTypeTag::Caption,
            Self::THead => NodeTypeTag::THead,
            Self::TBody => NodeTypeTag::TBody,
            Self::TFoot => NodeTypeTag::TFoot,
            Self::Tr => NodeTypeTag::Tr,
            Self::Th => NodeTypeTag::Th,
            Self::Td => NodeTypeTag::Td,
            Self::ColGroup => NodeTypeTag::ColGroup,
            Self::Col => NodeTypeTag::Col,
            Self::Form => NodeTypeTag::Form,
            Self::FieldSet => NodeTypeTag::FieldSet,
            Self::Legend => NodeTypeTag::Legend,
            Self::Label => NodeTypeTag::Label,
            Self::Input => NodeTypeTag::Input,
            Self::Button => NodeTypeTag::Button,
            Self::Select => NodeTypeTag::Select,
            Self::OptGroup => NodeTypeTag::OptGroup,
            Self::SelectOption => NodeTypeTag::SelectOption,
            Self::TextArea => NodeTypeTag::TextArea,
            Self::Output => NodeTypeTag::Output,
            Self::Progress => NodeTypeTag::Progress,
            Self::Meter => NodeTypeTag::Meter,
            Self::DataList => NodeTypeTag::DataList,
            Self::Span => NodeTypeTag::Span,
            Self::A => NodeTypeTag::A,
            Self::Em => NodeTypeTag::Em,
            Self::Strong => NodeTypeTag::Strong,
            Self::B => NodeTypeTag::B,
            Self::I => NodeTypeTag::I,
            Self::U => NodeTypeTag::U,
            Self::S => NodeTypeTag::S,
            Self::Mark => NodeTypeTag::Mark,
            Self::Del => NodeTypeTag::Del,
            Self::Ins => NodeTypeTag::Ins,
            Self::Code => NodeTypeTag::Code,
            Self::Samp => NodeTypeTag::Samp,
            Self::Kbd => NodeTypeTag::Kbd,
            Self::Var => NodeTypeTag::Var,
            Self::Cite => NodeTypeTag::Cite,
            Self::Dfn => NodeTypeTag::Dfn,
            Self::Abbr => NodeTypeTag::Abbr,
            Self::Acronym => NodeTypeTag::Acronym,
            Self::Q => NodeTypeTag::Q,
            Self::Time => NodeTypeTag::Time,
            Self::Sub => NodeTypeTag::Sub,
            Self::Sup => NodeTypeTag::Sup,
            Self::Small => NodeTypeTag::Small,
            Self::Big => NodeTypeTag::Big,
            Self::Bdo => NodeTypeTag::Bdo,
            Self::Bdi => NodeTypeTag::Bdi,
            Self::Wbr => NodeTypeTag::Wbr,
            Self::Ruby => NodeTypeTag::Ruby,
            Self::Rt => NodeTypeTag::Rt,
            Self::Rtc => NodeTypeTag::Rtc,
            Self::Rp => NodeTypeTag::Rp,
            Self::Data => NodeTypeTag::Data,
            Self::Canvas => NodeTypeTag::Canvas,
            Self::Object => NodeTypeTag::Object,
            Self::Param => NodeTypeTag::Param,
            Self::Embed => NodeTypeTag::Embed,
            Self::Audio => NodeTypeTag::Audio,
            Self::Video => NodeTypeTag::Video,
            Self::Source => NodeTypeTag::Source,
            Self::Track => NodeTypeTag::Track,
            Self::Map => NodeTypeTag::Map,
            Self::Area => NodeTypeTag::Area,
            Self::Svg => NodeTypeTag::Svg,
            Self::Title => NodeTypeTag::Title,
            Self::Meta => NodeTypeTag::Meta,
            Self::Link => NodeTypeTag::Link,
            Self::Script => NodeTypeTag::Script,
            Self::Style => NodeTypeTag::Style,
            Self::Base => NodeTypeTag::Base,
            Self::Text(_) => NodeTypeTag::Text,
            Self::Image(_) => NodeTypeTag::Img,
            Self::IFrame(_) => NodeTypeTag::IFrame,
            Self::Icon(_) => NodeTypeTag::Icon,
            Self::Before => NodeTypeTag::Before,
            Self::After => NodeTypeTag::After,
            Self::Marker => NodeTypeTag::Marker,
            Self::Placeholder => NodeTypeTag::Placeholder,
        }
    }

    /// Returns whether this node type is a semantic HTML element that should
    /// automatically generate an accessibility tree node.
    ///
    /// These are elements with inherent semantic meaning that assistive
    /// technologies should be aware of, even without explicit ARIA attributes.
    pub const fn is_semantic_for_accessibility(&self) -> bool {
        matches!(
            self,
            Self::Button
                | Self::Input
                | Self::TextArea
                | Self::Select
                | Self::A
                | Self::H1
                | Self::H2
                | Self::H3
                | Self::H4
                | Self::H5
                | Self::H6
                | Self::Article
                | Self::Section
                | Self::Nav
                | Self::Main
                | Self::Header
                | Self::Footer
                | Self::Aside
        )
    }
}

/// Represents the CSS formatting context for an element
#[derive(Clone, PartialEq)]
pub enum FormattingContext {
    /// Block-level formatting context
    Block {
        /// Whether this element establishes a new block formatting context
        establishes_new_context: bool,
    },
    /// Inline-level formatting context
    Inline,
    /// Inline-block (participates in an IFC but creates a BFC)
    InlineBlock,
    /// Flex formatting context
    Flex,
    /// Float (left or right)
    Float(LayoutFloat),
    /// Absolutely positioned (out of flow)
    OutOfFlow(LayoutPosition),
    /// Table formatting context (container)
    Table,
    /// Table row group formatting context (thead, tbody, tfoot)
    TableRowGroup,
    /// Table row formatting context
    TableRow,
    /// Table cell formatting context (td, th)
    TableCell,
    /// Table column group formatting context
    TableColumnGroup,
    /// Table caption formatting context
    TableCaption,
    /// Grid formatting context
    Grid,
    /// No formatting context (display: none)
    None,
}

impl fmt::Debug for FormattingContext {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FormattingContext::Block {
                establishes_new_context,
            } => write!(
                f,
                "Block {{ establishes_new_context: {establishes_new_context:?} }}"
            ),
            FormattingContext::Inline => write!(f, "Inline"),
            FormattingContext::InlineBlock => write!(f, "InlineBlock"),
            FormattingContext::Flex => write!(f, "Flex"),
            FormattingContext::Float(layout_float) => write!(f, "Float({layout_float:?})"),
            FormattingContext::OutOfFlow(layout_position) => {
                write!(f, "OutOfFlow({layout_position:?})")
            }
            FormattingContext::Grid => write!(f, "Grid"),
            FormattingContext::None => write!(f, "None"),
            FormattingContext::Table => write!(f, "Table"),
            FormattingContext::TableRowGroup => write!(f, "TableRowGroup"),
            FormattingContext::TableRow => write!(f, "TableRow"),
            FormattingContext::TableCell => write!(f, "TableCell"),
            FormattingContext::TableColumnGroup => write!(f, "TableColumnGroup"),
            FormattingContext::TableCaption => write!(f, "TableCaption"),
        }
    }
}

impl Default for FormattingContext {
    fn default() -> Self {
        FormattingContext::Block {
            establishes_new_context: false,
        }
    }
}

/// Defines the type of event that can trigger a callback action.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[repr(C)]
pub enum On {
    /// Mouse cursor is hovering over the element.
    MouseOver,
    /// Mouse cursor has is over element and is pressed
    /// (not good for "click" events - use `MouseUp` instead).
    MouseDown,
    /// (Specialization of `MouseDown`). Fires only if the left mouse button
    /// has been pressed while cursor was over the element.
    LeftMouseDown,
    /// (Specialization of `MouseDown`). Fires only if the middle mouse button
    /// has been pressed while cursor was over the element.
    MiddleMouseDown,
    /// (Specialization of `MouseDown`). Fires only if the right mouse button
    /// has been pressed while cursor was over the element.
    RightMouseDown,
    /// Mouse button has been released while cursor was over the element.
    MouseUp,
    /// (Specialization of `MouseUp`). Fires only if the left mouse button has
    /// been released while cursor was over the element.
    LeftMouseUp,
    /// (Specialization of `MouseUp`). Fires only if the middle mouse button has
    /// been released while cursor was over the element.
    MiddleMouseUp,
    /// (Specialization of `MouseUp`). Fires only if the right mouse button has
    /// been released while cursor was over the element.
    RightMouseUp,
    /// Mouse cursor has entered the element.
    MouseEnter,
    /// Mouse cursor has left the element.
    MouseLeave,
    /// Mousewheel / touchpad scrolling.
    Scroll,
    /// The window received a unicode character (also respects the system locale).
    /// Check `keyboard_state.current_char` to get the current pressed character.
    TextInput,
    /// A **virtual keycode** was pressed. Note: This is only the virtual keycode,
    /// not the actual char. If you want to get the character, use `TextInput` instead.
    /// A virtual key does not have to map to a printable character.
    ///
    /// You can get all currently pressed virtual keycodes in the
    /// `keyboard_state.current_virtual_keycodes` and / or just the last keycode in the
    /// `keyboard_state.latest_virtual_keycode`.
    VirtualKeyDown,
    /// A **virtual keycode** was release. See `VirtualKeyDown` for more info.
    VirtualKeyUp,
    /// A file has been dropped on the element.
    HoveredFile,
    /// A file is being hovered on the element.
    DroppedFile,
    /// A file was hovered, but has exited the window.
    HoveredFileCancelled,
    /// Equivalent to `onfocus`.
    FocusReceived,
    /// Equivalent to `onblur`.
    FocusLost,

    // Accessibility-specific events
    /// Default action triggered by screen reader (usually same as click/activate)
    Default,
    /// Element should collapse (e.g., accordion panel, tree node)
    Collapse,
    /// Element should expand (e.g., accordion panel, tree node)
    Expand,
    /// Increment value (e.g., number input, slider)
    Increment,
    /// Decrement value (e.g., number input, slider)
    Decrement,
}

// NOTE: EventFilter types moved to core/src/events.rs (Phase 3.5)
//
// The following types are now defined in events.rs and re-exported above:
// - EventFilter
// - HoverEventFilter
// - FocusEventFilter
// - WindowEventFilter
// - NotEventFilter
// - ComponentEventFilter
// - ApplicationEventFilter
//
// This consolidates all event-related logic in one place.

/// Contains the necessary information to render an embedded `IFrame` node.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct IFrameNode {
    /// The callback function that returns the DOM for the iframe's content.
    pub callback: IFrameCallback,
    /// The application data passed to the iframe's layout callback.
    pub refany: RefAny,
}

/// An enum that holds either a CSS ID or a class name as a string.
#[repr(C, u8)]
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum IdOrClass {
    Id(AzString),
    Class(AzString),
}

impl_vec!(
    IdOrClass,
    IdOrClassVec,
    IdOrClassVecDestructor,
    IdOrClassVecDestructorType
);
impl_vec_debug!(IdOrClass, IdOrClassVec);
impl_vec_partialord!(IdOrClass, IdOrClassVec);
impl_vec_ord!(IdOrClass, IdOrClassVec);
impl_vec_clone!(IdOrClass, IdOrClassVec, IdOrClassVecDestructor);
impl_vec_partialeq!(IdOrClass, IdOrClassVec);
impl_vec_eq!(IdOrClass, IdOrClassVec);
impl_vec_hash!(IdOrClass, IdOrClassVec);

impl IdOrClass {
    pub fn as_id(&self) -> Option<&str> {
        match self {
            IdOrClass::Id(s) => Some(s.as_str()),
            IdOrClass::Class(_) => None,
        }
    }
    pub fn as_class(&self) -> Option<&str> {
        match self {
            IdOrClass::Class(s) => Some(s.as_str()),
            IdOrClass::Id(_) => None,
        }
    }
}

/// Name-value pair for custom attributes (data-*, aria-*, etc.)
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct AttributeNameValue {
    pub attr_name: AzString,
    pub value: AzString,
}

/// Strongly-typed HTML attribute with type-safe values.
///
/// This enum provides a type-safe way to represent HTML attributes, ensuring that
/// values are validated at compile-time and properly converted to their string
/// representations at runtime.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, u8)]
pub enum AttributeType {
    /// Element ID attribute (`id="..."`)
    Id(AzString),
    /// CSS class attribute (`class="..."`)
    Class(AzString),
    /// Accessible name/label (`aria-label="..."`)
    AriaLabel(AzString),
    /// Element that labels this one (`aria-labelledby="..."`)
    AriaLabelledBy(AzString),
    /// Element that describes this one (`aria-describedby="..."`)
    AriaDescribedBy(AzString),
    /// Role for accessibility (`role="..."`)
    AriaRole(AzString),
    /// Current state of an element (`aria-checked`, `aria-selected`, etc.)
    AriaState(AttributeNameValue),
    /// ARIA property (`aria-*`)
    AriaProperty(AttributeNameValue),

    /// Hyperlink target URL (`href="..."`)
    Href(AzString),
    /// Link relationship (`rel="..."`)
    Rel(AzString),
    /// Link target frame (`target="..."`)
    Target(AzString),

    /// Image source URL (`src="..."`)
    Src(AzString),
    /// Alternative text for images (`alt="..."`)
    Alt(AzString),
    /// Image title (tooltip) (`title="..."`)
    Title(AzString),

    /// Form input name (`name="..."`)
    Name(AzString),
    /// Form input value (`value="..."`)
    Value(AzString),
    /// Input type (`type="text|password|email|..."`)
    InputType(AzString),
    /// Placeholder text (`placeholder="..."`)
    Placeholder(AzString),
    /// Input is required (`required`)
    Required,
    /// Input is disabled (`disabled`)
    Disabled,
    /// Input is readonly (`readonly`)
    Readonly,
    /// Input is checked (checkbox/radio) (`checked`)
    Checked,
    /// Input is selected (option) (`selected`)
    Selected,
    /// Maximum value for number inputs (`max="..."`)
    Max(AzString),
    /// Minimum value for number inputs (`min="..."`)
    Min(AzString),
    /// Step value for number inputs (`step="..."`)
    Step(AzString),
    /// Input pattern for validation (`pattern="..."`)
    Pattern(AzString),
    /// Minimum length (`minlength="..."`)
    MinLength(i32),
    /// Maximum length (`maxlength="..."`)
    MaxLength(i32),
    /// Autocomplete behavior (`autocomplete="on|off|..."`)
    Autocomplete(AzString),

    /// Table header scope (`scope="row|col|rowgroup|colgroup"`)
    Scope(AzString),
    /// Number of columns to span (`colspan="..."`)
    ColSpan(i32),
    /// Number of rows to span (`rowspan="..."`)
    RowSpan(i32),

    /// Tab index for keyboard navigation (`tabindex="..."`)
    TabIndex(i32),
    /// Element can receive focus (`tabindex="0"` equivalent)
    Focusable,

    /// Language code (`lang="..."`)
    Lang(AzString),
    /// Text direction (`dir="ltr|rtl|auto"`)
    Dir(AzString),

    /// Content is editable (`contenteditable="true|false"`)
    ContentEditable(bool),
    /// Element is draggable (`draggable="true|false"`)
    Draggable(bool),
    /// Element is hidden (`hidden`)
    Hidden,

    /// Generic data attribute (`data-*="..."`)
    Data(AttributeNameValue),
    /// Generic custom attribute (for future extensibility)
    Custom(AttributeNameValue),
}

impl_vec!(
    AttributeType,
    AttributeVec,
    AttributeVecDestructor,
    AttributeVecDestructorType
);
impl_vec_debug!(AttributeType, AttributeVec);
impl_vec_partialord!(AttributeType, AttributeVec);
impl_vec_ord!(AttributeType, AttributeVec);
impl_vec_clone!(AttributeType, AttributeVec, AttributeVecDestructor);
impl_vec_partialeq!(AttributeType, AttributeVec);
impl_vec_eq!(AttributeType, AttributeVec);
impl_vec_hash!(AttributeType, AttributeVec);

impl AttributeType {
    /// Get the attribute name (e.g., "href", "aria-label", "data-foo")
    pub fn name(&self) -> &str {
        match self {
            AttributeType::Id(_) => "id",
            AttributeType::Class(_) => "class",
            AttributeType::AriaLabel(_) => "aria-label",
            AttributeType::AriaLabelledBy(_) => "aria-labelledby",
            AttributeType::AriaDescribedBy(_) => "aria-describedby",
            AttributeType::AriaRole(_) => "role",
            AttributeType::AriaState(nv) => nv.attr_name.as_str(),
            AttributeType::AriaProperty(nv) => nv.attr_name.as_str(),
            AttributeType::Href(_) => "href",
            AttributeType::Rel(_) => "rel",
            AttributeType::Target(_) => "target",
            AttributeType::Src(_) => "src",
            AttributeType::Alt(_) => "alt",
            AttributeType::Title(_) => "title",
            AttributeType::Name(_) => "name",
            AttributeType::Value(_) => "value",
            AttributeType::InputType(_) => "type",
            AttributeType::Placeholder(_) => "placeholder",
            AttributeType::Required => "required",
            AttributeType::Disabled => "disabled",
            AttributeType::Readonly => "readonly",
            AttributeType::Checked => "checked",
            AttributeType::Selected => "selected",
            AttributeType::Max(_) => "max",
            AttributeType::Min(_) => "min",
            AttributeType::Step(_) => "step",
            AttributeType::Pattern(_) => "pattern",
            AttributeType::MinLength(_) => "minlength",
            AttributeType::MaxLength(_) => "maxlength",
            AttributeType::Autocomplete(_) => "autocomplete",
            AttributeType::Scope(_) => "scope",
            AttributeType::ColSpan(_) => "colspan",
            AttributeType::RowSpan(_) => "rowspan",
            AttributeType::TabIndex(_) => "tabindex",
            AttributeType::Focusable => "tabindex",
            AttributeType::Lang(_) => "lang",
            AttributeType::Dir(_) => "dir",
            AttributeType::ContentEditable(_) => "contenteditable",
            AttributeType::Draggable(_) => "draggable",
            AttributeType::Hidden => "hidden",
            AttributeType::Data(nv) => nv.attr_name.as_str(),
            AttributeType::Custom(nv) => nv.attr_name.as_str(),
        }
    }

    /// Get the attribute value as a string
    pub fn value(&self) -> AzString {
        match self {
            AttributeType::Id(v)
            | AttributeType::Class(v)
            | AttributeType::AriaLabel(v)
            | AttributeType::AriaLabelledBy(v)
            | AttributeType::AriaDescribedBy(v)
            | AttributeType::AriaRole(v)
            | AttributeType::Href(v)
            | AttributeType::Rel(v)
            | AttributeType::Target(v)
            | AttributeType::Src(v)
            | AttributeType::Alt(v)
            | AttributeType::Title(v)
            | AttributeType::Name(v)
            | AttributeType::Value(v)
            | AttributeType::InputType(v)
            | AttributeType::Placeholder(v)
            | AttributeType::Max(v)
            | AttributeType::Min(v)
            | AttributeType::Step(v)
            | AttributeType::Pattern(v)
            | AttributeType::Autocomplete(v)
            | AttributeType::Scope(v)
            | AttributeType::Lang(v)
            | AttributeType::Dir(v) => v.clone(),

            AttributeType::AriaState(nv)
            | AttributeType::AriaProperty(nv)
            | AttributeType::Data(nv)
            | AttributeType::Custom(nv) => nv.value.clone(),

            AttributeType::MinLength(n)
            | AttributeType::MaxLength(n)
            | AttributeType::ColSpan(n)
            | AttributeType::RowSpan(n)
            | AttributeType::TabIndex(n) => n.to_string().into(),

            AttributeType::Focusable => "0".into(),
            AttributeType::ContentEditable(b) | AttributeType::Draggable(b) => {
                if *b {
                    "true".into()
                } else {
                    "false".into()
                }
            }

            AttributeType::Required
            | AttributeType::Disabled
            | AttributeType::Readonly
            | AttributeType::Checked
            | AttributeType::Selected
            | AttributeType::Hidden => "".into(), // Boolean attributes
        }
    }

    /// Check if this is a boolean attribute (present = true, absent = false)
    pub fn is_boolean(&self) -> bool {
        matches!(
            self,
            AttributeType::Required
                | AttributeType::Disabled
                | AttributeType::Readonly
                | AttributeType::Checked
                | AttributeType::Selected
                | AttributeType::Hidden
        )
    }
}

/// Compact accessibility information for common use cases.
///
/// This is a lighter-weight alternative to `AccessibilityInfo` for cases where
/// only basic accessibility properties are needed. Developers must explicitly
/// pass `None` if they choose not to provide accessibility information.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[repr(C)]
pub struct SmallAriaInfo {
    /// Accessible label/name
    pub label: OptionString,
    /// Element's role (button, link, etc.)
    pub role: OptionAccessibilityRole,
    /// Additional description
    pub description: OptionString,
}

impl_option!(
    SmallAriaInfo,
    OptionSmallAriaInfo,
    copy = false,
    [Debug, Clone, PartialEq, Eq, Hash]
);

impl SmallAriaInfo {
    pub fn label<S: Into<AzString>>(text: S) -> Self {
        Self {
            label: OptionString::Some(text.into()),
            role: OptionAccessibilityRole::None,
            description: OptionString::None,
        }
    }

    pub fn with_role(mut self, role: AccessibilityRole) -> Self {
        self.role = OptionAccessibilityRole::Some(role);
        self
    }

    pub fn with_description<S: Into<AzString>>(mut self, desc: S) -> Self {
        self.description = OptionString::Some(desc.into());
        self
    }

    /// Convert to full `AccessibilityInfo`
    pub fn to_full_info(&self) -> AccessibilityInfo {
        AccessibilityInfo {
            accessibility_name: self.label.clone(),
            accessibility_value: OptionString::None,
            role: match self.role {
                OptionAccessibilityRole::Some(r) => r,
                OptionAccessibilityRole::None => AccessibilityRole::Unknown,
            },
            states: Vec::new().into(),
            accelerator: OptionVirtualKeyCodeCombo::None,
            default_action: OptionString::None,
            supported_actions: Vec::new().into(),
            is_live_region: false,
            labelled_by: OptionDomNodeId::None,
            described_by: OptionDomNodeId::None,
        }
    }
}

/// Represents all data associated with a single DOM node, such as its type,
/// classes, IDs, callbacks, and inline styles.
#[repr(C)]
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct NodeData {
    /// `div`, `p`, `img`, etc.
    pub node_type: NodeType,
    /// `data-*` attributes for this node, useful to store UI-related data on the node itself.
    pub dataset: OptionRefAny,
    /// Stores all ids and classes as one vec - size optimization since
    /// most nodes don't have any classes or IDs.
    pub ids_and_classes: IdOrClassVec,
    /// Strongly-typed HTML attributes (aria-*, href, alt, etc.)
    pub attributes: AttributeVec,
    /// Callbacks attached to this node:
    ///
    /// `On::MouseUp` -> `Callback(my_button_click_handler)`
    pub callbacks: CoreCallbackDataVec,
    /// Conditional CSS properties with dynamic selectors.
    /// These are evaluated at runtime based on OS, viewport, container, theme, and pseudo-state.
    /// Uses "last wins" semantics - properties are evaluated in order, last match wins.
    pub css_props: CssPropertyWithConditionsVec,
    /// Tab index (commonly used property).
    pub tab_index: OptionTabIndex,
    /// Whether this node is contenteditable (accepts text input).
    /// Equivalent to HTML `contenteditable="true"` attribute.
    pub contenteditable: bool,
    /// Stores "extra", not commonly used data of the node: accessibility, clip-mask, tab-index,
    /// etc.
    ///
    /// SHOULD NOT EXPOSED IN THE API - necessary to retroactively add functionality
    /// to the node without breaking the ABI.
    extra: Option<Box<NodeDataExt>>,
}

impl Hash for NodeData {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.node_type.hash(state);
        self.dataset.hash(state);
        self.ids_and_classes.as_ref().hash(state);
        self.attributes.as_ref().hash(state);
        self.contenteditable.hash(state);

        // NOTE: callbacks are NOT hashed regularly, otherwise
        // they'd cause inconsistencies because of the scroll callback
        for callback in self.callbacks.as_ref().iter() {
            callback.event.hash(state);
            callback.callback.hash(state);
            callback.refany.get_type_id().hash(state);
        }

        // Hash CSS props (conditional CSS with dynamic selectors)
        for prop in self.css_props.as_ref().iter() {
            // Hash property type as a simple discriminant
            core::mem::discriminant(&prop.property).hash(state);
        }
        if let Some(ext) = self.extra.as_ref() {
            if let Some(c) = ext.clip_mask.as_ref() {
                c.hash(state);
            }
            // Note: AccessibilityInfo doesn't implement Hash (has non-hashable fields)
            // Skipping accessibility field in hash
            if let Some(c) = ext.menu_bar.as_ref() {
                c.hash(state);
            }
            if let Some(c) = ext.context_menu.as_ref() {
                c.hash(state);
            }
        }
    }
}

/// NOTE: NOT EXPOSED IN THE API! Stores extra,
/// not commonly used information for the NodeData.
/// This helps keep the primary `NodeData` struct smaller for common cases.
#[repr(C)]
#[derive(Debug, Default, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub struct NodeDataExt {
    /// Optional clip mask for this DOM node.
    pub clip_mask: Option<ImageMask>,
    /// Optional extra accessibility information about this DOM node (MSAA, AT-SPI, UA).
    pub accessibility: Option<Box<AccessibilityInfo>>,
    /// Menu bar that should be displayed at the top of this nodes rect.
    pub menu_bar: Option<Box<Menu>>,
    /// Context menu that should be opened when the item is left-clicked.
    pub context_menu: Option<Box<Menu>>,
    /// Whether this node is an anonymous box (generated for table layout).
    /// Anonymous boxes are not part of the original DOM tree and are created
    /// by the layout engine to satisfy table layout requirements (e.g., wrapping
    /// non-table children of table elements in anonymous table-row/table-cell boxes).
    pub is_anonymous: bool,
    /// Stable key for reconciliation. If provided, allows the framework to track
    /// this node across frames even if its position in the array changes.
    /// This is crucial for correct lifecycle events when lists are reordered.
    pub key: Option<u64>,
    /// Callback to merge dataset state from a previous frame's node into the current node.
    /// This enables heavy resource preservation (video decoders, GL textures) across frames.
    pub dataset_merge_callback: Option<DatasetMergeCallback>,
    // ... insert further API extensions here...
}

/// A callback function used to merge the state of an old dataset into a new one.
///
/// This enables components with heavy internal state (video players, WebGL contexts)
/// to preserve their resources across frames, while the DOM tree is recreated.
///
/// The callback receives both the old and new datasets as `RefAny` (cheap shallow clones)
/// and returns the dataset that should be used for the new node.
///
/// # Example
///
/// ```rust,ignore
/// fn merge_video_state(new_data: RefAny, old_data: RefAny) -> RefAny {
///     // Transfer heavy resources from old to new
///     if let (Some(mut new), Some(old)) = (
///         new_data.downcast_mut::<VideoState>(),
///         old_data.downcast_ref::<VideoState>()
///     ) {
///         new.decoder = old.decoder.take();
///         new.gl_texture = old.gl_texture.take();
///     }
///     new_data // Return the merged state
/// }
/// ```
#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[repr(C)]
pub struct DatasetMergeCallback {
    /// The function pointer that performs the merge.
    /// Signature: `fn(new_data: RefAny, old_data: RefAny) -> RefAny`
    pub cb: DatasetMergeCallbackType,
    /// Optional callable for FFI language bindings (Python, etc.)
    /// When set, the FFI layer can invoke this instead of `cb`.
    pub callable: OptionRefAny,
}

impl core::fmt::Debug for DatasetMergeCallback {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("DatasetMergeCallback")
            .field("cb", &(self.cb as usize))
            .field("callable", &self.callable)
            .finish()
    }
}

/// Allow creating DatasetMergeCallback from a raw function pointer.
/// This enables the `Into<DatasetMergeCallback>` pattern for Python bindings.
impl From<DatasetMergeCallbackType> for DatasetMergeCallback {
    fn from(cb: DatasetMergeCallbackType) -> Self {
        DatasetMergeCallback { 
            cb,
            callable: OptionRefAny::None,
        }
    }
}

impl_option!(
    DatasetMergeCallback,
    OptionDatasetMergeCallback,
    copy = false,
    [Debug, Clone]
);

/// Function pointer type for dataset merge callbacks.
/// 
/// Arguments:
/// - `new_data`: The new node's dataset (shallow clone, cheap)
/// - `old_data`: The old node's dataset (shallow clone, cheap)
/// 
/// Returns:
/// - The `RefAny` that should be used as the dataset for the new node
pub type DatasetMergeCallbackType = extern "C" fn(RefAny, RefAny) -> RefAny;

/// Holds information about a UI element for accessibility purposes (e.g., screen readers).
/// This is a wrapper for platform-specific accessibility APIs like MSAA.
#[derive(Debug, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(C)]
pub struct AccessibilityInfo {
    /// Get the "name" of the `IAccessible`, for example the
    /// name of a button, checkbox or menu item. Try to use unique names
    /// for each item in a dialog so that voice dictation software doesn't
    /// have to deal with extra ambiguity.
    pub accessibility_name: OptionString,
    /// Get the "value" of the `IAccessible`, for example a number in a slider,
    /// a URL for a link, the text a user entered in a field.
    pub accessibility_value: OptionString,
    /// Get an enumerated value representing what this IAccessible is used for,
    /// for example is it a link, static text, editable text, a checkbox, or a table cell, etc.
    pub role: AccessibilityRole,
    /// Possible on/off states, such as focused, focusable, selected, selectable,
    /// visible, protected (for passwords), checked, etc.
    pub states: AccessibilityStateVec,
    /// Optional keyboard accelerator.
    pub accelerator: OptionVirtualKeyCodeCombo,
    /// Optional "default action" description. Only used when there is at least
    /// one `ComponentEventFilter::DefaultAction` callback present on this node.
    pub default_action: OptionString,
    /// A list of actions the user can perform on this element.
    /// Maps to accesskit's Action enum.
    pub supported_actions: AccessibilityActionVec,
    /// For live regions that update automatically (e.g., chat messages, timers).
    /// Maps to accesskit's `Live` property.
    pub is_live_region: bool,
    /// ID of another node that labels this one (for `aria-labelledby`).
    pub labelled_by: OptionDomNodeId,
    /// ID of another node that describes this one (for `aria-describedby`).
    pub described_by: OptionDomNodeId,
}

/// Actions that can be performed on an accessible element.
/// This is a simplified version of accesskit::Action to avoid direct dependency in core.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, u8)]
pub enum AccessibilityAction {
    /// The default action for the element (usually a click).
    Default,
    /// Set focus to this element.
    Focus,
    /// Remove focus from this element.
    Blur,
    /// Collapse an expandable element (e.g., tree node, accordion).
    Collapse,
    /// Expand a collapsible element (e.g., tree node, accordion).
    Expand,
    /// Scroll this element into view.
    ScrollIntoView,
    /// Increment a numeric value (e.g., slider, spinner).
    Increment,
    /// Decrement a numeric value (e.g., slider, spinner).
    Decrement,
    /// Show a context menu.
    ShowContextMenu,
    /// Hide a tooltip.
    HideTooltip,
    /// Show a tooltip.
    ShowTooltip,
    /// Scroll up.
    ScrollUp,
    /// Scroll down.
    ScrollDown,
    /// Scroll left.
    ScrollLeft,
    /// Scroll right.
    ScrollRight,
    /// Replace selected text with new text.
    ReplaceSelectedText(AzString),
    /// Scroll to a specific point.
    ScrollToPoint(LogicalPosition),
    /// Set scroll offset.
    SetScrollOffset(LogicalPosition),
    /// Set text selection.
    SetTextSelection(TextSelectionStartEnd),
    /// Set sequential focus navigation starting point.
    SetSequentialFocusNavigationStartingPoint,
    /// Set the value of a control.
    SetValue(AzString),
    /// Set numeric value of a control.
    SetNumericValue(FloatValue),
    /// Custom action with ID.
    CustomAction(i32),
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TextSelectionStartEnd {
    pub selection_start: usize,
    pub selection_end: usize,
}

impl_vec![
    AccessibilityAction,
    AccessibilityActionVec,
    AccessibilityActionVecDestructor,
    AccessibilityActionVecDestructorType
];
impl_vec_debug!(AccessibilityAction, AccessibilityActionVec);
impl_vec_clone!(
    AccessibilityAction,
    AccessibilityActionVec,
    AccessibilityActionVecDestructor
);
impl_vec_partialeq!(AccessibilityAction, AccessibilityActionVec);
impl_vec_eq!(AccessibilityAction, AccessibilityActionVec);
impl_vec_partialord!(AccessibilityAction, AccessibilityActionVec);
impl_vec_ord!(AccessibilityAction, AccessibilityActionVec);
impl_vec_hash!(AccessibilityAction, AccessibilityActionVec);

impl_option![
    AccessibilityAction,
    OptionAccessibilityAction,
    copy = false,
    [Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
];

impl_option!(
    AccessibilityInfo,
    OptionAccessibilityInfo,
    copy = false,
    [Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

/// Defines the element's purpose for accessibility APIs, informing assistive technologies
/// like screen readers about the function of a UI element. Each variant corresponds to a
/// standard control type or UI structure.
///
/// For more details, see the [MSDN Role Constants page](https://docs.microsoft.com/en-us/windows/winauto/object-roles).
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub enum AccessibilityRole {
    /// Represents the title or caption bar of a window.
    /// - **Purpose**: To identify the title bar containing the window title and system commands.
    /// - **When to use**: This role is typically inserted by the operating system for standard
    ///   windows.
    /// - **Example**: The bar at the top of an application window displaying its name and the
    ///   minimize, maximize, and close buttons.
    TitleBar,

    /// Represents a menu bar at the top of a window.
    /// - **Purpose**: To contain a set of top-level menus for an application.
    /// - **When to use**: For the main menu bar of an application, such as one containing "File,"
    ///   "Edit," and "View."
    /// - **Example**: The "File", "Edit", "View" menu bar at the top of a text editor.
    MenuBar,

    /// Represents a vertical or horizontal scroll bar.
    /// - **Purpose**: To enable scrolling through content that is larger than the visible area.
    /// - **When to use**: For any scrollable region of content.
    /// - **Example**: The bar on the side of a web page that allows the user to scroll up and
    ///   down.
    ScrollBar,

    /// Represents a handle or grip used for moving or resizing.
    /// - **Purpose**: To provide a user interface element for manipulating another element's size
    ///   or position.
    /// - **When to use**: For handles that allow resizing of windows, panes, or other objects.
    /// - **Example**: The small textured area in the bottom-right corner of a window that can be
    ///   dragged to resize it.
    Grip,

    /// Represents a system sound indicating an event.
    /// - **Purpose**: To associate a sound with a UI event, providing an auditory cue.
    /// - **When to use**: When a sound is the primary representation of an event.
    /// - **Example**: A system notification sound that plays when a new message arrives.
    Sound,

    /// Represents the system's mouse pointer or other pointing device.
    /// - **Purpose**: To indicate the screen position of the user's pointing device.
    /// - **When to use**: This role is managed by the operating system.
    /// - **Example**: The arrow that moves on the screen as you move the mouse.
    Cursor,

    /// Represents the text insertion point indicator.
    /// - **Purpose**: To show the current text entry or editing position.
    /// - **When to use**: This role is typically managed by the operating system for text input
    ///   fields.
    /// - **Example**: The blinking vertical line in a text box that shows where the next character
    ///   will be typed.
    Caret,

    /// Represents an alert or notification.
    /// - **Purpose**: To convey an important, non-modal message to the user.
    /// - **When to use**: For non-intrusive notifications that do not require immediate user
    ///   interaction.
    /// - **Example**: A small, temporary "toast" notification that appears to confirm an action,
    ///   like "Email sent."
    Alert,

    /// Represents a window frame.
    /// - **Purpose**: To serve as the container for other objects like a title bar and client
    ///   area.
    /// - **When to use**: This is a fundamental role, typically managed by the windowing system.
    /// - **Example**: The main window of any application, which contains all other UI elements.
    Window,

    /// Represents a window's client area, where the main content is displayed.
    /// - **Purpose**: To define the primary content area of a window.
    /// - **When to use**: For the main content region of a window. It's often the default role for
    ///   a custom control container.
    /// - **Example**: The area of a web browser where the web page content is rendered.
    Client,

    /// Represents a pop-up menu.
    /// - **Purpose**: To display a list of `MenuItem` objects that appears when a user performs an
    ///   action.
    /// - **When to use**: For context menus (right-click menus) or drop-down menus.
    /// - **Example**: The menu that appears when you right-click on a file in a file explorer.
    MenuPopup,

    /// Represents an individual item within a menu.
    /// - **Purpose**: To represent a single command, option, or separator within a menu.
    /// - **When to use**: For individual options inside a `MenuBar` or `MenuPopup`.
    /// - **Example**: The "Save" option within the "File" menu.
    MenuItem,

    /// Represents a small pop-up window that provides information.
    /// - **Purpose**: To offer brief, contextual help or information about a UI element.
    /// - **When to use**: For informational pop-ups that appear on mouse hover.
    /// - **Example**: The small box of text that appears when you hover over a button in a
    ///   toolbar.
    Tooltip,

    /// Represents the main window of an application.
    /// - **Purpose**: To identify the top-level window of an application.
    /// - **When to use**: For the primary window that represents the application itself.
    /// - **Example**: The main window of a calculator or notepad application.
    Application,

    /// Represents a document window within an application.
    /// - **Purpose**: To represent a contained document, typically in a Multiple Document
    ///   Interface (MDI) application.
    /// - **When to use**: For individual document windows inside a larger application shell.
    /// - **Example**: In a photo editor that allows multiple images to be open in separate
    ///   windows, each image window would be a `Document`.
    Document,

    /// Represents a pane or a distinct section of a window.
    /// - **Purpose**: To divide a window into visually and functionally distinct areas.
    /// - **When to use**: For sub-regions of a window, like a navigation pane, preview pane, or
    ///   sidebar.
    /// - **Example**: The preview pane in an email client that shows the content of the selected
    ///   email.
    Pane,

    /// Represents a graphical chart or graph.
    /// - **Purpose**: To display data visually in a chart format.
    /// - **When to use**: For any type of chart, such as a bar chart, line chart, or pie chart.
    /// - **Example**: A bar chart displaying monthly sales figures.
    Chart,

    /// Represents a dialog box or message box.
    /// - **Purpose**: To create a secondary window that requires user interaction before returning
    ///   to the main application.
    /// - **When to use**: For modal or non-modal windows that prompt the user for information or a
    ///   response.
    /// - **Example**: The "Open File" or "Print" dialog in most applications.
    Dialog,

    /// Represents a window's border.
    /// - **Purpose**: To identify the border of a window, which is often used for resizing.
    /// - **When to use**: This role is typically managed by the windowing system.
    /// - **Example**: The decorative and functional frame around a window.
    Border,

    /// Represents a group of related controls.
    /// - **Purpose**: To logically group other objects that share a common purpose.
    /// - **When to use**: For grouping controls like a set of radio buttons or a fieldset with a
    ///   legend.
    /// - **Example**: A "Settings" group box in a dialog that contains several related checkboxes.
    Grouping,

    /// Represents a visual separator.
    /// - **Purpose**: To visually divide a space or a group of controls.
    /// - **When to use**: For visual separators in menus, toolbars, or between panes.
    /// - **Example**: The horizontal line in a menu that separates groups of related menu items.
    Separator,

    /// Represents a toolbar containing a group of controls.
    /// - **Purpose**: To group controls, typically buttons, for quick access to frequently used
    ///   functions.
    /// - **When to use**: For a bar of buttons or other controls, usually at the top of a window
    ///   or pane.
    /// - **Example**: The toolbar at the top of a word processor with buttons for "Bold,"
    ///   "Italic," and "Underline."
    Toolbar,

    /// Represents a status bar for displaying information.
    /// - **Purpose**: To display status information about the current state of the application.
    /// - **When to use**: For a bar, typically at the bottom of a window, that displays messages.
    /// - **Example**: The bar at the bottom of a web browser that shows the loading status of a
    ///   page.
    StatusBar,

    /// Represents a data table.
    /// - **Purpose**: To present data in a two-dimensional grid of rows and columns.
    /// - **When to use**: For grid-like data presentation.
    /// - **Example**: A spreadsheet or a table of data in a database application.
    Table,

    /// Represents a column header in a table.
    /// - **Purpose**: To provide a label for a column of data.
    /// - **When to use**: For the headers of columns in a `Table`.
    /// - **Example**: The header row in a spreadsheet with labels like "Name," "Date," and
    ///   "Amount."
    ColumnHeader,

    /// Represents a row header in a table.
    /// - **Purpose**: To provide a label for a row of data.
    /// - **When to use**: For the headers of rows in a `Table`.
    /// - **Example**: The numbered rows on the left side of a spreadsheet.
    RowHeader,

    /// Represents a full column of cells in a table.
    /// - **Purpose**: To represent an entire column as a single accessible object.
    /// - **When to use**: When it is useful to interact with a column as a whole.
    /// - **Example**: The "Amount" column in a financial data table.
    Column,

    /// Represents a full row of cells in a table.
    /// - **Purpose**: To represent an entire row as a single accessible object.
    /// - **When to use**: When it is useful to interact with a row as a whole.
    /// - **Example**: A row representing a single customer's information in a customer list.
    Row,

    /// Represents a single cell within a table.
    /// - **Purpose**: To represent a single data point or control within a `Table`.
    /// - **When to use**: For individual cells in a grid or table.
    /// - **Example**: A single cell in a spreadsheet containing a specific value.
    Cell,

    /// Represents a hyperlink to a resource.
    /// - **Purpose**: To provide a navigational link to another document or location.
    /// - **When to use**: For text or images that, when clicked, navigate to another resource.
    /// - **Example**: A clickable link on a web page.
    Link,

    /// Represents a help balloon or pop-up.
    /// - **Purpose**: To provide more detailed help information than a standard tooltip.
    /// - **When to use**: For a pop-up that offers extended help text, often initiated by a help
    ///   button.
    /// - **Example**: A pop-up balloon with a paragraph of help text that appears when a user
    ///   clicks a help icon.
    HelpBalloon,

    /// Represents an animated, character-like graphic object.
    /// - **Purpose**: To provide an animated agent for user assistance or entertainment.
    /// - **When to use**: For animated characters or avatars that provide help or guidance.
    /// - **Example**: An animated paperclip that offers tips in a word processor (e.g.,
    ///   Microsoft's Clippy).
    Character,

    /// Represents a list of items.
    /// - **Purpose**: To contain a set of `ListItem` objects.
    /// - **When to use**: For list boxes or similar controls that present a list of selectable
    ///   items.
    /// - **Example**: The list of files in a file selection dialog.
    List,

    /// Represents an individual item within a list.
    /// - **Purpose**: To represent a single, selectable item within a `List`.
    /// - **When to use**: For each individual item in a list box or combo box.
    /// - **Example**: A single file name in a list of files.
    ListItem,

    /// Represents an outline or tree structure.
    /// - **Purpose**: To display a hierarchical view of data.
    /// - **When to use**: For tree-view controls that show nested items.
    /// - **Example**: A file explorer's folder tree view.
    Outline,

    /// Represents an individual item within an outline or tree.
    /// - **Purpose**: To represent a single node (which can be a leaf or a branch) in an
    ///   `Outline`.
    /// - **When to use**: For each node in a tree view.
    /// - **Example**: A single folder in a file explorer's tree view.
    OutlineItem,

    /// Represents a single tab in a tabbed interface.
    /// - **Purpose**: To provide a control for switching between different `PropertyPage` views.
    /// - **When to use**: For the individual tabs that the user can click to switch pages.
    /// - **Example**: The "General" and "Security" tabs in a file properties dialog.
    PageTab,

    /// Represents the content of a page in a property sheet.
    /// - **Purpose**: To serve as a container for the controls displayed when a `PageTab` is
    ///   selected.
    /// - **When to use**: For the content area associated with a specific tab.
    /// - **Example**: The set of options displayed when the "Security" tab is active.
    PropertyPage,

    /// Represents a visual indicator, like a slider thumb.
    /// - **Purpose**: To visually indicate the current value or position of another control.
    /// - **When to use**: For a sub-element that indicates status, like the thumb of a scrollbar.
    /// - **Example**: The draggable thumb of a scrollbar that indicates the current scroll
    ///   position.
    Indicator,

    /// Represents a picture or graphical image.
    /// - **Purpose**: To display a non-interactive image.
    /// - **When to use**: For images and icons that are purely decorative or informational.
    /// - **Example**: A company logo displayed in an application's "About" dialog.
    Graphic,

    /// Represents read-only text.
    /// - **Purpose**: To provide a non-editable text label for another control or for displaying
    ///   information.
    /// - **When to use**: For text that the user cannot edit.
    /// - **Example**: The label "Username:" next to a text input field.
    StaticText,

    /// Represents editable text or a text area.
    /// - **Purpose**: To allow for user text input or selection.
    /// - **When to use**: For text input fields where the user can type.
    /// - **Example**: A text box for entering a username or password.
    Text,

    /// Represents a standard push button.
    /// - **Purpose**: To initiate an immediate action.
    /// - **When to use**: For standard buttons that perform an action when clicked.
    /// - **Example**: An "OK" or "Cancel" button in a dialog.
    PushButton,

    /// Represents a check box control.
    /// - **Purpose**: To allow the user to make a binary choice (checked or unchecked).
    /// - **When to use**: For options that can be toggled on or off independently.
    /// - **Example**: A "Remember me" checkbox on a login form.
    CheckButton,

    /// Represents a radio button.
    /// - **Purpose**: To allow the user to select one option from a mutually exclusive group.
    /// - **When to use**: For a choice where only one option from a `Grouping` can be selected.
    /// - **Example**: "Male" and "Female" radio buttons for selecting gender.
    RadioButton,

    /// Represents a combination of a text field and a drop-down list.
    /// - **Purpose**: To allow the user to either type a value or select one from a list.
    /// - **When to use**: For controls that offer a list of suggestions but also allow custom
    ///   input.
    /// - **Example**: A font selector that allows you to type a font name or choose one from a
    ///   list.
    ComboBox,

    /// Represents a drop-down list box.
    /// - **Purpose**: To allow the user to select an item from a non-editable list that drops
    ///   down.
    /// - **When to use**: For selecting a single item from a predefined list of options.
    /// - **Example**: A country selection drop-down menu.
    DropList,

    /// Represents a progress bar.
    /// - **Purpose**: To indicate the progress of a lengthy operation.
    /// - **When to use**: To provide feedback for tasks like file downloads or installations.
    /// - **Example**: The bar that fills up to show the progress of a file copy operation.
    ProgressBar,

    /// Represents a dial or knob.
    /// - **Purpose**: To allow selecting a value from a continuous or discrete range, often
    ///   circularly.
    /// - **When to use**: For controls that resemble real-world dials, like a volume knob.
    /// - **Example**: A volume control knob in a media player application.
    Dial,

    /// Represents a control for entering a keyboard shortcut.
    /// - **Purpose**: To capture a key combination from the user.
    /// - **When to use**: In settings where users can define their own keyboard shortcuts.
    /// - **Example**: A text field in a settings dialog where a user can press a key combination
    ///   to assign it to a command.
    HotkeyField,

    /// Represents a slider for selecting a value within a range.
    /// - **Purpose**: To allow the user to adjust a setting along a continuous or discrete range.
    /// - **When to use**: For adjusting values like volume, brightness, or zoom level.
    /// - **Example**: A slider to control the volume of a video.
    Slider,

    /// Represents a spin button (up/down arrows) for incrementing or decrementing a value.
    /// - **Purpose**: To provide fine-tuned adjustment of a value, typically numeric.
    /// - **When to use**: For controls that allow stepping through a range of values.
    /// - **Example**: The up and down arrows next to a number input for setting the font size.
    SpinButton,

    /// Represents a diagram or flowchart.
    /// - **Purpose**: To represent data or relationships in a schematic form.
    /// - **When to use**: For visual representations of structures that are not charts, like a
    ///   database schema diagram.
    /// - **Example**: A flowchart illustrating a business process.
    Diagram,

    /// Represents an animation control.
    /// - **Purpose**: To display a sequence of images or indicate an ongoing process.
    /// - **When to use**: For animations that show that an operation is in progress.
    /// - **Example**: The animation that plays while files are being copied.
    Animation,

    /// Represents a mathematical equation.
    /// - **Purpose**: To display a mathematical formula in the correct format.
    /// - **When to use**: For displaying mathematical equations.
    /// - **Example**: A rendered mathematical equation in a scientific document editor.
    Equation,

    /// Represents a button that drops down a list of items.
    /// - **Purpose**: To combine a default action button with a list of alternative actions.
    /// - **When to use**: For buttons that have a primary action and a secondary list of options.
    /// - **Example**: A "Send" button with a dropdown arrow that reveals "Send and Archive."
    ButtonDropdown,

    /// Represents a button that drops down a full menu.
    /// - **Purpose**: To provide a button that opens a menu of choices rather than performing a
    ///   single action.
    /// - **When to use**: When a button's primary purpose is to reveal a menu.
    /// - **Example**: A "Tools" button that opens a menu with various tool options.
    ButtonMenu,

    /// Represents a button that drops down a grid for selection.
    /// - **Purpose**: To allow selection from a two-dimensional grid of options.
    /// - **When to use**: For buttons that open a grid-based selection UI.
    /// - **Example**: A color picker button that opens a grid of color swatches.
    ButtonDropdownGrid,

    /// Represents blank space between other objects.
    /// - **Purpose**: To represent significant empty areas in a UI that are part of the layout.
    /// - **When to use**: Sparingly, to signify that a large area is intentionally blank.
    /// - **Example**: A large empty panel in a complex layout might use this role.
    Whitespace,

    /// Represents the container for a set of tabs.
    /// - **Purpose**: To group a set of `PageTab` elements.
    /// - **When to use**: To act as the parent container for a row or column of tabs.
    /// - **Example**: The entire row of tabs at the top of a properties dialog.
    PageTabList,

    /// Represents a clock control.
    /// - **Purpose**: To display the current time.
    /// - **When to use**: For any UI element that displays time.
    /// - **Example**: The clock in the system tray of the operating system.
    Clock,

    /// Represents a button with two parts: a default action and a dropdown.
    /// - **Purpose**: To combine a frequently used action with a set of related, less-used
    ///   actions.
    /// - **When to use**: When a button has a default action and other related actions available
    ///   in a dropdown.
    /// - **Example**: A "Save" split button where the primary part saves, and the dropdown offers
    ///   "Save As."
    SplitButton,

    /// Represents a control for entering an IP address.
    /// - **Purpose**: To provide a specialized input field for IP addresses, often with formatting
    ///   and validation.
    /// - **When to use**: For dedicated IP address input fields.
    /// - **Example**: A network configuration dialog with a field for entering a static IP
    ///   address.
    IpAddress,

    /// Represents an element with no specific role.
    /// - **Purpose**: To indicate an element that has no semantic meaning for accessibility.
    /// - **When to use**: Should be used sparingly for purely decorative elements that should be
    ///   ignored by assistive technologies.
    /// - **Example**: A decorative graphical flourish that has no function or information to
    ///   convey.
    Nothing,

    /// Unknown or unspecified role.
    /// - **Purpose**: Default fallback when no specific role is assigned.
    /// - **When to use**: As a default value or when role information is unavailable.
    Unknown,
}

impl_option!(
    AccessibilityRole,
    OptionAccessibilityRole,
    [Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

/// Defines the current state of an element for accessibility APIs (e.g., focused, checked).
/// These states provide dynamic information to assistive technologies about the element's
/// condition.
///
/// See the [MSDN State Constants page](https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants) for more details.
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub enum AccessibilityState {
    /// The element is unavailable and cannot be interacted with.
    /// - **Purpose**: To indicate that a control is disabled or grayed out.
    /// - **When to use**: For disabled buttons, non-interactive menu items, or any control that is
    ///   temporarily non-functional.
    /// - **Example**: A "Save" button that is disabled until the user makes changes to a document.
    Unavailable,

    /// The element is selected.
    /// - **Purpose**: To indicate that an item is currently chosen or highlighted. This is
    ///   distinct from having focus.
    /// - **When to use**: For selected items in a list, highlighted text, or the currently active
    ///   tab in a tab list.
    /// - **Example**: A file highlighted in a file explorer, or multiple selected emails in an
    ///   inbox.
    Selected,

    /// The element has the keyboard focus.
    /// - **Purpose**: To identify the single element that will receive keyboard input.
    /// - **When to use**: For the control that is currently active and ready to be manipulated by
    ///   the keyboard.
    /// - **Example**: A text box with a blinking cursor, or a button with a dotted outline around
    ///   it.
    Focused,

    /// The element is checked, toggled, or in a mixed state.
    /// - **Purpose**: To represent the state of controls like checkboxes, radio buttons, and
    ///   toggle buttons.
    /// - **When to use**: For checkboxes that are ticked, selected radio buttons, or toggle
    ///   buttons that are "on."
    /// - **Example**: A checked "I agree" checkbox, a selected "Yes" radio button, or an active
    ///   "Bold" button in a toolbar.
    Checked,

    /// The element's content cannot be edited by the user.
    /// - **Purpose**: To indicate that the element's value can be viewed and copied, but not
    ///   modified.
    /// - **When to use**: For display-only text fields or documents.
    /// - **Example**: A text box displaying a license agreement that the user can scroll through
    ///   but cannot edit.
    Readonly,

    /// The element is the default action in a dialog or form.
    /// - **Purpose**: To identify the button that will be activated if the user presses the Enter
    ///   key.
    /// - **When to use**: For the primary confirmation button in a dialog.
    /// - **Example**: The "OK" button in a dialog box, which often has a thicker or colored
    ///   border.
    Default,

    /// The element is expanded, showing its child items.
    /// - **Purpose**: To indicate that a collapsible element is currently open and its contents
    ///   are visible.
    /// - **When to use**: For tree view nodes, combo boxes with their lists open, or expanded
    ///   accordion panels.
    /// - **Example**: A folder in a file explorer's tree view that has been clicked to show its
    ///   subfolders.
    Expanded,

    /// The element is collapsed, hiding its child items.
    /// - **Purpose**: To indicate that a collapsible element is closed and its contents are
    ///   hidden.
    /// - **When to use**: The counterpart to `Expanded` for any collapsible UI element.
    /// - **Example**: A closed folder in a file explorer's tree view, hiding its contents.
    Collapsed,

    /// The element is busy and cannot respond to user interaction.
    /// - **Purpose**: To indicate that the element or application is performing an operation and
    ///   is temporarily unresponsive.
    /// - **When to use**: When an application is loading, processing refany, or otherwise occupied.
    /// - **Example**: A window that is grayed out and shows a spinning cursor while saving a large
    ///   file.
    Busy,

    /// The element is not currently visible on the screen.
    /// - **Purpose**: To indicate that an element exists but is currently scrolled out of the
    ///   visible area.
    /// - **When to use**: For items in a long list or a large document that are not within the
    ///   current viewport.
    /// - **Example**: A list item in a long dropdown that you would have to scroll down to see.
    Offscreen,

    /// The element can accept keyboard focus.
    /// - **Purpose**: To indicate that the user can navigate to this element using the keyboard
    ///   (e.g., with the Tab key).
    /// - **When to use**: On all interactive elements like buttons, links, and input fields,
    ///   whether they currently have focus or not.
    /// - **Example**: A button that can receive focus, even if it is not the currently focused
    ///   element.
    Focusable,

    /// The element is a container whose children can be selected.
    /// - **Purpose**: To indicate that the element contains items that can be chosen.
    /// - **When to use**: On container controls like list boxes, tree views, or text spans where
    ///   text can be highlighted.
    /// - **Example**: A list box control is `Selectable`, while its individual list items have the
    ///   `Selected` state when chosen.
    Selectable,

    /// The element is a hyperlink.
    /// - **Purpose**: To identify an object that navigates to another resource or location when
    ///   activated.
    /// - **When to use**: On any object that functions as a hyperlink.
    /// - **Example**: Text or an image that, when clicked, opens a web page.
    Linked,

    /// The element is a hyperlink that has been visited.
    /// - **Purpose**: To indicate that a hyperlink has already been followed by the user.
    /// - **When to use**: On a `Linked` object that the user has previously activated.
    /// - **Example**: A hyperlink on a web page that has changed color to show it has been
    ///   visited.
    Traversed,

    /// The element allows multiple of its children to be selected at once.
    /// - **Purpose**: To indicate that a container control supports multi-selection.
    /// - **When to use**: On container controls like list boxes or file explorers that support
    ///   multiple selections (e.g., with Ctrl-click).
    /// - **Example**: A file list that allows the user to select several files at once for a copy
    ///   operation.
    Multiselectable,

    /// The element contains protected content that should not be read aloud.
    /// - **Purpose**: To prevent assistive technologies from speaking the content of a sensitive
    ///   field.
    /// - **When to use**: Primarily for password input fields.
    /// - **Example**: A password text box where typed characters are masked with asterisks or
    ///   dots.
    Protected,
}

impl_vec!(
    AccessibilityState,
    AccessibilityStateVec,
    AccessibilityStateVecDestructor,
    AccessibilityStateVecDestructorType
);
impl_vec_clone!(
    AccessibilityState,
    AccessibilityStateVec,
    AccessibilityStateVecDestructor
);
impl_vec_debug!(AccessibilityState, AccessibilityStateVec);
impl_vec_partialeq!(AccessibilityState, AccessibilityStateVec);
impl_vec_partialord!(AccessibilityState, AccessibilityStateVec);
impl_vec_eq!(AccessibilityState, AccessibilityStateVec);
impl_vec_ord!(AccessibilityState, AccessibilityStateVec);
impl_vec_hash!(AccessibilityState, AccessibilityStateVec);

impl Clone for NodeData {
    #[inline]
    fn clone(&self) -> Self {
        Self {
            node_type: self.node_type.into_library_owned_nodetype(),
            dataset: match &self.dataset {
                OptionRefAny::None => OptionRefAny::None,
                OptionRefAny::Some(s) => OptionRefAny::Some(s.clone()),
            },
            ids_and_classes: self.ids_and_classes.clone(), /* do not clone the IDs and classes if
                                                            * they are &'static */
            attributes: self.attributes.clone(),
            css_props: self.css_props.clone(),
            callbacks: self.callbacks.clone(),
            tab_index: self.tab_index,
            contenteditable: self.contenteditable,
            extra: self.extra.clone(),
        }
    }
}

// Clone, PartialEq, Eq, Hash, PartialOrd, Ord
impl_vec!(
    NodeData,
    NodeDataVec,
    NodeDataVecDestructor,
    NodeDataVecDestructorType
);
impl_vec_clone!(NodeData, NodeDataVec, NodeDataVecDestructor);
impl_vec_mut!(NodeData, NodeDataVec);
impl_vec_debug!(NodeData, NodeDataVec);
impl_vec_partialord!(NodeData, NodeDataVec);
impl_vec_ord!(NodeData, NodeDataVec);
impl_vec_partialeq!(NodeData, NodeDataVec);
impl_vec_eq!(NodeData, NodeDataVec);
impl_vec_hash!(NodeData, NodeDataVec);

impl NodeDataVec {
    #[inline]
    pub fn as_container<'a>(&'a self) -> NodeDataContainerRef<'a, NodeData> {
        NodeDataContainerRef {
            internal: self.as_ref(),
        }
    }
    #[inline]
    pub fn as_container_mut<'a>(&'a mut self) -> NodeDataContainerRefMut<'a, NodeData> {
        NodeDataContainerRefMut {
            internal: self.as_mut(),
        }
    }
}

unsafe impl Send for NodeData {}

/// Determines the behavior of an element in sequential focus navigation
// (e.g., using the Tab key).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(C, u8)]
pub enum TabIndex {
    /// Automatic tab index, similar to simply setting `focusable = "true"` or `tabindex = 0`
    /// (both have the effect of making the element focusable).
    ///
    /// Sidenote: See https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
    /// for interesting notes on tabindex and accessibility
    Auto,
    /// Set the tab index in relation to its parent element. I.e. if you have a list of elements,
    /// the focusing order is restricted to the current parent.
    ///
    /// When pressing tab repeatedly, the focusing order will be
    /// determined by OverrideInParent elements taking precedence among global order.
    OverrideInParent(u32),
    /// Elements can be focused in callbacks, but are not accessible via
    /// keyboard / tab navigation (-1).
    NoKeyboardFocus,
}

impl_option!(
    TabIndex,
    OptionTabIndex,
    [Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

impl TabIndex {
    /// Returns the HTML-compatible number of the `tabindex` element.
    pub fn get_index(&self) -> isize {
        use self::TabIndex::*;
        match self {
            Auto => 0,
            OverrideInParent(x) => *x as isize,
            NoKeyboardFocus => -1,
        }
    }
}

impl Default for TabIndex {
    fn default() -> Self {
        TabIndex::Auto
    }
}

impl Default for NodeData {
    fn default() -> Self {
        NodeData::create_node(NodeType::Div)
    }
}

impl fmt::Display for NodeData {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let html_type = self.node_type.get_path();
        let attributes_string = node_data_to_string(&self);

        match self.node_type.format() {
            Some(content) => write!(
                f,
                "<{}{}>{}</{}>",
                html_type, attributes_string, content, html_type
            ),
            None => write!(f, "<{}{}/>", html_type, attributes_string),
        }
    }
}

fn node_data_to_string(node_data: &NodeData) -> String {
    let mut id_string = String::new();
    let ids = node_data
        .ids_and_classes
        .as_ref()
        .iter()
        .filter_map(|s| s.as_id())
        .collect::<Vec<_>>()
        .join(" ");

    if !ids.is_empty() {
        id_string = format!(" id=\"{}\" ", ids);
    }

    let mut class_string = String::new();
    let classes = node_data
        .ids_and_classes
        .as_ref()
        .iter()
        .filter_map(|s| s.as_class())
        .collect::<Vec<_>>()
        .join(" ");

    if !classes.is_empty() {
        class_string = format!(" class=\"{}\" ", classes);
    }

    let mut tabindex_string = String::new();
    if let Some(tab_index) = node_data.get_tab_index() {
        tabindex_string = format!(" tabindex=\"{}\" ", tab_index.get_index());
    };

    format!("{}{}{}", id_string, class_string, tabindex_string)
}

impl NodeData {
    /// Creates a new `NodeData` instance from a given `NodeType`.
    #[inline]
    pub const fn create_node(node_type: NodeType) -> Self {
        Self {
            node_type,
            dataset: OptionRefAny::None,
            ids_and_classes: IdOrClassVec::from_const_slice(&[]),
            attributes: AttributeVec::from_const_slice(&[]),
            callbacks: CoreCallbackDataVec::from_const_slice(&[]),
            css_props: CssPropertyWithConditionsVec::from_const_slice(&[]),
            tab_index: OptionTabIndex::None,
            contenteditable: false,
            extra: None,
        }
    }

    /// Shorthand for `NodeData::create_node(NodeType::Body)`.
    #[inline(always)]
    pub const fn create_body() -> Self {
        Self::create_node(NodeType::Body)
    }

    /// Shorthand for `NodeData::create_node(NodeType::Div)`.
    #[inline(always)]
    pub const fn create_div() -> Self {
        Self::create_node(NodeType::Div)
    }

    /// Shorthand for `NodeData::create_node(NodeType::Br)`.
    #[inline(always)]
    pub const fn create_br() -> Self {
        Self::create_node(NodeType::Br)
    }

    /// Shorthand for `NodeData::create_node(NodeType::Text(value.into()))`.
    #[inline(always)]
    pub fn create_text<S: Into<AzString>>(value: S) -> Self {
        Self::create_node(NodeType::Text(value.into()))
    }

    /// Shorthand for `NodeData::create_node(NodeType::Image(image_id))`.
    #[inline(always)]
    pub fn create_image(image: ImageRef) -> Self {
        Self::create_node(NodeType::Image(image))
    }

    #[inline(always)]
    pub fn create_iframe(data: RefAny, callback: impl Into<IFrameCallback>) -> Self {
        Self::create_node(NodeType::IFrame(IFrameNode {
            callback: callback.into(),
            refany: data,
        }))
    }

    /// Checks whether this node is of the given node type (div, image, text).
    #[inline]
    pub fn is_node_type(&self, searched_type: NodeType) -> bool {
        self.node_type == searched_type
    }

    /// Checks whether this node has the searched ID attached.
    pub fn has_id(&self, id: &str) -> bool {
        self.ids_and_classes
            .iter()
            .any(|id_or_class| id_or_class.as_id() == Some(id))
    }

    /// Checks whether this node has the searched class attached.
    pub fn has_class(&self, class: &str) -> bool {
        self.ids_and_classes
            .iter()
            .any(|id_or_class| id_or_class.as_class() == Some(class))
    }

    pub fn has_context_menu(&self) -> bool {
        self.extra
            .as_ref()
            .map(|m| m.context_menu.is_some())
            .unwrap_or(false)
    }

    pub fn is_text_node(&self) -> bool {
        match self.node_type {
            NodeType::Text(_) => true,
            _ => false,
        }
    }

    pub fn is_iframe_node(&self) -> bool {
        match self.node_type {
            NodeType::IFrame(_) => true,
            _ => false,
        }
    }

    // NOTE: Getters are used here in order to allow changing the memory allocator for the NodeData
    // in the future (which is why the fields are all private).

    #[inline(always)]
    pub const fn get_node_type(&self) -> &NodeType {
        &self.node_type
    }
    #[inline(always)]
    pub fn get_dataset_mut(&mut self) -> &mut OptionRefAny {
        &mut self.dataset
    }
    #[inline(always)]
    pub const fn get_dataset(&self) -> &OptionRefAny {
        &self.dataset
    }
    #[inline(always)]
    pub const fn get_ids_and_classes(&self) -> &IdOrClassVec {
        &self.ids_and_classes
    }
    #[inline(always)]
    pub const fn get_callbacks(&self) -> &CoreCallbackDataVec {
        &self.callbacks
    }
    #[inline(always)]
    pub const fn get_css_props(&self) -> &CssPropertyWithConditionsVec {
        &self.css_props
    }

    #[inline]
    pub fn get_clip_mask(&self) -> Option<&ImageMask> {
        self.extra.as_ref().and_then(|e| e.clip_mask.as_ref())
    }
    #[inline]
    pub fn get_tab_index(&self) -> Option<&TabIndex> {
        self.tab_index.as_ref()
    }
    #[inline]
    pub fn get_accessibility_info(&self) -> Option<&Box<AccessibilityInfo>> {
        self.extra.as_ref().and_then(|e| e.accessibility.as_ref())
    }
    #[inline]
    pub fn get_menu_bar(&self) -> Option<&Box<Menu>> {
        self.extra.as_ref().and_then(|e| e.menu_bar.as_ref())
    }
    #[inline]
    pub fn get_context_menu(&self) -> Option<&Box<Menu>> {
        self.extra.as_ref().and_then(|e| e.context_menu.as_ref())
    }

    /// Returns whether this node is an anonymous box generated for table layout.
    #[inline]
    pub fn is_anonymous(&self) -> bool {
        self.extra.as_ref().map(|e| e.is_anonymous).unwrap_or(false)
    }

    #[inline(always)]
    pub fn set_node_type(&mut self, node_type: NodeType) {
        self.node_type = node_type;
    }
    #[inline(always)]
    pub fn set_dataset(&mut self, data: OptionRefAny) {
        self.dataset = data;
    }
    #[inline(always)]
    pub fn set_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec) {
        self.ids_and_classes = ids_and_classes;
    }
    #[inline(always)]
    pub fn set_callbacks(&mut self, callbacks: CoreCallbackDataVec) {
        self.callbacks = callbacks;
    }
    #[inline(always)]
    pub fn set_css_props(&mut self, css_props: CssPropertyWithConditionsVec) {
        self.css_props = css_props;
    }
    #[inline]
    pub fn set_clip_mask(&mut self, clip_mask: ImageMask) {
        self.extra
            .get_or_insert_with(|| Box::new(NodeDataExt::default()))
            .clip_mask = Some(clip_mask);
    }
    #[inline]
    pub fn set_tab_index(&mut self, tab_index: TabIndex) {
        self.tab_index = Some(tab_index).into();
    }
    #[inline]
    pub fn set_contenteditable(&mut self, contenteditable: bool) {
        self.contenteditable = contenteditable;
    }
    #[inline]
    pub fn is_contenteditable(&self) -> bool {
        self.contenteditable
    }
    #[inline]
    pub fn set_accessibility_info(&mut self, accessibility_info: AccessibilityInfo) {
        self.extra
            .get_or_insert_with(|| Box::new(NodeDataExt::default()))
            .accessibility = Some(Box::new(accessibility_info));
    }

    /// Marks this node as an anonymous box (generated for table layout).
    #[inline]
    pub fn set_anonymous(&mut self, is_anonymous: bool) {
        self.extra
            .get_or_insert_with(|| Box::new(NodeDataExt::default()))
            .is_anonymous = is_anonymous;
    }
    #[inline]
    pub fn set_menu_bar(&mut self, menu_bar: Menu) {
        self.extra
            .get_or_insert_with(|| Box::new(NodeDataExt::default()))
            .menu_bar = Some(Box::new(menu_bar));
    }
    #[inline]
    pub fn set_context_menu(&mut self, context_menu: Menu) {
        self.extra
            .get_or_insert_with(|| Box::new(NodeDataExt::default()))
            .context_menu = Some(Box::new(context_menu));
    }

    /// Sets a stable key for this node used in reconciliation.
    ///
    /// This key is used to track node identity across DOM updates, enabling
    /// the framework to distinguish between "moving" a node and "destroying/creating" one.
    /// This is crucial for correct lifecycle events when lists are reordered.
    ///
    /// # Example
    /// ```rust
    /// node_data.set_key("user-123");
    /// ```
    #[inline]
    pub fn set_key<K: core::hash::Hash>(&mut self, key: K) {
        use highway::{HighwayHash, HighwayHasher, Key};
        let mut hasher = HighwayHasher::new(Key([0; 4]));
        key.hash(&mut hasher);
        self.extra
            .get_or_insert_with(|| Box::new(NodeDataExt::default()))
            .key = Some(hasher.finalize64());
    }

    /// Gets the key for this node, if set.
    #[inline]
    pub fn get_key(&self) -> Option<u64> {
        self.extra.as_ref().and_then(|ext| ext.key)
    }

    /// Sets a dataset merge callback for this node.
    ///
    /// The merge callback is invoked during reconciliation when a node from the
    /// previous frame is matched with a node in the new frame. It allows heavy
    /// resources (video decoders, GL textures, network connections) to be
    /// transferred from the old node to the new node instead of being destroyed.
    ///
    /// # Type Safety
    ///
    /// The callback stores the `TypeId` of `T`. During execution, both the old
    /// and new datasets must match this type, otherwise the merge is skipped.
    ///
    /// # Example
    /// ```rust
    /// struct VideoPlayer {
    ///     url: String,
    ///     decoder: Option<DecoderHandle>,
    /// }
    /// 
    /// extern "C" fn merge_video(new_data: RefAny, old_data: RefAny) -> RefAny {
    ///     // Transfer the heavy decoder handle from old to new
    ///     if let (Some(mut new), Some(old)) = (
    ///         new_data.downcast_mut::<VideoPlayer>(),
    ///         old_data.downcast_ref::<VideoPlayer>()
    ///     ) {
    ///         new.decoder = old.decoder.take();
    ///     }
    ///     new_data
    /// }
    /// 
    /// node_data.set_merge_callback(merge_video);
    /// ```
    #[inline]
    pub fn set_merge_callback<C: Into<DatasetMergeCallback>>(&mut self, callback: C) {
        self.extra
            .get_or_insert_with(|| Box::new(NodeDataExt::default()))
            .dataset_merge_callback = Some(callback.into());
    }

    /// Gets the merge callback for this node, if set.
    #[inline]
    pub fn get_merge_callback(&self) -> Option<DatasetMergeCallback> {
        self.extra.as_ref().and_then(|ext| ext.dataset_merge_callback.clone())
    }

    #[inline]
    pub fn with_menu_bar(mut self, menu_bar: Menu) -> Self {
        self.set_menu_bar(menu_bar);
        self
    }

    #[inline]
    pub fn with_context_menu(mut self, context_menu: Menu) -> Self {
        self.set_context_menu(context_menu);
        self
    }

    #[inline]
    pub fn add_callback<C: Into<CoreCallback>>(
        &mut self,
        event: EventFilter,
        data: RefAny,
        callback: C,
    ) {
        let callback = callback.into();
        let mut v: CoreCallbackDataVec = Vec::new().into();
        mem::swap(&mut v, &mut self.callbacks);
        let mut v = v.into_library_owned_vec();
        v.push(CoreCallbackData {
            event,
            refany: data,
            callback,
        });
        self.callbacks = v.into();
    }

    #[inline]
    pub fn add_id(&mut self, s: AzString) {
        let mut v: IdOrClassVec = Vec::new().into();
        mem::swap(&mut v, &mut self.ids_and_classes);
        let mut v = v.into_library_owned_vec();
        v.push(IdOrClass::Id(s));
        self.ids_and_classes = v.into();
    }
    #[inline]
    pub fn add_class(&mut self, s: AzString) {
        let mut v: IdOrClassVec = Vec::new().into();
        mem::swap(&mut v, &mut self.ids_and_classes);
        let mut v = v.into_library_owned_vec();
        v.push(IdOrClass::Class(s));
        self.ids_and_classes = v.into();
    }

    /// Add an unconditional CSS property (always applies)
    #[inline]
    pub fn add_css_property(&mut self, p: CssProperty) {
        use azul_css::dynamic_selector::CssPropertyWithConditions;
        let mut v: CssPropertyWithConditionsVec = Vec::new().into();
        mem::swap(&mut v, &mut self.css_props);
        let mut v = v.into_library_owned_vec();
        v.push(CssPropertyWithConditions::simple(p));
        self.css_props = v.into();
    }

    /// Add a CSS property that applies only on hover
    #[inline]
    pub fn add_hover_css_property(&mut self, p: CssProperty) {
        use azul_css::dynamic_selector::{
            CssPropertyWithConditions, DynamicSelector, PseudoStateType,
        };
        let mut v: CssPropertyWithConditionsVec = Vec::new().into();
        mem::swap(&mut v, &mut self.css_props);
        let mut v = v.into_library_owned_vec();
        v.push(CssPropertyWithConditions::with_condition(
            p,
            DynamicSelector::PseudoState(PseudoStateType::Hover),
        ));
        self.css_props = v.into();
    }

    /// Add a CSS property that applies only when active (clicked)
    #[inline]
    pub fn add_active_css_property(&mut self, p: CssProperty) {
        use azul_css::dynamic_selector::{
            CssPropertyWithConditions, DynamicSelector, PseudoStateType,
        };
        let mut v: CssPropertyWithConditionsVec = Vec::new().into();
        mem::swap(&mut v, &mut self.css_props);
        let mut v = v.into_library_owned_vec();
        v.push(CssPropertyWithConditions::with_condition(
            p,
            DynamicSelector::PseudoState(PseudoStateType::Active),
        ));
        self.css_props = v.into();
    }

    /// Add a CSS property that applies only when focused
    #[inline]
    pub fn add_focus_css_property(&mut self, p: CssProperty) {
        use azul_css::dynamic_selector::{
            CssPropertyWithConditions, DynamicSelector, PseudoStateType,
        };
        let mut v: CssPropertyWithConditionsVec = Vec::new().into();
        mem::swap(&mut v, &mut self.css_props);
        let mut v = v.into_library_owned_vec();
        v.push(CssPropertyWithConditions::with_condition(
            p,
            DynamicSelector::PseudoState(PseudoStateType::Focus),
        ));
        self.css_props = v.into();
    }

    /// Calculates a deterministic node hash for this node.
    pub fn calculate_node_data_hash(&self) -> DomNodeHash {
        use highway::{HighwayHash, HighwayHasher, Key};
        let mut hasher = HighwayHasher::new(Key([0; 4]));
        self.hash(&mut hasher);
        let h = hasher.finalize64();
        DomNodeHash { inner: h }
    }

    #[inline(always)]
    pub fn with_tab_index(mut self, tab_index: TabIndex) -> Self {
        self.set_tab_index(tab_index);
        self
    }
    #[inline(always)]
    pub fn with_contenteditable(mut self, contenteditable: bool) -> Self {
        self.set_contenteditable(contenteditable);
        self
    }
    #[inline(always)]
    pub fn with_node_type(mut self, node_type: NodeType) -> Self {
        self.set_node_type(node_type);
        self
    }
    #[inline(always)]
    pub fn with_callback<C: Into<CoreCallback>>(
        mut self,
        event: EventFilter,
        data: RefAny,
        callback: C,
    ) -> Self {
        self.add_callback(event, data, callback);
        self
    }
    #[inline(always)]
    pub fn with_dataset(mut self, data: OptionRefAny) -> Self {
        self.dataset = data;
        self
    }
    #[inline(always)]
    pub fn with_ids_and_classes(mut self, ids_and_classes: IdOrClassVec) -> Self {
        self.ids_and_classes = ids_and_classes;
        self
    }
    #[inline(always)]
    pub fn with_callbacks(mut self, callbacks: CoreCallbackDataVec) -> Self {
        self.callbacks = callbacks;
        self
    }
    #[inline(always)]
    pub fn with_css_props(mut self, css_props: CssPropertyWithConditionsVec) -> Self {
        self.css_props = css_props;
        self
    }

    /// Assigns a stable key to this node for reconciliation.
    ///
    /// This is crucial for performance and correct state preservation when
    /// lists of items change order or items are inserted/removed. Without keys,
    /// the reconciliation algorithm falls back to hash-based matching.
    ///
    /// # Example
    /// ```rust
    /// NodeData::create_div()
    ///     .with_key("user-avatar-123")
    /// ```
    #[inline]
    pub fn with_key<K: core::hash::Hash>(mut self, key: K) -> Self {
        self.set_key(key);
        self
    }

    /// Registers a callback to merge dataset state from the previous frame.
    ///
    /// This is used for components that maintain heavy internal state (video players,
    /// WebGL contexts, network connections) that should not be destroyed and recreated
    /// on every render frame.
    ///
    /// The callback receives both datasets as `RefAny` (cheap shallow clones) and
    /// returns the `RefAny` that should be used for the new node.
    ///
    /// # Example
    /// ```rust
    /// struct VideoPlayer {
    ///     url: String,
    ///     decoder_handle: Option<DecoderHandle>,
    /// }
    ///
    /// extern "C" fn merge_video(new_data: RefAny, old_data: RefAny) -> RefAny {
    ///     if let (Some(mut new), Some(old)) = (
    ///         new_data.downcast_mut::<VideoPlayer>(),
    ///         old_data.downcast_ref::<VideoPlayer>()
    ///     ) {
    ///         new.decoder_handle = old.decoder_handle.take();
    ///     }
    ///     new_data
    /// }
    ///
    /// NodeData::create_div()
    ///     .with_dataset(RefAny::new(VideoPlayer::new("movie.mp4")).into())
    ///     .with_merge_callback(merge_video)
    /// ```
    #[inline]
    pub fn with_merge_callback<C: Into<DatasetMergeCallback>>(mut self, callback: C) -> Self {
        self.set_merge_callback(callback);
        self
    }

    /// Parse CSS from a string and add as unconditional properties
    pub fn set_inline_style(&mut self, style: &str) {
        use azul_css::dynamic_selector::CssPropertyWithConditions;
        let parsed = CssPropertyWithConditionsVec::parse_normal(style);
        let mut current = Vec::new().into();
        mem::swap(&mut current, &mut self.css_props);
        let mut v = current.into_library_owned_vec();
        v.extend(parsed.into_library_owned_vec());
        self.css_props = v.into();
    }

    /// Builder method for setting inline CSS styles for the normal state
    pub fn with_inline_style(mut self, style: &str) -> Self {
        self.set_inline_style(style);
        self
    }

    /// Sets inline CSS styles for the hover state, parsing from a CSS string
    pub fn set_inline_hover_style(&mut self, style: &str) {
        let parsed = CssPropertyWithConditionsVec::parse_hover(style);
        let mut current = Vec::new().into();
        mem::swap(&mut current, &mut self.css_props);
        let mut v = current.into_library_owned_vec();
        v.extend(parsed.into_library_owned_vec());
        self.css_props = v.into();
    }

    /// Builder method for setting inline CSS styles for the hover state
    pub fn with_inline_hover_style(mut self, style: &str) -> Self {
        self.set_inline_hover_style(style);
        self
    }

    /// Sets inline CSS styles for the active state, parsing from a CSS string
    pub fn set_inline_active_style(&mut self, style: &str) {
        let parsed = CssPropertyWithConditionsVec::parse_active(style);
        let mut current = Vec::new().into();
        mem::swap(&mut current, &mut self.css_props);
        let mut v = current.into_library_owned_vec();
        v.extend(parsed.into_library_owned_vec());
        self.css_props = v.into();
    }

    /// Builder method for setting inline CSS styles for the active state
    pub fn with_inline_active_style(mut self, style: &str) -> Self {
        self.set_inline_active_style(style);
        self
    }

    /// Sets inline CSS styles for the focus state, parsing from a CSS string
    pub fn set_inline_focus_style(&mut self, style: &str) {
        let parsed = CssPropertyWithConditionsVec::parse_focus(style);
        let mut current = Vec::new().into();
        mem::swap(&mut current, &mut self.css_props);
        let mut v = current.into_library_owned_vec();
        v.extend(parsed.into_library_owned_vec());
        self.css_props = v.into();
    }

    /// Builder method for setting inline CSS styles for the focus state
    pub fn with_inline_focus_style(mut self, style: &str) -> Self {
        self.set_inline_focus_style(style);
        self
    }

    #[inline(always)]
    pub fn swap_with_default(&mut self) -> Self {
        let mut s = NodeData::create_div();
        mem::swap(&mut s, self);
        s
    }

    #[inline]
    pub fn copy_special(&self) -> Self {
        Self {
            node_type: self.node_type.into_library_owned_nodetype(),
            dataset: match &self.dataset {
                OptionRefAny::None => OptionRefAny::None,
                OptionRefAny::Some(s) => OptionRefAny::Some(s.clone()),
            },
            ids_and_classes: self.ids_and_classes.clone(), /* do not clone the IDs and classes if
                                                            * they are &'static */
            attributes: self.attributes.clone(),
            css_props: self.css_props.clone(),
            callbacks: self.callbacks.clone(),
            tab_index: self.tab_index,
            contenteditable: self.contenteditable,
            extra: self.extra.clone(),
        }
    }

    pub fn is_focusable(&self) -> bool {
        // TODO: do some better analysis of next / first / item
        self.get_tab_index().is_some()
            || self
                .get_callbacks()
                .iter()
                .any(|cb| cb.event.is_focus_callback())
    }

    /// Returns true if this element has "activation behavior" per HTML5 spec.
    ///
    /// Elements with activation behavior can be activated via Enter or Space key
    /// when focused, which generates a synthetic click event.
    ///
    /// Per HTML5 spec, elements with activation behavior include:
    /// - Button elements
    /// - Input elements (submit, button, reset, checkbox, radio)
    /// - Anchor elements with href
    /// - Any element with a click callback (implicit activation)
    ///
    /// See: https://html.spec.whatwg.org/multipage/interaction.html#activation-behavior
    pub fn has_activation_behavior(&self) -> bool {
        use crate::events::{EventFilter, HoverEventFilter};
        
        // Check for click callback (most common case for Azul)
        // In Azul, "click" is typically LeftMouseUp
        let has_click_callback = self
            .get_callbacks()
            .iter()
            .any(|cb| matches!(
                cb.event, 
                EventFilter::Hover(HoverEventFilter::MouseUp) 
                | EventFilter::Hover(HoverEventFilter::LeftMouseUp)
            ));

        if has_click_callback {
            return true;
        }

        // Check accessibility role for button-like elements
        if let Some(ref ext) = self.extra {
            if let Some(ref accessibility) = ext.accessibility {
                use crate::dom::AccessibilityRole;
                match accessibility.role {
                    AccessibilityRole::PushButton  // Button
                    | AccessibilityRole::Link
                    | AccessibilityRole::CheckButton  // Checkbox
                    | AccessibilityRole::RadioButton  // Radio
                    | AccessibilityRole::MenuItem
                    | AccessibilityRole::PageTab  // Tab
                    => return true,
                    _ => {}
                }
            }
        }

        false
    }

    /// Returns true if this element is currently activatable.
    ///
    /// An element is activatable if it has activation behavior AND is not disabled.
    /// This checks for common disability patterns (aria-disabled, disabled attribute).
    pub fn is_activatable(&self) -> bool {
        if !self.has_activation_behavior() {
            return false;
        }

        // Check for disabled state in accessibility info
        if let Some(ref ext) = self.extra {
            if let Some(ref accessibility) = ext.accessibility {
                // Check if explicitly marked as unavailable
                if accessibility
                    .states
                    .as_ref()
                    .iter()
                    .any(|s| matches!(s, AccessibilityState::Unavailable))
                {
                    return false;
                }
            }
        }

        // Not disabled, so activatable
        true
    }

    /// Returns the tab index for this element.
    ///
    /// Tab index determines keyboard navigation order:
    /// - `None`: Not in tab order (unless naturally focusable)
    /// - `Some(-1)`: Focusable programmatically but not via Tab
    /// - `Some(0)`: In natural tab order
    /// - `Some(n > 0)`: In tab order with priority n (higher = later)
    pub fn get_effective_tabindex(&self) -> Option<i32> {
        match self.tab_index {
            OptionTabIndex::None => {
                // Check if naturally focusable (has focus callback)
                if self.get_callbacks().iter().any(|cb| cb.event.is_focus_callback()) {
                    Some(0)
                } else {
                    None
                }
            }
            OptionTabIndex::Some(tab_idx) => {
                match tab_idx {
                    TabIndex::Auto => Some(0),
                    TabIndex::OverrideInParent(n) => Some(n as i32),
                    TabIndex::NoKeyboardFocus => Some(-1),
                }
            }
        }
    }

    pub fn get_iframe_node(&mut self) -> Option<&mut IFrameNode> {
        match &mut self.node_type {
            NodeType::IFrame(i) => Some(i),
            _ => None,
        }
    }

    pub fn get_render_image_callback_node<'a>(
        &'a mut self,
    ) -> Option<(&'a mut CoreImageCallback, ImageRefHash)> {
        match &mut self.node_type {
            NodeType::Image(img) => {
                let hash = image_ref_get_hash(&img);
                img.get_image_callback_mut().map(|r| (r, hash))
            }
            _ => None,
        }
    }

    pub fn debug_print_start(
        &self,
        css_cache: &CssPropertyCache,
        node_id: &NodeId,
        node_state: &StyledNodeState,
    ) -> String {
        let html_type = self.node_type.get_path();
        let attributes_string = node_data_to_string(&self);
        let style = css_cache.get_computed_css_style_string(&self, node_id, node_state);
        format!(
            "<{} data-az-node-id=\"{}\" {} {style}>",
            html_type,
            node_id.index(),
            attributes_string,
            style = if style.trim().is_empty() {
                String::new()
            } else {
                format!("style=\"{style}\"")
            }
        )
    }

    pub fn debug_print_end(&self) -> String {
        let html_type = self.node_type.get_path();
        format!("</{}>", html_type)
    }
}

/// A unique, runtime-generated identifier for a single `Dom` instance.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(C)]
pub struct DomId {
    pub inner: usize,
}

impl fmt::Display for DomId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}

impl DomId {
    pub const ROOT_ID: DomId = DomId { inner: 0 };
}

impl Default for DomId {
    fn default() -> DomId {
        DomId::ROOT_ID
    }
}

impl_option!(
    DomId,
    OptionDomId,
    [Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

impl_vec!(DomId, DomIdVec, DomIdVecDestructor, DomIdVecDestructorType);
impl_vec_debug!(DomId, DomIdVec);
impl_vec_clone!(DomId, DomIdVec, DomIdVecDestructor);
impl_vec_partialeq!(DomId, DomIdVec);
impl_vec_partialord!(DomId, DomIdVec);

/// A UUID for a DOM node within a `LayoutWindow`.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct DomNodeId {
    /// The ID of the `Dom` this node belongs to.
    pub dom: DomId,
    /// The hierarchical ID of the node within its `Dom`.
    pub node: NodeHierarchyItemId,
}

impl_option!(
    DomNodeId,
    OptionDomNodeId,
    [Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

impl DomNodeId {
    pub const ROOT: DomNodeId = DomNodeId {
        dom: DomId::ROOT_ID,
        node: NodeHierarchyItemId::NONE,
    };
}

/// The document model, similar to HTML. This is a create-only structure, you don't actually read
/// anything back from it. It's designed for ease of construction.
#[repr(C)]
#[derive(PartialEq, Clone, Eq, Hash, PartialOrd, Ord)]
pub struct Dom {
    /// The data for the root node of this DOM (or sub-DOM).
    pub root: NodeData,
    /// The children of this DOM node.
    pub children: DomVec,
    // Tracks the number of sub-children of the current children, so that
    // the `Dom` can be converted into a `CompactDom`.
    pub estimated_total_children: usize,
}

impl_option!(
    Dom,
    OptionDom,
    copy = false,
    [Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

impl_vec!(Dom, DomVec, DomVecDestructor, DomVecDestructorType);
impl_vec_clone!(Dom, DomVec, DomVecDestructor);
impl_vec_mut!(Dom, DomVec);
impl_vec_debug!(Dom, DomVec);
impl_vec_partialord!(Dom, DomVec);
impl_vec_ord!(Dom, DomVec);
impl_vec_partialeq!(Dom, DomVec);
impl_vec_eq!(Dom, DomVec);
impl_vec_hash!(Dom, DomVec);

impl Dom {
    // ----- DOM CONSTRUCTORS

    /// Creates an empty DOM with a give `NodeType`. Note: This is a `const fn` and
    /// doesn't allocate, it only allocates once you add at least one child node.
    #[inline(always)]
    pub fn create_node(node_type: NodeType) -> Self {
        Self {
            root: NodeData::create_node(node_type),
            children: Vec::new().into(),
            estimated_total_children: 0,
        }
    }
    #[inline(always)]
    pub fn from_data(node_data: NodeData) -> Self {
        Self {
            root: node_data,
            children: Vec::new().into(),
            estimated_total_children: 0,
        }
    }

    // Document Structure Elements

    /// Creates the root HTML element.
    ///
    /// **Accessibility**: The `<html>` element is the root of an HTML document and should have a
    /// `lang` attribute.
    #[inline(always)]
    pub const fn create_html() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Html),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates the document head element.
    ///
    /// **Accessibility**: The `<head>` contains metadata. Use `<title>` for page titles.
    #[inline(always)]
    pub const fn create_head() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Head),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    #[inline(always)]
    pub const fn create_body() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Body),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a generic block-level container.
    ///
    /// **Accessibility**: Prefer semantic elements like `<article>`, `<section>`, `<nav>` when
    /// applicable.
    #[inline(always)]
    pub const fn create_div() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Div),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    // Semantic Structure Elements

    /// Creates an article element.
    ///
    /// **Accessibility**: Represents self-contained content that could be distributed
    /// independently. Screen readers can navigate by articles. Consider adding aria-label for
    /// multiple articles.
    #[inline(always)]
    pub const fn create_article() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Article),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a section element.
    ///
    /// **Accessibility**: Represents a thematic grouping of content with a heading.
    /// Should typically have a heading (h1-h6) as a child. Consider aria-labelledby.
    #[inline(always)]
    pub const fn create_section() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Section),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a navigation element.
    ///
    /// **Accessibility**: Represents navigation links. Screen readers can jump to navigation.
    /// Use aria-label to distinguish multiple nav elements (e.g., "Main navigation", "Footer
    /// links").
    #[inline(always)]
    pub const fn create_nav() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Nav),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates an aside element.
    ///
    /// **Accessibility**: Represents content tangentially related to main content (sidebars,
    /// callouts). Screen readers announce this as complementary content.
    #[inline(always)]
    pub const fn create_aside() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Aside),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a header element.
    ///
    /// **Accessibility**: Represents introductory content or navigational aids.
    /// Can be used for page headers or section headers.
    #[inline(always)]
    pub const fn create_header() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Header),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a footer element.
    ///
    /// **Accessibility**: Represents footer for nearest section or page.
    /// Typically contains copyright, author info, or related links.
    #[inline(always)]
    pub const fn create_footer() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Footer),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a main content element.
    ///
    /// **Accessibility**: Represents the dominant content. There should be only ONE main per page.
    /// Screen readers can jump directly to main content. Do not nest inside
    /// article/aside/footer/header/nav.
    #[inline(always)]
    pub const fn create_main() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Main),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a figure element.
    ///
    /// **Accessibility**: Represents self-contained content like diagrams, photos, code listings.
    /// Use with `<figcaption>` to provide a caption. Screen readers associate caption with figure.
    #[inline(always)]
    pub const fn create_figure() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Figure),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a figure caption element.
    ///
    /// **Accessibility**: Provides a caption for `<figure>`. Screen readers announce this as the
    /// figure description.
    #[inline(always)]
    pub const fn create_figcaption() -> Self {
        Self {
            root: NodeData::create_node(NodeType::FigCaption),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    // Interactive Elements

    /// Creates a details disclosure element.
    ///
    /// **Accessibility**: Creates a disclosure widget. Screen readers announce expanded/collapsed
    /// state. Must contain a `<summary>` element. Keyboard accessible by default.
    #[inline(always)]
    pub const fn create_details() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Details),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a summary element for details.
    ///
    /// **Accessibility**: The visible heading/label for `<details>`.
    /// Must be the first child of details. Keyboard accessible (Enter/Space to toggle).
    #[inline]
    pub fn summary<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::Summary),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a dialog element.
    ///
    /// **Accessibility**: Represents a modal or non-modal dialog.
    /// When opened as modal, focus is trapped. Use aria-label or aria-labelledby.
    /// Escape key should close modal dialogs.
    #[inline(always)]
    pub const fn create_dialog() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Dialog),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    // Basic Structural Elements

    #[inline(always)]
    pub const fn create_br() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Br),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }
    #[inline(always)]
    pub fn create_text<S: Into<AzString>>(value: S) -> Self {
        Self::create_node(NodeType::Text(value.into()))
    }
    #[inline(always)]
    pub fn create_image(image: ImageRef) -> Self {
        Self::create_node(NodeType::Image(image))
    }
    /// Creates an icon node with the given icon name.
    ///
    /// The icon name should match names from the icon provider (e.g., "home", "settings", "search").
    /// Icons are resolved to actual content (font glyph, image, etc.) during StyledDom creation
    /// based on the configured IconProvider.
    ///
    /// # Example
    /// ```rust,ignore
    /// Dom::create_icon("home")
    ///     .with_class("nav-icon")
    /// ```
    #[inline(always)]
    pub fn create_icon<S: Into<AzString>>(icon_name: S) -> Self {
        Self::create_node(NodeType::Icon(icon_name.into()))
    }

    #[inline(always)]
    pub fn create_iframe(data: RefAny, callback: impl Into<IFrameCallback>) -> Self {
        Self::create_node(NodeType::IFrame(IFrameNode {
            callback: callback.into(),
            refany: data,
        }))
    }

    // Semantic HTML Elements with Accessibility Guidance

    /// Creates a paragraph element.
    ///
    /// **Accessibility**: Paragraphs provide semantic structure for screen readers.
    #[inline(always)]
    pub const fn create_p() -> Self {
        Self {
            root: NodeData::create_node(NodeType::P),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a heading level 1 element.
    ///
    /// **Accessibility**: Use `h1` for the main page title. There should typically be only one `h1`
    /// per page.
    ///
    /// **Parameters:**
    /// - `text`: Heading text
    #[inline]
    pub fn h1<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::H1),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a heading level 2 element.
    ///
    /// **Accessibility**: Use `h2` for major section headings under `h1`.
    ///
    /// **Parameters:**
    /// - `text`: Heading text
    #[inline]
    pub fn h2<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::H2),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a heading level 3 element.
    ///
    /// **Accessibility**: Use `h3` for subsections under `h2`.
    ///
    /// **Parameters:**
    /// - `text`: Heading text
    #[inline]
    pub fn h3<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::H3),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a heading level 4 element.
    ///
    /// **Parameters:**
    /// - `text`: Heading text
    #[inline]
    pub fn h4<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::H4),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a heading level 5 element.
    ///
    /// **Parameters:**
    /// - `text`: Heading text
    #[inline]
    pub fn h5<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::H5),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a heading level 6 element.
    ///
    /// **Parameters:**
    /// - `text`: Heading text
    #[inline]
    pub fn h6<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::H6),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a generic inline container (span).
    ///
    /// **Accessibility**: Prefer semantic elements like `strong`, `em`, `code`, etc. when
    /// applicable.
    ///
    /// **Parameters:**
    /// - `text`: Span content
    #[inline]
    pub fn span<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::Span),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a strongly emphasized text element (strong importance).
    ///
    /// **Accessibility**: Use `strong` instead of `b` for semantic meaning. Screen readers can
    /// convey the importance. Use for text that has strong importance, seriousness, or urgency.
    ///
    /// **Parameters:**
    /// - `text`: Text to emphasize
    #[inline]
    pub fn strong<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::Strong),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates an emphasized text element (stress emphasis).
    ///
    /// **Accessibility**: Use `em` instead of `i` for semantic meaning. Screen readers can
    /// convey the emphasis. Use for text that has stress emphasis.
    ///
    /// **Parameters:**
    /// - `text`: Text to emphasize
    #[inline]
    pub fn em<S: Into<AzString>>(text: S) -> Self {
        Self {
            root: NodeData::create_node(NodeType::Em),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
        .with_child(Self::create_text(text))
    }

    /// Creates a code/computer code element.
    ///
    /// **Accessibility**: Represents a fragment of computer code. Screen readers can identify
    /// this as code content.
    ///
    /// **Parameters:**
    /// - `code`: Code content
    #[inline]
    pub fn code<S: Into<AzString>>(code: S) -> Self {
        Self::create_node(NodeType::Code).with_child(Self::create_text(code))
    }

    /// Creates a preformatted text element.
    ///
    /// **Accessibility**: Preserves whitespace and line breaks. Useful for code blocks or
    /// ASCII art. Screen readers will read the content as-is.
    ///
    /// **Parameters:**
    /// - `text`: Preformatted content
    #[inline]
    pub fn pre<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Pre).with_child(Self::create_text(text))
    }

    /// Creates a blockquote element.
    ///
    /// **Accessibility**: Represents a section quoted from another source. Screen readers
    /// can identify quoted content. Consider adding a `cite` attribute.
    ///
    /// **Parameters:**
    /// - `text`: Quote content
    #[inline]
    pub fn blockquote<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::BlockQuote).with_child(Self::create_text(text))
    }

    /// Creates a citation element.
    ///
    /// **Accessibility**: Represents a reference to a creative work. Screen readers can
    /// identify citations.
    ///
    /// **Parameters:**
    /// - `text`: Citation text
    #[inline]
    pub fn cite<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Cite).with_child(Self::create_text(text))
    }

    /// Creates an abbreviation element.
    ///
    /// **Accessibility**: Represents an abbreviation or acronym. Use with a `title` attribute
    /// to provide the full expansion for screen readers.
    ///
    /// **Parameters:**
    /// - `abbr_text`: Abbreviated text
    /// - `title`: Full expansion
    #[inline]
    pub fn create_abbr(abbr_text: AzString, title: AzString) -> Self {
        Self::create_node(NodeType::Abbr)
            .with_attribute(AttributeType::Title(title))
            .with_child(Self::create_text(abbr_text))
    }

    /// Creates a keyboard input element.
    ///
    /// **Accessibility**: Represents keyboard input or key combinations. Screen readers can
    /// identify keyboard instructions.
    ///
    /// **Parameters:**
    /// - `text`: Keyboard instruction
    #[inline]
    pub fn kbd<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Kbd).with_child(Self::create_text(text))
    }

    /// Creates a sample output element.
    ///
    /// **Accessibility**: Represents sample output from a program or computing system.
    ///
    /// **Parameters:**
    /// - `text`: Sample text
    #[inline]
    pub fn samp<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Samp).with_child(Self::create_text(text))
    }

    /// Creates a variable element.
    ///
    /// **Accessibility**: Represents a variable in mathematical expressions or programming.
    ///
    /// **Parameters:**
    /// - `text`: Variable name
    #[inline]
    pub fn var<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Var).with_child(Self::create_text(text))
    }

    /// Creates a subscript element.
    ///
    /// **Accessibility**: Screen readers may announce subscript formatting.
    ///
    /// **Parameters:**
    /// - `text`: Subscript content
    #[inline]
    pub fn sub<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Sub).with_child(Self::create_text(text))
    }

    /// Creates a superscript element.
    ///
    /// **Accessibility**: Screen readers may announce superscript formatting.
    ///
    /// **Parameters:**
    /// - `text`: Superscript content
    #[inline]
    pub fn sup<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Sup).with_child(Self::create_text(text))
    }

    /// Creates an underline text element.
    ///
    /// **Accessibility**: Screen readers typically don't announce underline formatting.
    /// Use semantic elements when possible (e.g., `<em>` for emphasis).
    #[inline]
    pub fn u<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::U).with_child(Self::create_text(text))
    }

    /// Creates a strikethrough text element.
    ///
    /// **Accessibility**: Represents text that is no longer accurate or relevant.
    /// Consider using `<del>` for deleted content with datetime attribute.
    #[inline]
    pub fn s<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::S).with_child(Self::create_text(text))
    }

    /// Creates a marked/highlighted text element.
    ///
    /// **Accessibility**: Represents text marked for reference or notation purposes.
    /// Screen readers may announce this as "highlighted".
    #[inline]
    pub fn mark<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Mark).with_child(Self::create_text(text))
    }

    /// Creates a deleted text element.
    ///
    /// **Accessibility**: Represents deleted content in document edits.
    /// Use with `datetime` and `cite` attributes for edit tracking.
    #[inline]
    pub fn del<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Del).with_child(Self::create_text(text))
    }

    /// Creates an inserted text element.
    ///
    /// **Accessibility**: Represents inserted content in document edits.
    /// Use with `datetime` and `cite` attributes for edit tracking.
    #[inline]
    pub fn ins<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Ins).with_child(Self::create_text(text))
    }

    /// Creates a definition element.
    ///
    /// **Accessibility**: Represents the defining instance of a term.
    /// Often used within a definition list or with `<abbr>`.
    #[inline]
    pub fn dfn<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Dfn).with_child(Self::create_text(text))
    }

    /// Creates a time element.
    ///
    /// **Accessibility**: Represents a specific time or date.
    /// Use `datetime` attribute for machine-readable format.
    ///
    /// **Parameters:**
    /// - `text`: Human-readable time/date
    /// - `datetime`: Optional machine-readable datetime
    #[inline]
    pub fn create_time(text: AzString, datetime: OptionString) -> Self {
        let mut element = Self::create_node(NodeType::Time).with_child(Self::create_text(text));
        if let OptionString::Some(dt) = datetime {
            element = element.with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "datetime".into(),
                value: dt,
            }));
        }
        element
    }

    /// Creates a bi-directional override element.
    ///
    /// **Accessibility**: Overrides text direction. Use `dir` attribute (ltr/rtl).
    #[inline]
    pub fn bdo<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Bdo).with_child(Self::create_text(text))
    }

    /// Creates an anchor/hyperlink element.
    ///
    /// **Accessibility**: Always provide meaningful link text. Avoid "click here" or "read more".
    /// Screen readers often navigate by links, so descriptive text is crucial.
    ///
    /// **Parameters:**
    /// - `href`: Link destination URL
    /// - `label`: Link text (pass `None` for image-only links with alt text)
    #[inline]
    pub fn create_a(href: AzString, label: OptionString) -> Self {
        let mut link = Self::create_node(NodeType::A).with_attribute(AttributeType::Href(href));
        if let OptionString::Some(text) = label {
            link = link.with_child(Self::create_text(text));
        }
        link
    }

    /// Creates a button element.
    ///
    /// **Accessibility**: Buttons are keyboard accessible by default. Always provide clear
    /// button text or an `aria-label` for icon-only buttons.
    ///
    /// **Parameters:**
    /// - `text`: Button label text
    #[inline]
    pub fn create_button(text: AzString) -> Self {
        Self::create_node(NodeType::Button).with_child(Self::create_text(text))
    }

    /// Creates a label element for form controls.
    ///
    /// **Accessibility**: Always associate labels with form controls using `for` attribute
    /// or by wrapping the control. This is critical for screen reader users.
    ///
    /// **Parameters:**
    /// - `for_id`: ID of the associated form control
    /// - `text`: Label text
    #[inline]
    pub fn create_label(for_id: AzString, text: AzString) -> Self {
        Self::create_node(NodeType::Label)
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "for".into(),
                value: for_id,
            }))
            .with_child(Self::create_text(text))
    }

    /// Creates an input element.
    ///
    /// **Accessibility**: Always provide a label or `aria-label`. Set appropriate `type`
    /// and `aria-` attributes for the input's purpose.
    ///
    /// **Parameters:**
    /// - `input_type`: Input type (text, password, email, etc.)
    /// - `name`: Form field name
    /// - `label`: Accessibility label (required)
    #[inline]
    pub fn create_input(input_type: AzString, name: AzString, label: AzString) -> Self {
        Self::create_node(NodeType::Input)
            .with_attribute(AttributeType::InputType(input_type))
            .with_attribute(AttributeType::Name(name))
            .with_attribute(AttributeType::AriaLabel(label))
    }

    /// Creates a textarea element.
    ///
    /// **Accessibility**: Always provide a label or `aria-label`. Consider `aria-describedby`
    /// for additional instructions.
    ///
    /// **Parameters:**
    /// - `name`: Form field name
    /// - `label`: Accessibility label (required)
    #[inline]
    pub fn create_textarea(name: AzString, label: AzString) -> Self {
        Self::create_node(NodeType::TextArea)
            .with_attribute(AttributeType::Name(name))
            .with_attribute(AttributeType::AriaLabel(label))
    }

    /// Creates a select dropdown element.
    ///
    /// **Accessibility**: Always provide a label. Group related options with `optgroup`.
    ///
    /// **Parameters:**
    /// - `name`: Form field name
    /// - `label`: Accessibility label (required)
    #[inline]
    pub fn create_select(name: AzString, label: AzString) -> Self {
        Self::create_node(NodeType::Select)
            .with_attribute(AttributeType::Name(name))
            .with_attribute(AttributeType::AriaLabel(label))
    }

    /// Creates an option element for select dropdowns.
    ///
    /// **Parameters:**
    /// - `value`: Option value
    /// - `text`: Display text
    #[inline]
    pub fn create_option(value: AzString, text: AzString) -> Self {
        Self::create_node(NodeType::SelectOption)
            .with_attribute(AttributeType::Value(value))
            .with_child(Self::create_text(text))
    }

    /// Creates an unordered list element.
    ///
    /// **Accessibility**: Screen readers announce lists and item counts, helping users
    /// understand content structure.
    #[inline(always)]
    pub fn create_ul() -> Self {
        Self::create_node(NodeType::Ul)
    }

    /// Creates an ordered list element.
    ///
    /// **Accessibility**: Screen readers announce lists and item counts, helping users
    /// understand content structure and numbering.
    #[inline(always)]
    pub fn create_ol() -> Self {
        Self::create_node(NodeType::Ol)
    }

    /// Creates a list item element.
    ///
    /// **Accessibility**: Must be a child of `ul`, `ol`, or `menu`. Screen readers announce
    /// list item position (e.g., "2 of 5").
    #[inline(always)]
    pub fn create_li() -> Self {
        Self::create_node(NodeType::Li)
    }

    /// Creates a table element.
    ///
    /// **Accessibility**: Use proper table structure with `thead`, `tbody`, `th`, and `td`.
    /// Provide a `caption` for table purpose. Use `scope` attribute on header cells.
    #[inline(always)]
    pub fn create_table() -> Self {
        Self::create_node(NodeType::Table)
    }

    /// Creates a table caption element.
    ///
    /// **Accessibility**: Describes the purpose of the table. Screen readers announce this first.
    #[inline(always)]
    pub fn create_caption() -> Self {
        Self::create_node(NodeType::Caption)
    }

    /// Creates a table header element.
    ///
    /// **Accessibility**: Groups header rows. Screen readers can navigate table structure.
    #[inline(always)]
    pub fn create_thead() -> Self {
        Self::create_node(NodeType::THead)
    }

    /// Creates a table body element.
    ///
    /// **Accessibility**: Groups body rows. Screen readers can navigate table structure.
    #[inline(always)]
    pub fn create_tbody() -> Self {
        Self::create_node(NodeType::TBody)
    }

    /// Creates a table footer element.
    ///
    /// **Accessibility**: Groups footer rows. Screen readers can navigate table structure.
    #[inline(always)]
    pub fn create_tfoot() -> Self {
        Self::create_node(NodeType::TFoot)
    }

    /// Creates a table row element.
    #[inline(always)]
    pub fn create_tr() -> Self {
        Self::create_node(NodeType::Tr)
    }

    /// Creates a table header cell element.
    ///
    /// **Accessibility**: Use `scope` attribute ("col" or "row") to associate headers with
    /// data cells. Screen readers use this to announce cell context.
    #[inline(always)]
    pub fn create_th() -> Self {
        Self::create_node(NodeType::Th)
    }

    /// Creates a table data cell element.
    #[inline(always)]
    pub fn create_td() -> Self {
        Self::create_node(NodeType::Td)
    }

    /// Creates a form element.
    ///
    /// **Accessibility**: Group related form controls with `fieldset` and `legend`.
    /// Provide clear labels for all inputs. Consider `aria-describedby` for instructions.
    #[inline(always)]
    pub fn create_form() -> Self {
        Self::create_node(NodeType::Form)
    }

    /// Creates a fieldset element for grouping form controls.
    ///
    /// **Accessibility**: Groups related form controls. Always include a `legend` as the
    /// first child to describe the group. Screen readers announce the legend when entering
    /// the fieldset.
    #[inline(always)]
    pub fn create_fieldset() -> Self {
        Self::create_node(NodeType::FieldSet)
    }

    /// Creates a legend element for fieldsets.
    ///
    /// **Accessibility**: Describes the purpose of a fieldset. Must be the first child of
    /// a fieldset. Screen readers announce this when entering the fieldset.
    #[inline(always)]
    pub fn create_legend() -> Self {
        Self::create_node(NodeType::Legend)
    }

    /// Creates a horizontal rule element.
    ///
    /// **Accessibility**: Represents a thematic break. Screen readers may announce this as
    /// a separator. Consider using CSS borders for purely decorative lines.
    #[inline(always)]
    pub fn create_hr() -> Self {
        Self::create_node(NodeType::Hr)
    }

    // Additional Element Constructors

    /// Creates an address element.
    ///
    /// **Accessibility**: Represents contact information. Screen readers identify this
    /// as address content.
    #[inline(always)]
    pub const fn create_address() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Address),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a definition list element.
    ///
    /// **Accessibility**: Screen readers announce definition lists and their structure.
    #[inline(always)]
    pub const fn create_dl() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Dl),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a definition term element.
    ///
    /// **Accessibility**: Must be a child of `dl`. Represents the term being defined.
    #[inline(always)]
    pub const fn create_dt() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Dt),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a definition description element.
    ///
    /// **Accessibility**: Must be a child of `dl`. Provides the definition for the term.
    #[inline(always)]
    pub const fn create_dd() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Dd),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a table column group element.
    #[inline(always)]
    pub const fn create_colgroup() -> Self {
        Self {
            root: NodeData::create_node(NodeType::ColGroup),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a table column element.
    #[inline]
    pub fn create_col(span: i32) -> Self {
        Self::create_node(NodeType::Col).with_attribute(AttributeType::ColSpan(span))
    }

    /// Creates an optgroup element for grouping select options.
    ///
    /// **Parameters:**
    /// - `label`: Label for the option group
    #[inline]
    pub fn create_optgroup(label: AzString) -> Self {
        Self::create_node(NodeType::OptGroup).with_attribute(AttributeType::AriaLabel(label))
    }

    /// Creates a quotation element.
    ///
    /// **Accessibility**: Represents an inline quotation.
    #[inline(always)]
    pub const fn create_q() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Q),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates an acronym element.
    ///
    /// **Note**: Deprecated in HTML5. Consider using `abbr()` instead.
    #[inline(always)]
    pub const fn acronym() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Acronym),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a menu element.
    ///
    /// **Accessibility**: Represents a list of commands. Similar to `<ul>` but semantic for
    /// toolbars/menus.
    #[inline(always)]
    pub const fn create_menu() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Menu),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a menu item element.
    ///
    /// **Accessibility**: Represents a command in a menu. Use with appropriate role/aria
    /// attributes.
    #[inline(always)]
    pub const fn menuitem() -> Self {
        Self {
            root: NodeData::create_node(NodeType::MenuItem),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates an output element.
    ///
    /// **Accessibility**: Represents the result of a calculation or user action.
    /// Use `for` attribute to associate with input elements. Screen readers announce updates.
    #[inline(always)]
    pub const fn create_output() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Output),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a progress indicator element.
    ///
    /// **Accessibility**: Represents task progress. Use `value` and `max` attributes.
    /// Screen readers announce progress percentage. Use aria-label to describe the task.
    #[inline]
    pub fn create_progress(value: f32, max: f32) -> Self {
        Self::create_node(NodeType::Progress)
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "value".into(),
                value: value.to_string().into(),
            }))
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "max".into(),
                value: max.to_string().into(),
            }))
    }

    /// Creates a meter gauge element.
    ///
    /// **Accessibility**: Represents a scalar measurement within a known range.
    /// Use `value`, `min`, `max`, `low`, `high`, `optimum` attributes.
    /// Screen readers announce the measurement. Provide aria-label for context.
    #[inline]
    pub fn create_meter(value: f32, min: f32, max: f32) -> Self {
        Self::create_node(NodeType::Meter)
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "value".into(),
                value: value.to_string().into(),
            }))
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "min".into(),
                value: min.to_string().into(),
            }))
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "max".into(),
                value: max.to_string().into(),
            }))
    }

    /// Creates a datalist element for input suggestions.
    ///
    /// **Accessibility**: Provides autocomplete options for inputs.
    /// Associate with input using `list` attribute. Screen readers announce available options.
    #[inline(always)]
    pub const fn create_datalist() -> Self {
        Self {
            root: NodeData::create_node(NodeType::DataList),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    // Embedded Content Elements

    /// Creates a canvas element for graphics.
    ///
    /// **Accessibility**: Canvas content is not accessible by default.
    /// Always provide fallback content as children and/or detailed aria-label.
    /// Consider using SVG for accessible graphics when possible.
    #[inline(always)]
    pub const fn create_canvas() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Canvas),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates an object element for embedded content.
    ///
    /// **Accessibility**: Provide fallback content as children. Use aria-label to describe content.
    #[inline(always)]
    pub const fn create_object() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Object),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a param element for object parameters.
    ///
    /// **Parameters:**
    /// - `name`: Parameter name
    /// - `value`: Parameter value
    #[inline]
    pub fn create_param(name: AzString, value: AzString) -> Self {
        Self::create_node(NodeType::Param)
            .with_attribute(AttributeType::Name(name))
            .with_attribute(AttributeType::Value(value))
    }

    /// Creates an embed element.
    ///
    /// **Accessibility**: Provide alternative content or link. Use aria-label to describe embedded
    /// content.
    #[inline(always)]
    pub const fn create_embed() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Embed),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates an audio element.
    ///
    /// **Accessibility**: Always provide controls. Use `<track>` for captions/subtitles.
    /// Provide fallback text for unsupported browsers.
    #[inline(always)]
    pub const fn create_audio() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Audio),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a video element.
    ///
    /// **Accessibility**: Always provide controls. Use `<track>` for
    /// captions/subtitles/descriptions. Provide fallback text. Consider providing transcript.
    #[inline(always)]
    pub const fn create_video() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Video),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a source element for media.
    ///
    /// **Parameters:**
    /// - `src`: Media source URL
    /// - `media_type`: MIME type (e.g., "video/mp4", "audio/ogg")
    #[inline]
    pub fn create_source(src: AzString, media_type: AzString) -> Self {
        Self::create_node(NodeType::Source)
            .with_attribute(AttributeType::Src(src))
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "type".into(),
                value: media_type,
            }))
    }

    /// Creates a track element for media captions/subtitles.
    ///
    /// **Accessibility**: Essential for deaf/hard-of-hearing users and non-native speakers.
    /// Use `kind` (subtitles/captions/descriptions), `srclang`, and `label` attributes.
    ///
    /// **Parameters:**
    /// - `src`: Track file URL (WebVTT format)
    /// - `kind`: Track kind ("subtitles", "captions", "descriptions", "chapters", "metadata")
    #[inline]
    pub fn create_track(src: AzString, kind: AzString) -> Self {
        Self::create_node(NodeType::Track)
            .with_attribute(AttributeType::Src(src))
            .with_attribute(AttributeType::Custom(AttributeNameValue {
                attr_name: "kind".into(),
                value: kind,
            }))
    }

    /// Creates a map element for image maps.
    ///
    /// **Accessibility**: Provide text alternatives. Ensure all areas have alt text.
    #[inline(always)]
    pub const fn create_map() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Map),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates an area element for image map regions.
    ///
    /// **Accessibility**: Always provide `alt` text describing the region/link purpose.
    /// Keyboard users should be able to navigate areas.
    #[inline(always)]
    pub const fn create_area() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Area),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    // Metadata Elements

    /// Creates a title element for document title.
    ///
    /// **Accessibility**: Required for all pages. Screen readers announce this first.
    /// Should be unique and descriptive. Keep under 60 characters.
    #[inline]
    pub fn title<S: Into<AzString>>(text: S) -> Self {
        Self::create_node(NodeType::Title).with_child(Self::create_text(text))
    }

    /// Creates a meta element.
    ///
    /// **Accessibility**: Use for charset, viewport, description. Crucial for proper text display.
    #[inline(always)]
    pub const fn meta() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Meta),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a link element for external resources.
    ///
    /// **Accessibility**: Use for stylesheets, icons, alternate versions.
    /// Provide meaningful `title` attribute for alternate stylesheets.
    #[inline(always)]
    pub const fn create_link() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Link),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a script element.
    ///
    /// **Accessibility**: Ensure scripted content is accessible.
    /// Provide noscript fallbacks for critical functionality.
    #[inline(always)]
    pub const fn create_script() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Script),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a style element for embedded CSS.
    ///
    /// **Note**: In Azul, use the `.style()` method instead for styling.
    /// This creates a `<style>` HTML element for embedded stylesheets.
    #[inline(always)]
    pub const fn style_element() -> Self {
        Self {
            root: NodeData::create_node(NodeType::Style),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        }
    }

    /// Creates a base element for document base URL.
    ///
    /// **Parameters:**
    /// - `href`: Base URL for relative URLs in the document
    #[inline]
    pub fn base(href: AzString) -> Self {
        Self::create_node(NodeType::Base).with_attribute(AttributeType::Href(href))
    }

    // Advanced Constructors with Parameters

    /// Creates a table header cell with scope.
    ///
    /// **Parameters:**
    /// - `scope`: "col", "row", "colgroup", or "rowgroup"
    /// - `text`: Header text
    ///
    /// **Accessibility**: The scope attribute is crucial for associating headers with data cells.
    #[inline]
    pub fn th_with_scope(scope: AzString, text: AzString) -> Self {
        Self::create_node(NodeType::Th)
            .with_attribute(AttributeType::Scope(scope))
            .with_child(Self::create_text(text))
    }

    /// Creates a table data cell with text.
    ///
    /// **Parameters:**
    /// - `text`: Cell content
    #[inline]
    pub fn td_with_text<S: Into<AzString>>(text: S) -> Self {
        Self::create_td().with_child(Self::create_text(text))
    }

    /// Creates a table header cell with text.
    ///
    /// **Parameters:**
    /// - `text`: Header text
    #[inline]
    pub fn th_with_text<S: Into<AzString>>(text: S) -> Self {
        Self::create_th().with_child(Self::create_text(text))
    }

    /// Creates a list item with text.
    ///
    /// **Parameters:**
    /// - `text`: List item content
    #[inline]
    pub fn li_with_text<S: Into<AzString>>(text: S) -> Self {
        Self::create_li().with_child(Self::create_text(text))
    }

    /// Creates a paragraph with text.
    ///
    /// **Parameters:**
    /// - `text`: Paragraph content
    #[inline]
    pub fn p_with_text<S: Into<AzString>>(text: S) -> Self {
        Self::create_p().with_child(Self::create_text(text))
    }

    // Accessibility-Aware Constructors
    // These constructors require explicit accessibility information.

    /// Creates a button with text content and accessibility information.
    ///
    /// **Parameters:**
    /// - `text`: The visible button text
    /// - `aria`: Accessibility information (role, description, etc.)
    #[inline]
    pub fn button_with_aria<S: Into<AzString>>(text: S, aria: SmallAriaInfo) -> Self {
        let mut btn = Self::create_button(text.into());
        btn.root.set_accessibility_info(aria.to_full_info());
        btn
    }

    /// Creates a link (anchor) with href, text, and accessibility information.
    ///
    /// **Parameters:**
    /// - `href`: The link destination
    /// - `text`: The visible link text
    /// - `aria`: Accessibility information (expanded description, etc.)
    #[inline]
    pub fn link_with_aria<S1: Into<AzString>, S2: Into<AzString>>(
        href: S1,
        text: S2,
        aria: SmallAriaInfo,
    ) -> Self {
        let mut link = Self::create_a(href.into(), OptionString::Some(text.into()));
        link.root.set_accessibility_info(aria.to_full_info());
        link
    }

    /// Creates an input element with type, name, and accessibility information.
    ///
    /// **Parameters:**
    /// - `input_type`: The input type (text, password, email, etc.)
    /// - `name`: The form field name
    /// - `label`: Base accessibility label
    /// - `aria`: Additional accessibility information (description, etc.)
    #[inline]
    pub fn input_with_aria<S1: Into<AzString>, S2: Into<AzString>, S3: Into<AzString>>(
        input_type: S1,
        name: S2,
        label: S3,
        aria: SmallAriaInfo,
    ) -> Self {
        let mut input = Self::create_input(input_type.into(), name.into(), label.into());
        input.root.set_accessibility_info(aria.to_full_info());
        input
    }

    /// Creates a textarea with name and accessibility information.
    ///
    /// **Parameters:**
    /// - `name`: The form field name
    /// - `label`: Base accessibility label
    /// - `aria`: Additional accessibility information (description, etc.)
    #[inline]
    pub fn textarea_with_aria<S1: Into<AzString>, S2: Into<AzString>>(
        name: S1,
        label: S2,
        aria: SmallAriaInfo,
    ) -> Self {
        let mut textarea = Self::create_textarea(name.into(), label.into());
        textarea.root.set_accessibility_info(aria.to_full_info());
        textarea
    }

    /// Creates a select dropdown with name and accessibility information.
    ///
    /// **Parameters:**
    /// - `name`: The form field name
    /// - `label`: Base accessibility label
    /// - `aria`: Additional accessibility information (description, etc.)
    #[inline]
    pub fn select_with_aria<S1: Into<AzString>, S2: Into<AzString>>(
        name: S1,
        label: S2,
        aria: SmallAriaInfo,
    ) -> Self {
        let mut select = Self::create_select(name.into(), label.into());
        select.root.set_accessibility_info(aria.to_full_info());
        select
    }

    /// Creates a table with caption and accessibility information.
    ///
    /// **Parameters:**
    /// - `caption`: Table caption (visible title)
    /// - `aria`: Accessibility information describing table purpose
    #[inline]
    pub fn table_with_aria<S: Into<AzString>>(caption: S, aria: SmallAriaInfo) -> Self {
        let mut table = Self::create_table()
            .with_child(Self::create_caption().with_child(Self::create_text(caption)));
        table.root.set_accessibility_info(aria.to_full_info());
        table
    }

    /// Creates a label for a form control with additional accessibility information.
    ///
    /// **Parameters:**
    /// - `for_id`: The ID of the associated form control
    /// - `text`: The visible label text
    /// - `aria`: Additional accessibility information (description, etc.)
    #[inline]
    pub fn label_with_aria<S1: Into<AzString>, S2: Into<AzString>>(
        for_id: S1,
        text: S2,
        aria: SmallAriaInfo,
    ) -> Self {
        let mut label = Self::create_label(for_id.into(), text.into());
        label.root.set_accessibility_info(aria.to_full_info());
        label
    }

    /// Parse XML/XHTML string into a DOM
    ///
    /// This is a simple wrapper that parses XML and converts it to a DOM.
    /// For now, it just creates a text node with the content since full XML parsing
    /// requires the xml feature and more complex parsing logic.
    #[cfg(feature = "xml")]
    pub fn from_xml<S: AsRef<str>>(xml_str: S) -> Self {
        // TODO: Implement full XML parsing
        // For now, just create a text node showing that XML was loaded
        Self::create_text(format!(
            "XML content loaded ({} bytes)",
            xml_str.as_ref().len()
        ))
    }

    /// Parse XML/XHTML string into a DOM (fallback without xml feature)
    #[cfg(not(feature = "xml"))]
    pub fn from_xml<S: AsRef<str>>(xml_str: S) -> Self {
        Self::create_text(format!(
            "XML parsing requires 'xml' feature ({} bytes)",
            xml_str.as_ref().len()
        ))
    }

    // Swaps `self` with a default DOM, necessary for builder methods
    #[inline(always)]
    pub fn swap_with_default(&mut self) -> Self {
        let mut s = Self {
            root: NodeData::create_div(),
            children: DomVec::from_const_slice(&[]),
            estimated_total_children: 0,
        };
        mem::swap(&mut s, self);
        s
    }

    #[inline]
    pub fn add_child(&mut self, child: Dom) {
        let estimated = child.estimated_total_children;
        let mut v: DomVec = Vec::new().into();
        mem::swap(&mut v, &mut self.children);
        let mut v = v.into_library_owned_vec();
        v.push(child);
        self.children = v.into();
        self.estimated_total_children += estimated + 1;
    }

    #[inline(always)]
    pub fn set_children(&mut self, children: DomVec) {
        let children_estimated = children
            .iter()
            .map(|s| s.estimated_total_children + 1)
            .sum();
        self.children = children;
        self.estimated_total_children = children_estimated;
    }

    pub fn copy_except_for_root(&mut self) -> Self {
        Self {
            root: self.root.copy_special(),
            children: self.children.clone(),
            estimated_total_children: self.estimated_total_children,
        }
    }
    pub fn node_count(&self) -> usize {
        self.estimated_total_children + 1
    }

    pub fn style(&mut self, css: azul_css::css::Css) -> StyledDom {
        StyledDom::create(self, css)
    }
    #[inline(always)]
    pub fn with_children(mut self, children: DomVec) -> Self {
        self.set_children(children);
        self
    }
    #[inline(always)]
    pub fn with_child(mut self, child: Self) -> Self {
        self.add_child(child);
        self
    }
    #[inline(always)]
    pub fn with_node_type(mut self, node_type: NodeType) -> Self {
        self.root.set_node_type(node_type);
        self
    }
    #[inline(always)]
    pub fn with_id(mut self, id: AzString) -> Self {
        self.root.add_id(id);
        self
    }
    #[inline(always)]
    pub fn with_class(mut self, class: AzString) -> Self {
        self.root.add_class(class);
        self
    }
    #[inline(always)]
    pub fn with_callback<C: Into<CoreCallback>>(
        mut self,
        event: EventFilter,
        data: RefAny,
        callback: C,
    ) -> Self {
        self.root.add_callback(event, data, callback);
        self
    }
    #[inline(always)]
    pub fn with_css_property(mut self, prop: CssProperty) -> Self {
        self.root.add_css_property(prop);
        self
    }
    #[inline(always)]
    pub fn with_hover_css_property(mut self, prop: CssProperty) -> Self {
        self.root.add_hover_css_property(prop);
        self
    }
    #[inline(always)]
    pub fn with_active_css_property(mut self, prop: CssProperty) -> Self {
        self.root.add_active_css_property(prop);
        self
    }
    #[inline(always)]
    pub fn with_focus_css_property(mut self, prop: CssProperty) -> Self {
        self.root.add_focus_css_property(prop);
        self
    }
    #[inline(always)]
    pub fn with_tab_index(mut self, tab_index: TabIndex) -> Self {
        self.root.set_tab_index(tab_index);
        self
    }
    #[inline(always)]
    pub fn with_contenteditable(mut self, contenteditable: bool) -> Self {
        self.root.set_contenteditable(contenteditable);
        self
    }
    #[inline(always)]
    pub fn with_dataset(mut self, data: OptionRefAny) -> Self {
        self.root.dataset = data;
        self
    }
    #[inline(always)]
    pub fn with_ids_and_classes(mut self, ids_and_classes: IdOrClassVec) -> Self {
        self.root.ids_and_classes = ids_and_classes;
        self
    }

    /// Adds an attribute to this DOM element.
    #[inline(always)]
    pub fn with_attribute(mut self, attr: AttributeType) -> Self {
        let mut attrs = self.root.attributes.clone();
        let mut v = attrs.into_library_owned_vec();
        v.push(attr);
        self.root.attributes = v.into();
        self
    }

    /// Adds multiple attributes to this DOM element.
    #[inline(always)]
    pub fn with_attributes(mut self, attributes: AttributeVec) -> Self {
        self.root.attributes = attributes;
        self
    }

    #[inline(always)]
    pub fn with_callbacks(mut self, callbacks: CoreCallbackDataVec) -> Self {
        self.root.callbacks = callbacks;
        self
    }
    #[inline(always)]
    pub fn with_css_props(mut self, css_props: CssPropertyWithConditionsVec) -> Self {
        self.root.css_props = css_props;
        self
    }

    /// Assigns a stable key to the root node of this DOM for reconciliation.
    ///
    /// This is crucial for performance and correct state preservation when
    /// lists of items change order or items are inserted/removed.
    ///
    /// # Example
    /// ```rust
    /// Dom::create_div()
    ///     .with_key("user-avatar-123")
    /// ```
    #[inline]
    pub fn with_key<K: core::hash::Hash>(mut self, key: K) -> Self {
        self.root.set_key(key);
        self
    }

    /// Registers a callback to merge dataset state from the previous frame.
    ///
    /// This is used for components that maintain heavy internal state (video players,
    /// WebGL contexts, network connections) that should not be destroyed and recreated
    /// on every render frame.
    ///
    /// The callback receives both datasets as `RefAny` (cheap shallow clones) and
    /// returns the `RefAny` that should be used for the new node.
    #[inline]
    pub fn with_merge_callback<C: Into<DatasetMergeCallback>>(mut self, callback: C) -> Self {
        self.root.set_merge_callback(callback);
        self
    }

    pub fn set_inline_style(&mut self, style: &str) {
        self.root.set_inline_style(style);
    }

    pub fn with_inline_style(mut self, style: &str) -> Self {
        self.set_inline_style(style);
        self
    }

    /// Sets inline CSS styles for the hover state on the root node
    pub fn set_inline_hover_style(&mut self, style: &str) {
        self.root.set_inline_hover_style(style);
    }

    /// Builder method for setting inline CSS styles for the hover state
    pub fn with_inline_hover_style(mut self, style: &str) -> Self {
        self.set_inline_hover_style(style);
        self
    }

    /// Sets inline CSS styles for the active state on the root node
    pub fn set_inline_active_style(&mut self, style: &str) {
        self.root.set_inline_active_style(style);
    }

    /// Builder method for setting inline CSS styles for the active state
    pub fn with_inline_active_style(mut self, style: &str) -> Self {
        self.set_inline_active_style(style);
        self
    }

    /// Sets inline CSS styles for the focus state on the root node
    pub fn set_inline_focus_style(&mut self, style: &str) {
        self.root.set_inline_focus_style(style);
    }

    /// Builder method for setting inline CSS styles for the focus state
    pub fn with_inline_focus_style(mut self, style: &str) -> Self {
        self.set_inline_focus_style(style);
        self
    }

    /// Sets the context menu for the root node
    #[inline]
    pub fn set_context_menu(&mut self, context_menu: Menu) {
        self.root.set_context_menu(context_menu);
    }

    #[inline]
    pub fn with_context_menu(mut self, context_menu: Menu) -> Self {
        self.set_context_menu(context_menu);
        self
    }

    /// Sets the menu bar for the root node
    #[inline]
    pub fn set_menu_bar(&mut self, menu_bar: Menu) {
        self.root.set_menu_bar(menu_bar);
    }

    #[inline]
    pub fn with_menu_bar(mut self, menu_bar: Menu) -> Self {
        self.set_menu_bar(menu_bar);
        self
    }

    #[inline]
    pub fn with_clip_mask(mut self, clip_mask: ImageMask) -> Self {
        self.root.set_clip_mask(clip_mask);
        self
    }

    #[inline]
    pub fn with_accessibility_info(mut self, accessibility_info: AccessibilityInfo) -> Self {
        self.root.set_accessibility_info(accessibility_info);
        self
    }

    pub fn fixup_children_estimated(&mut self) -> usize {
        if self.children.is_empty() {
            self.estimated_total_children = 0;
        } else {
            self.estimated_total_children = self
                .children
                .iter_mut()
                .map(|s| s.fixup_children_estimated() + 1)
                .sum();
        }
        return self.estimated_total_children;
    }
}

impl core::iter::FromIterator<Dom> for Dom {
    fn from_iter<I: IntoIterator<Item = Dom>>(iter: I) -> Self {
        let mut estimated_total_children = 0;
        let children = iter
            .into_iter()
            .map(|c| {
                estimated_total_children += c.estimated_total_children + 1;
                c
            })
            .collect::<Vec<Dom>>();

        Dom {
            root: NodeData::create_div(),
            children: children.into(),
            estimated_total_children,
        }
    }
}

impl fmt::Debug for Dom {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fn print_dom(d: &Dom, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "Dom {{\r\n")?;
            write!(f, "\troot: {:#?}\r\n", d.root)?;
            write!(
                f,
                "\testimated_total_children: {:#?}\r\n",
                d.estimated_total_children
            )?;
            write!(f, "\tchildren: [\r\n")?;
            for c in d.children.iter() {
                print_dom(c, f)?;
            }
            write!(f, "\t]\r\n")?;
            write!(f, "}}\r\n")?;
            Ok(())
        }

        print_dom(self, f)
    }
}

```

================================================================================
## FILE: core/src/styled_dom.rs
## Description: Styled DOM
================================================================================
```
use alloc::{boxed::Box, collections::btree_map::BTreeMap, string::String, vec::Vec};
use core::{
    fmt,
    hash::{Hash, Hasher},
};

use azul_css::{
    css::{Css, CssPath},
    props::{
        basic::{StyleFontFamily, StyleFontFamilyVec, StyleFontSize},
        property::{
            BoxDecorationBreakValue, BreakInsideValue, CaretAnimationDurationValue,
            CaretColorValue, ColumnCountValue, ColumnFillValue, ColumnRuleColorValue,
            ColumnRuleStyleValue, ColumnRuleWidthValue, ColumnSpanValue, ColumnWidthValue,
            ContentValue, CounterIncrementValue, CounterResetValue, CssProperty, CssPropertyType,
            FlowFromValue, FlowIntoValue, LayoutAlignContentValue, LayoutAlignItemsValue,
            LayoutAlignSelfValue, LayoutBorderBottomWidthValue, LayoutBorderLeftWidthValue,
            LayoutBorderRightWidthValue, LayoutBorderTopWidthValue, LayoutBoxSizingValue,
            LayoutClearValue, LayoutColumnGapValue, LayoutDisplayValue, LayoutFlexBasisValue,
            LayoutFlexDirectionValue, LayoutFlexGrowValue, LayoutFlexShrinkValue,
            LayoutFlexWrapValue, LayoutFloatValue, LayoutGapValue, LayoutGridAutoColumnsValue,
            LayoutGridAutoFlowValue, LayoutGridAutoRowsValue, LayoutGridColumnValue,
            LayoutGridRowValue, LayoutGridTemplateColumnsValue, LayoutGridTemplateRowsValue,
            LayoutHeightValue, LayoutInsetBottomValue, LayoutJustifyContentValue,
            LayoutJustifyItemsValue, LayoutJustifySelfValue, LayoutLeftValue,
            LayoutMarginBottomValue, LayoutMarginLeftValue, LayoutMarginRightValue,
            LayoutMarginTopValue, LayoutMaxHeightValue, LayoutMaxWidthValue, LayoutMinHeightValue,
            LayoutMinWidthValue, LayoutOverflowValue, LayoutPaddingBottomValue,
            LayoutPaddingLeftValue, LayoutPaddingRightValue, LayoutPaddingTopValue,
            LayoutPositionValue, LayoutRightValue, LayoutRowGapValue, LayoutScrollbarWidthValue,
            LayoutTextJustifyValue, LayoutTopValue, LayoutWidthValue, LayoutWritingModeValue,
            LayoutZIndexValue, OrphansValue, PageBreakValue, ScrollbarStyleValue,
            SelectionBackgroundColorValue, SelectionColorValue, ShapeImageThresholdValue,
            ShapeMarginValue, ShapeOutsideValue, StringSetValue, StyleBackfaceVisibilityValue,
            StyleBackgroundContentVecValue, StyleBackgroundPositionVecValue,
            StyleBackgroundRepeatVecValue, StyleBackgroundSizeVecValue,
            StyleBorderBottomColorValue, StyleBorderBottomLeftRadiusValue,
            StyleBorderBottomRightRadiusValue, StyleBorderBottomStyleValue,
            StyleBorderLeftColorValue, StyleBorderLeftStyleValue, StyleBorderRightColorValue,
            StyleBorderRightStyleValue, StyleBorderTopColorValue, StyleBorderTopLeftRadiusValue,
            StyleBorderTopRightRadiusValue, StyleBorderTopStyleValue, StyleBoxShadowValue,
            StyleCursorValue, StyleDirectionValue, StyleFilterVecValue, StyleFontFamilyVecValue,
            StyleFontSizeValue, StyleFontValue, StyleHyphensValue, StyleLetterSpacingValue,
            StyleLineHeightValue, StyleMixBlendModeValue, StyleOpacityValue,
            StylePerspectiveOriginValue, StyleScrollbarColorValue, StyleTabWidthValue,
            StyleTextAlignValue, StyleTextColorValue, StyleTransformOriginValue,
            StyleTransformVecValue, StyleVisibilityValue, StyleWhiteSpaceValue,
            StyleWordSpacingValue, WidowsValue,
        },
        style::StyleTextColor,
    },
    AzString,
};

use crate::{
    callbacks::Update,
    dom::{Dom, DomId, NodeData, NodeDataVec, OptionTabIndex, OptionTagId, TabIndex, TagId},
    id::{
        Node, NodeDataContainer, NodeDataContainerRef, NodeDataContainerRefMut, NodeHierarchy,
        NodeId,
    },
    menu::Menu,
    prop_cache::{CssPropertyCache, CssPropertyCachePtr},
    refany::RefAny,
    resources::{Au, ImageCache, ImageRef, ImmediateFontId, RendererResources},
    style::{
        construct_html_cascade_tree, matches_html_element, rule_ends_with, CascadeInfo,
        CascadeInfoVec,
    },
    FastBTreeSet, FastHashMap,
};

#[repr(C)]
#[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]
pub struct ChangedCssProperty {
    pub previous_state: StyledNodeState,
    pub previous_prop: CssProperty,
    pub current_state: StyledNodeState,
    pub current_prop: CssProperty,
}

impl_vec!(
    ChangedCssProperty,
    ChangedCssPropertyVec,
    ChangedCssPropertyVecDestructor,
    ChangedCssPropertyVecDestructorType
);
impl_vec_debug!(ChangedCssProperty, ChangedCssPropertyVec);
impl_vec_partialord!(ChangedCssProperty, ChangedCssPropertyVec);
impl_vec_clone!(
    ChangedCssProperty,
    ChangedCssPropertyVec,
    ChangedCssPropertyVecDestructor
);
impl_vec_partialeq!(ChangedCssProperty, ChangedCssPropertyVec);

/// Focus state change for restyle operations
#[derive(Debug, Clone, PartialEq)]
pub struct FocusChange {
    /// Node that lost focus (if any)
    pub lost_focus: Option<NodeId>,
    /// Node that gained focus (if any)
    pub gained_focus: Option<NodeId>,
}

/// Hover state change for restyle operations
#[derive(Debug, Clone, PartialEq)]
pub struct HoverChange {
    /// Nodes that the mouse left
    pub left_nodes: Vec<NodeId>,
    /// Nodes that the mouse entered
    pub entered_nodes: Vec<NodeId>,
}

/// Active (mouse down) state change for restyle operations
#[derive(Debug, Clone, PartialEq)]
pub struct ActiveChange {
    /// Nodes that were deactivated (mouse up)
    pub deactivated: Vec<NodeId>,
    /// Nodes that were activated (mouse down)
    pub activated: Vec<NodeId>,
}

/// Result of a restyle operation, indicating what needs to be updated
#[derive(Debug, Clone, Default)]
pub struct RestyleResult {
    /// Nodes whose CSS properties changed, with details of the changes
    pub changed_nodes: BTreeMap<NodeId, Vec<ChangedCssProperty>>,
    /// Whether layout needs to be recalculated (layout properties changed)
    pub needs_layout: bool,
    /// Whether display list needs regeneration (visual properties changed)
    pub needs_display_list: bool,
    /// Whether only GPU-level properties changed (opacity, transform)
    /// If true and needs_display_list is false, we can update via GPU without display list rebuild
    pub gpu_only_changes: bool,
}

impl RestyleResult {
    /// Returns true if any changes occurred
    pub fn has_changes(&self) -> bool {
        !self.changed_nodes.is_empty()
    }

    /// Merge another RestyleResult into this one
    pub fn merge(&mut self, other: RestyleResult) {
        for (node_id, changes) in other.changed_nodes {
            self.changed_nodes.entry(node_id).or_default().extend(changes);
        }
        self.needs_layout = self.needs_layout || other.needs_layout;
        self.needs_display_list = self.needs_display_list || other.needs_display_list;
        self.gpu_only_changes = self.gpu_only_changes && other.gpu_only_changes;
    }
}

#[repr(C, u8)]
#[derive(Debug, Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]
pub enum CssPropertySource {
    Css(CssPath),
    Inline,
}

/// NOTE: multiple states can be active at the same time
///
/// Tracks all CSS pseudo-class states for a node.
/// Each flag is independent - a node can be both :hover and :focus simultaneously.
#[repr(C)]
#[derive(Clone, Copy, PartialEq, Hash, PartialOrd, Eq, Ord, Default)]
pub struct StyledNodeState {
    /// Element is being hovered (:hover)
    pub hover: bool,
    /// Element is active/being clicked (:active)
    pub active: bool,
    /// Element has focus (:focus)
    pub focused: bool,
    /// Element is disabled (:disabled)
    pub disabled: bool,
    /// Element is checked/selected (:checked)
    pub checked: bool,
    /// Element or descendant has focus (:focus-within)
    pub focus_within: bool,
    /// Link has been visited (:visited)
    pub visited: bool,
}

impl core::fmt::Debug for StyledNodeState {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        let mut v = Vec::new();
        if self.hover {
            v.push("hover");
        }
        if self.active {
            v.push("active");
        }
        if self.focused {
            v.push("focused");
        }
        if self.disabled {
            v.push("disabled");
        }
        if self.checked {
            v.push("checked");
        }
        if self.focus_within {
            v.push("focus_within");
        }
        if self.visited {
            v.push("visited");
        }
        if v.is_empty() {
            v.push("normal");
        }
        write!(f, "{:?}", v)
    }
}

impl StyledNodeState {
    /// Creates a new state with all states set to false (normal state).
    pub const fn new() -> Self {
        StyledNodeState {
            hover: false,
            active: false,
            focused: false,
            disabled: false,
            checked: false,
            focus_within: false,
            visited: false,
        }
    }

    /// Check if a specific pseudo-state is active
    pub fn has_state(&self, state_type: u8) -> bool {
        match state_type {
            0 => true, // Normal is always active
            1 => self.hover,
            2 => self.active,
            3 => self.focused,
            4 => self.disabled,
            5 => self.checked,
            6 => self.focus_within,
            7 => self.visited,
            _ => false,
        }
    }

    /// Returns true if no special state is active (just normal)
    pub fn is_normal(&self) -> bool {
        !self.hover
            && !self.active
            && !self.focused
            && !self.disabled
            && !self.checked
            && !self.focus_within
            && !self.visited
    }

    /// Convert to PseudoStateFlags for use with dynamic selectors
    pub fn to_pseudo_state_flags(&self) -> azul_css::dynamic_selector::PseudoStateFlags {
        azul_css::dynamic_selector::PseudoStateFlags {
            hover: self.hover,
            active: self.active,
            focused: self.focused,
            disabled: self.disabled,
            checked: self.checked,
            focus_within: self.focus_within,
            visited: self.visited,
        }
    }

    /// Create from PseudoStateFlags (reverse of to_pseudo_state_flags)
    pub fn from_pseudo_state_flags(flags: &azul_css::dynamic_selector::PseudoStateFlags) -> Self {
        StyledNodeState {
            hover: flags.hover,
            active: flags.active,
            focused: flags.focused,
            disabled: flags.disabled,
            checked: flags.checked,
            focus_within: flags.focus_within,
            visited: flags.visited,
        }
    }
}

/// A styled Dom node
#[repr(C)]
#[derive(Debug, Default, Clone, PartialEq, PartialOrd)]
pub struct StyledNode {
    /// Current state of this styled node (used later for caching the style / layout)
    pub styled_node_state: StyledNodeState,
    /// Optional tag ID
    ///
    /// NOTE: The tag ID has to be adjusted after the layout is done (due to scroll tags)
    pub tag_id: OptionTagId,
}

impl_vec!(
    StyledNode,
    StyledNodeVec,
    StyledNodeVecDestructor,
    StyledNodeVecDestructorType
);
impl_vec_mut!(StyledNode, StyledNodeVec);
impl_vec_debug!(StyledNode, StyledNodeVec);
impl_vec_partialord!(StyledNode, StyledNodeVec);
impl_vec_clone!(StyledNode, StyledNodeVec, StyledNodeVecDestructor);
impl_vec_partialeq!(StyledNode, StyledNodeVec);

impl StyledNodeVec {
    /// Returns an immutable container reference for indexed access.
    pub fn as_container<'a>(&'a self) -> NodeDataContainerRef<'a, StyledNode> {
        NodeDataContainerRef {
            internal: self.as_ref(),
        }
    }
    /// Returns a mutable container reference for indexed access.
    pub fn as_container_mut<'a>(&'a mut self) -> NodeDataContainerRefMut<'a, StyledNode> {
        NodeDataContainerRefMut {
            internal: self.as_mut(),
        }
    }
}

#[test]
fn test_it() {
    let s = "
        html, body, p {
            margin: 0;
            padding: 0;
        }
        #div1 {
            border: solid black;
            height: 2in;
            position: absolute;
            top: 1in;
            width: 3in;
        }
        div div {
            background: blue;
            height: 1in;
            position: fixed;
            width: 1in;
        }
    ";

    let css = azul_css::parser2::new_from_str(s);
    let _styled_dom = Dom::create_body()
        .with_children(
            vec![Dom::create_div()
                .with_ids_and_classes(
                    vec![crate::dom::IdOrClass::Id("div1".to_string().into())].into(),
                )
                .with_children(vec![Dom::create_div()].into())]
            .into(),
        )
        .style(css.0);
}

/// Calculated hash of a font-family
#[derive(Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]
pub struct StyleFontFamilyHash(pub u64);

impl ::core::fmt::Debug for StyleFontFamilyHash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "StyleFontFamilyHash({})", self.0)
    }
}

impl StyleFontFamilyHash {
    /// Computes a 64-bit hash of a font family for cache lookups.
    pub fn new(family: &StyleFontFamily) -> Self {
        use highway::{HighwayHash, HighwayHasher, Key};
        let mut hasher = HighwayHasher::new(Key([0; 4]));
        family.hash(&mut hasher);
        Self(hasher.finalize64())
    }
}

/// Calculated hash of a font-family
#[derive(Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]
pub struct StyleFontFamiliesHash(pub u64);

impl ::core::fmt::Debug for StyleFontFamiliesHash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "StyleFontFamiliesHash({})", self.0)
    }
}

impl StyleFontFamiliesHash {
    /// Computes a 64-bit hash of multiple font families for cache lookups.
    pub fn new(families: &[StyleFontFamily]) -> Self {
        use highway::{HighwayHash, HighwayHasher, Key};
        let mut hasher = HighwayHasher::new(Key([0; 4]));
        for f in families.iter() {
            f.hash(&mut hasher);
        }
        Self(hasher.finalize64())
    }
}

/// FFI-safe representation of `Option<NodeId>` as a single `usize`.
///
/// # Encoding (1-based)
///
/// - `inner = 0` → `None` (no node)
/// - `inner = n > 0` → `Some(NodeId(n - 1))`
///
/// This type exists because C/C++ cannot use Rust's `Option` type.
/// Use [`NodeHierarchyItemId::into_crate_internal`] to decode and
/// [`NodeHierarchyItemId::from_crate_internal`] to encode.
///
/// # Difference from `NodeId`
///
/// - **`NodeId`**: A 0-based array index. `NodeId::new(0)` refers to the first node.
///   Use directly for array indexing: `nodes[node_id.index()]`.
///
/// - **`NodeHierarchyItemId`**: A 1-based encoded `Option<NodeId>`.
///   `inner = 0` means `None`, `inner = 1` means `Some(NodeId(0))`.
///   **Never use `inner` as an array index!** Always decode first.
///
/// # Warning
///
/// The `inner` field uses **1-based encoding**, not a direct index!
/// Never use `inner` directly as an array index - always decode first.
///
/// # Example
///
/// ```ignore
/// // Encoding: Option<NodeId> -> NodeHierarchyItemId
/// let opt = NodeHierarchyItemId::from_crate_internal(Some(NodeId::new(5)));
/// assert_eq!(opt.into_raw(), 6);  // 5 + 1 = 6
///
/// // Decoding: NodeHierarchyItemId -> Option<NodeId>
/// let decoded = opt.into_crate_internal();
/// assert_eq!(decoded, Some(NodeId::new(5)));
///
/// // None case
/// let none = NodeHierarchyItemId::NONE;
/// assert_eq!(none.into_raw(), 0);
/// assert_eq!(none.into_crate_internal(), None);
/// ```
#[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(C)]
pub struct NodeHierarchyItemId {
    // Uses 1-based encoding: 0 = None, n > 0 = Some(NodeId(n-1))
    // Do NOT use directly as an array index!
    inner: usize,
}

impl fmt::Debug for NodeHierarchyItemId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.into_crate_internal() {
            Some(n) => write!(f, "Some(NodeId({}))", n),
            None => write!(f, "None"),
        }
    }
}

impl fmt::Display for NodeHierarchyItemId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl NodeHierarchyItemId {
    /// Represents `None` (no node). Encoded as `inner = 0`.
    pub const NONE: NodeHierarchyItemId = NodeHierarchyItemId { inner: 0 };

    /// Creates an `NodeHierarchyItemId` from a raw 1-based encoded value.
    ///
    /// # Warning
    ///
    /// The value must use 1-based encoding (0 = None, n = NodeId(n-1)).
    /// Prefer using [`NodeHierarchyItemId::from_crate_internal`] instead.
    #[inline]
    pub const fn from_raw(value: usize) -> Self {
        Self { inner: value }
    }

    /// Returns the raw 1-based encoded value.
    ///
    /// # Warning
    ///
    /// The returned value uses 1-based encoding. Do NOT use as an array index!
    #[inline]
    pub const fn into_raw(&self) -> usize {
        self.inner
    }
}

impl_option!(
    NodeHierarchyItemId,
    OptionNodeHierarchyItemId,
    [Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

impl_vec!(
    NodeHierarchyItemId,
    NodeIdVec,
    NodeIdVecDestructor,
    NodeIdVecDestructorType
);
impl_vec_mut!(NodeHierarchyItemId, NodeIdVec);
impl_vec_debug!(NodeHierarchyItemId, NodeIdVec);
impl_vec_ord!(NodeHierarchyItemId, NodeIdVec);
impl_vec_eq!(NodeHierarchyItemId, NodeIdVec);
impl_vec_hash!(NodeHierarchyItemId, NodeIdVec);
impl_vec_partialord!(NodeHierarchyItemId, NodeIdVec);
impl_vec_clone!(NodeHierarchyItemId, NodeIdVec, NodeIdVecDestructor);
impl_vec_partialeq!(NodeHierarchyItemId, NodeIdVec);

impl NodeHierarchyItemId {
    /// Decodes to `Option<NodeId>` (0 = None, n > 0 = Some(NodeId(n-1))).
    #[inline]
    pub const fn into_crate_internal(&self) -> Option<NodeId> {
        NodeId::from_usize(self.inner)
    }

    /// Encodes from `Option<NodeId>` (None → 0, Some(NodeId(n)) → n+1).
    #[inline]
    pub const fn from_crate_internal(t: Option<NodeId>) -> Self {
        Self {
            inner: NodeId::into_raw(&t),
        }
    }
}

impl From<Option<NodeId>> for NodeHierarchyItemId {
    #[inline]
    fn from(opt: Option<NodeId>) -> Self {
        NodeHierarchyItemId::from_crate_internal(opt)
    }
}

impl From<NodeHierarchyItemId> for Option<NodeId> {
    #[inline]
    fn from(id: NodeHierarchyItemId) -> Self {
        id.into_crate_internal()
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(C)]
pub struct NodeHierarchyItem {
    pub parent: usize,
    pub previous_sibling: usize,
    pub next_sibling: usize,
    pub last_child: usize,
}

impl NodeHierarchyItem {
    /// Creates a zeroed hierarchy item (no parent, siblings, or children).
    pub const fn zeroed() -> Self {
        Self {
            parent: 0,
            previous_sibling: 0,
            next_sibling: 0,
            last_child: 0,
        }
    }
}

impl From<Node> for NodeHierarchyItem {
    fn from(node: Node) -> NodeHierarchyItem {
        NodeHierarchyItem {
            parent: NodeId::into_raw(&node.parent),
            previous_sibling: NodeId::into_raw(&node.previous_sibling),
            next_sibling: NodeId::into_raw(&node.next_sibling),
            last_child: NodeId::into_raw(&node.last_child),
        }
    }
}

impl NodeHierarchyItem {
    /// Returns the parent node ID, if any.
    pub fn parent_id(&self) -> Option<NodeId> {
        NodeId::from_usize(self.parent)
    }
    /// Returns the previous sibling node ID, if any.
    pub fn previous_sibling_id(&self) -> Option<NodeId> {
        NodeId::from_usize(self.previous_sibling)
    }
    /// Returns the next sibling node ID, if any.
    pub fn next_sibling_id(&self) -> Option<NodeId> {
        NodeId::from_usize(self.next_sibling)
    }
    /// Returns the first child node ID (current_node_id + 1 if has children).
    pub fn first_child_id(&self, current_node_id: NodeId) -> Option<NodeId> {
        self.last_child_id().map(|_| current_node_id + 1)
    }
    /// Returns the last child node ID, if any.
    pub fn last_child_id(&self) -> Option<NodeId> {
        NodeId::from_usize(self.last_child)
    }
}

impl_vec!(
    NodeHierarchyItem,
    NodeHierarchyItemVec,
    NodeHierarchyItemVecDestructor,
    NodeHierarchyItemVecDestructorType
);
impl_vec_mut!(NodeHierarchyItem, NodeHierarchyItemVec);
impl_vec_debug!(AzNode, NodeHierarchyItemVec);
impl_vec_partialord!(AzNode, NodeHierarchyItemVec);
impl_vec_clone!(
    NodeHierarchyItem,
    NodeHierarchyItemVec,
    NodeHierarchyItemVecDestructor
);
impl_vec_partialeq!(AzNode, NodeHierarchyItemVec);

impl NodeHierarchyItemVec {
    /// Returns an immutable container reference for indexed access.
    pub fn as_container<'a>(&'a self) -> NodeDataContainerRef<'a, NodeHierarchyItem> {
        NodeDataContainerRef {
            internal: self.as_ref(),
        }
    }
    /// Returns a mutable container reference for indexed access.
    pub fn as_container_mut<'a>(&'a mut self) -> NodeDataContainerRefMut<'a, NodeHierarchyItem> {
        NodeDataContainerRefMut {
            internal: self.as_mut(),
        }
    }
}

impl<'a> NodeDataContainerRef<'a, NodeHierarchyItem> {
    /// Returns the number of descendant nodes under the given parent.
    #[inline]
    pub fn subtree_len(&self, parent_id: NodeId) -> usize {
        let self_item_index = parent_id.index();
        let next_item_index = match self[parent_id].next_sibling_id() {
            None => self.len(),
            Some(s) => s.index(),
        };
        next_item_index - self_item_index - 1
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[repr(C)]
pub struct ParentWithNodeDepth {
    pub depth: usize,
    pub node_id: NodeHierarchyItemId,
}

impl core::fmt::Debug for ParentWithNodeDepth {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(
            f,
            "{{ depth: {}, node: {:?} }}",
            self.depth,
            self.node_id.into_crate_internal()
        )
    }
}

impl_vec!(
    ParentWithNodeDepth,
    ParentWithNodeDepthVec,
    ParentWithNodeDepthVecDestructor,
    ParentWithNodeDepthVecDestructorType
);
impl_vec_mut!(ParentWithNodeDepth, ParentWithNodeDepthVec);
impl_vec_debug!(ParentWithNodeDepth, ParentWithNodeDepthVec);
impl_vec_partialord!(ParentWithNodeDepth, ParentWithNodeDepthVec);
impl_vec_clone!(
    ParentWithNodeDepth,
    ParentWithNodeDepthVec,
    ParentWithNodeDepthVecDestructor
);
impl_vec_partialeq!(ParentWithNodeDepth, ParentWithNodeDepthVec);

#[derive(Debug, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub struct TagIdToNodeIdMapping {
    // Hit-testing tag ID (not all nodes have a tag, only nodes that are hit-testable)
    pub tag_id: TagId,
    /// Node ID of the node that has a tag
    pub node_id: NodeHierarchyItemId,
    /// Whether this node has a tab-index field
    pub tab_index: OptionTabIndex,
    /// Parents of this NodeID, sorted in depth order, necessary for efficient hit-testing
    pub parent_node_ids: NodeIdVec,
}

impl_vec!(
    TagIdToNodeIdMapping,
    TagIdToNodeIdMappingVec,
    TagIdToNodeIdMappingVecDestructor,
    TagIdToNodeIdMappingVecDestructorType
);
impl_vec_mut!(TagIdToNodeIdMapping, TagIdToNodeIdMappingVec);
impl_vec_debug!(TagIdToNodeIdMapping, TagIdToNodeIdMappingVec);
impl_vec_partialord!(TagIdToNodeIdMapping, TagIdToNodeIdMappingVec);
impl_vec_clone!(
    TagIdToNodeIdMapping,
    TagIdToNodeIdMappingVec,
    TagIdToNodeIdMappingVecDestructor
);
impl_vec_partialeq!(TagIdToNodeIdMapping, TagIdToNodeIdMappingVec);

#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[repr(C)]
pub struct ContentGroup {
    /// The parent of the current node group, i.e. either the root node (0)
    /// or the last positioned node ()
    pub root: NodeHierarchyItemId,
    /// Node ids in order of drawing
    pub children: ContentGroupVec,
}

impl_vec!(
    ContentGroup,
    ContentGroupVec,
    ContentGroupVecDestructor,
    ContentGroupVecDestructorType
);
impl_vec_mut!(ContentGroup, ContentGroupVec);
impl_vec_debug!(ContentGroup, ContentGroupVec);
impl_vec_partialord!(ContentGroup, ContentGroupVec);
impl_vec_clone!(ContentGroup, ContentGroupVec, ContentGroupVecDestructor);
impl_vec_partialeq!(ContentGroup, ContentGroupVec);

#[derive(Debug, PartialEq, Clone)]
#[repr(C)]
pub struct StyledDom {
    pub root: NodeHierarchyItemId,
    pub node_hierarchy: NodeHierarchyItemVec,
    pub node_data: NodeDataVec,
    pub styled_nodes: StyledNodeVec,
    pub cascade_info: CascadeInfoVec,
    pub nodes_with_window_callbacks: NodeIdVec,
    pub nodes_with_not_callbacks: NodeIdVec,
    pub nodes_with_datasets: NodeIdVec,
    pub tag_ids_to_node_ids: TagIdToNodeIdMappingVec,
    pub non_leaf_nodes: ParentWithNodeDepthVec,
    pub css_property_cache: CssPropertyCachePtr,
    /// The ID of this DOM in the layout tree (for multi-DOM support with IFrames)
    pub dom_id: DomId,
}
impl_option!(
    StyledDom,
    OptionStyledDom,
    copy = false,
    [Debug, Clone, PartialEq]
);

impl Default for StyledDom {
    fn default() -> Self {
        let root_node: NodeHierarchyItem = Node::ROOT.into();
        let root_node_id: NodeHierarchyItemId =
            NodeHierarchyItemId::from_crate_internal(Some(NodeId::ZERO));
        Self {
            root: root_node_id,
            node_hierarchy: vec![root_node].into(),
            node_data: vec![NodeData::create_body()].into(),
            styled_nodes: vec![StyledNode::default()].into(),
            cascade_info: vec![CascadeInfo {
                index_in_parent: 0,
                is_last_child: true,
            }]
            .into(),
            tag_ids_to_node_ids: Vec::new().into(),
            non_leaf_nodes: vec![ParentWithNodeDepth {
                depth: 0,
                node_id: root_node_id,
            }]
            .into(),
            nodes_with_window_callbacks: Vec::new().into(),
            nodes_with_not_callbacks: Vec::new().into(),
            nodes_with_datasets: Vec::new().into(),
            css_property_cache: CssPropertyCachePtr::new(CssPropertyCache::empty(1)),
            dom_id: DomId::ROOT_ID,
        }
    }
}

impl StyledDom {
    /// Creates a new StyledDom by applying CSS styles to a DOM tree.
    ///
    /// NOTE: After calling this function, the DOM will be reset to an empty DOM.
    // This is for memory optimization, so that the DOM does not need to be cloned.
    //
    // The CSS will be left in-place, but will be re-ordered
    pub fn create(dom: &mut Dom, mut css: Css) -> Self {
        use core::mem;

        use crate::dom::EventFilter;

        let mut swap_dom = Dom::create_body();

        mem::swap(dom, &mut swap_dom);

        let compact_dom: CompactDom = swap_dom.into();
        let non_leaf_nodes = compact_dom
            .node_hierarchy
            .as_ref()
            .get_parents_sorted_by_depth();
        let node_hierarchy: NodeHierarchyItemVec = compact_dom
            .node_hierarchy
            .as_ref()
            .internal
            .iter()
            .map(|i| (*i).into())
            .collect::<Vec<NodeHierarchyItem>>()
            .into();

        let mut styled_nodes = vec![
            StyledNode {
                tag_id: OptionTagId::None,
                styled_node_state: StyledNodeState::new()
            };
            compact_dom.len()
        ];

        // fill out the css property cache: compute the inline properties first so that
        // we can early-return in case the css is empty

        let mut css_property_cache = CssPropertyCache::empty(compact_dom.node_data.len());

        let html_tree =
            construct_html_cascade_tree(&compact_dom.node_hierarchy.as_ref(), &non_leaf_nodes[..]);

        let non_leaf_nodes = non_leaf_nodes
            .iter()
            .map(|(depth, node_id)| ParentWithNodeDepth {
                depth: *depth,
                node_id: NodeHierarchyItemId::from_crate_internal(Some(*node_id)),
            })
            .collect::<Vec<_>>();

        let non_leaf_nodes: ParentWithNodeDepthVec = non_leaf_nodes.into();

        // apply all the styles from the CSS
        let tag_ids = css_property_cache.restyle(
            &mut css,
            &compact_dom.node_data.as_ref(),
            &node_hierarchy,
            &non_leaf_nodes,
            &html_tree.as_ref(),
        );

        // Apply UA CSS properties to all nodes (lowest priority in cascade)
        // This MUST be done before compute_inherited_values() so that UA CSS
        // properties can be inherited by child nodes (especially text nodes)
        css_property_cache.apply_ua_css(compact_dom.node_data.as_ref().internal);

        // Compute inherited values for all nodes (resolves em, %, etc.)
        // This must be called after restyle() and apply_ua_css() to ensure
        // CSS properties are available for inheritance
        css_property_cache.compute_inherited_values(
            node_hierarchy.as_container().internal,
            compact_dom.node_data.as_ref().internal,
        );

        tag_ids
            .iter()
            .filter_map(|tag_id_node_id_mapping| {
                tag_id_node_id_mapping
                    .node_id
                    .into_crate_internal()
                    .map(|node_id| (node_id, tag_id_node_id_mapping.tag_id))
            })
            .for_each(|(nid, tag_id)| {
                styled_nodes[nid.index()].tag_id = OptionTagId::Some(tag_id);
            });

        // Pre-filter all EventFilter::Window and EventFilter::Not nodes
        // since we need them in the CallbacksOfHitTest::new function
        let nodes_with_window_callbacks = compact_dom
            .node_data
            .as_ref()
            .internal
            .iter()
            .enumerate()
            .filter_map(|(node_id, c)| {
                let node_has_none_callbacks = c.get_callbacks().iter().any(|cb| match cb.event {
                    EventFilter::Window(_) => true,
                    _ => false,
                });
                if node_has_none_callbacks {
                    Some(NodeHierarchyItemId::from_crate_internal(Some(NodeId::new(
                        node_id,
                    ))))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        let nodes_with_not_callbacks = compact_dom
            .node_data
            .as_ref()
            .internal
            .iter()
            .enumerate()
            .filter_map(|(node_id, c)| {
                let node_has_none_callbacks = c.get_callbacks().iter().any(|cb| match cb.event {
                    EventFilter::Not(_) => true,
                    _ => false,
                });
                if node_has_none_callbacks {
                    Some(NodeHierarchyItemId::from_crate_internal(Some(NodeId::new(
                        node_id,
                    ))))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        // collect nodes with either dataset or callback properties
        let nodes_with_datasets = compact_dom
            .node_data
            .as_ref()
            .internal
            .iter()
            .enumerate()
            .filter_map(|(node_id, c)| {
                if !c.get_callbacks().is_empty() || c.get_dataset().is_some() {
                    Some(NodeHierarchyItemId::from_crate_internal(Some(NodeId::new(
                        node_id,
                    ))))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        let mut styled_dom = StyledDom {
            root: NodeHierarchyItemId::from_crate_internal(Some(compact_dom.root)),
            node_hierarchy,
            node_data: compact_dom.node_data.internal.into(),
            cascade_info: html_tree.internal.into(),
            styled_nodes: styled_nodes.into(),
            tag_ids_to_node_ids: tag_ids.into(),
            nodes_with_window_callbacks: nodes_with_window_callbacks.into(),
            nodes_with_not_callbacks: nodes_with_not_callbacks.into(),
            nodes_with_datasets: nodes_with_datasets.into(),
            non_leaf_nodes,
            css_property_cache: CssPropertyCachePtr::new(css_property_cache),
            dom_id: DomId::ROOT_ID, // Will be assigned by layout engine for iframes
        };

        // Generate anonymous table elements if needed (CSS 2.2 Section 17.2.1)
        // This must happen after CSS cascade but before layout
        // Anonymous nodes are marked with is_anonymous=true and are skipped by CallbackInfo
        #[cfg(feature = "table_layout")]
        if let Err(e) = crate::dom_table::generate_anonymous_table_elements(&mut styled_dom) {
            eprintln!(
                "Warning: Failed to generate anonymous table elements: {:?}",
                e
            );
        }

        styled_dom
    }

    /// Appends another `StyledDom` as a child to the `self.root`
    /// without re-styling the DOM itself
    pub fn append_child(&mut self, mut other: Self) {
        // shift all the node ids in other by self.len()
        let self_len = self.node_hierarchy.as_ref().len();
        let other_len = other.node_hierarchy.as_ref().len();
        let self_tag_len = self.tag_ids_to_node_ids.as_ref().len();
        let self_root_id = self.root.into_crate_internal().unwrap_or(NodeId::ZERO);
        let other_root_id = other.root.into_crate_internal().unwrap_or(NodeId::ZERO);

        // iterate through the direct root children and adjust the cascade_info
        let current_root_children_count = self_root_id
            .az_children(&self.node_hierarchy.as_container())
            .count();

        other.cascade_info.as_mut()[other_root_id.index()].index_in_parent =
            current_root_children_count as u32;
        other.cascade_info.as_mut()[other_root_id.index()].is_last_child = true;

        self.cascade_info.append(&mut other.cascade_info);

        // adjust node hierarchy
        // Note: 0 means "no node" (None) in the 1-based encoding used by from_usize/into_usize
        for other in other.node_hierarchy.as_mut().iter_mut() {
            if other.parent != 0 {
                other.parent += self_len;
            }
            if other.previous_sibling != 0 {
                other.previous_sibling += self_len;
            }
            if other.next_sibling != 0 {
                other.next_sibling += self_len;
            }
            if other.last_child != 0 {
                other.last_child += self_len;
            }
        }

        other.node_hierarchy.as_container_mut()[other_root_id].parent =
            NodeId::into_raw(&Some(self_root_id));
        let current_last_child = self.node_hierarchy.as_container()[self_root_id].last_child_id();
        other.node_hierarchy.as_container_mut()[other_root_id].previous_sibling =
            NodeId::into_raw(&current_last_child);
        if let Some(current_last) = current_last_child {
            if self.node_hierarchy.as_container_mut()[current_last]
                .next_sibling_id()
                .is_some()
            {
                self.node_hierarchy.as_container_mut()[current_last].next_sibling +=
                    other_root_id.index() + other_len;
            } else {
                self.node_hierarchy.as_container_mut()[current_last].next_sibling =
                    NodeId::into_raw(&Some(NodeId::new(self_len + other_root_id.index())));
            }
        }
        self.node_hierarchy.as_container_mut()[self_root_id].last_child =
            NodeId::into_raw(&Some(NodeId::new(self_len + other_root_id.index())));

        self.node_hierarchy.append(&mut other.node_hierarchy);
        self.node_data.append(&mut other.node_data);
        self.styled_nodes.append(&mut other.styled_nodes);
        self.get_css_property_cache_mut()
            .append(other.get_css_property_cache_mut());

        for tag_id_node_id in other.tag_ids_to_node_ids.iter_mut() {
            tag_id_node_id.tag_id.inner += self_tag_len as u64;
            tag_id_node_id.node_id.inner += self_len;
        }

        self.tag_ids_to_node_ids
            .append(&mut other.tag_ids_to_node_ids);

        for nid in other.nodes_with_window_callbacks.iter_mut() {
            nid.inner += self_len;
        }
        self.nodes_with_window_callbacks
            .append(&mut other.nodes_with_window_callbacks);

        for nid in other.nodes_with_not_callbacks.iter_mut() {
            nid.inner += self_len;
        }
        self.nodes_with_not_callbacks
            .append(&mut other.nodes_with_not_callbacks);

        for nid in other.nodes_with_datasets.iter_mut() {
            nid.inner += self_len;
        }
        self.nodes_with_datasets
            .append(&mut other.nodes_with_datasets);

        // edge case: if the other StyledDom consists of only one node
        // then it is not a parent itself
        if other_len != 1 {
            for other_non_leaf_node in other.non_leaf_nodes.iter_mut() {
                other_non_leaf_node.node_id.inner += self_len;
                other_non_leaf_node.depth += 1;
            }
            self.non_leaf_nodes.append(&mut other.non_leaf_nodes);
            self.non_leaf_nodes.sort_by(|a, b| a.depth.cmp(&b.depth));
        }
    }

    /// Same as `append_child()`, but as a builder method
    pub fn with_child(mut self, other: Self) -> Self {
        self.append_child(other);
        self
    }

    /// Sets the context menu for the root node
    pub fn set_context_menu(&mut self, context_menu: Menu) {
        if let Some(root_id) = self.root.into_crate_internal() {
            self.node_data.as_container_mut()[root_id].set_context_menu(context_menu);
        }
    }

    /// Builder method for setting the context menu
    pub fn with_context_menu(mut self, context_menu: Menu) -> Self {
        self.set_context_menu(context_menu);
        self
    }

    /// Sets the menu bar for the root node
    pub fn set_menu_bar(&mut self, menu_bar: Menu) {
        if let Some(root_id) = self.root.into_crate_internal() {
            self.node_data.as_container_mut()[root_id].set_menu_bar(menu_bar);
        }
    }

    /// Builder method for setting the menu bar
    pub fn with_menu_bar(mut self, menu_bar: Menu) -> Self {
        self.set_menu_bar(menu_bar);
        self
    }

    /// Re-applies CSS styles to the existing DOM structure.
    pub fn restyle(&mut self, mut css: Css) {
        let new_tag_ids = self.css_property_cache.downcast_mut().restyle(
            &mut css,
            &self.node_data.as_container(),
            &self.node_hierarchy,
            &self.non_leaf_nodes,
            &self.cascade_info.as_container(),
        );

        // Apply UA CSS properties before computing inheritance
        self.css_property_cache
            .downcast_mut()
            .apply_ua_css(self.node_data.as_container().internal);

        // Compute inherited values after restyle and apply_ua_css (resolves em, %, etc.)
        self.css_property_cache
            .downcast_mut()
            .compute_inherited_values(
                self.node_hierarchy.as_container().internal,
                self.node_data.as_container().internal,
            );

        // Restyling may change the tag IDs
        let mut styled_nodes_mut = self.styled_nodes.as_container_mut();

        styled_nodes_mut
            .internal
            .iter_mut()
            .for_each(|styled_node| {
                styled_node.tag_id = None.into();
            });

        new_tag_ids
            .iter()
            .filter_map(|tag_id_node_id_mapping| {
                tag_id_node_id_mapping
                    .node_id
                    .into_crate_internal()
                    .map(|node_id| (node_id, tag_id_node_id_mapping.tag_id))
            })
            .for_each(|(nid, tag_id)| {
                styled_nodes_mut[nid].tag_id = Some(tag_id).into();
            });

        self.tag_ids_to_node_ids = new_tag_ids.into();
    }

    /// Returns the total number of nodes in this StyledDom.
    #[inline]
    pub fn node_count(&self) -> usize {
        self.node_data.len()
    }

    /// Returns an immutable reference to the CSS property cache.
    #[inline]
    pub fn get_css_property_cache<'a>(&'a self) -> &'a CssPropertyCache {
        &*self.css_property_cache.ptr
    }

    /// Returns a mutable reference to the CSS property cache.
    #[inline]
    pub fn get_css_property_cache_mut<'a>(&'a mut self) -> &'a mut CssPropertyCache {
        &mut *self.css_property_cache.ptr
    }

    /// Returns the current state (hover, active, focus) of a styled node.
    #[inline]
    pub fn get_styled_node_state(&self, node_id: &NodeId) -> StyledNodeState {
        self.styled_nodes.as_container()[*node_id]
            .styled_node_state
            .clone()
    }

    /// Scans the display list for all image keys
    pub fn scan_for_image_keys(&self, css_image_cache: &ImageCache) -> FastBTreeSet<ImageRef> {
        use azul_css::props::style::StyleBackgroundContentVec;

        use crate::{dom::NodeType::*, resources::OptionImageMask};

        #[derive(Default)]
        struct ScanImageVec {
            node_type_image: Option<ImageRef>,
            background_image: Vec<ImageRef>,
            clip_mask: Option<ImageRef>,
        }

        let default_backgrounds: StyleBackgroundContentVec = Vec::new().into();

        let images = self
            .node_data
            .as_container()
            .internal
            .iter()
            .enumerate()
            .map(|(node_id, node_data)| {
                let node_id = NodeId::new(node_id);
                let mut v = ScanImageVec::default();

                // If the node has an image content, it needs to be uploaded
                if let Image(id) = node_data.get_node_type() {
                    v.node_type_image = Some(id.clone());
                }

                // If the node has a CSS background image, it needs to be uploaded
                let opt_background_image = self.get_css_property_cache().get_background_content(
                    &node_data,
                    &node_id,
                    &self.styled_nodes.as_container()[node_id].styled_node_state,
                );

                if let Some(style_backgrounds) = opt_background_image {
                    v.background_image = style_backgrounds
                        .get_property()
                        .unwrap_or(&default_backgrounds)
                        .iter()
                        .filter_map(|bg| {
                            use azul_css::props::style::StyleBackgroundContent::*;
                            let css_image_id = match bg {
                                Image(i) => i,
                                _ => return None,
                            };
                            let image_ref = css_image_cache.get_css_image_id(css_image_id)?;
                            Some(image_ref.clone())
                        })
                        .collect();
                }

                // If the node has a clip mask, it needs to be uploaded
                if let Some(clip_mask) = node_data.get_clip_mask() {
                    v.clip_mask = Some(clip_mask.image.clone());
                }

                v
            })
            .collect::<Vec<_>>();

        let mut set = FastBTreeSet::new();

        for scan_image in images.into_iter() {
            if let Some(n) = scan_image.node_type_image {
                set.insert(n);
            }
            if let Some(n) = scan_image.clip_mask {
                set.insert(n);
            }
            for bg in scan_image.background_image {
                set.insert(bg);
            }
        }

        set
    }

    /// Updates hover state for nodes and returns changed CSS properties.
    #[must_use]
    pub fn restyle_nodes_hover(
        &mut self,
        nodes: &[NodeId],
        new_hover_state: bool,
    ) -> BTreeMap<NodeId, Vec<ChangedCssProperty>> {
        // save the old node state
        let old_node_states = nodes
            .iter()
            .map(|nid| {
                self.styled_nodes.as_container()[*nid]
                    .styled_node_state
                    .clone()
            })
            .collect::<Vec<_>>();

        for nid in nodes.iter() {
            self.styled_nodes.as_container_mut()[*nid]
                .styled_node_state
                .hover = new_hover_state;
        }

        let css_property_cache = self.get_css_property_cache();
        let styled_nodes = self.styled_nodes.as_container();
        let node_data = self.node_data.as_container();

        let default_map = BTreeMap::default();

        // scan all properties that could have changed because of addition / removal
        let v = nodes
            .iter()
            .zip(old_node_states.iter())
            .filter_map(|(node_id, old_node_state)| {
                let mut keys_normal: Vec<_> = css_property_cache
                    .css_hover_props
                    .get(node_id)
                    .unwrap_or(&default_map)
                    .keys()
                    .collect();
                let mut keys_inherited: Vec<_> = css_property_cache
                    .cascaded_hover_props
                    .get(node_id)
                    .unwrap_or(&default_map)
                    .keys()
                    .collect();
                let keys_inline: Vec<CssPropertyType> = {
                    use azul_css::dynamic_selector::{DynamicSelector, PseudoStateType};
                    node_data[*node_id]
                        .css_props
                        .iter()
                        .filter_map(|prop| {
                            let is_hover = prop.apply_if.as_slice().iter().any(|c| {
                                matches!(c, DynamicSelector::PseudoState(PseudoStateType::Hover))
                            });
                            if is_hover {
                                Some(prop.property.get_type())
                            } else {
                                None
                            }
                        })
                        .collect()
                };
                let mut keys_inline_ref = keys_inline.iter().map(|r| r).collect();

                keys_normal.append(&mut keys_inherited);
                keys_normal.append(&mut keys_inline_ref);

                let node_properties_that_could_have_changed = keys_normal;

                if node_properties_that_could_have_changed.is_empty() {
                    return None;
                }

                let new_node_state = &styled_nodes[*node_id].styled_node_state;
                let node_data = &node_data[*node_id];

                let changes = node_properties_that_could_have_changed
                    .into_iter()
                    .filter_map(|prop| {
                        // calculate both the old and the new state
                        let old = css_property_cache.get_property(
                            node_data,
                            node_id,
                            old_node_state,
                            prop,
                        );
                        let new = css_property_cache.get_property(
                            node_data,
                            node_id,
                            new_node_state,
                            prop,
                        );
                        if old == new {
                            None
                        } else {
                            Some(ChangedCssProperty {
                                previous_state: old_node_state.clone(),
                                previous_prop: match old {
                                    None => CssProperty::auto(*prop),
                                    Some(s) => s.clone(),
                                },
                                current_state: new_node_state.clone(),
                                current_prop: match new {
                                    None => CssProperty::auto(*prop),
                                    Some(s) => s.clone(),
                                },
                            })
                        }
                    })
                    .collect::<Vec<_>>();

                if changes.is_empty() {
                    None
                } else {
                    Some((*node_id, changes))
                }
            })
            .collect::<Vec<_>>();

        v.into_iter().collect()
    }

    /// Updates active state for nodes and returns changed CSS properties.
    #[must_use]
    pub fn restyle_nodes_active(
        &mut self,
        nodes: &[NodeId],
        new_active_state: bool,
    ) -> BTreeMap<NodeId, Vec<ChangedCssProperty>> {
        // save the old node state
        let old_node_states = nodes
            .iter()
            .map(|nid| {
                self.styled_nodes.as_container()[*nid]
                    .styled_node_state
                    .clone()
            })
            .collect::<Vec<_>>();

        for nid in nodes.iter() {
            self.styled_nodes.as_container_mut()[*nid]
                .styled_node_state
                .active = new_active_state;
        }

        let css_property_cache = self.get_css_property_cache();
        let styled_nodes = self.styled_nodes.as_container();
        let node_data = self.node_data.as_container();

        let default_map = BTreeMap::default();

        // scan all properties that could have changed because of addition / removal
        let v = nodes
            .iter()
            .zip(old_node_states.iter())
            .filter_map(|(node_id, old_node_state)| {
                let mut keys_normal: Vec<_> = css_property_cache
                    .css_active_props
                    .get(node_id)
                    .unwrap_or(&default_map)
                    .keys()
                    .collect();

                let mut keys_inherited: Vec<_> = css_property_cache
                    .cascaded_active_props
                    .get(node_id)
                    .unwrap_or(&default_map)
                    .keys()
                    .collect();

                let keys_inline: Vec<CssPropertyType> = {
                    use azul_css::dynamic_selector::{DynamicSelector, PseudoStateType};
                    node_data[*node_id]
                        .css_props
                        .iter()
                        .filter_map(|prop| {
                            let is_active = prop.apply_if.as_slice().iter().any(|c| {
                                matches!(c, DynamicSelector::PseudoState(PseudoStateType::Active))
                            });
                            if is_active {
                                Some(prop.property.get_type())
                            } else {
                                None
                            }
                        })
                        .collect()
                };
                let mut keys_inline_ref = keys_inline.iter().map(|r| r).collect();

                keys_normal.append(&mut keys_inherited);
                keys_normal.append(&mut keys_inline_ref);

                let node_properties_that_could_have_changed = keys_normal;

                if node_properties_that_could_have_changed.is_empty() {
                    return None;
                }

                let new_node_state = &styled_nodes[*node_id].styled_node_state;
                let node_data = &node_data[*node_id];

                let changes = node_properties_that_could_have_changed
                    .into_iter()
                    .filter_map(|prop| {
                        // calculate both the old and the new state
                        let old = css_property_cache.get_property(
                            node_data,
                            node_id,
                            old_node_state,
                            prop,
                        );
                        let new = css_property_cache.get_property(
                            node_data,
                            node_id,
                            new_node_state,
                            prop,
                        );
                        if old == new {
                            None
                        } else {
                            Some(ChangedCssProperty {
                                previous_state: old_node_state.clone(),
                                previous_prop: match old {
                                    None => CssProperty::auto(*prop),
                                    Some(s) => s.clone(),
                                },
                                current_state: new_node_state.clone(),
                                current_prop: match new {
                                    None => CssProperty::auto(*prop),
                                    Some(s) => s.clone(),
                                },
                            })
                        }
                    })
                    .collect::<Vec<_>>();

                if changes.is_empty() {
                    None
                } else {
                    Some((*node_id, changes))
                }
            })
            .collect::<Vec<_>>();

        v.into_iter().collect()
    }

    /// Updates focus state for nodes and returns changed CSS properties.
    #[must_use]
    pub fn restyle_nodes_focus(
        &mut self,
        nodes: &[NodeId],
        new_focus_state: bool,
    ) -> BTreeMap<NodeId, Vec<ChangedCssProperty>> {
        
        // save the old node state
        let old_node_states = nodes
            .iter()
            .map(|nid| {
                let state = self.styled_nodes.as_container()[*nid]
                    .styled_node_state
                    .clone();
                state
            })
            .collect::<Vec<_>>();

        for nid in nodes.iter() {
            self.styled_nodes.as_container_mut()[*nid]
                .styled_node_state
                .focused = new_focus_state;
        }

        let css_property_cache = self.get_css_property_cache();
        let styled_nodes = self.styled_nodes.as_container();
        let node_data = self.node_data.as_container();

        let default_map = BTreeMap::default();

        // scan all properties that could have changed because of addition / removal
        let v = nodes
            .iter()
            .zip(old_node_states.iter())
            .filter_map(|(node_id, old_node_state)| {
                let mut keys_normal: Vec<_> = css_property_cache
                    .css_focus_props
                    .get(node_id)
                    .unwrap_or(&default_map)
                    .keys()
                    .collect();
                

                let mut keys_inherited: Vec<_> = css_property_cache
                    .cascaded_focus_props
                    .get(node_id)
                    .unwrap_or(&default_map)
                    .keys()
                    .collect();
                

                let keys_inline: Vec<CssPropertyType> = {
                    use azul_css::dynamic_selector::{DynamicSelector, PseudoStateType};
                    node_data[*node_id]
                        .css_props
                        .iter()
                        .filter_map(|prop| {
                            let is_focus = prop.apply_if.as_slice().iter().any(|c| {
                                matches!(c, DynamicSelector::PseudoState(PseudoStateType::Focus))
                            });
                            if is_focus {
                                Some(prop.property.get_type())
                            } else {
                                None
                            }
                        })
                        .collect()
                };
                let mut keys_inline_ref = keys_inline.iter().map(|r| r).collect();

                keys_normal.append(&mut keys_inherited);
                keys_normal.append(&mut keys_inline_ref);

                let node_properties_that_could_have_changed = keys_normal;
                

                if node_properties_that_could_have_changed.is_empty() {
                    return None;
                }

                let new_node_state = &styled_nodes[*node_id].styled_node_state;
                let node_data = &node_data[*node_id];

                let changes = node_properties_that_could_have_changed
                    .into_iter()
                    .filter_map(|prop| {
                        // calculate both the old and the new state
                        let old = css_property_cache.get_property(
                            node_data,
                            node_id,
                            old_node_state,
                            prop,
                        );
                        let new = css_property_cache.get_property(
                            node_data,
                            node_id,
                            new_node_state,
                            prop,
                        );
                        if old == new {
                            None
                        } else {
                            Some(ChangedCssProperty {
                                previous_state: old_node_state.clone(),
                                previous_prop: match old {
                                    None => CssProperty::auto(*prop),
                                    Some(s) => s.clone(),
                                },
                                current_state: new_node_state.clone(),
                                current_prop: match new {
                                    None => CssProperty::auto(*prop),
                                    Some(s) => s.clone(),
                                },
                            })
                        }
                    })
                    .collect::<Vec<_>>();

                if changes.is_empty() {
                    None
                } else {
                    Some((*node_id, changes))
                }
            })
            .collect::<Vec<_>>();

        v.into_iter().collect()
    }

    /// Unified entry point for all CSS restyle operations.
    ///
    /// This function synchronizes the StyledNodeState with runtime state
    /// and computes which CSS properties have changed. It determines whether
    /// layout, display list, or GPU-only updates are needed.
    ///
    /// # Arguments
    /// * `focus_changes` - Nodes gaining/losing focus
    /// * `hover_changes` - Nodes gaining/losing hover
    /// * `active_changes` - Nodes gaining/losing active (mouse down)
    ///
    /// # Returns
    /// * `RestyleResult` containing changed nodes and what needs updating
    #[must_use]
    pub fn restyle_on_state_change(
        &mut self,
        focus_changes: Option<FocusChange>,
        hover_changes: Option<HoverChange>,
        active_changes: Option<ActiveChange>,
    ) -> RestyleResult {
        
        let mut result = RestyleResult::default();
        result.gpu_only_changes = true; // Start with GPU-only assumption

        // Helper closure to merge changes and analyze property categories
        let mut process_changes = |changes: BTreeMap<NodeId, Vec<ChangedCssProperty>>| {
            for (node_id, props) in changes {
                for change in &props {
                    let prop_type = change.current_prop.get_type();
                    
                    // Check if this property triggers relayout
                    if prop_type.can_trigger_relayout() {
                        result.needs_layout = true;
                        result.gpu_only_changes = false;
                    }
                    
                    // Check if this is a GPU-only property
                    if !prop_type.is_gpu_only_property() {
                        result.gpu_only_changes = false;
                    }
                    
                    // Any visual change needs display list update (unless GPU-only)
                    result.needs_display_list = true;
                }
                
                result.changed_nodes.entry(node_id).or_default().extend(props);
            }
        };

        // 1. Process focus changes
        if let Some(focus) = focus_changes {
            if let Some(old) = focus.lost_focus {
                let changes = self.restyle_nodes_focus(&[old], false);
                process_changes(changes);
            }
            if let Some(new) = focus.gained_focus {
                let changes = self.restyle_nodes_focus(&[new], true);
                process_changes(changes);
            }
        }

        // 2. Process hover changes
        if let Some(hover) = hover_changes {
            if !hover.left_nodes.is_empty() {
                let changes = self.restyle_nodes_hover(&hover.left_nodes, false);
                process_changes(changes);
            }
            if !hover.entered_nodes.is_empty() {
                let changes = self.restyle_nodes_hover(&hover.entered_nodes, true);
                process_changes(changes);
            }
        }

        // 3. Process active changes
        if let Some(active) = active_changes {
            if !active.deactivated.is_empty() {
                let changes = self.restyle_nodes_active(&active.deactivated, false);
                process_changes(changes);
            }
            if !active.activated.is_empty() {
                let changes = self.restyle_nodes_active(&active.activated, true);
                process_changes(changes);
            }
        }

        // If no changes, reset display_list flag
        if result.changed_nodes.is_empty() {
            result.needs_display_list = false;
            result.gpu_only_changes = false;
        }
        
        // If layout is needed, display list is also needed
        if result.needs_layout {
            result.needs_display_list = true;
            result.gpu_only_changes = false;
        }

        result
    }

    /// Overrides CSS properties for a node and returns changed properties.
    // Inserts a property into the self.user_overridden_properties
    #[must_use]
    pub fn restyle_user_property(
        &mut self,
        node_id: &NodeId,
        new_properties: &[CssProperty],
    ) -> BTreeMap<NodeId, Vec<ChangedCssProperty>> {
        let mut map = BTreeMap::default();

        if new_properties.is_empty() {
            return map;
        }

        let node_data = self.node_data.as_container();
        let node_data = &node_data[*node_id];

        let node_states = &self.styled_nodes.as_container();
        let old_node_state = &node_states[*node_id].styled_node_state;

        let changes: Vec<ChangedCssProperty> = {
            let css_property_cache = self.get_css_property_cache();

            new_properties
                .iter()
                .filter_map(|new_prop| {
                    let old_prop = css_property_cache.get_property(
                        node_data,
                        node_id,
                        old_node_state,
                        &new_prop.get_type(),
                    );

                    let old_prop = match old_prop {
                        None => CssProperty::auto(new_prop.get_type()),
                        Some(s) => s.clone(),
                    };

                    if old_prop == *new_prop {
                        None
                    } else {
                        Some(ChangedCssProperty {
                            previous_state: old_node_state.clone(),
                            previous_prop: old_prop,
                            // overriding a user property does not change the state
                            current_state: old_node_state.clone(),
                            current_prop: new_prop.clone(),
                        })
                    }
                })
                .collect()
        };

        let css_property_cache_mut = self.get_css_property_cache_mut();

        for new_prop in new_properties.iter() {
            if new_prop.is_initial() {
                let mut should_remove_map = false;
                if let Some(map) = css_property_cache_mut
                    .user_overridden_properties
                    .get_mut(node_id)
                {
                    // CssProperty::Initial = remove overridden property
                    map.remove(&new_prop.get_type());
                    should_remove_map = map.is_empty();
                }
                if should_remove_map {
                    css_property_cache_mut
                        .user_overridden_properties
                        .remove(node_id);
                }
            } else {
                css_property_cache_mut
                    .user_overridden_properties
                    .entry(*node_id)
                    .or_insert_with(|| BTreeMap::new())
                    .insert(new_prop.get_type(), new_prop.clone());
            }
        }

        if !changes.is_empty() {
            map.insert(*node_id, changes);
        }

        map
    }

    /// Scans the `StyledDom` for iframe callbacks
    pub fn scan_for_iframe_callbacks(&self) -> Vec<NodeId> {
        use crate::dom::NodeType;
        self.node_data
            .as_ref()
            .iter()
            .enumerate()
            .filter_map(|(node_id, node_data)| match node_data.get_node_type() {
                NodeType::IFrame(_) => Some(NodeId::new(node_id)),
                _ => None,
            })
            .collect()
    }

    /// Scans the `StyledDom` for OpenGL callbacks
    pub fn scan_for_gltexture_callbacks(&self) -> Vec<NodeId> {
        use crate::dom::NodeType;
        self.node_data
            .as_ref()
            .iter()
            .enumerate()
            .filter_map(|(node_id, node_data)| {
                use crate::resources::DecodedImage;
                match node_data.get_node_type() {
                    NodeType::Image(image_ref) => {
                        if let DecodedImage::Callback(_) = image_ref.get_data() {
                            Some(NodeId::new(node_id))
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            })
            .collect()
    }

    /// Returns a HTML-formatted version of the DOM for easier debugging.
    ///
    /// For example, a DOM with a parent div containing a child div would return:
    ///
    /// ```xml,no_run,ignore
    /// <div id="hello">
    ///      <div id="test" />
    /// </div>
    /// ```
    pub fn get_html_string(&self, custom_head: &str, custom_body: &str, test_mode: bool) -> String {
        let css_property_cache = self.get_css_property_cache();

        let mut output = String::new();

        // After which nodes should a close tag be printed?
        let mut should_print_close_tag_after_node = BTreeMap::new();

        let should_print_close_tag_debug = self
            .non_leaf_nodes
            .iter()
            .filter_map(|p| {
                let parent_node_id = p.node_id.into_crate_internal()?;
                let mut total_last_child = None;
                recursive_get_last_child(
                    parent_node_id,
                    &self.node_hierarchy.as_ref(),
                    &mut total_last_child,
                );
                let total_last_child = total_last_child?;
                Some((parent_node_id, (total_last_child, p.depth)))
            })
            .collect::<BTreeMap<_, _>>();

        for (parent_id, (last_child, parent_depth)) in should_print_close_tag_debug {
            should_print_close_tag_after_node
                .entry(last_child)
                .or_insert_with(|| Vec::new())
                .push((parent_id, parent_depth));
        }

        let mut all_node_depths = self
            .non_leaf_nodes
            .iter()
            .filter_map(|p| {
                let parent_node_id = p.node_id.into_crate_internal()?;
                Some((parent_node_id, p.depth))
            })
            .collect::<BTreeMap<_, _>>();

        for (parent_node_id, parent_depth) in self
            .non_leaf_nodes
            .iter()
            .filter_map(|p| Some((p.node_id.into_crate_internal()?, p.depth)))
        {
            for child_id in parent_node_id.az_children(&self.node_hierarchy.as_container()) {
                all_node_depths.insert(child_id, parent_depth + 1);
            }
        }

        for node_id in self.node_hierarchy.as_container().linear_iter() {
            let depth = all_node_depths[&node_id];

            let node_data = &self.node_data.as_container()[node_id];
            let node_state = &self.styled_nodes.as_container()[node_id].styled_node_state;
            let tabs = String::from("    ").repeat(depth);

            output.push_str("\r\n");
            output.push_str(&tabs);
            output.push_str(&node_data.debug_print_start(css_property_cache, &node_id, node_state));

            if let Some(content) = node_data.get_node_type().format().as_ref() {
                output.push_str(content);
            }

            let node_has_children = self.node_hierarchy.as_container()[node_id]
                .first_child_id(node_id)
                .is_some();
            if !node_has_children {
                let node_data = &self.node_data.as_container()[node_id];
                output.push_str(&node_data.debug_print_end());
            }

            if let Some(close_tag_vec) = should_print_close_tag_after_node.get(&node_id) {
                let mut close_tag_vec = close_tag_vec.clone();
                close_tag_vec.sort_by(|a, b| b.1.cmp(&a.1)); // sort by depth descending
                for (close_tag_parent_id, close_tag_depth) in close_tag_vec {
                    let node_data = &self.node_data.as_container()[close_tag_parent_id];
                    let tabs = String::from("    ").repeat(close_tag_depth);
                    output.push_str("\r\n");
                    output.push_str(&tabs);
                    output.push_str(&node_data.debug_print_end());
                }
            }
        }

        if !test_mode {
            format!(
                "
                <html>
                    <head>
                    <style>* {{ margin:0px; padding:0px; }}</style>
                    {custom_head}
                    </head>
                {output}
                {custom_body}
                </html>
            "
            )
        } else {
            output
        }
    }

    /// Returns the node ID of all sub-children of a node
    pub fn get_subtree(&self, parent: NodeId) -> Vec<NodeId> {
        let mut total_last_child = None;
        recursive_get_last_child(parent, &self.node_hierarchy.as_ref(), &mut total_last_child);
        if let Some(last) = total_last_child {
            (parent.index()..=last.index())
                .map(|id| NodeId::new(id))
                .collect()
        } else {
            Vec::new()
        }
    }

    /// Returns node IDs of all parent nodes in the subtree (nodes with children).
    // Same as get_subtree, but only returns parents
    pub fn get_subtree_parents(&self, parent: NodeId) -> Vec<NodeId> {
        let mut total_last_child = None;
        recursive_get_last_child(parent, &self.node_hierarchy.as_ref(), &mut total_last_child);
        if let Some(last) = total_last_child {
            (parent.index()..=last.index())
                .filter_map(|id| {
                    if self.node_hierarchy.as_ref()[id].last_child_id().is_some() {
                        Some(NodeId::new(id))
                    } else {
                        None
                    }
                })
                .collect()
        } else {
            Vec::new()
        }
    }

    /// Returns nodes grouped by their rendering order (respects z-index and position).
    pub fn get_rects_in_rendering_order(&self) -> ContentGroup {
        Self::determine_rendering_order(
            &self.non_leaf_nodes.as_ref(),
            &self.node_hierarchy.as_container(),
            &self.styled_nodes.as_container(),
            &self.node_data.as_container(),
            &self.get_css_property_cache(),
        )
    }

    /// Returns the rendering order of the items (the rendering
    /// order doesn't have to be the original order)
    fn determine_rendering_order<'a>(
        non_leaf_nodes: &[ParentWithNodeDepth],
        node_hierarchy: &NodeDataContainerRef<'a, NodeHierarchyItem>,
        styled_nodes: &NodeDataContainerRef<StyledNode>,
        node_data_container: &NodeDataContainerRef<NodeData>,
        css_property_cache: &CssPropertyCache,
    ) -> ContentGroup {
        let children_sorted = non_leaf_nodes
            .iter()
            .filter_map(|parent| {
                Some((
                    parent.node_id,
                    sort_children_by_position(
                        parent.node_id.into_crate_internal()?,
                        node_hierarchy,
                        styled_nodes,
                        node_data_container,
                        css_property_cache,
                    ),
                ))
            })
            .collect::<Vec<_>>();

        let children_sorted: BTreeMap<NodeHierarchyItemId, Vec<NodeHierarchyItemId>> =
            children_sorted.into_iter().collect();

        let mut root_content_group = ContentGroup {
            root: NodeHierarchyItemId::from_crate_internal(Some(NodeId::ZERO)),
            children: Vec::new().into(),
        };

        fill_content_group_children(&mut root_content_group, &children_sorted);

        root_content_group
    }

    /// Replaces this StyledDom with default and returns the old value.
    pub fn swap_with_default(&mut self) -> Self {
        let mut new = Self::default();
        core::mem::swap(self, &mut new);
        new
    }

    // Computes the diff between the two DOMs
    // pub fn diff(&self, other: &Self) -> StyledDomDiff { /**/ }
}

/// Same as `Dom`, but arena-based for more efficient memory layout and faster traversal.
#[derive(Debug, PartialEq, PartialOrd, Eq)]
pub struct CompactDom {
    /// The arena containing the hierarchical relationships (parent, child, sibling) of all nodes.
    pub node_hierarchy: NodeHierarchy,
    /// The arena containing the actual data (`NodeData`) for each node.
    pub node_data: NodeDataContainer<NodeData>,
    /// The ID of the root node of the DOM tree.
    pub root: NodeId,
}

impl CompactDom {
    /// Returns the number of nodes in this DOM.
    #[inline(always)]
    pub fn len(&self) -> usize {
        self.node_hierarchy.as_ref().len()
    }
}

impl From<Dom> for CompactDom {
    fn from(dom: Dom) -> Self {
        convert_dom_into_compact_dom(dom)
    }
}

/// Converts a tree-based Dom into an arena-based CompactDom for efficient traversal.
pub fn convert_dom_into_compact_dom(mut dom: Dom) -> CompactDom {
    // note: somehow convert this into a non-recursive form later on!
    fn convert_dom_into_compact_dom_internal(
        dom: &mut Dom,
        node_hierarchy: &mut [Node],
        node_data: &mut Vec<NodeData>,
        parent_node_id: NodeId,
        node: Node,
        cur_node_id: &mut usize,
    ) {
        // - parent [0]
        //    - child [1]
        //    - child [2]
        //        - child of child 2 [2]
        //        - child of child 2 [4]
        //    - child [5]
        //    - child [6]
        //        - child of child 4 [7]

        // Write node into the arena here!
        node_hierarchy[parent_node_id.index()] = node.clone();

        let copy = dom.root.copy_special();

        node_data[parent_node_id.index()] = copy;

        *cur_node_id += 1;

        let mut previous_sibling_id = None;
        let children_len = dom.children.len();
        for (child_index, child_dom) in dom.children.as_mut().iter_mut().enumerate() {
            let child_node_id = NodeId::new(*cur_node_id);
            let is_last_child = (child_index + 1) == children_len;
            let child_dom_is_empty = child_dom.children.is_empty();
            let child_node = Node {
                parent: Some(parent_node_id),
                previous_sibling: previous_sibling_id,
                next_sibling: if is_last_child {
                    None
                } else {
                    Some(child_node_id + child_dom.estimated_total_children + 1)
                },
                last_child: if child_dom_is_empty {
                    None
                } else {
                    Some(child_node_id + child_dom.estimated_total_children)
                },
            };
            previous_sibling_id = Some(child_node_id);
            // recurse BEFORE adding the next child
            convert_dom_into_compact_dom_internal(
                child_dom,
                node_hierarchy,
                node_data,
                child_node_id,
                child_node,
                cur_node_id,
            );
        }
    }

    // Pre-allocate all nodes (+ 1 root node)
    const DEFAULT_NODE_DATA: NodeData = NodeData::create_div();

    let sum_nodes = dom.fixup_children_estimated();

    let mut node_hierarchy = vec![Node::ROOT; sum_nodes + 1];
    let mut node_data = vec![NodeData::create_div(); sum_nodes + 1];
    let mut cur_node_id = 0;

    let root_node_id = NodeId::ZERO;
    let root_node = Node {
        parent: None,
        previous_sibling: None,
        next_sibling: None,
        last_child: if dom.children.is_empty() {
            None
        } else {
            Some(root_node_id + dom.estimated_total_children)
        },
    };

    convert_dom_into_compact_dom_internal(
        &mut dom,
        &mut node_hierarchy,
        &mut node_data,
        root_node_id,
        root_node,
        &mut cur_node_id,
    );

    CompactDom {
        node_hierarchy: NodeHierarchy {
            internal: node_hierarchy,
        },
        node_data: NodeDataContainer {
            internal: node_data,
        },
        root: root_node_id,
    }
}

fn fill_content_group_children(
    group: &mut ContentGroup,
    children_sorted: &BTreeMap<NodeHierarchyItemId, Vec<NodeHierarchyItemId>>,
) {
    if let Some(c) = children_sorted.get(&group.root) {
        // returns None for leaf nodes
        group.children = c
            .iter()
            .map(|child| ContentGroup {
                root: *child,
                children: Vec::new().into(),
            })
            .collect::<Vec<ContentGroup>>()
            .into();

        for c in group.children.as_mut() {
            fill_content_group_children(c, children_sorted);
        }
    }
}

fn sort_children_by_position<'a>(
    parent: NodeId,
    node_hierarchy: &NodeDataContainerRef<'a, NodeHierarchyItem>,
    rectangles: &NodeDataContainerRef<StyledNode>,
    node_data_container: &NodeDataContainerRef<NodeData>,
    css_property_cache: &CssPropertyCache,
) -> Vec<NodeHierarchyItemId> {
    use azul_css::props::layout::LayoutPosition::*;

    let children_positions = parent
        .az_children(node_hierarchy)
        .map(|nid| {
            let position = css_property_cache
                .get_position(
                    &node_data_container[nid],
                    &nid,
                    &rectangles[nid].styled_node_state,
                )
                .and_then(|p| p.clone().get_property_or_default())
                .unwrap_or_default();
            let id = NodeHierarchyItemId::from_crate_internal(Some(nid));
            (id, position)
        })
        .collect::<Vec<_>>();

    let mut not_absolute_children = children_positions
        .iter()
        .filter_map(|(node_id, position)| {
            if *position != Absolute {
                Some(*node_id)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    let mut absolute_children = children_positions
        .iter()
        .filter_map(|(node_id, position)| {
            if *position == Absolute {
                Some(*node_id)
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    // Append the position:absolute children after the regular children
    not_absolute_children.append(&mut absolute_children);
    not_absolute_children
}

// calls get_last_child() recursively until the last child of the last child of the ... has been
// found
fn recursive_get_last_child(
    node_id: NodeId,
    node_hierarchy: &[NodeHierarchyItem],
    target: &mut Option<NodeId>,
) {
    match node_hierarchy[node_id.index()].last_child_id() {
        None => return,
        Some(s) => {
            *target = Some(s);
            recursive_get_last_child(s, node_hierarchy, target);
        }
    }
}

// ============================================================================
// DOM TRAVERSAL FOR MULTI-NODE SELECTION
// ============================================================================

/// Determine if node_a comes before node_b in document order.
///
/// Document order is defined as pre-order depth-first traversal order.
/// This is equivalent to the order nodes appear in HTML source.
///
/// ## Algorithm
/// 1. Find the path from root to each node
/// 2. Find the Lowest Common Ancestor (LCA)
/// 3. At the divergence point, the child that appears first in sibling order comes first
pub fn is_before_in_document_order(
    hierarchy: &NodeHierarchyItemVec,
    node_a: NodeId,
    node_b: NodeId,
) -> bool {
    if node_a == node_b {
        return false;
    }
    
    let hierarchy = hierarchy.as_container();
    
    // Get paths from root to each node (stored as root-first order)
    let path_a = get_path_to_root(&hierarchy, node_a);
    let path_b = get_path_to_root(&hierarchy, node_b);
    
    // Find divergence point (last common ancestor)
    let min_len = path_a.len().min(path_b.len());
    
    for i in 0..min_len {
        if path_a[i] != path_b[i] {
            // Found divergence - check which sibling comes first
            let child_towards_a = path_a[i];
            let child_towards_b = path_b[i];
            
            // A smaller NodeId index means it was created earlier in DOM construction,
            // which means it comes first in document order for siblings
            return child_towards_a.index() < child_towards_b.index();
        }
    }
    
    // One path is a prefix of the other - the shorter path (ancestor) comes first
    path_a.len() < path_b.len()
}

/// Get the path from root to a node, returned in root-first order.
fn get_path_to_root(
    hierarchy: &NodeDataContainerRef<'_, NodeHierarchyItem>,
    node: NodeId,
) -> Vec<NodeId> {
    let mut path = Vec::new();
    let mut current = Some(node);
    
    while let Some(node_id) = current {
        path.push(node_id);
        current = hierarchy.get(node_id).and_then(|h| h.parent_id());
    }
    
    // Reverse to get root-first order
    path.reverse();
    path
}

/// Collect all nodes between start and end (inclusive) in document order.
///
/// This performs a pre-order depth-first traversal starting from the root,
/// collecting nodes once we've seen `start` and stopping at `end`.
///
/// ## Parameters
/// * `hierarchy` - The node hierarchy
/// * `start_node` - First node in document order
/// * `end_node` - Last node in document order
///
/// ## Returns
/// Vector of NodeIds in document order, from start to end (inclusive)
pub fn collect_nodes_in_document_order(
    hierarchy: &NodeHierarchyItemVec,
    start_node: NodeId,
    end_node: NodeId,
) -> Vec<NodeId> {
    if start_node == end_node {
        return vec![start_node];
    }
    
    let hierarchy_container = hierarchy.as_container();
    let hierarchy_slice = hierarchy.as_ref();
    
    let mut result = Vec::new();
    let mut in_range = false;
    
    // Pre-order DFS using a stack
    // We need to traverse in document order, which is pre-order DFS
    let mut stack: Vec<NodeId> = vec![NodeId::ZERO]; // Start from root
    
    while let Some(current) = stack.pop() {
        // Check if we've entered the range
        if current == start_node {
            in_range = true;
        }
        
        // Collect if in range
        if in_range {
            result.push(current);
        }
        
        // Check if we've exited the range
        if current == end_node {
            break;
        }
        
        // Push children in reverse order so they pop in correct order
        // (first child should be processed first)
        if let Some(item) = hierarchy_container.get(current) {
            // Get first child
            if let Some(first_child) = item.first_child_id(current) {
                // Collect all children by following next_sibling
                let mut children = Vec::new();
                let mut child = Some(first_child);
                while let Some(child_id) = child {
                    children.push(child_id);
                    child = hierarchy_container.get(child_id).and_then(|h| h.next_sibling_id());
                }
                // Push in reverse order for correct DFS order
                for child_id in children.into_iter().rev() {
                    stack.push(child_id);
                }
            }
        }
    }
    
    result
}

```

### CALLBACKS AND FOCUS

================================================================================
## FILE: core/src/callbacks.rs
## Description: Callback system
================================================================================
```
#![allow(dead_code)]

#[cfg(not(feature = "std"))]
use alloc::string::ToString;
use alloc::{alloc::Layout, boxed::Box, collections::BTreeMap, sync::Arc, vec::Vec};
use core::{
    ffi::c_void,
    fmt,
    sync::atomic::{AtomicUsize, Ordering as AtomicOrdering},
};
#[cfg(feature = "std")]
use std::hash::Hash;

use azul_css::{
    css::{CssPath, CssPropertyValue},
    props::{
        basic::{
            AnimationInterpolationFunction, FontRef, InterpolateResolver, LayoutRect, LayoutSize,
        },
        property::{CssProperty, CssPropertyType},
    },
    system::SystemStyle,
    AzString,
};
use rust_fontconfig::{FcFontCache, FontSource};

use crate::{
    dom::{DomId, DomNodeId, EventFilter},
    geom::{LogicalPosition, LogicalRect, LogicalSize, OptionLogicalPosition, PhysicalSize},
    gl::OptionGlContextPtr,
    hit_test::OverflowingScrollNode,
    id::{NodeDataContainer, NodeDataContainerRef, NodeDataContainerRefMut, NodeId},
    prop_cache::CssPropertyCache,
    refany::{OptionRefAny, RefAny},
    resources::{
        DpiScaleFactor, FontInstanceKey, IdNamespace, ImageCache, ImageMask, ImageRef,
        RendererResources,
    },
    styled_dom::{
        NodeHierarchyItemId, NodeHierarchyItemVec, OptionStyledDom, StyledDom, StyledNode,
        StyledNodeVec,
    },
    task::{
        Duration as AzDuration, GetSystemTimeCallback, Instant as AzInstant, Instant,
        TerminateTimer, ThreadId, ThreadReceiver, ThreadSendMsg, TimerId,
    },
    window::{
        AzStringPair, KeyboardState, MouseState, OptionChar, RawWindowHandle, UpdateFocusWarning,
        WindowFlags, WindowSize, WindowTheme,
    },
    FastBTreeSet, FastHashMap,
};

/// Specifies if the screen should be updated after the callback function has returned
#[repr(C)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Update {
    /// The screen does not need to redraw after the callback has been called
    DoNothing,
    /// After the callback is called, the screen needs to redraw (layout() function being called
    /// again)
    RefreshDom,
    /// The layout has to be re-calculated for all windows
    RefreshDomAllWindows,
}

impl Update {
    pub fn max_self(&mut self, other: Self) {
        if *self == Update::DoNothing && other != Update::DoNothing {
            *self = other;
        } else if *self == Update::RefreshDom && other == Update::RefreshDomAllWindows {
            *self = other;
        }
    }
}

// -- layout callback

/// Callback function pointer (has to be a function pointer in
/// order to be compatible with C APIs later on).
///
/// IMPORTANT: The callback needs to deallocate the `RefAnyPtr` and `LayoutCallbackInfoPtr`,
/// otherwise that memory is leaked. If you use the official auto-generated
/// bindings, this is already done for you.
///
/// NOTE: The original callback was `fn(&self, LayoutCallbackInfo) -> Dom`
/// which then evolved to `fn(&RefAny, LayoutCallbackInfo) -> Dom`.
/// The indirection is necessary because of the memory management
/// around the C API
///
/// See azul-core/ui_state.rs:298 for how the memory is managed
/// across the callback boundary.
pub type LayoutCallbackType = extern "C" fn(RefAny, LayoutCallbackInfo) -> StyledDom;

extern "C" fn default_layout_callback(_: RefAny, _: LayoutCallbackInfo) -> StyledDom {
    StyledDom::default()
}

/// Wrapper around the layout callback
///
/// For FFI languages (Python, Java, etc.), the RefAny contains both:
/// - The user's application data
/// - The callback function object from the foreign language
///
/// The trampoline function (stored in `cb`) knows how to extract both
/// from the RefAny and invoke the foreign callback with the user data.
#[repr(C)]
pub struct LayoutCallback {
    pub cb: LayoutCallbackType,
    /// For FFI: stores the foreign callable (e.g., PyFunction)
    /// Native Rust code sets this to None
    pub ctx: OptionRefAny,
}

impl_callback!(LayoutCallback, LayoutCallbackType);

impl LayoutCallback {
    pub fn create<I: Into<Self>>(cb: I) -> Self {
        cb.into()
    }
}

impl Default for LayoutCallback {
    fn default() -> Self {
        Self {
            cb: default_layout_callback,
            ctx: OptionRefAny::None,
        }
    }
}

// -- iframe callback

pub type IFrameCallbackType = extern "C" fn(RefAny, IFrameCallbackInfo) -> IFrameCallbackReturn;

/// Callback that, given a rectangle area on the screen, returns the DOM
/// appropriate for that bounds (useful for infinite lists)
#[repr(C)]
pub struct IFrameCallback {
    pub cb: IFrameCallbackType,
    /// For FFI: stores the foreign callable (e.g., PyFunction)
    /// Native Rust code sets this to None
    pub ctx: OptionRefAny,
}
impl_callback!(IFrameCallback, IFrameCallbackType);

impl IFrameCallback {
    pub fn create(cb: IFrameCallbackType) -> Self {
        Self {
            cb,
            ctx: OptionRefAny::None,
        }
    }
}

/// Reason why an IFrame callback is being invoked.
///
/// This helps the callback optimize its behavior based on why it's being called.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C, u8)]
pub enum IFrameCallbackReason {
    /// Initial render - first time the IFrame appears
    InitialRender,
    /// Parent DOM was recreated (cache invalidated)
    DomRecreated,
    /// Window/IFrame bounds expanded beyond current scroll_size
    BoundsExpanded,
    /// Scroll position is near an edge (within 200px threshold)
    EdgeScrolled(EdgeType),
    /// Scroll position extends beyond current scroll_size
    ScrollBeyondContent,
}

/// Which edge triggered a scroll-based re-invocation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
pub enum EdgeType {
    Top,
    Bottom,
    Left,
    Right,
}

#[derive(Debug)]
#[repr(C)]
pub struct IFrameCallbackInfo {
    pub reason: IFrameCallbackReason,
    pub system_fonts: *const FcFontCache,
    pub image_cache: *const ImageCache,
    pub window_theme: WindowTheme,
    pub bounds: HidpiAdjustedBounds,
    pub scroll_size: LogicalSize,
    pub scroll_offset: LogicalPosition,
    pub virtual_scroll_size: LogicalSize,
    pub virtual_scroll_offset: LogicalPosition,
    /// Pointer to the callable (OptionRefAny) for FFI language bindings (Python, etc.)
    /// Set by the caller before invoking the callback. Native Rust callbacks have this as null.
    callable_ptr: *const OptionRefAny,
    /// Extension for future ABI stability (mutable data)
    _abi_mut: *mut c_void,
}

impl Clone for IFrameCallbackInfo {
    fn clone(&self) -> Self {
        Self {
            reason: self.reason,
            system_fonts: self.system_fonts,
            image_cache: self.image_cache,
            window_theme: self.window_theme,
            bounds: self.bounds,
            scroll_size: self.scroll_size,
            scroll_offset: self.scroll_offset,
            virtual_scroll_size: self.virtual_scroll_size,
            virtual_scroll_offset: self.virtual_scroll_offset,
            callable_ptr: self.callable_ptr,
            _abi_mut: self._abi_mut,
        }
    }
}

impl IFrameCallbackInfo {
    pub fn new<'a>(
        reason: IFrameCallbackReason,
        system_fonts: &'a FcFontCache,
        image_cache: &'a ImageCache,
        window_theme: WindowTheme,
        bounds: HidpiAdjustedBounds,
        scroll_size: LogicalSize,
        scroll_offset: LogicalPosition,
        virtual_scroll_size: LogicalSize,
        virtual_scroll_offset: LogicalPosition,
    ) -> Self {
        Self {
            reason,
            system_fonts: system_fonts as *const FcFontCache,
            image_cache: image_cache as *const ImageCache,
            window_theme,
            bounds,
            scroll_size,
            scroll_offset,
            virtual_scroll_size,
            virtual_scroll_offset,
            callable_ptr: core::ptr::null(),
            _abi_mut: core::ptr::null_mut(),
        }
    }

    /// Set the callable pointer for FFI language bindings
    pub fn set_callable_ptr(&mut self, callable: &OptionRefAny) {
        self.callable_ptr = callable as *const OptionRefAny;
    }

    /// Get the callable for FFI language bindings (Python, etc.)
    pub fn get_ctx(&self) -> OptionRefAny {
        if self.callable_ptr.is_null() {
            OptionRefAny::None
        } else {
            unsafe { (*self.callable_ptr).clone() }
        }
    }

    pub fn get_bounds(&self) -> HidpiAdjustedBounds {
        self.bounds
    }

    fn internal_get_system_fonts<'a>(&'a self) -> &'a FcFontCache {
        unsafe { &*self.system_fonts }
    }
    fn internal_get_image_cache<'a>(&'a self) -> &'a ImageCache {
        unsafe { &*self.image_cache }
    }
}

/// Return value for an IFrame rendering callback.
///
/// Contains two size/offset pairs for lazy loading and virtualization:
///
/// - `scroll_size` / `scroll_offset`: Size and position of actually rendered content
/// - `virtual_scroll_size` / `virtual_scroll_offset`: Size for scrollbar representation
///
/// The callback is re-invoked on: initial render, parent DOM recreation, window expansion
/// beyond `scroll_size`, or scrolling near content edges (200px threshold).
///
/// Return `OptionStyledDom::None` to keep the current DOM and only update scroll bounds.
#[derive(Debug, Clone, PartialEq)]
#[repr(C)]
pub struct IFrameCallbackReturn {
    /// The styled DOM with actual rendered content, or None to keep current DOM.
    ///
    /// - `OptionStyledDom::Some(dom)` - Replace current content with this new DOM
    /// - `OptionStyledDom::None` - Keep using the previous DOM, only update scroll bounds
    ///
    /// Returning `None` is an optimization when the callback determines that the
    /// current content is sufficient (e.g., already rendered ahead of scroll position).
    pub dom: OptionStyledDom,

    /// Size of the actual rendered content rectangle.
    ///
    /// This is the size of the content in the `dom` field (if Some). It may be smaller than
    /// `virtual_scroll_size` if only a subset of content is rendered (virtualization).
    ///
    /// **Example**: For a table showing rows 10-30, this might be 600px tall
    /// (20 rows x 30px each).
    pub scroll_size: LogicalSize,

    /// Offset of the actual rendered content within the virtual coordinate space.
    ///
    /// This positions the rendered content within the larger virtual space. For
    /// virtualized content, this will be non-zero to indicate where the rendered
    /// "window" starts.
    ///
    /// **Example**: For a table showing rows 10-30, this might be y=300
    /// (row 10 starts 300px from the top).
    pub scroll_offset: LogicalPosition,

    /// Size of the virtual content rectangle (for scrollbar sizing).
    ///
    /// This is the size the scrollbar will represent. It can be much larger than
    /// `scroll_size` to enable lazy loading and virtualization.
    ///
    /// **Example**: For a 1000-row table, this might be 30,000px tall
    /// (1000 rows x 30px each), even though only 20 rows are actually rendered.
    pub virtual_scroll_size: LogicalSize,

    /// Offset of the virtual content (usually zero).
    ///
    /// This is typically `(0, 0)` since the virtual space usually starts at the origin.
    /// Advanced use cases might use this for complex virtualization scenarios.
    pub virtual_scroll_offset: LogicalPosition,
}

impl Default for IFrameCallbackReturn {
    fn default() -> IFrameCallbackReturn {
        IFrameCallbackReturn {
            dom: OptionStyledDom::None,
            scroll_size: LogicalSize::zero(),
            scroll_offset: LogicalPosition::zero(),
            virtual_scroll_size: LogicalSize::zero(),
            virtual_scroll_offset: LogicalPosition::zero(),
        }
    }
}

impl IFrameCallbackReturn {
    /// Creates a new IFrameCallbackReturn with updated DOM content.
    ///
    /// Use this when the callback has rendered new content to display.
    ///
    /// # Arguments
    /// - `dom` - The new styled DOM to render
    /// - `scroll_size` - Size of the actual rendered content
    /// - `scroll_offset` - Position of rendered content in virtual space
    /// - `virtual_scroll_size` - Size for scrollbar representation
    /// - `virtual_scroll_offset` - Usually `LogicalPosition::zero()`
    pub fn with_dom(
        dom: StyledDom,
        scroll_size: LogicalSize,
        scroll_offset: LogicalPosition,
        virtual_scroll_size: LogicalSize,
        virtual_scroll_offset: LogicalPosition,
    ) -> Self {
        Self {
            dom: OptionStyledDom::Some(dom),
            scroll_size,
            scroll_offset,
            virtual_scroll_size,
            virtual_scroll_offset,
        }
    }

    /// Creates a return value that keeps the current DOM unchanged.
    ///
    /// Use this when the callback determines that the existing content
    /// is sufficient (e.g., already rendered ahead of scroll position).
    /// This is an optimization to avoid rebuilding the DOM unnecessarily.
    ///
    /// # Arguments
    /// - `scroll_size` - Size of the current rendered content
    /// - `scroll_offset` - Position of current content in virtual space
    /// - `virtual_scroll_size` - Size for scrollbar representation
    /// - `virtual_scroll_offset` - Usually `LogicalPosition::zero()`
    pub fn keep_current(
        scroll_size: LogicalSize,
        scroll_offset: LogicalPosition,
        virtual_scroll_size: LogicalSize,
        virtual_scroll_offset: LogicalPosition,
    ) -> Self {
        Self {
            dom: OptionStyledDom::None,
            scroll_size,
            scroll_offset,
            virtual_scroll_size,
            virtual_scroll_offset,
        }
    }

    /// DEPRECATED: Use `with_dom()` instead for new content, or `keep_current()` to maintain
    /// existing content.
    ///
    /// This method is kept for backward compatibility but will be removed in a future version.
    #[deprecated(
        since = "1.0.0",
        note = "Use `with_dom()` for new content or `keep_current()` for no update"
    )]
    pub fn new(
        dom: StyledDom,
        scroll_size: LogicalSize,
        scroll_offset: LogicalPosition,
        virtual_scroll_size: LogicalSize,
        virtual_scroll_offset: LogicalPosition,
    ) -> Self {
        Self::with_dom(
            dom,
            scroll_size,
            scroll_offset,
            virtual_scroll_size,
            virtual_scroll_offset,
        )
    }
}

// --  thread callback

// -- timer callback

#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct TimerCallbackReturn {
    pub should_update: Update,
    pub should_terminate: TerminateTimer,
}

impl TimerCallbackReturn {
    /// Creates a new TimerCallbackReturn with the given update and terminate flags.
    pub fn create(should_update: Update, should_terminate: TerminateTimer) -> Self {
        Self {
            should_update,
            should_terminate,
        }
    }

    /// Timer continues running, no DOM update needed.
    pub fn continue_unchanged() -> Self {
        Self {
            should_update: Update::DoNothing,
            should_terminate: TerminateTimer::Continue,
        }
    }

    /// Timer continues running and DOM should be refreshed.
    pub fn continue_and_update() -> Self {
        Self {
            should_update: Update::RefreshDom,
            should_terminate: TerminateTimer::Continue,
        }
    }

    /// Timer should stop, no DOM update needed.
    pub fn terminate_unchanged() -> Self {
        Self {
            should_update: Update::DoNothing,
            should_terminate: TerminateTimer::Terminate,
        }
    }

    /// Timer should stop and DOM should be refreshed.
    pub fn terminate_and_update() -> Self {
        Self {
            should_update: Update::RefreshDom,
            should_terminate: TerminateTimer::Terminate,
        }
    }
}

impl Default for TimerCallbackReturn {
    fn default() -> Self {
        Self::continue_unchanged()
    }
}

/// Gives the `layout()` function access to the `RendererResources` and the `Window`
/// (for querying images and fonts, as well as width / height)
#[derive(Debug)]
#[repr(C)]
/// Reference data container for LayoutCallbackInfo (all read-only fields)
///
/// This struct consolidates all readonly references that layout callbacks need to query state.
/// By grouping these into a single struct, we reduce the number of parameters to
/// LayoutCallbackInfo::new() from 6 to 2, making the API more maintainable and easier to extend.
///
/// This is pure syntax sugar - the struct lives on the stack in the caller and is passed by
/// reference.
pub struct LayoutCallbackInfoRefData<'a> {
    /// Allows the layout() function to reference image IDs
    pub image_cache: &'a ImageCache,
    /// OpenGL context so that the layout() function can render textures
    pub gl_context: &'a OptionGlContextPtr,
    /// Reference to the system font cache
    pub system_fonts: &'a FcFontCache,
    /// Platform-specific system style (colors, spacing, etc.)
    /// Used for CSD rendering and menu windows.
    pub system_style: Arc<SystemStyle>,
}

#[repr(C)]
pub struct LayoutCallbackInfo {
    /// Single reference to all readonly reference data
    /// This consolidates 4 individual parameters into 1, improving API ergonomics
    ref_data: *const LayoutCallbackInfoRefData<'static>,
    /// Window size (so that apps can return a different UI depending on
    /// the window size - mobile / desktop view). Should be later removed
    /// in favor of "resize" handlers and @media queries.
    pub window_size: WindowSize,
    /// Registers whether the UI is dependent on the window theme
    pub theme: WindowTheme,
    /// Pointer to the callable (OptionRefAny) for FFI language bindings (Python, etc.)
    /// Set by the caller before invoking the callback. Native Rust callbacks have this as null.
    callable_ptr: *const OptionRefAny,
    /// Extension for future ABI stability (mutable data)
    _abi_mut: *mut core::ffi::c_void,
}

impl Clone for LayoutCallbackInfo {
    fn clone(&self) -> Self {
        Self {
            ref_data: self.ref_data,
            window_size: self.window_size,
            theme: self.theme,
            callable_ptr: self.callable_ptr,
            _abi_mut: self._abi_mut,
        }
    }
}

impl core::fmt::Debug for LayoutCallbackInfo {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("LayoutCallbackInfo")
            .field("window_size", &self.window_size)
            .field("theme", &self.theme)
            .finish_non_exhaustive()
    }
}

impl LayoutCallbackInfo {
    pub fn new<'a>(
        ref_data: &'a LayoutCallbackInfoRefData<'a>,
        window_size: WindowSize,
        theme: WindowTheme,
    ) -> Self {
        Self {
            // SAFETY: We cast away the lifetime 'a to 'static because LayoutCallbackInfo
            // only lives for the duration of the callback, which is shorter than 'a
            ref_data: unsafe { core::mem::transmute(ref_data) },
            window_size,
            theme,
            callable_ptr: core::ptr::null(),
            _abi_mut: core::ptr::null_mut(),
        }
    }

    /// Set the callable pointer for FFI language bindings
    pub fn set_callable_ptr(&mut self, callable: &OptionRefAny) {
        self.callable_ptr = callable as *const OptionRefAny;
    }

    /// Get the callable for FFI language bindings (Python, etc.)
    pub fn get_ctx(&self) -> OptionRefAny {
        if self.callable_ptr.is_null() {
            OptionRefAny::None
        } else {
            unsafe { (*self.callable_ptr).clone() }
        }
    }

    /// Get a clone of the system style Arc
    pub fn get_system_style(&self) -> Arc<SystemStyle> {
        unsafe { (*self.ref_data).system_style.clone() }
    }

    fn internal_get_image_cache<'a>(&'a self) -> &'a ImageCache {
        unsafe { (*self.ref_data).image_cache }
    }
    fn internal_get_system_fonts<'a>(&'a self) -> &'a FcFontCache {
        unsafe { (*self.ref_data).system_fonts }
    }
    fn internal_get_gl_context<'a>(&'a self) -> &'a OptionGlContextPtr {
        unsafe { (*self.ref_data).gl_context }
    }

    pub fn get_gl_context(&self) -> OptionGlContextPtr {
        self.internal_get_gl_context().clone()
    }

    pub fn get_system_fonts(&self) -> Vec<AzStringPair> {
        let fc_cache = self.internal_get_system_fonts();

        fc_cache
            .list()
            .iter()
            .filter_map(|(pattern, font_id)| {
                let source = fc_cache.get_font_by_id(font_id)?;
                match source {
                    FontSource::Memory(f) => None,
                    FontSource::Disk(d) => Some((pattern.name.as_ref()?.clone(), d.path.clone())),
                }
            })
            .map(|(k, v)| AzStringPair {
                key: k.into(),
                value: v.into(),
            })
            .collect()
    }

    pub fn get_image(&self, image_id: &AzString) -> Option<ImageRef> {
        self.internal_get_image_cache()
            .get_css_image_id(image_id)
            .cloned()
    }

    // Responsive layout helper methods
    /// Returns true if the window width is less than the given pixel value
    pub fn window_width_less_than(&self, px: f32) -> bool {
        self.window_size.dimensions.width < px
    }

    /// Returns true if the window width is greater than the given pixel value
    pub fn window_width_greater_than(&self, px: f32) -> bool {
        self.window_size.dimensions.width > px
    }

    /// Returns true if the window width is between min and max (inclusive)
    pub fn window_width_between(&self, min_px: f32, max_px: f32) -> bool {
        let width = self.window_size.dimensions.width;
        width >= min_px && width <= max_px
    }

    /// Returns true if the window height is less than the given pixel value
    pub fn window_height_less_than(&self, px: f32) -> bool {
        self.window_size.dimensions.height < px
    }

    /// Returns true if the window height is greater than the given pixel value
    pub fn window_height_greater_than(&self, px: f32) -> bool {
        self.window_size.dimensions.height > px
    }

    /// Returns true if the window height is between min and max (inclusive)
    pub fn window_height_between(&self, min_px: f32, max_px: f32) -> bool {
        let height = self.window_size.dimensions.height;
        height >= min_px && height <= max_px
    }

    /// Returns the current window width in pixels
    pub fn get_window_width(&self) -> f32 {
        self.window_size.dimensions.width
    }

    /// Returns the current window height in pixels
    pub fn get_window_height(&self) -> f32 {
        self.window_size.dimensions.height
    }

    /// Returns the current window DPI factor
    pub fn get_dpi_factor(&self) -> f32 {
        self.window_size.dpi as f32
    }
}

/// Information about the bounds of a laid-out div rectangle.
///
/// Necessary when invoking `IFrameCallbacks` and `RenderImageCallbacks`, so
/// that they can change what their content is based on their size.
#[derive(Debug, Copy, Clone)]
#[repr(C)]
pub struct HidpiAdjustedBounds {
    pub logical_size: LogicalSize,
    pub hidpi_factor: DpiScaleFactor,
}

impl HidpiAdjustedBounds {
    #[inline(always)]
    pub fn from_bounds(bounds: LayoutSize, hidpi_factor: DpiScaleFactor) -> Self {
        let logical_size = LogicalSize::new(bounds.width as f32, bounds.height as f32);
        Self {
            logical_size,
            hidpi_factor,
        }
    }

    pub fn get_physical_size(&self) -> PhysicalSize<u32> {
        self.get_logical_size()
            .to_physical(self.get_hidpi_factor().inner.get())
    }

    pub fn get_logical_size(&self) -> LogicalSize {
        self.logical_size
    }

    pub fn get_hidpi_factor(&self) -> DpiScaleFactor {
        self.hidpi_factor.clone()
    }
}

/// Defines the focus_targeted node ID for the next frame
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C, u8)]
pub enum FocusTarget {
    Id(DomNodeId),
    Path(FocusTargetPath),
    Previous,
    Next,
    First,
    Last,
    NoFocus,
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct FocusTargetPath {
    pub dom: DomId,
    pub css_path: CssPath,
}

// -- normal callback

// core callback types (usize-based placeholders)
//
// These types use `usize` instead of function pointers to avoid creating
// a circular dependency between azul-core and azul-layout.
//
// The actual function pointers will be stored in azul-layout, which will
// use unsafe code to transmute between usize and the real function pointers.
//
// IMPORTANT: The memory layout must be identical to the real types!
// Tests for this are in azul-layout/src/callbacks.rs
//
// Naming convention: "Core" prefix indicates these are the low-level types

/// Core callback type - uses usize instead of function pointer to avoid circular dependencies.
///
/// **IMPORTANT**: This is NOT actually a usize at runtime - it's a function pointer that is
/// cast to usize for storage in the data model. When invoking the callback, this usize is
/// unsafely cast back to the actual function pointer type:
/// `extern "C" fn(RefAny, CallbackInfo) -> Update`
///
/// This design allows azul-core to store callbacks without depending on azul-layout's CallbackInfo
/// type. The actual function pointer type is defined in azul-layout as `CallbackType`.
pub type CoreCallbackType = usize;

/// Stores a callback as usize (actually a function pointer cast to usize)
///
/// **IMPORTANT**: The `cb` field stores a function pointer disguised as usize to avoid
/// circular dependencies between azul-core and azul-layout. When creating a CoreCallback,
/// you can directly assign a function pointer - Rust will implicitly cast it to usize.
/// When invoking, the usize must be unsafely cast back to the function pointer type.
///
/// Must return an `Update` that denotes if the screen should be redrawn.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CoreCallback {
    pub cb: CoreCallbackType,
    /// For FFI: stores the foreign callable (e.g., PyFunction)
    /// Native Rust code sets this to None
    pub ctx: OptionRefAny,
}

/// Allow creating CoreCallback from a raw function pointer (as usize)
/// Sets callable to None (for native Rust/C usage)
impl From<CoreCallbackType> for CoreCallback {
    fn from(cb: CoreCallbackType) -> Self {
        CoreCallback {
            cb,
            ctx: OptionRefAny::None,
        }
    }
}

impl_option!(
    CoreCallback,
    OptionCoreCallback,
    [Debug, Eq, Clone, PartialEq, PartialOrd, Ord, Hash]
);

/// Data associated with a callback (event filter, callback, and user data)
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CoreCallbackData {
    pub event: EventFilter,
    pub callback: CoreCallback,
    pub refany: RefAny,
}

impl_vec!(
    CoreCallbackData,
    CoreCallbackDataVec,
    CoreCallbackDataVecDestructor,
    CoreCallbackDataVecDestructorType
);
impl_vec_clone!(
    CoreCallbackData,
    CoreCallbackDataVec,
    CoreCallbackDataVecDestructor
);
impl_vec_mut!(CoreCallbackData, CoreCallbackDataVec);
impl_vec_debug!(CoreCallbackData, CoreCallbackDataVec);
impl_vec_partialord!(CoreCallbackData, CoreCallbackDataVec);
impl_vec_ord!(CoreCallbackData, CoreCallbackDataVec);
impl_vec_partialeq!(CoreCallbackData, CoreCallbackDataVec);
impl_vec_eq!(CoreCallbackData, CoreCallbackDataVec);
impl_vec_hash!(CoreCallbackData, CoreCallbackDataVec);

impl CoreCallbackDataVec {
    #[inline]
    pub fn as_container<'a>(&'a self) -> NodeDataContainerRef<'a, CoreCallbackData> {
        NodeDataContainerRef {
            internal: self.as_ref(),
        }
    }
    #[inline]
    pub fn as_container_mut<'a>(&'a mut self) -> NodeDataContainerRefMut<'a, CoreCallbackData> {
        NodeDataContainerRefMut {
            internal: self.as_mut(),
        }
    }
}

// -- image rendering callback

/// Image rendering callback type - uses usize instead of function pointer
pub type CoreRenderImageCallbackType = usize;

/// Callback that returns a rendered OpenGL texture (usize placeholder)
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CoreRenderImageCallback {
    pub cb: CoreRenderImageCallbackType,
    /// For FFI: stores the foreign callable (e.g., PyFunction)
    /// Native Rust code sets this to None
    pub ctx: OptionRefAny,
}

/// Allow creating CoreRenderImageCallback from a raw function pointer (as usize)
/// Sets callable to None (for native Rust/C usage)
impl From<CoreRenderImageCallbackType> for CoreRenderImageCallback {
    fn from(cb: CoreRenderImageCallbackType) -> Self {
        CoreRenderImageCallback {
            cb,
            ctx: OptionRefAny::None,
        }
    }
}

/// Image callback with associated data
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(C)]
pub struct CoreImageCallback {
    pub refany: RefAny,
    pub callback: CoreRenderImageCallback,
}

impl_option!(
    CoreImageCallback,
    OptionCoreImageCallback,
    copy = false,
    [Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash]
);

```

### CSS

================================================================================
## FILE: css/src/lib.rs
## Description: CSS parsing
================================================================================
```
//! Provides datatypes used to describe an application's style using the Azul GUI framework.
#![allow(warnings)]

// #![no_std]

#[macro_use]
extern crate alloc;
extern crate core;

#[macro_use]
pub mod macros;
pub mod corety;
pub mod css;
pub mod dynamic_selector;
pub mod format_rust_code;
#[cfg(feature = "parser")]
pub mod parser2;
pub mod props;
pub mod shape;
pub mod shape_parser;
pub mod system;

pub use self::corety::*;

```

### TEST EXAMPLE

### SHELL2 CORE

================================================================================
## FILE: dll/src/desktop/shell2/mod.rs
## Description: Shell2 module root
================================================================================
```
//! shell2 - Modern windowing system abstraction.
//!
//! This module provides a clean, platform-agnostic windowing API with:
//! - Dynamic library loading (Linux, Windows) to avoid linker errors
//! - CPU/GPU compositor selection per window
//! - Clean trait-based architecture
//! - Support for macOS, Windows, Linux (X11 + Wayland)
//!
//! # Architecture
//!
//! ```text
//! shell2/
//! ├── common/          Platform-agnostic traits and types
//! ├── macos/           AppKit implementation (static linking)
//! ├── windows/         Win32 implementation (dynamic loading)
//! ├── linux/
//! │   ├── x11/         X11 implementation (dynamic loading)
//! │   └── wayland/     Wayland implementation (dynamic loading)
//! └── stub/            Headless testing backend
//! ```
//!
//! # Feature Flags
//!
//! - `shell2` - Enable new shell2 implementation (default)
//! - `x11` - Enable X11 backend (Linux)
//! - `wayland` - Enable Wayland backend (Linux)
//!
//! # Environment Variables
//!
//! - `AZUL_COMPOSITOR` - Force compositor mode: "cpu", "gpu", "auto" (default)
//! - `AZUL_BACKEND` - Force Linux backend: "x11", "wayland" (auto-detect default)

pub mod common;

// Platform-specific modules
#[cfg(target_os = "linux")]
pub mod linux;
#[cfg(target_os = "ios")]
pub mod linux;
#[cfg(target_os = "macos")]
pub mod macos;
#[cfg(target_os = "windows")]
pub mod windows;

// Always available for testing
pub mod stub;
// Main event loop implementation
pub mod run;

// Re-export common types
pub use common::{
    select_compositor_mode, Compositor, CompositorError, CompositorMode, CpuCompositor, DlError,
    DynamicLibrary, PlatformWindow, RenderContext, SystemCapabilities, WindowError,
    WindowProperties,
};
// Re-export run function
pub use run::run;

// Platform-specific window type selection
cfg_if::cfg_if! {
    if #[cfg(target_os = "macos")] {
        pub use macos::MacOSWindow as Window;
        pub use macos::MacOSEvent as WindowEvent;
    } else if #[cfg(target_os = "ios")] {
        pub use ios::IOSWindow as Window;
        pub use ios::IOSEvent as WindowEvent;
    } else if #[cfg(target_os = "windows")] {
        pub use windows::Win32Window as Window;
        pub use windows::Win32Event as WindowEvent;
    } else if #[cfg(target_os = "linux")] {
        pub use linux::LinuxWindow as Window;
        pub use linux::LinuxEvent as WindowEvent;
    } else {
        // Unknown platform - use stub
        pub use stub::StubWindow as Window;
        pub use stub::StubEvent as WindowEvent;
    }
}

/// Get the current windowing backend name.
pub fn get_backend_name() -> &'static str {
    #[cfg(target_os = "macos")]
    return "macos-appkit";

    #[cfg(target_os = "windows")]
    return "windows-win32";

    #[cfg(target_os = "ios")]
    return "ios-uikit";

    #[cfg(target_os = "linux")]
    {
        // Runtime detection on Linux
        if std::env::var("AZUL_BACKEND").as_deref() == Ok("x11") {
            return "linux-x11";
        }
        if std::env::var("AZUL_BACKEND").as_deref() == Ok("wayland") {
            return "linux-wayland";
        }
        if std::env::var("WAYLAND_DISPLAY").is_ok() {
            return "linux-wayland";
        } else if std::env::var("DISPLAY").is_ok() {
            return "linux-x11";
        } else {
            return "linux-headless";
        }
    }

    #[cfg(not(any(
        target_os = "macos",
        target_os = "ios",
        target_os = "windows",
        target_os = "linux"
    )))]
    return "stub";
}

/// Get shell2 version information.
pub fn get_version() -> &'static str {
    env!("CARGO_PKG_VERSION")
}

```

### DLL ENTRY

================================================================================
## FILE: dll/src/lib.rs
## Description: DLL lib
================================================================================
```
//! Azul DLL - C API bindings for the Azul GUI framework
//!
//! This crate provides the C-ABI functions for the Azul library.
//! The API is auto-generated from api.json using `azul-doc codegen all`.
//!
//! To regenerate all bindings:
//!   cd doc && cargo run --release -- codegen all
//!
//! ## Feature Flags
//!
//! ### Build Modes
//! - `build-dll`: Build the shared library (libazul.dylib/so/dll) with C-API exports
//!
//! ### Link Modes (for consumers)
//! - `link-static`: Statically link Azul (types + trait impls via transmute)
//! - `link-dynamic`: Dynamically link against libazul.dylib/so/dll (extern "C" calls)
//!
//! These link modes are mutually exclusive. If neither is enabled, only the
//! desktop module is exported as a regular Rust library.

#![deny(improper_ctypes_definitions)]
#![allow(unused_imports)]
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(non_snake_case)]

#[macro_use]
extern crate alloc;

// Internal crates - only needed for build-dll and link-static
#[cfg(any(feature = "build-dll", feature = "link-static"))]
extern crate azul_core;
#[cfg(any(feature = "build-dll", feature = "link-static"))]
extern crate azul_css;
#[cfg(any(feature = "build-dll", feature = "link-static"))]
extern crate azul_layout;

// Desktop windowing implementation (OpenGL, fonts, event loop, etc.)
// Compiled for both build-dll AND link-static (only link-dynamic excludes it)
#[cfg(all(
    any(feature = "build-dll", feature = "link-static"),
    not(target_arch = "wasm32")
))]
pub mod desktop;

// =============================================================================
// Build DLL: Include C-API functions with #[no_mangle] for export
// This is used when building libazul.dylib/so/dll
// Generated by: cd doc && cargo run --release -- codegen all
// =============================================================================

#[cfg(feature = "build-dll")]
mod __ffi_build {
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/codegen/v2/dll_api_build.rs"
    ));
}

#[cfg(feature = "build-dll")]
pub use __ffi_build::__dll_api_inner::dll;

#[cfg(feature = "build-dll")]
pub mod ffi {
    pub use crate::__ffi_build::__dll_api_inner::*;
}

// =============================================================================
// Static Linking: Types + trait impls via transmute (NO C-API functions)
// This is used when statically linking Azul into your Rust application
// Generated by: cd doc && cargo run --release -- codegen all
// =============================================================================

#[cfg(all(feature = "link-static", not(feature = "build-dll")))]
mod __ffi_static {
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/codegen/v2/dll_api_static.rs"
    ));
}

#[cfg(all(feature = "link-static", not(feature = "build-dll")))]
pub use __ffi_static::__dll_api_inner::dll;

#[cfg(all(feature = "link-static", not(feature = "build-dll")))]
pub mod ffi {
    pub use crate::__ffi_static::__dll_api_inner::*;
}

// =============================================================================
// Dynamic Linking: Types + extern "C" declarations
// This is used when linking against a pre-built libazul.dylib/so/dll
// Generated by: cd doc && cargo run --release -- codegen all
// =============================================================================

#[cfg(all(
    feature = "link-dynamic",
    not(feature = "link-static"),
    not(feature = "build-dll")
))]
mod __ffi_dynamic {
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/codegen/v2/dll_api_dynamic.rs"
    ));
}

#[cfg(all(
    feature = "link-dynamic",
    not(feature = "link-static"),
    not(feature = "build-dll")
))]
pub use __ffi_dynamic::__dll_api_inner::dll;

#[cfg(all(
    feature = "link-dynamic",
    not(feature = "link-static"),
    not(feature = "build-dll")
))]
pub mod ffi {
    pub use crate::__ffi_dynamic::__dll_api_inner::*;
}

// =============================================================================
// Public Rust API: Re-exports without Az prefix
// Generated by: cd doc && cargo run --release -- codegen all
//
// This provides a nice Rust API:
//   use azul::prelude::*;
//   use azul::app::App;
//   use azul::dom::Dom;
// =============================================================================

#[cfg(any(
    feature = "link-static",
    feature = "link-dynamic",
    feature = "build-dll"
))]
include!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/../target/codegen/v2/reexports.rs"
));

// =============================================================================
// Python Extension Module
// Generated by: cd doc && cargo run --release -- codegen all
// =============================================================================

#[cfg(feature = "python-extension")]
mod python {
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/codegen/v2/python_api.rs"
    ));
}

// Re-export the pymodule function at crate root for PyInit_azul to work
#[cfg(feature = "python-extension")]
pub use python::azul;

// =============================================================================
// Memory Tests: Size and alignment verification
// Generated by: cd doc && cargo run --release -- codegen all
// Run with: cd dll && cargo test
// =============================================================================

#[cfg(test)]
mod memtest {
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../target/codegen/v2/memtest.rs"
    ));
}

```

================================================================================
## FILE: dll/main.rs
## Description: DLL main
================================================================================
```
// empty binary, simply so that "cargo install azul-dll" downloads and builds the azul_dll crate"
fn main() {}

```

### CORE LIB

================================================================================
## FILE: core/src/lib.rs
## Description: Core lib root
================================================================================
```
//! Shared datatypes for azul-* crates

#![cfg_attr(not(feature = "std"), no_std)]
#![allow(warnings)]

#[macro_use]
extern crate core;
#[macro_use]
extern crate alloc;
#[macro_use]
extern crate azul_css;

/// Useful macros for implementing Azul APIs without duplicating code
#[macro_use]
pub mod macros;
/// Unified debug logging system
#[macro_use]
pub mod debug;
/// Type definitions for various types of callbacks plus focus and scroll handling
#[macro_use]
pub mod callbacks;
/// `Dom` construction, `NodeData` and `NodeType` management functions
pub mod dom;
/// Table layout support (anonymous box generation)
pub mod dom_table;
/// Unified drag context for text selection, scrollbar, node, and window drags
pub mod drag;
/// Icon system for loading and resolving icons from fonts, images, or zip packs
pub mod icon;
/// Type definitions for Glyphs
pub mod glyph;
/// Functions to manage adding fonts + images, garbage collection
pub mod resources;
/// Primitives for cursor and text selection handling
pub mod selection;
/// Algorithms to create git-like diffs between two doms in linear time
pub mod diff;
/// Animation system
pub mod animation;
/// Event handling (mouse, keyboard, window events)
pub mod events;
/// Geometry module for physical and logical sizes
pub mod geom;
/// Contains OpenGL helper functions (to compile / link shaders)
pub mod gl;
/// FXAA (Fast Approximate Anti-Aliasing) shader implementation
pub mod gl_fxaa;
/// OpenGL constants
pub mod glconst;
/// GPU value synchronization (colors, transforms) for WebRender preparation
pub mod gpu;
/// Hit-testing module
pub mod hit_test;
/// Type-safe hit-test tag system for WebRender integration
pub mod hit_test_tag;
/// Internal, arena-based storage for Dom nodes
pub mod id;
/// Types for handling menus (context menu, menubar)
pub mod menu;
/// Cache for CSS Properties
pub mod prop_cache;
/// Type-erased reference wrapper (like `Box<dyn Any>` but for references)
pub mod refany;
/// CSS cascading module
pub mod style;
/// `StyledDom` = CSSOM
pub mod styled_dom;
/// SVG module
pub mod svg;
/// Async (task, thread, timer) helper functions
pub mod task;
/// CSS transform computation
pub mod transform;
/// User-agent default stylesheet
pub mod ua_css;
/// Handles the UI layout and UI layout solver
pub mod ui_solver;
/// Window creation / interaction with the OS' windowing API
pub mod window;
/// XML structures
pub mod xml;

// Typedef for possible faster implementation of hashing
pub type FastHashMap<T, U> = alloc::collections::BTreeMap<T, U>;
pub type FastBTreeSet<T> = alloc::collections::BTreeSet<T>;

```

================================================================================
## FILE: core/src/animation.rs
## Description: Animation system
================================================================================
```
//! Core data structures for configuring and tracking CSS animations

use azul_css::props::{basic::AnimationInterpolationFunction, property::CssProperty};

use crate::task::{Duration as AzDuration, GetSystemTimeCallback, Instant as AzInstant};

/// Specifies which image layer of an element an animation should apply to.
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub enum UpdateImageType {
    /// The animation targets the element's background.
    Background,
    /// The animation targets the element's main content.
    Content,
}

/// Holds the dynamic, runtime state of an active animation instance.
/// This is created when an `Animation` begins playing.
#[derive(Debug, Clone, PartialEq)]
pub struct AnimationData {
    /// The starting `CssProperty` value of the animation.
    pub from: CssProperty,
    /// The target `CssProperty` value at the end of the animation.
    pub to: CssProperty,
    /// The timestamp marking when the animation began.
    pub start: AzInstant,
    /// The total time the animation takes to complete one cycle.
    pub duration: AzDuration,
    /// The repetition behavior of the animation (e.g., loop, ping-pong).
    pub repeat: AnimationRepeat,
    /// The easing function used to control the animation's pacing.
    pub interpolate: AnimationInterpolationFunction,
    /// If `true`, a relayout is triggered after the animation finishes.
    pub relayout_on_finish: bool,
    /// The width of the parent's bounding rectangle at the animation's start.
    pub parent_rect_width: f32,
    /// The height of the parent's bounding rectangle at the animation's start.
    pub parent_rect_height: f32,
    /// The width of the animated element's bounding rectangle at the animation's start.
    pub current_rect_width: f32,
    /// The height of the animated element's bounding rectangle at the animation's start.
    pub current_rect_height: f32,
    /// A callback function used to get the current system time for synchronized timing.
    pub get_system_time_fn: GetSystemTimeCallback,
}

/// Defines the static configuration for a CSS animation, parsed from a stylesheet.
#[derive(Debug, Clone, PartialEq)]
#[repr(C)]
pub struct Animation {
    /// The `CssProperty` at the beginning of the animation (0% keyframe).
    pub from: CssProperty,
    /// The `CssProperty` at the end of the animation (100% keyframe).
    pub to: CssProperty,
    /// The time it takes for the animation to complete one cycle.
    pub duration: AzDuration,
    /// The repetition behavior to apply when a cycle finishes.
    pub repeat: AnimationRepeat,
    /// How many times the animation should repeat.
    pub repeat_times: AnimationRepeatCount,
    /// The easing function that dictates the animation's rate of change.
    pub easing: AnimationInterpolationFunction,
    /// If `true`, a full relayout is performed after the animation concludes.
    pub relayout_on_finish: bool,
}

/// Describes the behavior of an animation when it reaches the end of a cycle.
#[derive(Debug, Copy, Clone, PartialEq)]
#[repr(C)]
pub enum AnimationRepeat {
    /// The animation plays once and then stops.
    NoRepeat,
    /// The animation restarts from the beginning after finishing.
    Loop,
    /// The animation plays forwards, then backwards, alternating each cycle.
    PingPong,
}

/// Specifies how many times an animation cycle should repeat.
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Hash)]
#[repr(C, u8)]
pub enum AnimationRepeatCount {
    /// The animation repeats for a specific number of cycles.
    Times(usize),
    /// The animation repeats indefinitely.
    Infinite,
}

```

### FONT HANDLING

### ADDITIONAL LAYOUT FILES

================================================================================
## FILE: layout/src/hit_test.rs
================================================================================
```
//! Hit-testing logic for layout windows
//!
//! This module handles determining which DOM nodes are under the mouse cursor
//! and resolving the cursor icon based on CSS cursor properties.
//!
//! ## Cursor Resolution Algorithm
//!
//! WebRender returns hit-test results in **front-to-back** order:
//! - `depth = 0` is the frontmost/topmost element (closest to the user)
//! - Higher depth values are further back in the z-order
//!
//! The algorithm finds the **frontmost** node that has an explicit CSS `cursor`
//! property set. If no node has a cursor property, we check if the node has
//! text children and use their cursor property (typically `cursor:text`).
//!
//! ## Design Principles
//!
//! 1. **Frontmost priority**: The node closest to the user (lowest depth) takes
//!    precedence. This matches browser behavior where a button's cursor:pointer
//!    overrides any parent's cursor setting.
//!
//! 2. **Text-child inheritance**: Text nodes are inline and don't get hit-test areas.
//!    Their container inherits the text node's cursor if the container has no explicit
//!    cursor property. This shows I-beam cursor over text containers.
//!
//! 3. **Explicit cursor wins**: If a container has an explicit cursor property
//!    (like `cursor:pointer` on a button), it overrides any text-child cursor.

use std::collections::BTreeMap;

// Re-export FullHitTest from azul_core for backwards compatibility
pub use azul_core::hit_test::FullHitTest;
use azul_core::{
    dom::{DomId, DomNodeId, NodeId},
    hit_test::{HitTest, HitTestItem},
    window::MouseCursorType,
};
use azul_css::props::style::StyleCursor;

use crate::window::LayoutWindow;

/// Result of cursor type hit-testing, determines which mouse cursor to display
#[derive(Debug, Clone, Default, PartialEq)]
pub struct CursorTypeHitTest {
    /// The node that has a non-default cursor property (if any)
    pub cursor_node: Option<(DomId, NodeId)>,
    /// The mouse cursor type to display
    pub cursor_icon: MouseCursorType,
}

impl CursorTypeHitTest {
    /// Create a new cursor type hit-test from a full hit-test and layout window
    ///
    /// Finds the frontmost (lowest depth) node with a cursor property.
    ///
    /// ## Algorithm
    ///
    /// 1. First, check cursor_hit_test_nodes (direct text run hits with TAG_TYPE_CURSOR)
    ///    - These are hit-test areas pushed for text runs with source_node_id
    ///    - The cursor type is encoded directly in the hit-test tag
    /// 2. Then, check regular_hit_test_nodes (DOM nodes with explicit cursor property)
    /// 3. The frontmost (lowest depth) cursor wins
    ///
    /// This approach eliminates the need for text-child-detection hacks because
    /// text runs now have their own hit-test areas with the correct cursor type.
    pub fn new(hit_test: &FullHitTest, layout_window: &LayoutWindow) -> Self {
        use azul_core::hit_test_tag::CursorType;
        
        let mut cursor_node = None;
        let mut cursor_icon = MouseCursorType::Default;
        // Start with MAX so any node with a cursor property will be selected
        let mut best_depth: u32 = u32::MAX;

        // Iterate through all hovered nodes across all DOMs
        for (dom_id, hit_nodes) in hit_test.hovered_nodes.iter() {
            // Get the layout result for this DOM
            let layout_result = match layout_window.get_layout_result(dom_id) {
                Some(lr) => lr,
                None => continue,
            };

            let styled_dom = &layout_result.styled_dom;
            let node_data_container = styled_dom.node_data.as_container();
            let styled_nodes = styled_dom.styled_nodes.as_container();

            // PHASE 1: Check cursor_hit_test_nodes first (direct text run hits)
            // These are hit-test areas for text runs that have the cursor type
            // encoded directly in the tag, eliminating the need for CSS lookups.
            for (node_id, cursor_hit) in hit_nodes.cursor_hit_test_nodes.iter() {
                let node_depth = cursor_hit.hit_depth;
                
                // Only consider if it's in front of our current best
                if node_depth >= best_depth {
                    continue;
                }
                
                // Convert CursorType to MouseCursorType
                let mouse_cursor = translate_cursor_type(cursor_hit.cursor_type);
                
                // Only use this cursor if it's not the default
                // (allows containers behind text to show their cursor if text has default)
                if mouse_cursor != MouseCursorType::Default {
                    cursor_node = Some((*dom_id, *node_id));
                    cursor_icon = mouse_cursor;
                    best_depth = node_depth;
                }
            }

            // PHASE 2: Check regular_hit_test_nodes (DOM nodes with CSS cursor property)
            for (node_id, hit_item) in hit_nodes.regular_hit_test_nodes.iter() {
                let node_depth = hit_item.hit_depth;
                
                // Only consider this node if it's in front of our current best
                if node_depth >= best_depth {
                    continue;
                }
                
                // Query the CSS cursor property for this node
                let cursor_prop = styled_dom.get_css_property_cache().get_cursor(
                    &node_data_container[*node_id],
                    node_id,
                    &styled_nodes[*node_id].styled_node_state,
                );
                
                // If this node has an explicit cursor property, use it
                if let Some(cursor_prop) = cursor_prop {
                    let css_cursor = cursor_prop.get_property().copied().unwrap_or_default();
                    cursor_node = Some((*dom_id, *node_id));
                    cursor_icon = translate_cursor(css_cursor);
                    best_depth = node_depth;
                }
            }
        }

        Self {
            cursor_node,
            cursor_icon,
        }
    }
}

/// Translate CursorType (from hit-test tag) to MouseCursorType
fn translate_cursor_type(cursor_type: azul_core::hit_test_tag::CursorType) -> MouseCursorType {
    use azul_core::hit_test_tag::CursorType;
    
    match cursor_type {
        CursorType::Default => MouseCursorType::Default,
        CursorType::Pointer => MouseCursorType::Hand,
        CursorType::Text => MouseCursorType::Text,
        CursorType::Crosshair => MouseCursorType::Crosshair,
        CursorType::Move => MouseCursorType::Move,
        CursorType::NotAllowed => MouseCursorType::NotAllowed,
        CursorType::Grab => MouseCursorType::Grab,
        CursorType::Grabbing => MouseCursorType::Grabbing,
        CursorType::EResize => MouseCursorType::EResize,
        CursorType::WResize => MouseCursorType::WResize,
        CursorType::NResize => MouseCursorType::NResize,
        CursorType::SResize => MouseCursorType::SResize,
        CursorType::EwResize => MouseCursorType::EwResize,
        CursorType::NsResize => MouseCursorType::NsResize,
        CursorType::NeswResize => MouseCursorType::NeswResize,
        CursorType::NwseResize => MouseCursorType::NwseResize,
        CursorType::ColResize => MouseCursorType::ColResize,
        CursorType::RowResize => MouseCursorType::RowResize,
        CursorType::Wait => MouseCursorType::Wait,
        CursorType::Help => MouseCursorType::Help,
        CursorType::Progress => MouseCursorType::Progress,
    }
}

/// Translate CSS cursor value to MouseCursorType
fn translate_cursor(cursor: StyleCursor) -> MouseCursorType {
    use azul_css::props::style::effects::StyleCursor;

    match cursor {
        StyleCursor::Default => MouseCursorType::Default,
        StyleCursor::Crosshair => MouseCursorType::Crosshair,
        StyleCursor::Pointer => MouseCursorType::Hand,
        StyleCursor::Move => MouseCursorType::Move,
        StyleCursor::Text => MouseCursorType::Text,
        StyleCursor::Wait => MouseCursorType::Wait,
        StyleCursor::Help => MouseCursorType::Help,
        StyleCursor::Progress => MouseCursorType::Progress,
        StyleCursor::ContextMenu => MouseCursorType::ContextMenu,
        StyleCursor::Cell => MouseCursorType::Cell,
        StyleCursor::VerticalText => MouseCursorType::VerticalText,
        StyleCursor::Alias => MouseCursorType::Alias,
        StyleCursor::Copy => MouseCursorType::Copy,
        StyleCursor::Grab => MouseCursorType::Grab,
        StyleCursor::Grabbing => MouseCursorType::Grabbing,
        StyleCursor::AllScroll => MouseCursorType::AllScroll,
        StyleCursor::ZoomIn => MouseCursorType::ZoomIn,
        StyleCursor::ZoomOut => MouseCursorType::ZoomOut,
        StyleCursor::EResize => MouseCursorType::EResize,
        StyleCursor::NResize => MouseCursorType::NResize,
        StyleCursor::SResize => MouseCursorType::SResize,
        StyleCursor::SeResize => MouseCursorType::SeResize,
        StyleCursor::WResize => MouseCursorType::WResize,
        StyleCursor::EwResize => MouseCursorType::EwResize,
        StyleCursor::NsResize => MouseCursorType::NsResize,
        StyleCursor::NeswResize => MouseCursorType::NeswResize,
        StyleCursor::NwseResize => MouseCursorType::NwseResize,
        StyleCursor::ColResize => MouseCursorType::ColResize,
        StyleCursor::RowResize => MouseCursorType::RowResize,
        StyleCursor::Unset => MouseCursorType::Default,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use azul_core::dom::DomNodeId;
    use azul_core::dom::OptionDomNodeId;

    #[test]
    fn test_full_hit_test_empty() {
        let hit_test = FullHitTest::empty(None);
        assert!(hit_test.is_empty());
        assert!(hit_test.focused_node.is_none());
    }

    #[test]
    fn test_full_hit_test_with_focused_node() {
        let focused = DomNodeId {
            dom: DomId { inner: 0 },
            node: azul_core::styled_dom::NodeHierarchyItemId::from_crate_internal(Some(
                NodeId::new(5),
            )),
        };
        let hit_test = FullHitTest::empty(Some(focused));
        assert!(hit_test.is_empty()); // No hovered nodes
        assert_eq!(
            hit_test.focused_node,
            OptionDomNodeId::Some(DomNodeId {
                dom: DomId { inner: 0 },
                node: azul_core::styled_dom::NodeHierarchyItemId::from_crate_internal(Some(
                    NodeId::new(5),
                )),
            })
        );
    }

    #[test]
    fn test_cursor_type_hit_test_default() {
        let cursor_test = CursorTypeHitTest::default();
        assert_eq!(cursor_test.cursor_icon, MouseCursorType::Default);
        assert!(cursor_test.cursor_node.is_none());
    }

    #[test]
    fn test_translate_cursor_mapping() {
        use azul_css::props::style::effects::StyleCursor;

        assert_eq!(
            translate_cursor(StyleCursor::Default),
            MouseCursorType::Default
        );
        assert_eq!(
            translate_cursor(StyleCursor::Pointer),
            MouseCursorType::Hand
        );
        assert_eq!(translate_cursor(StyleCursor::Text), MouseCursorType::Text);
        assert_eq!(translate_cursor(StyleCursor::Move), MouseCursorType::Move);
        assert_eq!(
            translate_cursor(StyleCursor::Crosshair),
            MouseCursorType::Crosshair
        );
    }
}

```


---

## ANALYSIS REQUEST

Please analyze the above code and provide:

1. **Root Cause Analysis** for each bug listed above
2. **Specific Code Fixes** with exact file paths and line numbers
3. **Architecture Recommendations** if the current design has fundamental issues
4. **Testing Strategy** to verify fixes

Focus especially on:
- Why "No focused node" error occurs when clicking on contenteditable text
- How focus should propagate from parent `<div tabindex=0>` to contenteditable child
- The relationship between IFC root nodes and contenteditable containers
- Why line wrapping happens when it shouldn't
- Scrollbar visibility and positioning logic

Total lines in this prompt: ~36231
