I have analyzed the action plan and the existing code. I will now provide the necessary fixes and architectural changes to complete the `shell2` implementation for Windows, preparing it for the features outlined in your plan.

Here are the complete, updated code blocks for the files that need to be changed.

=== dll/src/lib.rs ===
```rust
//! WARNING: autogenerated code for azul api version 1.0.0-alpha1

#![deny(improper_ctypes_definitions)]

#[macro_use]
extern crate alloc;
extern crate azul_core;

#[cfg(not(target_arch = "wasm32"))]
pub mod desktop;
#[cfg(target_arch = "wasm32")]
pub mod web;

// Re-enabled extra module, as it has no breaking API incompatibilities.
pub mod extra;

pub mod str;

pub mod azul_impl {
    #[cfg(target_arch = "wasm32")]
    pub use self::web::*;
    #[cfg(not(target_arch = "wasm32"))]
    pub use super::desktop::*;
}

#[cfg(all(
    feature = "python-extension",
    feature = "link-dynamic",
    not(feature = "link-static")
))]
pub mod python;

// TODO: Re-enable widgets after fixing API compatibility
// The widgets module has similar API incompatibilities as extra:
// - NodeId::from_crate_internal() / into_crate_internal() usage throughout
// - Direct NodeData.callbacks field access (now private, use accessors)
// - LayoutCallbackInfo API changes
// - ExternalSystemCallbacks::default() -> ::rust_internal()
// Total errors: ~68 across all widget implementations
// pub mod widgets;
```
=== dll/src/desktop/shell2/mod.rs ===
```rust
//! shell2 - Modern windowing system abstraction.
//!
//! This module provides a clean, platform-agnostic windowing API with:
//! - Dynamic library loading (Linux, Windows) to avoid linker errors
//! - CPU/GPU compositor selection per window
//! - Clean trait-based architecture
//! - Support for macOS, Windows, Linux (X11 + Wayland)
//!
//! # Architecture
//!
//! ```text
//! shell2/
//! ‚îú‚îÄ‚îÄ common/          Platform-agnostic traits and types
//! ‚îú‚îÄ‚îÄ macos/           AppKit implementation (static linking)
//! ‚îú‚îÄ‚îÄ windows/         Win32 implementation (dynamic loading)
//! ‚îú‚îÄ‚îÄ linux/
//! ‚îÇ   ‚îú‚îÄ‚îÄ x11/         X11 implementation (dynamic loading)
//! ‚îÇ   ‚îî‚îÄ‚îÄ wayland/     Wayland implementation (dynamic loading)
//! ‚îî‚îÄ‚îÄ stub/            Headless testing backend
//! ```
//!
//! # Usage
//!
//! ```rust,ignore
//! use shell2::{PlatformWindow, WindowCreateOptions};
//!
//! let window = PlatformWindow::new(WindowCreateOptions::default())?;
//! ```
//!
//! # Feature Flags
//!
//! - `shell2` - Enable new shell2 implementation (default)
//! - `x11` - Enable X11 backend (Linux)
//! - `wayland` - Enable Wayland backend (Linux)
//!
//! # Environment Variables
//!
//! - `AZUL_COMPOSITOR` - Force compositor mode: "cpu", "gpu", "auto" (default)
//! - `AZUL_BACKEND` - Force Linux backend: "x11", "wayland" (auto-detect default)

pub mod common;

// Platform-specific modules
#[cfg(target_os = "macos")]
pub mod macos;

#[cfg(target_os = "windows")]
pub mod windows;

#[cfg(target_os = "linux")]
pub mod linux;

// Always available for testing
pub mod stub;

// Main event loop implementation
pub mod run;

// Re-export common types
pub use common::{
    select_compositor_mode, Compositor, CompositorError, CompositorMode, CpuCompositor, DlError,
    DynamicLibrary, PlatformWindow, RenderContext, SystemCapabilities, WindowError,
    WindowProperties,
};
// Re-export run function
pub use run::run;

// Platform-specific window type selection
cfg_if::cfg_if! {
    if #[cfg(target_os = "macos")] {
        pub use macos::MacOSWindow as Window;
        pub use macos::MacOSEvent as WindowEvent;
    } else if #[cfg(target_os = "windows")] {
        pub use windows::Win32Window as Window;
        pub use windows::Win32Event as WindowEvent;
    } else if #[cfg(target_os = "linux")] {
        pub use linux::LinuxWindow as Window;
        pub use linux::LinuxEvent as WindowEvent;
    } else {
        // Unknown platform - use stub
        pub use stub::StubWindow as Window;
        pub use stub::StubEvent as WindowEvent;
    }
}

/// Get the current windowing backend name.
pub fn get_backend_name() -> &'static str {
    #[cfg(target_os = "macos")]
    return "macos-appkit";

    #[cfg(target_os = "windows")]
    return "windows-win32";

    #[cfg(target_os = "linux")]
    {
        // Runtime detection on Linux
        if std::env::var("WAYLAND_DISPLAY").is_ok() {
            return "linux-wayland";
        } else {
            return "linux-x11";
        }
    }

    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "linux")))]
    return "stub";
}

/// Get shell2 version information.
pub fn get_version() -> &'static str {
    env!("CARGO_PKG_VERSION")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_backend_name() {
        let backend = get_backend_name();
        assert!(!backend.is_empty());
        println!("Backend: {}", backend);
    }

    #[test]
    fn test_version() {
        let version = get_version();
        assert!(!version.is_empty());
        println!("shell2 version: {}", version);
    }

    #[test]
    fn test_compositor_mode_from_env() {
        // Should not panic
        let _ = CompositorMode::from_env();
    }

    #[test]
    fn test_capabilities_detection() {
        let caps = SystemCapabilities::detect();
        println!("System capabilities: {:?}", caps);
    }

    #[test]
    fn test_stub_window_creation() {
        use azul_layout::window_state::WindowCreateOptions;

        let window = Window::new(WindowCreateOptions::default());
        assert!(window.is_ok());
    }
}
```
=== dll/src/desktop/shell2/run.rs ===
```rust
//! Main event loop implementation for shell2
//!
//! This module provides the cross-platform run() function that starts
//! the application and event loop for each platform.

use std::sync::Arc;

use azul_core::resources::AppConfig;
use azul_layout::window_state::WindowCreateOptions;
use rust_fontconfig::FcFontCache;

#[cfg(target_os = "macos")]
use super::macos::MacOSWindow;
use super::{PlatformWindow, WindowError};

/// Run the application with the given root window configuration
///
/// This function:
/// 1. Creates the root window using the platform-specific implementation
/// 2. Shows the window
/// 3. Enters the main event loop
/// 4. Processes events until the window is closed
///
/// # Platform-specific behavior
///
/// - **macOS**: Uses NSApplication.run() which blocks until app terminates, OR uses a manual event
///   loop if config.termination_behavior == ReturnToMain
/// - **Windows**: Manual event loop with GetMessage/TranslateMessage/DispatchMessage
/// - **Linux**: X11/Wayland event loop with appropriate polling
///
/// # Termination behavior
///
/// The behavior when all windows are closed is controlled by `config.termination_behavior`:
/// - `ReturnToMain`: Returns control to main() (if platform supports it)
/// - `RunForever`: Keeps app running until explicitly quit (macOS standard behavior)
/// - `EndProcess`: Calls std::process::exit(0) when last window closes (default)
#[cfg(target_os = "macos")]
pub fn run(
    config: AppConfig,
    fc_cache: Arc<FcFontCache>,
    root_window: WindowCreateOptions,
) -> Result<(), WindowError> {
    use azul_core::resources::AppTerminationBehavior;
    use objc2::{rc::autoreleasepool, MainThreadMarker};
    use objc2_app_kit::{NSApplication, NSApplicationActivationPolicy, NSEvent, NSEventMask};

    autoreleasepool(|_| {
        let mtm = MainThreadMarker::new()
            .ok_or_else(|| WindowError::PlatformError("Not on main thread".into()))?;

        // Create the root window with fc_cache
        // The window is automatically made visible after the first frame is ready
        let mut window = MacOSWindow::new_with_fc_cache(root_window, fc_cache, mtm)?;

        // CRITICAL: Set up back-pointers to the window
        // These enable the view and delegate to call back into MacOSWindow
        // SAFETY: window lives for the entire duration of this function,
        // and the view/delegate are owned by the window
        unsafe {
            window.setup_gl_view_back_pointer();
            window.finalize_delegate_pointer();
        }

        // Request the first drawRect: call to display the pre-rendered frame
        window.request_redraw();

        // Get NSApplication and configure it
        let app = NSApplication::sharedApplication(mtm);
        unsafe {
            app.setActivationPolicy(NSApplicationActivationPolicy::Regular);
            #[allow(deprecated)]
            app.activateIgnoringOtherApps(true);
        }

        // Choose event loop based on termination behavior
        match config.termination_behavior {
            AppTerminationBehavior::RunForever => {
                // Standard macOS behavior: Use NSApplication.run()
                // This blocks until the app is explicitly terminated (Cmd+Q or quit menu)
                eprintln!(
                    "[Event Loop] Using NSApplication.run() - app will stay in dock when windows \
                     close"
                );
                unsafe {
                    app.run();
                }
            }
            AppTerminationBehavior::ReturnToMain | AppTerminationBehavior::EndProcess => {
                // Manual event loop: Checks if windows are closed and takes appropriate action
                let action = if config.termination_behavior == AppTerminationBehavior::ReturnToMain
                {
                    eprintln!(
                        "[Event Loop] Using manual event loop - will return to main() when all \
                         windows close"
                    );
                    "return to main()"
                } else {
                    eprintln!(
                        "[Event Loop] Using manual event loop - will exit process when all \
                         windows close"
                    );
                    "exit process"
                };

                loop {
                    autoreleasepool(|_| {
                        // Process all pending events
                        loop {
                            let event = unsafe {
                                app.nextEventMatchingMask_untilDate_inMode_dequeue(
                                    NSEventMask::Any,
                                    None, // Don't wait - process immediately
                                    objc2_foundation::ns_string!("kCFRunLoopDefaultMode"),
                                    true,
                                )
                            };

                            if let Some(event) = event {
                                unsafe {
                                    app.sendEvent(&event);
                                }
                            } else {
                                // No more events to process
                                break;
                            }
                        }

                        // Check if window is still open
                        if !window.is_open() {
                            match config.termination_behavior {
                                AppTerminationBehavior::ReturnToMain => {
                                    eprintln!(
                                        "[Event Loop] All windows closed, returning to main()"
                                    );
                                    return;
                                }
                                AppTerminationBehavior::EndProcess => {
                                    eprintln!(
                                        "[Event Loop] All windows closed, terminating process"
                                    );
                                    std::process::exit(0);
                                }
                                AppTerminationBehavior::RunForever => unreachable!(),
                            }
                        }
                    });
                }
            }
        }

        Ok(())
    })
}

#[cfg(target_os = "windows")]
pub fn run(
    config: AppConfig,
    fc_cache: Arc<FcFontCache>,
    root_window: WindowCreateOptions,
) -> Result<(), WindowError> {
    use std::cell::RefCell;

    use azul_core::{refany::RefAny, resources::AppTerminationBehavior};

    use super::windows::Win32Window;

    // Create app_data (placeholder for now - should be passed from App)
    let app_data = Arc::new(RefCell::new(RefAny::new(())));

    // Create the root window
    let mut window = Win32Window::new(root_window, fc_cache.clone(), app_data)?;

    // Store the window pointer in the user data field for the window procedure
    // SAFETY: We are boxing the window and then leaking it. This is necessary
    // so that the pointer remains valid for the lifetime of the window.
    let window_ptr = Box::into_raw(Box::new(window));
    unsafe {
        ((*window_ptr)
            .win32
            .user32
            .SetWindowLongPtrW)((*window_ptr).hwnd, dlopen::constants::GWLP_USERDATA, window_ptr as isize);
    }
    let window = unsafe { &mut *window_ptr };

    // Main event loop
    loop {
        // Process all pending events for this window
        while window.poll_event() {}

        // Check if window is still open
        if !window.is_open() {
            break;
        }
        
        // Wait for next event - use GetMessage for blocking wait.
        // For multi-window, this would need to be PeekMessage or MsgWaitForMultipleObjects.
        use super::windows::dlopen::MSG;
        let mut msg: MSG = unsafe { std::mem::zeroed() };
        let result = unsafe { (window.win32.user32.GetMessageW)(&mut msg, std::ptr::null_mut(), 0, 0) };
        
        if result > 0 {
            unsafe {
                (window.win32.user32.TranslateMessage)(&msg);
                (window.win32.user32.DispatchMessageW)(&msg);
            }
        } else {
            // WM_QUIT received or error
            break;
        }
    }
    
    // SAFETY: We must manually drop the window since we leaked the box.
    unsafe {
        Box::from_raw(window_ptr);
    }

    // Handle termination behavior
    match config.termination_behavior {
        AppTerminationBehavior::EndProcess => {
            std::process::exit(0);
        }
        AppTerminationBehavior::ReturnToMain => {
            // Return normally to allow cleanup
        }
        AppTerminationBehavior::RunForever => {
            // Should not exit - but window is closed, so return
        }
    }

    Ok(())
}

#[cfg(target_os = "linux")]
pub fn run(
    _config: AppConfig,
    _fc_cache: Arc<FcFontCache>,
    root_window: WindowCreateOptions,
) -> Result<(), WindowError> {
    use super::linux::LinuxWindow;

    let mut window = LinuxWindow::new(root_window)?;

    while window.is_open() {
        // First, dispatch all events that are already queued up.
        // poll_event is non-blocking.
        while let Some(_event) = window.poll_event() {
            // Event handling logic is inside poll_event for both X11 and Wayland
        }
        
        // After dispatching all pending events, we can safely block
        // until a new event arrives from the display server.
        // This is much more efficient than sleeping.
        if let LinuxWindow::Wayland(w) = &mut window {
            w.wait_for_events()?;
        } else {
            // X11 doesn't have a wait_for_events, so we sleep briefly
            std::thread::sleep(std::time::Duration::from_millis(1));
        }
    }

    Ok(())
}
```
=== dll/src/desktop/shell2/windows/wcreate.rs ===
```rust
//! Win32 window creation helper functions
//!
//! This module contains the complex window creation logic extracted from the main module.

use std::{mem, ptr};

use azul_core::window::WindowFrame;
use azul_layout::window_state::WindowCreateOptions;

use super::dlopen::{
    constants::*, encode_wide, Win32Libraries, HDC, HGLRC, HINSTANCE, HWND, POINT, RECT, WNDCLASSW,
};
use crate::desktop::shell2::common::WindowError;

/// Win32 window class name
pub const CLASS_NAME: &str = "AzulWindowClass";

/// Register the Win32 window class
///
/// This must be called before creating any windows.
/// It's safe to call multiple times - duplicate registrations are ignored.
pub fn register_window_class(
    hinstance: HINSTANCE,
    window_proc: super::dlopen::WNDPROC,
    win32: &Win32Libraries,
) -> Result<super::dlopen::ATOM, WindowError> {
    unsafe {
        let mut class_name = encode_wide(CLASS_NAME);
        let hbrBackground = (win32.gdi32.CreateSolidBrush)(0x00000000);

        let wc = WNDCLASSW {
            style: 0,
            lpfnWndProc: window_proc,
            cbClsExtra: 0,
            cbWndExtra: 0,
            hInstance: hinstance,
            hIcon: ptr::null_mut(),
            hCursor: ptr::null_mut(),
            hbrBackground,
            lpszMenuName: ptr::null(),
            lpszClassName: class_name.as_ptr(),
        };

        let atom = (win32.user32.RegisterClassW)(&wc);

        if atom == 0 {
            return Err(WindowError::PlatformError(
                "Failed to register window class".into(),
            ));
        }

        Ok(atom)
    }
}

/// Create a Win32 HWND window
pub fn create_hwnd(
    hinstance: HINSTANCE,
    options: &WindowCreateOptions,
    parent_hwnd: Option<HWND>,
    user_data: *mut core::ffi::c_void,
    win32: &Win32Libraries,
) -> Result<HWND, WindowError> {
    unsafe {
        let mut class_name = encode_wide(CLASS_NAME);
        let mut window_title = encode_wide(options.state.title.as_str());

        let parent = parent_hwnd.unwrap_or(ptr::null_mut());

        // Calculate initial window size
        let (width, height) = if options.size_to_content {
            (0, 0)
        } else {
            (
                libm::roundf(options.state.size.dimensions.width) as i32,
                libm::roundf(options.state.size.dimensions.height) as i32,
            )
        };

        // Window style
        let style = WS_OVERLAPPED
            | WS_CAPTION
            | WS_SYSMENU
            | WS_THICKFRAME
            | WS_MINIMIZEBOX
            | WS_MAXIMIZEBOX
            | WS_TABSTOP
            | WS_POPUP;

        let style_ex = WS_EX_APPWINDOW | WS_EX_ACCEPTFILES;

        let hwnd = (win32.user32.CreateWindowExW)(
            style_ex,
            class_name.as_ptr(),
            window_title.as_ptr(),
            style,
            CW_USEDEFAULT, // x
            CW_USEDEFAULT, // y
            width,
            height,
            parent,
            ptr::null_mut(), // Menu
            hinstance,
            user_data,
        );

        if hwnd.is_null() {
            return Err(WindowError::PlatformError("Failed to create HWND".into()));
        }

        Ok(hwnd)
    }
}

/// Create an OpenGL context for the window
pub fn create_gl_context(
    hwnd: HWND,
    hinstance: HINSTANCE,
    win32: &Win32Libraries,
) -> Result<HGLRC, WindowError> {
    use super::gl::ExtraWglFunctions;
    
    // Load WGL extension functions first
    let extra_wgl = ExtraWglFunctions::load().map_err(|e| {
        WindowError::PlatformError(format!("Failed to load WGL extensions: {:?}", e))
    })?;

    // Get device context
    let hdc = unsafe { (win32.user32.GetDC)(hwnd) };
    if hdc.is_null() {
        return Err(WindowError::PlatformError("GetDC failed".into()));
    }

    // Choose pixel format using modern ARB extension
    let pixel_format = unsafe {
        let float_attribs = [
            WGL_DRAW_TO_WINDOW_ARB as i32, 1,
            WGL_SUPPORT_OPENGL_ARB as i32, 1,
            WGL_DOUBLE_BUFFER_ARB as i32, 1,
            WGL_PIXEL_TYPE_ARB as i32, WGL_TYPE_RGBA_ARB as i32,
            WGL_COLOR_BITS_ARB as i32, 24,
            WGL_ALPHA_BITS_ARB as i32, 8,
            WGL_DEPTH_BITS_ARB as i32, 24,
            WGL_STENCIL_BITS_ARB as i32, 8,
            WGL_ACCELERATION_ARB as i32, WGL_FULL_ACCELERATION_ARB as i32,
            0, // Terminate
        ];

        let mut pixel_format = 0i32;
        let mut num_formats = 0u32;
        
        let choose_fn = extra_wgl.wglChoosePixelFormatARB.ok_or_else(|| {
            WindowError::PlatformError("wglChoosePixelFormatARB not available".into())
        })?;
        
        let result = choose_fn(
            hdc as _,
            float_attribs.as_ptr(),
            std::ptr::null(),
            1,
            &mut pixel_format,
            &mut num_formats,
        );

        if result == 0 || num_formats == 0 {
            (win32.user32.ReleaseDC)(hwnd, hdc);
            return Err(WindowError::PlatformError(
                "wglChoosePixelFormatARB failed".into(),
            ));
        }

        pixel_format
    };

    // Set pixel format
    unsafe {
        use winapi::um::wingdi::{DescribePixelFormat, SetPixelFormat, PIXELFORMATDESCRIPTOR};
        
        let mut pfd: PIXELFORMATDESCRIPTOR = std::mem::zeroed();
        DescribePixelFormat(
            hdc as _,
            pixel_format,
            std::mem::size_of::<PIXELFORMATDESCRIPTOR>() as u32,
            &mut pfd,
        );

        if SetPixelFormat(hdc as _, pixel_format, &pfd) == 0 {
            (win32.user32.ReleaseDC)(hwnd, hdc);
            return Err(WindowError::PlatformError("SetPixelFormat failed".into()));
        }
    }

    // Create OpenGL 3.2+ Core Profile context
    let hglrc = unsafe {
        let context_attribs = [
            WGL_CONTEXT_MAJOR_VERSION_ARB as i32, 3,
            WGL_CONTEXT_MINOR_VERSION_ARB as i32, 2,
            WGL_CONTEXT_PROFILE_MASK_ARB as i32, WGL_CONTEXT_CORE_PROFILE_BIT_ARB as i32,
            WGL_CONTEXT_FLAGS_ARB as i32, 0,
            0, // Terminate
        ];

        let create_fn = extra_wgl.wglCreateContextAttribsARB.ok_or_else(|| {
            WindowError::PlatformError("wglCreateContextAttribsARB not available".into())
        })?;

        let hglrc = create_fn(
            hdc as _,
            std::ptr::null_mut(),
            context_attribs.as_ptr(),
        );

        if hglrc.is_null() {
            (win32.user32.ReleaseDC)(hwnd, hdc);
            return Err(WindowError::PlatformError(
                "wglCreateContextAttribsARB failed".into(),
            ));
        }

        hglrc as HGLRC
    };

    // Release DC (keep context)
    unsafe {
        (win32.user32.ReleaseDC)(hwnd, hdc);
    }

    Ok(hglrc)
}

// WGL extension constants (should match gl.rs definitions)
const WGL_DRAW_TO_WINDOW_ARB: u32 = 0x2001;
const WGL_SUPPORT_OPENGL_ARB: u32 = 0x2010;
const WGL_DOUBLE_BUFFER_ARB: u32 = 0x2011;
const WGL_PIXEL_TYPE_ARB: u32 = 0x2013;
const WGL_TYPE_RGBA_ARB: u32 = 0x202B;
const WGL_COLOR_BITS_ARB: u32 = 0x2014;
const WGL_ALPHA_BITS_ARB: u32 = 0x201B;
const WGL_DEPTH_BITS_ARB: u32 = 0x2022;
const WGL_STENCIL_BITS_ARB: u32 = 0x2023;
const WGL_ACCELERATION_ARB: u32 = 0x2003;
const WGL_FULL_ACCELERATION_ARB: u32 = 0x2027;
const WGL_CONTEXT_MAJOR_VERSION_ARB: u32 = 0x2091;
const WGL_CONTEXT_MINOR_VERSION_ARB: u32 = 0x2092;
const WGL_CONTEXT_PROFILE_MASK_ARB: u32 = 0x9126;
const WGL_CONTEXT_CORE_PROFILE_BIT_ARB: u32 = 0x00000001;
const WGL_CONTEXT_FLAGS_ARB: u32 = 0x2094;

/// Show or hide a window with the appropriate frame state
pub fn show_window_with_frame(
    hwnd: HWND,
    frame: WindowFrame,
    is_visible: bool,
    win32: &Win32Libraries,
) {
    let mut show_cmd = SW_HIDE;

    if is_visible {
        show_cmd = match frame {
            WindowFrame::Normal => SW_SHOWNORMAL,
            WindowFrame::Minimized => SW_MINIMIZE,
            WindowFrame::Maximized => SW_MAXIMIZE,
            WindowFrame::Fullscreen => SW_MAXIMIZE,
        };
    }

    unsafe { (win32.user32.ShowWindow)(hwnd, show_cmd) };
}

/// Get client rectangle size
pub fn get_client_rect(hwnd: HWND, win32: &Win32Libraries) -> Result<(u32, u32), WindowError> {
    unsafe {
        let mut rect = RECT::default();
        let result = (win32.user32.GetClientRect)(hwnd, &mut rect);

        if result == 0 {
            return Err(WindowError::PlatformError("GetClientRect failed".into()));
        }

        Ok((rect.width(), rect.height()))
    }
}

/// Resize a window to specific dimensions
pub fn set_window_size(
    hwnd: HWND,
    width: i32,
    height: i32,
    win32: &Win32Libraries,
) -> Result<(), WindowError> {
    let result = unsafe {
        (win32.user32.SetWindowPos)(
            hwnd,
            HWND_TOP,
            0,
            0,
            width,
            height,
            SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED,
        )
    };

    if result == 0 {
        return Err(WindowError::PlatformError("SetWindowPos failed".into()));
    }

    Ok(())
}
```
=== dll/src/desktop/shell2/windows/process.rs ===
```rust
//! Process event callbacks and manage window lifecycle for Win32.
//!
//! This module handles:
//!
//! - Processing UI events and invoking callbacks
//! - Timer event handling
//! - Thread message processing
//! - Window creation/destruction
//! - Callback result processing

use std::{collections::HashMap, sync::Arc};

use azul_core::{refany::RefAny, resources::ImageCache};
use azul_layout::{
    callbacks::CallCallbacksResult,
    thread::Thread,
    timer::Timer,
    window::LayoutWindow,
    window_state::{FullWindowState, WindowCreateOptions},
};
use rust_fontconfig::FcFontCache;
use webrender::Transaction as WrTransaction;

use super::Win32Window;

/// Hit test node structure for event routing
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HitTestNode {
    pub dom_id: u64,
    pub node_id: u64,
}

/// Target for callback dispatch
#[derive(Debug, Clone, Copy)]
pub enum CallbackTarget {
    /// Dispatch to callbacks on a specific node
    Node(HitTestNode),
    /// Dispatch to callbacks on root nodes (NodeId::ZERO) across all DOMs
    RootNodes,
}

/// Result of processing an event - tells the system what to do next
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum ProcessEventResult {
    /// Do nothing, continue normal event loop
    DoNothing,
    /// Re-render the current window (GPU scroll, etc.)
    ShouldReRenderCurrentWindow,
    /// Update the display list for the current window
    ShouldUpdateDisplayListCurrentWindow,
    /// Update hit-tester and process the event again
    UpdateHitTesterAndProcessAgain,
    /// Regenerate the DOM for the current window
    ShouldRegenerateDomCurrentWindow,
    /// Regenerate the DOM for all windows
    ShouldRegenerateDomAllWindows,
}

impl PartialOrd for ProcessEventResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for ProcessEventResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        use ProcessEventResult::*;
        let self_priority = match self {
            DoNothing => 0,
            ShouldReRenderCurrentWindow => 1,
            ShouldUpdateDisplayListCurrentWindow => 2,
            UpdateHitTesterAndProcessAgain => 3,
            ShouldRegenerateDomCurrentWindow => 4,
            ShouldRegenerateDomAllWindows => 5,
        };
        let other_priority = match other {
            DoNothing => 0,
            ShouldReRenderCurrentWindow => 1,
            ShouldUpdateDisplayListCurrentWindow => 2,
            UpdateHitTesterAndProcessAgain => 3,
            ShouldRegenerateDomCurrentWindow => 4,
            ShouldRegenerateDomAllWindows => 5,
        };
        self_priority.cmp(&other_priority)
    }
}

/// Invoke callbacks for a given target and event filter
pub(crate) fn invoke_callbacks(
    window: &mut Win32Window,
    target: CallbackTarget,
    event_filter: azul_core::events::EventFilter,
) -> Vec<CallCallbacksResult> {
    use azul_core::{
        dom::{DomId, NodeId},
        id::NodeId as CoreNodeId,
    };

    // Collect callbacks based on target
    let callback_data_list = match target {
        CallbackTarget::Node(node) => {
            let layout_window = match window.layout_window.as_ref() {
                Some(lw) => lw,
                None => return Vec::new(),
            };

            let dom_id = DomId {
                inner: node.dom_id as usize,
            };
            let node_id = match NodeId::from_usize(node.node_id as usize) {
                Some(nid) => nid,
                None => return Vec::new(),
            };

            let layout_result = match layout_window.layout_results.get(&dom_id) {
                Some(lr) => lr,
                None => return Vec::new(),
            };

            let binding = layout_result.styled_dom.node_data.as_container();
            let node_data = match binding.get(node_id) {
                Some(nd) => nd,
                None => return Vec::new(),
            };

            node_data
                .get_callbacks()
                .as_container()
                .iter()
                .filter(|cd| cd.event == event_filter)
                .cloned()
                .collect::<Vec<_>>()
        }
        CallbackTarget::RootNodes => {
            let layout_window = match window.layout_window.as_ref() {
                Some(lw) => lw,
                None => return Vec::new(),
            };

            let mut callbacks = Vec::new();
            for (_dom_id, layout_result) in &layout_window.layout_results {
                if let Some(root_node) = layout_result
                    .styled_dom
                    .node_data
                    .as_container()
                    .get(CoreNodeId::ZERO)
                {
                    for callback in root_node.get_callbacks().iter() {
                        if callback.event == event_filter {
                            callbacks.push(callback.clone());
                        }
                    }
                }
            }
            callbacks
        }
    };

    if callback_data_list.is_empty() {
        return Vec::new();
    }

    // Invoke all collected callbacks
    let window_handle = window.get_raw_window_handle();
    let layout_window = match window.layout_window.as_mut() {
        Some(lw) => lw,
        None => return Vec::new(),
    };

    let mut results = Vec::new();
    let mut fc_cache_clone = (*window.fc_cache).clone();

    for callback_data in callback_data_list {
        let mut callback =
            azul_layout::callbacks::Callback::from_core(callback_data.callback.clone());

        let callback_result = layout_window.invoke_single_callback(
            &mut callback,
            &mut callback_data.data.clone(),
            &window_handle,
            &window.gl_context_ptr,
            &mut window.image_cache,
            &mut fc_cache_clone,
            &azul_layout::callbacks::ExternalSystemCallbacks::rust_internal(),
            &window.previous_window_state,
            &window.current_window_state,
            &window.renderer_resources,
        );

        results.push(callback_result);
    }

    results
}

/// Process a single callback result and update window state
pub(crate) fn process_callback_result(
    window: &mut Win32Window,
    result: &CallCallbacksResult,
) -> ProcessEventResult {
    use azul_core::callbacks::Update;

    let mut event_result = ProcessEventResult::DoNothing;

    // Handle window state modifications
    if let Some(ref modified_state) = result.modified_window_state {
        window.current_window_state.title = modified_state.title.clone();
        window.current_window_state.size = modified_state.size;
        window.current_window_state.position = modified_state.position;
        window.current_window_state.flags = modified_state.flags;
        window.current_window_state.background_color = modified_state.background_color;

        // Check if window should close
        if modified_state.flags.close_requested {
            window.is_open = false;
            return ProcessEventResult::DoNothing;
        }

        event_result = ProcessEventResult::ShouldReRenderCurrentWindow;
    }

    // Handle focus changes
    if let Some(new_focus) = result.update_focused_node {
        window.current_window_state.focused_node = new_focus;
        event_result = ProcessEventResult::ShouldReRenderCurrentWindow;
    }

    // Handle image updates
    if result.images_changed.is_some() || result.image_masks_changed.is_some() {
        event_result = event_result.max(ProcessEventResult::ShouldUpdateDisplayListCurrentWindow);
    }

    // Handle timers, threads, etc.
    if result.timers.is_some()
        || result.timers_removed.is_some()
        || result.threads.is_some()
        || result.threads_removed.is_some()
    {
        // TODO: Update timers and threads on the window
        event_result = event_result.max(ProcessEventResult::ShouldReRenderCurrentWindow);
    }

    // Process Update screen command
    match result.callbacks_update_screen {
        Update::RefreshDom => {
            if let Err(e) = window.regenerate_layout() {
                eprintln!("Layout regeneration error: {}", e);
            }
            event_result = event_result.max(ProcessEventResult::ShouldRegenerateDomCurrentWindow);
        }
        Update::RefreshDomAllWindows => {
            if let Err(e) = window.regenerate_layout() {
                eprintln!("Layout regeneration error: {}", e);
            }
            event_result = event_result.max(ProcessEventResult::ShouldRegenerateDomAllWindows);
        }
        Update::DoNothing => {}
    }

    event_result
}

/// Extension trait for Callback to convert from CoreCallbackData
trait CallbackExt {
    fn from_core(
        core_callback: azul_core::callbacks::CoreCallbackData,
    ) -> azul_layout::callbacks::Callback;
}

impl CallbackExt for azul_layout::callbacks::Callback {
    fn from_core(core_callback: azul_core::callbacks::CoreCallbackData) -> Self {
        Self {
            cb: unsafe { std::mem::transmute(core_callback.callback.cb) },
        }
    }
}
```